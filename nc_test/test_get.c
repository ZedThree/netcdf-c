#line 5 "test_get.m4"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 7
/*********************************************************************
 *   Copyright 1996, UCAR/Unidata
 *   See netcdf/COPYRIGHT file for copying and redistribution conditions.
 *   $Id: test_get.m4 2785 2014-10-26 05:21:20Z wkliao $
 *********************************************************************/

#ifdef USE_PARALLEL
#include <mpi.h>
#endif

#line 35

#include "tests.h"

#line 120

void
#line 121
test_nc_get_var1_text(void)
#line 121
{
#line 121
    int ncid;
#line 121
    int i;
#line 121
    int j;
#line 121
    int err;
#line 121
    int nok = 0;      /* count of valid comparisons */
#line 121
    size_t index[MAX_RANK];
#line 121
    double expect;
#line 121
    int canConvert;     /* Both text or both numeric */
#line 121
    text value;
#line 121

#line 121
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 121
    IF (err)
#line 121
	error("nc_open: %s", nc_strerror(err));
#line 121
    for (i = 0; i < numVars; i++) {
#line 121
        canConvert = (var_type[i] == NC_CHAR) == (NCT_TEXT == NCT_TEXT);
#line 121
	for (j = 0; j < var_rank[i]; j++)
#line 121
	    index[j] = 0;
#line 121
        err = nc_get_var1_text(BAD_ID, i, index, &value);
#line 121
        IF (err != NC_EBADID)
#line 121
	    error("bad ncid: status = %d", err);
#line 121
        err = nc_get_var1_text(ncid, BAD_VARID, index, &value);
#line 121
        IF (err != NC_ENOTVAR)
#line 121
	    error("bad var id: status = %d", err);
#line 121
	for (j = 0; j < var_rank[i]; j++) {
#line 121
	    index[j] = var_shape[i][j];
#line 121
	    err = nc_get_var1_text(ncid, i, index, &value);
#line 121
	    if(!canConvert) {
#line 121
		IF(err != NC_ECHAR)
#line 121
			error("conversion: status = %d", err);
#line 121
	    } else IF (err != NC_EINVALCOORDS)
#line 121
		error("bad index: status = %d", err);
#line 121
	    index[j] = 0;
#line 121
	}
#line 121
	for (j = 0; j < var_nels[i]; j++) {
#line 121
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 121
	    IF (err)
#line 121
		error("error in toMixedBase 1");
#line 121
	    expect = hash4( var_type[i], var_rank[i], index, NCT_TEXT );
#line 121
	    if (var_rank[i] == 0 && i%2 )
#line 121
		err = nc_get_var1_text(ncid, i, NULL, &value);
#line 121
	    else
#line 121
		err = nc_get_var1_text(ncid, i, index, &value);
#line 121
            if (canConvert) {
#line 121
		if (inRange3(expect,var_type[i], NCT_TEXT)) {
#line 121
		    if (expect >= text_min && expect <= text_max) {
#line 121
			IF (err) {
#line 121
			    error("%s", nc_strerror(err));
#line 121
			} else {
#line 121
			    IF (!equal(value,expect,var_type[i],NCT_TEXT)) {
#line 121
				error("expected: %G, got: %G", expect,
#line 121
				    (double) value);
#line 121
			    } else {
#line 121
				nok++;
#line 121
			    }
#line 121
			}
#line 121
		    } else {
#line 121
			IF (err != NC_ERANGE)
#line 121
			    error("Range error: status = %d", err);
#line 121
		    }
#line 121
                } else {
#line 121
                    IF (err != 0 && err != NC_ERANGE)
#line 121
                        error("OK or Range error: status = %d", err);
#line 121
		}
#line 121
	    } else {
#line 121
		IF (err != NC_ECHAR)
#line 121
		    error("wrong type: status = %d", err);
#line 121
	    }
#line 121
	}
#line 121
    }
#line 121
    err = nc_close(ncid);
#line 121
    IF (err)
#line 121
	error("nc_close: %s", nc_strerror(err));
#line 121
    print_nok(nok);
#line 121
}
#line 121

void
#line 122
test_nc_get_var1_uchar(void)
#line 122
{
#line 122
    int ncid;
#line 122
    int i;
#line 122
    int j;
#line 122
    int err;
#line 122
    int nok = 0;      /* count of valid comparisons */
#line 122
    size_t index[MAX_RANK];
#line 122
    double expect;
#line 122
    int canConvert;     /* Both text or both numeric */
#line 122
    uchar value;
#line 122

#line 122
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 122
    IF (err)
#line 122
	error("nc_open: %s", nc_strerror(err));
#line 122
    for (i = 0; i < numVars; i++) {
#line 122
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UCHAR == NCT_TEXT);
#line 122
	for (j = 0; j < var_rank[i]; j++)
#line 122
	    index[j] = 0;
#line 122
        err = nc_get_var1_uchar(BAD_ID, i, index, &value);
#line 122
        IF (err != NC_EBADID)
#line 122
	    error("bad ncid: status = %d", err);
#line 122
        err = nc_get_var1_uchar(ncid, BAD_VARID, index, &value);
#line 122
        IF (err != NC_ENOTVAR)
#line 122
	    error("bad var id: status = %d", err);
#line 122
	for (j = 0; j < var_rank[i]; j++) {
#line 122
	    index[j] = var_shape[i][j];
#line 122
	    err = nc_get_var1_uchar(ncid, i, index, &value);
#line 122
	    if(!canConvert) {
#line 122
		IF(err != NC_ECHAR)
#line 122
			error("conversion: status = %d", err);
#line 122
	    } else IF (err != NC_EINVALCOORDS)
#line 122
		error("bad index: status = %d", err);
#line 122
	    index[j] = 0;
#line 122
	}
#line 122
	for (j = 0; j < var_nels[i]; j++) {
#line 122
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 122
	    IF (err)
#line 122
		error("error in toMixedBase 1");
#line 122
	    expect = hash4( var_type[i], var_rank[i], index, NCT_UCHAR );
#line 122
	    if (var_rank[i] == 0 && i%2 )
#line 122
		err = nc_get_var1_uchar(ncid, i, NULL, &value);
#line 122
	    else
#line 122
		err = nc_get_var1_uchar(ncid, i, index, &value);
#line 122
            if (canConvert) {
#line 122
		if (inRange3(expect,var_type[i], NCT_UCHAR)) {
#line 122
		    if (expect >= uchar_min && expect <= uchar_max) {
#line 122
			IF (err) {
#line 122
			    error("%s", nc_strerror(err));
#line 122
			} else {
#line 122
			    IF (!equal(value,expect,var_type[i],NCT_UCHAR)) {
#line 122
				error("expected: %G, got: %G", expect,
#line 122
				    (double) value);
#line 122
			    } else {
#line 122
				nok++;
#line 122
			    }
#line 122
			}
#line 122
		    } else {
#line 122
			IF (err != NC_ERANGE)
#line 122
			    error("Range error: status = %d", err);
#line 122
		    }
#line 122
                } else {
#line 122
                    IF (err != 0 && err != NC_ERANGE)
#line 122
                        error("OK or Range error: status = %d", err);
#line 122
		}
#line 122
	    } else {
#line 122
		IF (err != NC_ECHAR)
#line 122
		    error("wrong type: status = %d", err);
#line 122
	    }
#line 122
	}
#line 122
    }
#line 122
    err = nc_close(ncid);
#line 122
    IF (err)
#line 122
	error("nc_close: %s", nc_strerror(err));
#line 122
    print_nok(nok);
#line 122
}
#line 122

void
#line 123
test_nc_get_var1_schar(void)
#line 123
{
#line 123
    int ncid;
#line 123
    int i;
#line 123
    int j;
#line 123
    int err;
#line 123
    int nok = 0;      /* count of valid comparisons */
#line 123
    size_t index[MAX_RANK];
#line 123
    double expect;
#line 123
    int canConvert;     /* Both text or both numeric */
#line 123
    schar value;
#line 123

#line 123
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 123
    IF (err)
#line 123
	error("nc_open: %s", nc_strerror(err));
#line 123
    for (i = 0; i < numVars; i++) {
#line 123
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SCHAR == NCT_TEXT);
#line 123
	for (j = 0; j < var_rank[i]; j++)
#line 123
	    index[j] = 0;
#line 123
        err = nc_get_var1_schar(BAD_ID, i, index, &value);
#line 123
        IF (err != NC_EBADID)
#line 123
	    error("bad ncid: status = %d", err);
#line 123
        err = nc_get_var1_schar(ncid, BAD_VARID, index, &value);
#line 123
        IF (err != NC_ENOTVAR)
#line 123
	    error("bad var id: status = %d", err);
#line 123
	for (j = 0; j < var_rank[i]; j++) {
#line 123
	    index[j] = var_shape[i][j];
#line 123
	    err = nc_get_var1_schar(ncid, i, index, &value);
#line 123
	    if(!canConvert) {
#line 123
		IF(err != NC_ECHAR)
#line 123
			error("conversion: status = %d", err);
#line 123
	    } else IF (err != NC_EINVALCOORDS)
#line 123
		error("bad index: status = %d", err);
#line 123
	    index[j] = 0;
#line 123
	}
#line 123
	for (j = 0; j < var_nels[i]; j++) {
#line 123
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 123
	    IF (err)
#line 123
		error("error in toMixedBase 1");
#line 123
	    expect = hash4( var_type[i], var_rank[i], index, NCT_SCHAR );
#line 123
	    if (var_rank[i] == 0 && i%2 )
#line 123
		err = nc_get_var1_schar(ncid, i, NULL, &value);
#line 123
	    else
#line 123
		err = nc_get_var1_schar(ncid, i, index, &value);
#line 123
            if (canConvert) {
#line 123
		if (inRange3(expect,var_type[i], NCT_SCHAR)) {
#line 123
		    if (expect >= schar_min && expect <= schar_max) {
#line 123
			IF (err) {
#line 123
			    error("%s", nc_strerror(err));
#line 123
			} else {
#line 123
			    IF (!equal(value,expect,var_type[i],NCT_SCHAR)) {
#line 123
				error("expected: %G, got: %G", expect,
#line 123
				    (double) value);
#line 123
			    } else {
#line 123
				nok++;
#line 123
			    }
#line 123
			}
#line 123
		    } else {
#line 123
			IF (err != NC_ERANGE)
#line 123
			    error("Range error: status = %d", err);
#line 123
		    }
#line 123
                } else {
#line 123
                    IF (err != 0 && err != NC_ERANGE)
#line 123
                        error("OK or Range error: status = %d", err);
#line 123
		}
#line 123
	    } else {
#line 123
		IF (err != NC_ECHAR)
#line 123
		    error("wrong type: status = %d", err);
#line 123
	    }
#line 123
	}
#line 123
    }
#line 123
    err = nc_close(ncid);
#line 123
    IF (err)
#line 123
	error("nc_close: %s", nc_strerror(err));
#line 123
    print_nok(nok);
#line 123
}
#line 123

void
#line 124
test_nc_get_var1_short(void)
#line 124
{
#line 124
    int ncid;
#line 124
    int i;
#line 124
    int j;
#line 124
    int err;
#line 124
    int nok = 0;      /* count of valid comparisons */
#line 124
    size_t index[MAX_RANK];
#line 124
    double expect;
#line 124
    int canConvert;     /* Both text or both numeric */
#line 124
    short value;
#line 124

#line 124
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 124
    IF (err)
#line 124
	error("nc_open: %s", nc_strerror(err));
#line 124
    for (i = 0; i < numVars; i++) {
#line 124
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SHORT == NCT_TEXT);
#line 124
	for (j = 0; j < var_rank[i]; j++)
#line 124
	    index[j] = 0;
#line 124
        err = nc_get_var1_short(BAD_ID, i, index, &value);
#line 124
        IF (err != NC_EBADID)
#line 124
	    error("bad ncid: status = %d", err);
#line 124
        err = nc_get_var1_short(ncid, BAD_VARID, index, &value);
#line 124
        IF (err != NC_ENOTVAR)
#line 124
	    error("bad var id: status = %d", err);
#line 124
	for (j = 0; j < var_rank[i]; j++) {
#line 124
	    index[j] = var_shape[i][j];
#line 124
	    err = nc_get_var1_short(ncid, i, index, &value);
#line 124
	    if(!canConvert) {
#line 124
		IF(err != NC_ECHAR)
#line 124
			error("conversion: status = %d", err);
#line 124
	    } else IF (err != NC_EINVALCOORDS)
#line 124
		error("bad index: status = %d", err);
#line 124
	    index[j] = 0;
#line 124
	}
#line 124
	for (j = 0; j < var_nels[i]; j++) {
#line 124
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 124
	    IF (err)
#line 124
		error("error in toMixedBase 1");
#line 124
	    expect = hash4( var_type[i], var_rank[i], index, NCT_SHORT );
#line 124
	    if (var_rank[i] == 0 && i%2 )
#line 124
		err = nc_get_var1_short(ncid, i, NULL, &value);
#line 124
	    else
#line 124
		err = nc_get_var1_short(ncid, i, index, &value);
#line 124
            if (canConvert) {
#line 124
		if (inRange3(expect,var_type[i], NCT_SHORT)) {
#line 124
		    if (expect >= short_min && expect <= short_max) {
#line 124
			IF (err) {
#line 124
			    error("%s", nc_strerror(err));
#line 124
			} else {
#line 124
			    IF (!equal(value,expect,var_type[i],NCT_SHORT)) {
#line 124
				error("expected: %G, got: %G", expect,
#line 124
				    (double) value);
#line 124
			    } else {
#line 124
				nok++;
#line 124
			    }
#line 124
			}
#line 124
		    } else {
#line 124
			IF (err != NC_ERANGE)
#line 124
			    error("Range error: status = %d", err);
#line 124
		    }
#line 124
                } else {
#line 124
                    IF (err != 0 && err != NC_ERANGE)
#line 124
                        error("OK or Range error: status = %d", err);
#line 124
		}
#line 124
	    } else {
#line 124
		IF (err != NC_ECHAR)
#line 124
		    error("wrong type: status = %d", err);
#line 124
	    }
#line 124
	}
#line 124
    }
#line 124
    err = nc_close(ncid);
#line 124
    IF (err)
#line 124
	error("nc_close: %s", nc_strerror(err));
#line 124
    print_nok(nok);
#line 124
}
#line 124

void
#line 125
test_nc_get_var1_int(void)
#line 125
{
#line 125
    int ncid;
#line 125
    int i;
#line 125
    int j;
#line 125
    int err;
#line 125
    int nok = 0;      /* count of valid comparisons */
#line 125
    size_t index[MAX_RANK];
#line 125
    double expect;
#line 125
    int canConvert;     /* Both text or both numeric */
#line 125
    int value;
#line 125

#line 125
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 125
    IF (err)
#line 125
	error("nc_open: %s", nc_strerror(err));
#line 125
    for (i = 0; i < numVars; i++) {
#line 125
        canConvert = (var_type[i] == NC_CHAR) == (NCT_INT == NCT_TEXT);
#line 125
	for (j = 0; j < var_rank[i]; j++)
#line 125
	    index[j] = 0;
#line 125
        err = nc_get_var1_int(BAD_ID, i, index, &value);
#line 125
        IF (err != NC_EBADID)
#line 125
	    error("bad ncid: status = %d", err);
#line 125
        err = nc_get_var1_int(ncid, BAD_VARID, index, &value);
#line 125
        IF (err != NC_ENOTVAR)
#line 125
	    error("bad var id: status = %d", err);
#line 125
	for (j = 0; j < var_rank[i]; j++) {
#line 125
	    index[j] = var_shape[i][j];
#line 125
	    err = nc_get_var1_int(ncid, i, index, &value);
#line 125
	    if(!canConvert) {
#line 125
		IF(err != NC_ECHAR)
#line 125
			error("conversion: status = %d", err);
#line 125
	    } else IF (err != NC_EINVALCOORDS)
#line 125
		error("bad index: status = %d", err);
#line 125
	    index[j] = 0;
#line 125
	}
#line 125
	for (j = 0; j < var_nels[i]; j++) {
#line 125
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 125
	    IF (err)
#line 125
		error("error in toMixedBase 1");
#line 125
	    expect = hash4( var_type[i], var_rank[i], index, NCT_INT );
#line 125
	    if (var_rank[i] == 0 && i%2 )
#line 125
		err = nc_get_var1_int(ncid, i, NULL, &value);
#line 125
	    else
#line 125
		err = nc_get_var1_int(ncid, i, index, &value);
#line 125
            if (canConvert) {
#line 125
		if (inRange3(expect,var_type[i], NCT_INT)) {
#line 125
		    if (expect >= int_min && expect <= int_max) {
#line 125
			IF (err) {
#line 125
			    error("%s", nc_strerror(err));
#line 125
			} else {
#line 125
			    IF (!equal(value,expect,var_type[i],NCT_INT)) {
#line 125
				error("expected: %G, got: %G", expect,
#line 125
				    (double) value);
#line 125
			    } else {
#line 125
				nok++;
#line 125
			    }
#line 125
			}
#line 125
		    } else {
#line 125
			IF (err != NC_ERANGE)
#line 125
			    error("Range error: status = %d", err);
#line 125
		    }
#line 125
                } else {
#line 125
                    IF (err != 0 && err != NC_ERANGE)
#line 125
                        error("OK or Range error: status = %d", err);
#line 125
		}
#line 125
	    } else {
#line 125
		IF (err != NC_ECHAR)
#line 125
		    error("wrong type: status = %d", err);
#line 125
	    }
#line 125
	}
#line 125
    }
#line 125
    err = nc_close(ncid);
#line 125
    IF (err)
#line 125
	error("nc_close: %s", nc_strerror(err));
#line 125
    print_nok(nok);
#line 125
}
#line 125

void
#line 126
test_nc_get_var1_long(void)
#line 126
{
#line 126
    int ncid;
#line 126
    int i;
#line 126
    int j;
#line 126
    int err;
#line 126
    int nok = 0;      /* count of valid comparisons */
#line 126
    size_t index[MAX_RANK];
#line 126
    double expect;
#line 126
    int canConvert;     /* Both text or both numeric */
#line 126
    long value;
#line 126

#line 126
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 126
    IF (err)
#line 126
	error("nc_open: %s", nc_strerror(err));
#line 126
    for (i = 0; i < numVars; i++) {
#line 126
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONG == NCT_TEXT);
#line 126
	for (j = 0; j < var_rank[i]; j++)
#line 126
	    index[j] = 0;
#line 126
        err = nc_get_var1_long(BAD_ID, i, index, &value);
#line 126
        IF (err != NC_EBADID)
#line 126
	    error("bad ncid: status = %d", err);
#line 126
        err = nc_get_var1_long(ncid, BAD_VARID, index, &value);
#line 126
        IF (err != NC_ENOTVAR)
#line 126
	    error("bad var id: status = %d", err);
#line 126
	for (j = 0; j < var_rank[i]; j++) {
#line 126
	    index[j] = var_shape[i][j];
#line 126
	    err = nc_get_var1_long(ncid, i, index, &value);
#line 126
	    if(!canConvert) {
#line 126
		IF(err != NC_ECHAR)
#line 126
			error("conversion: status = %d", err);
#line 126
	    } else IF (err != NC_EINVALCOORDS)
#line 126
		error("bad index: status = %d", err);
#line 126
	    index[j] = 0;
#line 126
	}
#line 126
	for (j = 0; j < var_nels[i]; j++) {
#line 126
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 126
	    IF (err)
#line 126
		error("error in toMixedBase 1");
#line 126
	    expect = hash4( var_type[i], var_rank[i], index, NCT_LONG );
#line 126
	    if (var_rank[i] == 0 && i%2 )
#line 126
		err = nc_get_var1_long(ncid, i, NULL, &value);
#line 126
	    else
#line 126
		err = nc_get_var1_long(ncid, i, index, &value);
#line 126
            if (canConvert) {
#line 126
		if (inRange3(expect,var_type[i], NCT_LONG)) {
#line 126
		    if (expect >= long_min && expect <= long_max) {
#line 126
			IF (err) {
#line 126
			    error("%s", nc_strerror(err));
#line 126
			} else {
#line 126
			    IF (!equal(value,expect,var_type[i],NCT_LONG)) {
#line 126
				error("expected: %G, got: %G", expect,
#line 126
				    (double) value);
#line 126
			    } else {
#line 126
				nok++;
#line 126
			    }
#line 126
			}
#line 126
		    } else {
#line 126
			IF (err != NC_ERANGE)
#line 126
			    error("Range error: status = %d", err);
#line 126
		    }
#line 126
                } else {
#line 126
                    IF (err != 0 && err != NC_ERANGE)
#line 126
                        error("OK or Range error: status = %d", err);
#line 126
		}
#line 126
	    } else {
#line 126
		IF (err != NC_ECHAR)
#line 126
		    error("wrong type: status = %d", err);
#line 126
	    }
#line 126
	}
#line 126
    }
#line 126
    err = nc_close(ncid);
#line 126
    IF (err)
#line 126
	error("nc_close: %s", nc_strerror(err));
#line 126
    print_nok(nok);
#line 126
}
#line 126

void
#line 127
test_nc_get_var1_float(void)
#line 127
{
#line 127
    int ncid;
#line 127
    int i;
#line 127
    int j;
#line 127
    int err;
#line 127
    int nok = 0;      /* count of valid comparisons */
#line 127
    size_t index[MAX_RANK];
#line 127
    double expect;
#line 127
    int canConvert;     /* Both text or both numeric */
#line 127
    float value;
#line 127

#line 127
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 127
    IF (err)
#line 127
	error("nc_open: %s", nc_strerror(err));
#line 127
    for (i = 0; i < numVars; i++) {
#line 127
        canConvert = (var_type[i] == NC_CHAR) == (NCT_FLOAT == NCT_TEXT);
#line 127
	for (j = 0; j < var_rank[i]; j++)
#line 127
	    index[j] = 0;
#line 127
        err = nc_get_var1_float(BAD_ID, i, index, &value);
#line 127
        IF (err != NC_EBADID)
#line 127
	    error("bad ncid: status = %d", err);
#line 127
        err = nc_get_var1_float(ncid, BAD_VARID, index, &value);
#line 127
        IF (err != NC_ENOTVAR)
#line 127
	    error("bad var id: status = %d", err);
#line 127
	for (j = 0; j < var_rank[i]; j++) {
#line 127
	    index[j] = var_shape[i][j];
#line 127
	    err = nc_get_var1_float(ncid, i, index, &value);
#line 127
	    if(!canConvert) {
#line 127
		IF(err != NC_ECHAR)
#line 127
			error("conversion: status = %d", err);
#line 127
	    } else IF (err != NC_EINVALCOORDS)
#line 127
		error("bad index: status = %d", err);
#line 127
	    index[j] = 0;
#line 127
	}
#line 127
	for (j = 0; j < var_nels[i]; j++) {
#line 127
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 127
	    IF (err)
#line 127
		error("error in toMixedBase 1");
#line 127
	    expect = hash4( var_type[i], var_rank[i], index, NCT_FLOAT );
#line 127
	    if (var_rank[i] == 0 && i%2 )
#line 127
		err = nc_get_var1_float(ncid, i, NULL, &value);
#line 127
	    else
#line 127
		err = nc_get_var1_float(ncid, i, index, &value);
#line 127
            if (canConvert) {
#line 127
		if (inRange3(expect,var_type[i], NCT_FLOAT)) {
#line 127
		    if (expect >= float_min && expect <= float_max) {
#line 127
			IF (err) {
#line 127
			    error("%s", nc_strerror(err));
#line 127
			} else {
#line 127
			    IF (!equal(value,expect,var_type[i],NCT_FLOAT)) {
#line 127
				error("expected: %G, got: %G", expect,
#line 127
				    (double) value);
#line 127
			    } else {
#line 127
				nok++;
#line 127
			    }
#line 127
			}
#line 127
		    } else {
#line 127
			IF (err != NC_ERANGE)
#line 127
			    error("Range error: status = %d", err);
#line 127
		    }
#line 127
                } else {
#line 127
                    IF (err != 0 && err != NC_ERANGE)
#line 127
                        error("OK or Range error: status = %d", err);
#line 127
		}
#line 127
	    } else {
#line 127
		IF (err != NC_ECHAR)
#line 127
		    error("wrong type: status = %d", err);
#line 127
	    }
#line 127
	}
#line 127
    }
#line 127
    err = nc_close(ncid);
#line 127
    IF (err)
#line 127
	error("nc_close: %s", nc_strerror(err));
#line 127
    print_nok(nok);
#line 127
}
#line 127

void
#line 128
test_nc_get_var1_double(void)
#line 128
{
#line 128
    int ncid;
#line 128
    int i;
#line 128
    int j;
#line 128
    int err;
#line 128
    int nok = 0;      /* count of valid comparisons */
#line 128
    size_t index[MAX_RANK];
#line 128
    double expect;
#line 128
    int canConvert;     /* Both text or both numeric */
#line 128
    double value;
#line 128

#line 128
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 128
    IF (err)
#line 128
	error("nc_open: %s", nc_strerror(err));
#line 128
    for (i = 0; i < numVars; i++) {
#line 128
        canConvert = (var_type[i] == NC_CHAR) == (NCT_DOUBLE == NCT_TEXT);
#line 128
	for (j = 0; j < var_rank[i]; j++)
#line 128
	    index[j] = 0;
#line 128
        err = nc_get_var1_double(BAD_ID, i, index, &value);
#line 128
        IF (err != NC_EBADID)
#line 128
	    error("bad ncid: status = %d", err);
#line 128
        err = nc_get_var1_double(ncid, BAD_VARID, index, &value);
#line 128
        IF (err != NC_ENOTVAR)
#line 128
	    error("bad var id: status = %d", err);
#line 128
	for (j = 0; j < var_rank[i]; j++) {
#line 128
	    index[j] = var_shape[i][j];
#line 128
	    err = nc_get_var1_double(ncid, i, index, &value);
#line 128
	    if(!canConvert) {
#line 128
		IF(err != NC_ECHAR)
#line 128
			error("conversion: status = %d", err);
#line 128
	    } else IF (err != NC_EINVALCOORDS)
#line 128
		error("bad index: status = %d", err);
#line 128
	    index[j] = 0;
#line 128
	}
#line 128
	for (j = 0; j < var_nels[i]; j++) {
#line 128
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 128
	    IF (err)
#line 128
		error("error in toMixedBase 1");
#line 128
	    expect = hash4( var_type[i], var_rank[i], index, NCT_DOUBLE );
#line 128
	    if (var_rank[i] == 0 && i%2 )
#line 128
		err = nc_get_var1_double(ncid, i, NULL, &value);
#line 128
	    else
#line 128
		err = nc_get_var1_double(ncid, i, index, &value);
#line 128
            if (canConvert) {
#line 128
		if (inRange3(expect,var_type[i], NCT_DOUBLE)) {
#line 128
		    if (expect >= double_min && expect <= double_max) {
#line 128
			IF (err) {
#line 128
			    error("%s", nc_strerror(err));
#line 128
			} else {
#line 128
			    IF (!equal(value,expect,var_type[i],NCT_DOUBLE)) {
#line 128
				error("expected: %G, got: %G", expect,
#line 128
				    (double) value);
#line 128
			    } else {
#line 128
				nok++;
#line 128
			    }
#line 128
			}
#line 128
		    } else {
#line 128
			IF (err != NC_ERANGE)
#line 128
			    error("Range error: status = %d", err);
#line 128
		    }
#line 128
                } else {
#line 128
                    IF (err != 0 && err != NC_ERANGE)
#line 128
                        error("OK or Range error: status = %d", err);
#line 128
		}
#line 128
	    } else {
#line 128
		IF (err != NC_ECHAR)
#line 128
		    error("wrong type: status = %d", err);
#line 128
	    }
#line 128
	}
#line 128
    }
#line 128
    err = nc_close(ncid);
#line 128
    IF (err)
#line 128
	error("nc_close: %s", nc_strerror(err));
#line 128
    print_nok(nok);
#line 128
}
#line 128

void
#line 129
test_nc_get_var1_ushort(void)
#line 129
{
#line 129
    int ncid;
#line 129
    int i;
#line 129
    int j;
#line 129
    int err;
#line 129
    int nok = 0;      /* count of valid comparisons */
#line 129
    size_t index[MAX_RANK];
#line 129
    double expect;
#line 129
    int canConvert;     /* Both text or both numeric */
#line 129
    ushort value;
#line 129

#line 129
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 129
    IF (err)
#line 129
	error("nc_open: %s", nc_strerror(err));
#line 129
    for (i = 0; i < numVars; i++) {
#line 129
        canConvert = (var_type[i] == NC_CHAR) == (NCT_USHORT == NCT_TEXT);
#line 129
	for (j = 0; j < var_rank[i]; j++)
#line 129
	    index[j] = 0;
#line 129
        err = nc_get_var1_ushort(BAD_ID, i, index, &value);
#line 129
        IF (err != NC_EBADID)
#line 129
	    error("bad ncid: status = %d", err);
#line 129
        err = nc_get_var1_ushort(ncid, BAD_VARID, index, &value);
#line 129
        IF (err != NC_ENOTVAR)
#line 129
	    error("bad var id: status = %d", err);
#line 129
	for (j = 0; j < var_rank[i]; j++) {
#line 129
	    index[j] = var_shape[i][j];
#line 129
	    err = nc_get_var1_ushort(ncid, i, index, &value);
#line 129
	    if(!canConvert) {
#line 129
		IF(err != NC_ECHAR)
#line 129
			error("conversion: status = %d", err);
#line 129
	    } else IF (err != NC_EINVALCOORDS)
#line 129
		error("bad index: status = %d", err);
#line 129
	    index[j] = 0;
#line 129
	}
#line 129
	for (j = 0; j < var_nels[i]; j++) {
#line 129
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 129
	    IF (err)
#line 129
		error("error in toMixedBase 1");
#line 129
	    expect = hash4( var_type[i], var_rank[i], index, NCT_USHORT );
#line 129
	    if (var_rank[i] == 0 && i%2 )
#line 129
		err = nc_get_var1_ushort(ncid, i, NULL, &value);
#line 129
	    else
#line 129
		err = nc_get_var1_ushort(ncid, i, index, &value);
#line 129
            if (canConvert) {
#line 129
		if (inRange3(expect,var_type[i], NCT_USHORT)) {
#line 129
		    if (expect >= ushort_min && expect <= ushort_max) {
#line 129
			IF (err) {
#line 129
			    error("%s", nc_strerror(err));
#line 129
			} else {
#line 129
			    IF (!equal(value,expect,var_type[i],NCT_USHORT)) {
#line 129
				error("expected: %G, got: %G", expect,
#line 129
				    (double) value);
#line 129
			    } else {
#line 129
				nok++;
#line 129
			    }
#line 129
			}
#line 129
		    } else {
#line 129
			IF (err != NC_ERANGE)
#line 129
			    error("Range error: status = %d", err);
#line 129
		    }
#line 129
                } else {
#line 129
                    IF (err != 0 && err != NC_ERANGE)
#line 129
                        error("OK or Range error: status = %d", err);
#line 129
		}
#line 129
	    } else {
#line 129
		IF (err != NC_ECHAR)
#line 129
		    error("wrong type: status = %d", err);
#line 129
	    }
#line 129
	}
#line 129
    }
#line 129
    err = nc_close(ncid);
#line 129
    IF (err)
#line 129
	error("nc_close: %s", nc_strerror(err));
#line 129
    print_nok(nok);
#line 129
}
#line 129

void
#line 130
test_nc_get_var1_uint(void)
#line 130
{
#line 130
    int ncid;
#line 130
    int i;
#line 130
    int j;
#line 130
    int err;
#line 130
    int nok = 0;      /* count of valid comparisons */
#line 130
    size_t index[MAX_RANK];
#line 130
    double expect;
#line 130
    int canConvert;     /* Both text or both numeric */
#line 130
    uint value;
#line 130

#line 130
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 130
    IF (err)
#line 130
	error("nc_open: %s", nc_strerror(err));
#line 130
    for (i = 0; i < numVars; i++) {
#line 130
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UINT == NCT_TEXT);
#line 130
	for (j = 0; j < var_rank[i]; j++)
#line 130
	    index[j] = 0;
#line 130
        err = nc_get_var1_uint(BAD_ID, i, index, &value);
#line 130
        IF (err != NC_EBADID)
#line 130
	    error("bad ncid: status = %d", err);
#line 130
        err = nc_get_var1_uint(ncid, BAD_VARID, index, &value);
#line 130
        IF (err != NC_ENOTVAR)
#line 130
	    error("bad var id: status = %d", err);
#line 130
	for (j = 0; j < var_rank[i]; j++) {
#line 130
	    index[j] = var_shape[i][j];
#line 130
	    err = nc_get_var1_uint(ncid, i, index, &value);
#line 130
	    if(!canConvert) {
#line 130
		IF(err != NC_ECHAR)
#line 130
			error("conversion: status = %d", err);
#line 130
	    } else IF (err != NC_EINVALCOORDS)
#line 130
		error("bad index: status = %d", err);
#line 130
	    index[j] = 0;
#line 130
	}
#line 130
	for (j = 0; j < var_nels[i]; j++) {
#line 130
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 130
	    IF (err)
#line 130
		error("error in toMixedBase 1");
#line 130
	    expect = hash4( var_type[i], var_rank[i], index, NCT_UINT );
#line 130
	    if (var_rank[i] == 0 && i%2 )
#line 130
		err = nc_get_var1_uint(ncid, i, NULL, &value);
#line 130
	    else
#line 130
		err = nc_get_var1_uint(ncid, i, index, &value);
#line 130
            if (canConvert) {
#line 130
		if (inRange3(expect,var_type[i], NCT_UINT)) {
#line 130
		    if (expect >= uint_min && expect <= uint_max) {
#line 130
			IF (err) {
#line 130
			    error("%s", nc_strerror(err));
#line 130
			} else {
#line 130
			    IF (!equal(value,expect,var_type[i],NCT_UINT)) {
#line 130
				error("expected: %G, got: %G", expect,
#line 130
				    (double) value);
#line 130
			    } else {
#line 130
				nok++;
#line 130
			    }
#line 130
			}
#line 130
		    } else {
#line 130
			IF (err != NC_ERANGE)
#line 130
			    error("Range error: status = %d", err);
#line 130
		    }
#line 130
                } else {
#line 130
                    IF (err != 0 && err != NC_ERANGE)
#line 130
                        error("OK or Range error: status = %d", err);
#line 130
		}
#line 130
	    } else {
#line 130
		IF (err != NC_ECHAR)
#line 130
		    error("wrong type: status = %d", err);
#line 130
	    }
#line 130
	}
#line 130
    }
#line 130
    err = nc_close(ncid);
#line 130
    IF (err)
#line 130
	error("nc_close: %s", nc_strerror(err));
#line 130
    print_nok(nok);
#line 130
}
#line 130

void
#line 131
test_nc_get_var1_longlong(void)
#line 131
{
#line 131
    int ncid;
#line 131
    int i;
#line 131
    int j;
#line 131
    int err;
#line 131
    int nok = 0;      /* count of valid comparisons */
#line 131
    size_t index[MAX_RANK];
#line 131
    double expect;
#line 131
    int canConvert;     /* Both text or both numeric */
#line 131
    longlong value;
#line 131

#line 131
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 131
    IF (err)
#line 131
	error("nc_open: %s", nc_strerror(err));
#line 131
    for (i = 0; i < numVars; i++) {
#line 131
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONGLONG == NCT_TEXT);
#line 131
	for (j = 0; j < var_rank[i]; j++)
#line 131
	    index[j] = 0;
#line 131
        err = nc_get_var1_longlong(BAD_ID, i, index, &value);
#line 131
        IF (err != NC_EBADID)
#line 131
	    error("bad ncid: status = %d", err);
#line 131
        err = nc_get_var1_longlong(ncid, BAD_VARID, index, &value);
#line 131
        IF (err != NC_ENOTVAR)
#line 131
	    error("bad var id: status = %d", err);
#line 131
	for (j = 0; j < var_rank[i]; j++) {
#line 131
	    index[j] = var_shape[i][j];
#line 131
	    err = nc_get_var1_longlong(ncid, i, index, &value);
#line 131
	    if(!canConvert) {
#line 131
		IF(err != NC_ECHAR)
#line 131
			error("conversion: status = %d", err);
#line 131
	    } else IF (err != NC_EINVALCOORDS)
#line 131
		error("bad index: status = %d", err);
#line 131
	    index[j] = 0;
#line 131
	}
#line 131
	for (j = 0; j < var_nels[i]; j++) {
#line 131
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 131
	    IF (err)
#line 131
		error("error in toMixedBase 1");
#line 131
	    expect = hash4( var_type[i], var_rank[i], index, NCT_LONGLONG );
#line 131
	    if (var_rank[i] == 0 && i%2 )
#line 131
		err = nc_get_var1_longlong(ncid, i, NULL, &value);
#line 131
	    else
#line 131
		err = nc_get_var1_longlong(ncid, i, index, &value);
#line 131
            if (canConvert) {
#line 131
		if (inRange3(expect,var_type[i], NCT_LONGLONG)) {
#line 131
		    if (expect >= longlong_min && expect <= longlong_max) {
#line 131
			IF (err) {
#line 131
			    error("%s", nc_strerror(err));
#line 131
			} else {
#line 131
			    IF (!equal(value,expect,var_type[i],NCT_LONGLONG)) {
#line 131
				error("expected: %G, got: %G", expect,
#line 131
				    (double) value);
#line 131
			    } else {
#line 131
				nok++;
#line 131
			    }
#line 131
			}
#line 131
		    } else {
#line 131
			IF (err != NC_ERANGE)
#line 131
			    error("Range error: status = %d", err);
#line 131
		    }
#line 131
                } else {
#line 131
                    IF (err != 0 && err != NC_ERANGE)
#line 131
                        error("OK or Range error: status = %d", err);
#line 131
		}
#line 131
	    } else {
#line 131
		IF (err != NC_ECHAR)
#line 131
		    error("wrong type: status = %d", err);
#line 131
	    }
#line 131
	}
#line 131
    }
#line 131
    err = nc_close(ncid);
#line 131
    IF (err)
#line 131
	error("nc_close: %s", nc_strerror(err));
#line 131
    print_nok(nok);
#line 131
}
#line 131

void
#line 132
test_nc_get_var1_ulonglong(void)
#line 132
{
#line 132
    int ncid;
#line 132
    int i;
#line 132
    int j;
#line 132
    int err;
#line 132
    int nok = 0;      /* count of valid comparisons */
#line 132
    size_t index[MAX_RANK];
#line 132
    double expect;
#line 132
    int canConvert;     /* Both text or both numeric */
#line 132
    ulonglong value;
#line 132

#line 132
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 132
    IF (err)
#line 132
	error("nc_open: %s", nc_strerror(err));
#line 132
    for (i = 0; i < numVars; i++) {
#line 132
        canConvert = (var_type[i] == NC_CHAR) == (NCT_ULONGLONG == NCT_TEXT);
#line 132
	for (j = 0; j < var_rank[i]; j++)
#line 132
	    index[j] = 0;
#line 132
        err = nc_get_var1_ulonglong(BAD_ID, i, index, &value);
#line 132
        IF (err != NC_EBADID)
#line 132
	    error("bad ncid: status = %d", err);
#line 132
        err = nc_get_var1_ulonglong(ncid, BAD_VARID, index, &value);
#line 132
        IF (err != NC_ENOTVAR)
#line 132
	    error("bad var id: status = %d", err);
#line 132
	for (j = 0; j < var_rank[i]; j++) {
#line 132
	    index[j] = var_shape[i][j];
#line 132
	    err = nc_get_var1_ulonglong(ncid, i, index, &value);
#line 132
	    if(!canConvert) {
#line 132
		IF(err != NC_ECHAR)
#line 132
			error("conversion: status = %d", err);
#line 132
	    } else IF (err != NC_EINVALCOORDS)
#line 132
		error("bad index: status = %d", err);
#line 132
	    index[j] = 0;
#line 132
	}
#line 132
	for (j = 0; j < var_nels[i]; j++) {
#line 132
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 132
	    IF (err)
#line 132
		error("error in toMixedBase 1");
#line 132
	    expect = hash4( var_type[i], var_rank[i], index, NCT_ULONGLONG );
#line 132
	    if (var_rank[i] == 0 && i%2 )
#line 132
		err = nc_get_var1_ulonglong(ncid, i, NULL, &value);
#line 132
	    else
#line 132
		err = nc_get_var1_ulonglong(ncid, i, index, &value);
#line 132
            if (canConvert) {
#line 132
		if (inRange3(expect,var_type[i], NCT_ULONGLONG)) {
#line 132
		    if (expect >= ulonglong_min && expect <= ulonglong_max) {
#line 132
			IF (err) {
#line 132
			    error("%s", nc_strerror(err));
#line 132
			} else {
#line 132
			    IF (!equal(value,expect,var_type[i],NCT_ULONGLONG)) {
#line 132
				error("expected: %G, got: %G", expect,
#line 132
				    (double) value);
#line 132
			    } else {
#line 132
				nok++;
#line 132
			    }
#line 132
			}
#line 132
		    } else {
#line 132
			IF (err != NC_ERANGE)
#line 132
			    error("Range error: status = %d", err);
#line 132
		    }
#line 132
                } else {
#line 132
                    IF (err != 0 && err != NC_ERANGE)
#line 132
                        error("OK or Range error: status = %d", err);
#line 132
		}
#line 132
	    } else {
#line 132
		IF (err != NC_ECHAR)
#line 132
		    error("wrong type: status = %d", err);
#line 132
	    }
#line 132
	}
#line 132
    }
#line 132
    err = nc_close(ncid);
#line 132
    IF (err)
#line 132
	error("nc_close: %s", nc_strerror(err));
#line 132
    print_nok(nok);
#line 132
}
#line 132



#line 229

void
#line 230
test_nc_get_var_text(void)
#line 230
{
#line 230
    int ncid;
#line 230
    int i;
#line 230
    int j;
#line 230
    int err;
#line 230
    int allInExtRange;	/* all values within external range? */
#line 230
    int allInIntRange;	/* all values within internal range? */
#line 230
    int nels;
#line 230
    int nok = 0;      /* count of valid comparisons */
#line 230
    size_t index[MAX_RANK];
#line 230
    int canConvert;     /* Both text or both numeric */
#line 230
    text value[MAX_NELS];
#line 230
    double expect[MAX_NELS];
#line 230

#line 230
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 230
    IF (err)
#line 230
	error("nc_open: %s", nc_strerror(err));
#line 230
    for (i = 0; i < numVars; i++) {
#line 230
        canConvert = (var_type[i] == NC_CHAR) == (NCT_TEXT == NCT_TEXT);
#line 230
        assert(var_rank[i] <= MAX_RANK);
#line 230
        assert(var_nels[i] <= MAX_NELS);
#line 230
        err = nc_get_var_text(BAD_ID, i, value);
#line 230
        IF (err != NC_EBADID)
#line 230
	    error("bad ncid: status = %d", err);
#line 230
        err = nc_get_var_text(ncid, BAD_VARID, value);
#line 230
        IF (err != NC_ENOTVAR)
#line 230
	    error("bad var id: status = %d", err);
#line 230

#line 230
	nels = 1;
#line 230
	for (j = 0; j < var_rank[i]; j++) {
#line 230
	    nels *= var_shape[i][j];
#line 230
	}
#line 230
	allInExtRange = allInIntRange = 1;
#line 230
	for (j = 0; j < nels; j++) {
#line 230
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 230
	    IF (err)
#line 230
		error("error in toMixedBase 1");
#line 230
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_TEXT);
#line 230
	    if (inRange3(expect[j],var_type[i], NCT_TEXT)) {
#line 230
		allInIntRange = allInIntRange && expect[j] >= text_min
#line 230
			    && expect[j] <= text_max;
#line 230
	    } else {
#line 230
		allInExtRange = 0;
#line 230
	    }
#line 230
	}
#line 230
	err = nc_get_var_text(ncid, i, value);
#line 230
	if (canConvert) {
#line 230
	    if (allInExtRange) {
#line 230
		if (allInIntRange) {
#line 230
		    IF (err)
#line 230
			error("%s", nc_strerror(err));
#line 230
		} else {
#line 230
		    IF (err != NC_ERANGE)
#line 230
			error("Range error: status = %d", err);
#line 230
		}
#line 230
	    } else {
#line 230
		IF (err != 0 && err != NC_ERANGE)
#line 230
		    error("OK or Range error: status = %d", err);
#line 230
	    }
#line 230
	    for (j = 0; j < nels; j++) {
#line 230
		if (inRange3(expect[j],var_type[i],NCT_TEXT)
#line 230
			&& expect[j] >= text_min && expect[j] <= text_max) {
#line 230
		    IF (!equal(value[j],expect[j],var_type[i],NCT_TEXT)){
#line 230
			error("value read not that expected");
#line 230
			if (verbose) {
#line 230
			    error("\n");
#line 230
			    error("varid: %d, ", i);
#line 230
			    error("var_name: %s, ", var_name[i]);
#line 230
			    error("element number: %d ", j);
#line 230
			    error("expect: %g", expect[j]);
#line 230
			    error("got: %g", (double) value[j]);
#line 230
			}
#line 230
		    } else {
#line 230
			nok++;
#line 230
		    }
#line 230
		}
#line 230
	    }
#line 230
	} else {
#line 230
	    IF (nels > 0 && err != NC_ECHAR)
#line 230
		error("wrong type: status = %d", err);
#line 230
	}
#line 230
    }
#line 230
    err = nc_close(ncid);
#line 230
    IF (err)
#line 230
	error("nc_close: %s", nc_strerror(err));
#line 230
    print_nok(nok);
#line 230
}
#line 230

void
#line 231
test_nc_get_var_uchar(void)
#line 231
{
#line 231
    int ncid;
#line 231
    int i;
#line 231
    int j;
#line 231
    int err;
#line 231
    int allInExtRange;	/* all values within external range? */
#line 231
    int allInIntRange;	/* all values within internal range? */
#line 231
    int nels;
#line 231
    int nok = 0;      /* count of valid comparisons */
#line 231
    size_t index[MAX_RANK];
#line 231
    int canConvert;     /* Both text or both numeric */
#line 231
    uchar value[MAX_NELS];
#line 231
    double expect[MAX_NELS];
#line 231

#line 231
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 231
    IF (err)
#line 231
	error("nc_open: %s", nc_strerror(err));
#line 231
    for (i = 0; i < numVars; i++) {
#line 231
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UCHAR == NCT_TEXT);
#line 231
        assert(var_rank[i] <= MAX_RANK);
#line 231
        assert(var_nels[i] <= MAX_NELS);
#line 231
        err = nc_get_var_uchar(BAD_ID, i, value);
#line 231
        IF (err != NC_EBADID)
#line 231
	    error("bad ncid: status = %d", err);
#line 231
        err = nc_get_var_uchar(ncid, BAD_VARID, value);
#line 231
        IF (err != NC_ENOTVAR)
#line 231
	    error("bad var id: status = %d", err);
#line 231

#line 231
	nels = 1;
#line 231
	for (j = 0; j < var_rank[i]; j++) {
#line 231
	    nels *= var_shape[i][j];
#line 231
	}
#line 231
	allInExtRange = allInIntRange = 1;
#line 231
	for (j = 0; j < nels; j++) {
#line 231
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 231
	    IF (err)
#line 231
		error("error in toMixedBase 1");
#line 231
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_UCHAR);
#line 231
	    if (inRange3(expect[j],var_type[i], NCT_UCHAR)) {
#line 231
		allInIntRange = allInIntRange && expect[j] >= uchar_min
#line 231
			    && expect[j] <= uchar_max;
#line 231
	    } else {
#line 231
		allInExtRange = 0;
#line 231
	    }
#line 231
	}
#line 231
	err = nc_get_var_uchar(ncid, i, value);
#line 231
	if (canConvert) {
#line 231
	    if (allInExtRange) {
#line 231
		if (allInIntRange) {
#line 231
		    IF (err)
#line 231
			error("%s", nc_strerror(err));
#line 231
		} else {
#line 231
		    IF (err != NC_ERANGE)
#line 231
			error("Range error: status = %d", err);
#line 231
		}
#line 231
	    } else {
#line 231
		IF (err != 0 && err != NC_ERANGE)
#line 231
		    error("OK or Range error: status = %d", err);
#line 231
	    }
#line 231
	    for (j = 0; j < nels; j++) {
#line 231
		if (inRange3(expect[j],var_type[i],NCT_UCHAR)
#line 231
			&& expect[j] >= uchar_min && expect[j] <= uchar_max) {
#line 231
		    IF (!equal(value[j],expect[j],var_type[i],NCT_UCHAR)){
#line 231
			error("value read not that expected");
#line 231
			if (verbose) {
#line 231
			    error("\n");
#line 231
			    error("varid: %d, ", i);
#line 231
			    error("var_name: %s, ", var_name[i]);
#line 231
			    error("element number: %d ", j);
#line 231
			    error("expect: %g", expect[j]);
#line 231
			    error("got: %g", (double) value[j]);
#line 231
			}
#line 231
		    } else {
#line 231
			nok++;
#line 231
		    }
#line 231
		}
#line 231
	    }
#line 231
	} else {
#line 231
	    IF (nels > 0 && err != NC_ECHAR)
#line 231
		error("wrong type: status = %d", err);
#line 231
	}
#line 231
    }
#line 231
    err = nc_close(ncid);
#line 231
    IF (err)
#line 231
	error("nc_close: %s", nc_strerror(err));
#line 231
    print_nok(nok);
#line 231
}
#line 231

void
#line 232
test_nc_get_var_schar(void)
#line 232
{
#line 232
    int ncid;
#line 232
    int i;
#line 232
    int j;
#line 232
    int err;
#line 232
    int allInExtRange;	/* all values within external range? */
#line 232
    int allInIntRange;	/* all values within internal range? */
#line 232
    int nels;
#line 232
    int nok = 0;      /* count of valid comparisons */
#line 232
    size_t index[MAX_RANK];
#line 232
    int canConvert;     /* Both text or both numeric */
#line 232
    schar value[MAX_NELS];
#line 232
    double expect[MAX_NELS];
#line 232

#line 232
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 232
    IF (err)
#line 232
	error("nc_open: %s", nc_strerror(err));
#line 232
    for (i = 0; i < numVars; i++) {
#line 232
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SCHAR == NCT_TEXT);
#line 232
        assert(var_rank[i] <= MAX_RANK);
#line 232
        assert(var_nels[i] <= MAX_NELS);
#line 232
        err = nc_get_var_schar(BAD_ID, i, value);
#line 232
        IF (err != NC_EBADID)
#line 232
	    error("bad ncid: status = %d", err);
#line 232
        err = nc_get_var_schar(ncid, BAD_VARID, value);
#line 232
        IF (err != NC_ENOTVAR)
#line 232
	    error("bad var id: status = %d", err);
#line 232

#line 232
	nels = 1;
#line 232
	for (j = 0; j < var_rank[i]; j++) {
#line 232
	    nels *= var_shape[i][j];
#line 232
	}
#line 232
	allInExtRange = allInIntRange = 1;
#line 232
	for (j = 0; j < nels; j++) {
#line 232
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 232
	    IF (err)
#line 232
		error("error in toMixedBase 1");
#line 232
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_SCHAR);
#line 232
	    if (inRange3(expect[j],var_type[i], NCT_SCHAR)) {
#line 232
		allInIntRange = allInIntRange && expect[j] >= schar_min
#line 232
			    && expect[j] <= schar_max;
#line 232
	    } else {
#line 232
		allInExtRange = 0;
#line 232
	    }
#line 232
	}
#line 232
	err = nc_get_var_schar(ncid, i, value);
#line 232
	if (canConvert) {
#line 232
	    if (allInExtRange) {
#line 232
		if (allInIntRange) {
#line 232
		    IF (err)
#line 232
			error("%s", nc_strerror(err));
#line 232
		} else {
#line 232
		    IF (err != NC_ERANGE)
#line 232
			error("Range error: status = %d", err);
#line 232
		}
#line 232
	    } else {
#line 232
		IF (err != 0 && err != NC_ERANGE)
#line 232
		    error("OK or Range error: status = %d", err);
#line 232
	    }
#line 232
	    for (j = 0; j < nels; j++) {
#line 232
		if (inRange3(expect[j],var_type[i],NCT_SCHAR)
#line 232
			&& expect[j] >= schar_min && expect[j] <= schar_max) {
#line 232
		    IF (!equal(value[j],expect[j],var_type[i],NCT_SCHAR)){
#line 232
			error("value read not that expected");
#line 232
			if (verbose) {
#line 232
			    error("\n");
#line 232
			    error("varid: %d, ", i);
#line 232
			    error("var_name: %s, ", var_name[i]);
#line 232
			    error("element number: %d ", j);
#line 232
			    error("expect: %g", expect[j]);
#line 232
			    error("got: %g", (double) value[j]);
#line 232
			}
#line 232
		    } else {
#line 232
			nok++;
#line 232
		    }
#line 232
		}
#line 232
	    }
#line 232
	} else {
#line 232
	    IF (nels > 0 && err != NC_ECHAR)
#line 232
		error("wrong type: status = %d", err);
#line 232
	}
#line 232
    }
#line 232
    err = nc_close(ncid);
#line 232
    IF (err)
#line 232
	error("nc_close: %s", nc_strerror(err));
#line 232
    print_nok(nok);
#line 232
}
#line 232

void
#line 233
test_nc_get_var_short(void)
#line 233
{
#line 233
    int ncid;
#line 233
    int i;
#line 233
    int j;
#line 233
    int err;
#line 233
    int allInExtRange;	/* all values within external range? */
#line 233
    int allInIntRange;	/* all values within internal range? */
#line 233
    int nels;
#line 233
    int nok = 0;      /* count of valid comparisons */
#line 233
    size_t index[MAX_RANK];
#line 233
    int canConvert;     /* Both text or both numeric */
#line 233
    short value[MAX_NELS];
#line 233
    double expect[MAX_NELS];
#line 233

#line 233
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 233
    IF (err)
#line 233
	error("nc_open: %s", nc_strerror(err));
#line 233
    for (i = 0; i < numVars; i++) {
#line 233
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SHORT == NCT_TEXT);
#line 233
        assert(var_rank[i] <= MAX_RANK);
#line 233
        assert(var_nels[i] <= MAX_NELS);
#line 233
        err = nc_get_var_short(BAD_ID, i, value);
#line 233
        IF (err != NC_EBADID)
#line 233
	    error("bad ncid: status = %d", err);
#line 233
        err = nc_get_var_short(ncid, BAD_VARID, value);
#line 233
        IF (err != NC_ENOTVAR)
#line 233
	    error("bad var id: status = %d", err);
#line 233

#line 233
	nels = 1;
#line 233
	for (j = 0; j < var_rank[i]; j++) {
#line 233
	    nels *= var_shape[i][j];
#line 233
	}
#line 233
	allInExtRange = allInIntRange = 1;
#line 233
	for (j = 0; j < nels; j++) {
#line 233
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 233
	    IF (err)
#line 233
		error("error in toMixedBase 1");
#line 233
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_SHORT);
#line 233
	    if (inRange3(expect[j],var_type[i], NCT_SHORT)) {
#line 233
		allInIntRange = allInIntRange && expect[j] >= short_min
#line 233
			    && expect[j] <= short_max;
#line 233
	    } else {
#line 233
		allInExtRange = 0;
#line 233
	    }
#line 233
	}
#line 233
	err = nc_get_var_short(ncid, i, value);
#line 233
	if (canConvert) {
#line 233
	    if (allInExtRange) {
#line 233
		if (allInIntRange) {
#line 233
		    IF (err)
#line 233
			error("%s", nc_strerror(err));
#line 233
		} else {
#line 233
		    IF (err != NC_ERANGE)
#line 233
			error("Range error: status = %d", err);
#line 233
		}
#line 233
	    } else {
#line 233
		IF (err != 0 && err != NC_ERANGE)
#line 233
		    error("OK or Range error: status = %d", err);
#line 233
	    }
#line 233
	    for (j = 0; j < nels; j++) {
#line 233
		if (inRange3(expect[j],var_type[i],NCT_SHORT)
#line 233
			&& expect[j] >= short_min && expect[j] <= short_max) {
#line 233
		    IF (!equal(value[j],expect[j],var_type[i],NCT_SHORT)){
#line 233
			error("value read not that expected");
#line 233
			if (verbose) {
#line 233
			    error("\n");
#line 233
			    error("varid: %d, ", i);
#line 233
			    error("var_name: %s, ", var_name[i]);
#line 233
			    error("element number: %d ", j);
#line 233
			    error("expect: %g", expect[j]);
#line 233
			    error("got: %g", (double) value[j]);
#line 233
			}
#line 233
		    } else {
#line 233
			nok++;
#line 233
		    }
#line 233
		}
#line 233
	    }
#line 233
	} else {
#line 233
	    IF (nels > 0 && err != NC_ECHAR)
#line 233
		error("wrong type: status = %d", err);
#line 233
	}
#line 233
    }
#line 233
    err = nc_close(ncid);
#line 233
    IF (err)
#line 233
	error("nc_close: %s", nc_strerror(err));
#line 233
    print_nok(nok);
#line 233
}
#line 233

void
#line 234
test_nc_get_var_int(void)
#line 234
{
#line 234
    int ncid;
#line 234
    int i;
#line 234
    int j;
#line 234
    int err;
#line 234
    int allInExtRange;	/* all values within external range? */
#line 234
    int allInIntRange;	/* all values within internal range? */
#line 234
    int nels;
#line 234
    int nok = 0;      /* count of valid comparisons */
#line 234
    size_t index[MAX_RANK];
#line 234
    int canConvert;     /* Both text or both numeric */
#line 234
    int value[MAX_NELS];
#line 234
    double expect[MAX_NELS];
#line 234

#line 234
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 234
    IF (err)
#line 234
	error("nc_open: %s", nc_strerror(err));
#line 234
    for (i = 0; i < numVars; i++) {
#line 234
        canConvert = (var_type[i] == NC_CHAR) == (NCT_INT == NCT_TEXT);
#line 234
        assert(var_rank[i] <= MAX_RANK);
#line 234
        assert(var_nels[i] <= MAX_NELS);
#line 234
        err = nc_get_var_int(BAD_ID, i, value);
#line 234
        IF (err != NC_EBADID)
#line 234
	    error("bad ncid: status = %d", err);
#line 234
        err = nc_get_var_int(ncid, BAD_VARID, value);
#line 234
        IF (err != NC_ENOTVAR)
#line 234
	    error("bad var id: status = %d", err);
#line 234

#line 234
	nels = 1;
#line 234
	for (j = 0; j < var_rank[i]; j++) {
#line 234
	    nels *= var_shape[i][j];
#line 234
	}
#line 234
	allInExtRange = allInIntRange = 1;
#line 234
	for (j = 0; j < nels; j++) {
#line 234
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 234
	    IF (err)
#line 234
		error("error in toMixedBase 1");
#line 234
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_INT);
#line 234
	    if (inRange3(expect[j],var_type[i], NCT_INT)) {
#line 234
		allInIntRange = allInIntRange && expect[j] >= int_min
#line 234
			    && expect[j] <= int_max;
#line 234
	    } else {
#line 234
		allInExtRange = 0;
#line 234
	    }
#line 234
	}
#line 234
	err = nc_get_var_int(ncid, i, value);
#line 234
	if (canConvert) {
#line 234
	    if (allInExtRange) {
#line 234
		if (allInIntRange) {
#line 234
		    IF (err)
#line 234
			error("%s", nc_strerror(err));
#line 234
		} else {
#line 234
		    IF (err != NC_ERANGE)
#line 234
			error("Range error: status = %d", err);
#line 234
		}
#line 234
	    } else {
#line 234
		IF (err != 0 && err != NC_ERANGE)
#line 234
		    error("OK or Range error: status = %d", err);
#line 234
	    }
#line 234
	    for (j = 0; j < nels; j++) {
#line 234
		if (inRange3(expect[j],var_type[i],NCT_INT)
#line 234
			&& expect[j] >= int_min && expect[j] <= int_max) {
#line 234
		    IF (!equal(value[j],expect[j],var_type[i],NCT_INT)){
#line 234
			error("value read not that expected");
#line 234
			if (verbose) {
#line 234
			    error("\n");
#line 234
			    error("varid: %d, ", i);
#line 234
			    error("var_name: %s, ", var_name[i]);
#line 234
			    error("element number: %d ", j);
#line 234
			    error("expect: %g", expect[j]);
#line 234
			    error("got: %g", (double) value[j]);
#line 234
			}
#line 234
		    } else {
#line 234
			nok++;
#line 234
		    }
#line 234
		}
#line 234
	    }
#line 234
	} else {
#line 234
	    IF (nels > 0 && err != NC_ECHAR)
#line 234
		error("wrong type: status = %d", err);
#line 234
	}
#line 234
    }
#line 234
    err = nc_close(ncid);
#line 234
    IF (err)
#line 234
	error("nc_close: %s", nc_strerror(err));
#line 234
    print_nok(nok);
#line 234
}
#line 234

void
#line 235
test_nc_get_var_long(void)
#line 235
{
#line 235
    int ncid;
#line 235
    int i;
#line 235
    int j;
#line 235
    int err;
#line 235
    int allInExtRange;	/* all values within external range? */
#line 235
    int allInIntRange;	/* all values within internal range? */
#line 235
    int nels;
#line 235
    int nok = 0;      /* count of valid comparisons */
#line 235
    size_t index[MAX_RANK];
#line 235
    int canConvert;     /* Both text or both numeric */
#line 235
    long value[MAX_NELS];
#line 235
    double expect[MAX_NELS];
#line 235

#line 235
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 235
    IF (err)
#line 235
	error("nc_open: %s", nc_strerror(err));
#line 235
    for (i = 0; i < numVars; i++) {
#line 235
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONG == NCT_TEXT);
#line 235
        assert(var_rank[i] <= MAX_RANK);
#line 235
        assert(var_nels[i] <= MAX_NELS);
#line 235
        err = nc_get_var_long(BAD_ID, i, value);
#line 235
        IF (err != NC_EBADID)
#line 235
	    error("bad ncid: status = %d", err);
#line 235
        err = nc_get_var_long(ncid, BAD_VARID, value);
#line 235
        IF (err != NC_ENOTVAR)
#line 235
	    error("bad var id: status = %d", err);
#line 235

#line 235
	nels = 1;
#line 235
	for (j = 0; j < var_rank[i]; j++) {
#line 235
	    nels *= var_shape[i][j];
#line 235
	}
#line 235
	allInExtRange = allInIntRange = 1;
#line 235
	for (j = 0; j < nels; j++) {
#line 235
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 235
	    IF (err)
#line 235
		error("error in toMixedBase 1");
#line 235
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_LONG);
#line 235
	    if (inRange3(expect[j],var_type[i], NCT_LONG)) {
#line 235
		allInIntRange = allInIntRange && expect[j] >= long_min
#line 235
			    && expect[j] <= long_max;
#line 235
	    } else {
#line 235
		allInExtRange = 0;
#line 235
	    }
#line 235
	}
#line 235
	err = nc_get_var_long(ncid, i, value);
#line 235
	if (canConvert) {
#line 235
	    if (allInExtRange) {
#line 235
		if (allInIntRange) {
#line 235
		    IF (err)
#line 235
			error("%s", nc_strerror(err));
#line 235
		} else {
#line 235
		    IF (err != NC_ERANGE)
#line 235
			error("Range error: status = %d", err);
#line 235
		}
#line 235
	    } else {
#line 235
		IF (err != 0 && err != NC_ERANGE)
#line 235
		    error("OK or Range error: status = %d", err);
#line 235
	    }
#line 235
	    for (j = 0; j < nels; j++) {
#line 235
		if (inRange3(expect[j],var_type[i],NCT_LONG)
#line 235
			&& expect[j] >= long_min && expect[j] <= long_max) {
#line 235
		    IF (!equal(value[j],expect[j],var_type[i],NCT_LONG)){
#line 235
			error("value read not that expected");
#line 235
			if (verbose) {
#line 235
			    error("\n");
#line 235
			    error("varid: %d, ", i);
#line 235
			    error("var_name: %s, ", var_name[i]);
#line 235
			    error("element number: %d ", j);
#line 235
			    error("expect: %g", expect[j]);
#line 235
			    error("got: %g", (double) value[j]);
#line 235
			}
#line 235
		    } else {
#line 235
			nok++;
#line 235
		    }
#line 235
		}
#line 235
	    }
#line 235
	} else {
#line 235
	    IF (nels > 0 && err != NC_ECHAR)
#line 235
		error("wrong type: status = %d", err);
#line 235
	}
#line 235
    }
#line 235
    err = nc_close(ncid);
#line 235
    IF (err)
#line 235
	error("nc_close: %s", nc_strerror(err));
#line 235
    print_nok(nok);
#line 235
}
#line 235

void
#line 236
test_nc_get_var_float(void)
#line 236
{
#line 236
    int ncid;
#line 236
    int i;
#line 236
    int j;
#line 236
    int err;
#line 236
    int allInExtRange;	/* all values within external range? */
#line 236
    int allInIntRange;	/* all values within internal range? */
#line 236
    int nels;
#line 236
    int nok = 0;      /* count of valid comparisons */
#line 236
    size_t index[MAX_RANK];
#line 236
    int canConvert;     /* Both text or both numeric */
#line 236
    float value[MAX_NELS];
#line 236
    double expect[MAX_NELS];
#line 236

#line 236
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 236
    IF (err)
#line 236
	error("nc_open: %s", nc_strerror(err));
#line 236
    for (i = 0; i < numVars; i++) {
#line 236
        canConvert = (var_type[i] == NC_CHAR) == (NCT_FLOAT == NCT_TEXT);
#line 236
        assert(var_rank[i] <= MAX_RANK);
#line 236
        assert(var_nels[i] <= MAX_NELS);
#line 236
        err = nc_get_var_float(BAD_ID, i, value);
#line 236
        IF (err != NC_EBADID)
#line 236
	    error("bad ncid: status = %d", err);
#line 236
        err = nc_get_var_float(ncid, BAD_VARID, value);
#line 236
        IF (err != NC_ENOTVAR)
#line 236
	    error("bad var id: status = %d", err);
#line 236

#line 236
	nels = 1;
#line 236
	for (j = 0; j < var_rank[i]; j++) {
#line 236
	    nels *= var_shape[i][j];
#line 236
	}
#line 236
	allInExtRange = allInIntRange = 1;
#line 236
	for (j = 0; j < nels; j++) {
#line 236
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 236
	    IF (err)
#line 236
		error("error in toMixedBase 1");
#line 236
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_FLOAT);
#line 236
	    if (inRange3(expect[j],var_type[i], NCT_FLOAT)) {
#line 236
		allInIntRange = allInIntRange && expect[j] >= float_min
#line 236
			    && expect[j] <= float_max;
#line 236
	    } else {
#line 236
		allInExtRange = 0;
#line 236
	    }
#line 236
	}
#line 236
	err = nc_get_var_float(ncid, i, value);
#line 236
	if (canConvert) {
#line 236
	    if (allInExtRange) {
#line 236
		if (allInIntRange) {
#line 236
		    IF (err)
#line 236
			error("%s", nc_strerror(err));
#line 236
		} else {
#line 236
		    IF (err != NC_ERANGE)
#line 236
			error("Range error: status = %d", err);
#line 236
		}
#line 236
	    } else {
#line 236
		IF (err != 0 && err != NC_ERANGE)
#line 236
		    error("OK or Range error: status = %d", err);
#line 236
	    }
#line 236
	    for (j = 0; j < nels; j++) {
#line 236
		if (inRange3(expect[j],var_type[i],NCT_FLOAT)
#line 236
			&& expect[j] >= float_min && expect[j] <= float_max) {
#line 236
		    IF (!equal(value[j],expect[j],var_type[i],NCT_FLOAT)){
#line 236
			error("value read not that expected");
#line 236
			if (verbose) {
#line 236
			    error("\n");
#line 236
			    error("varid: %d, ", i);
#line 236
			    error("var_name: %s, ", var_name[i]);
#line 236
			    error("element number: %d ", j);
#line 236
			    error("expect: %g", expect[j]);
#line 236
			    error("got: %g", (double) value[j]);
#line 236
			}
#line 236
		    } else {
#line 236
			nok++;
#line 236
		    }
#line 236
		}
#line 236
	    }
#line 236
	} else {
#line 236
	    IF (nels > 0 && err != NC_ECHAR)
#line 236
		error("wrong type: status = %d", err);
#line 236
	}
#line 236
    }
#line 236
    err = nc_close(ncid);
#line 236
    IF (err)
#line 236
	error("nc_close: %s", nc_strerror(err));
#line 236
    print_nok(nok);
#line 236
}
#line 236

void
#line 237
test_nc_get_var_double(void)
#line 237
{
#line 237
    int ncid;
#line 237
    int i;
#line 237
    int j;
#line 237
    int err;
#line 237
    int allInExtRange;	/* all values within external range? */
#line 237
    int allInIntRange;	/* all values within internal range? */
#line 237
    int nels;
#line 237
    int nok = 0;      /* count of valid comparisons */
#line 237
    size_t index[MAX_RANK];
#line 237
    int canConvert;     /* Both text or both numeric */
#line 237
    double value[MAX_NELS];
#line 237
    double expect[MAX_NELS];
#line 237

#line 237
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 237
    IF (err)
#line 237
	error("nc_open: %s", nc_strerror(err));
#line 237
    for (i = 0; i < numVars; i++) {
#line 237
        canConvert = (var_type[i] == NC_CHAR) == (NCT_DOUBLE == NCT_TEXT);
#line 237
        assert(var_rank[i] <= MAX_RANK);
#line 237
        assert(var_nels[i] <= MAX_NELS);
#line 237
        err = nc_get_var_double(BAD_ID, i, value);
#line 237
        IF (err != NC_EBADID)
#line 237
	    error("bad ncid: status = %d", err);
#line 237
        err = nc_get_var_double(ncid, BAD_VARID, value);
#line 237
        IF (err != NC_ENOTVAR)
#line 237
	    error("bad var id: status = %d", err);
#line 237

#line 237
	nels = 1;
#line 237
	for (j = 0; j < var_rank[i]; j++) {
#line 237
	    nels *= var_shape[i][j];
#line 237
	}
#line 237
	allInExtRange = allInIntRange = 1;
#line 237
	for (j = 0; j < nels; j++) {
#line 237
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 237
	    IF (err)
#line 237
		error("error in toMixedBase 1");
#line 237
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_DOUBLE);
#line 237
	    if (inRange3(expect[j],var_type[i], NCT_DOUBLE)) {
#line 237
		allInIntRange = allInIntRange && expect[j] >= double_min
#line 237
			    && expect[j] <= double_max;
#line 237
	    } else {
#line 237
		allInExtRange = 0;
#line 237
	    }
#line 237
	}
#line 237
	err = nc_get_var_double(ncid, i, value);
#line 237
	if (canConvert) {
#line 237
	    if (allInExtRange) {
#line 237
		if (allInIntRange) {
#line 237
		    IF (err)
#line 237
			error("%s", nc_strerror(err));
#line 237
		} else {
#line 237
		    IF (err != NC_ERANGE)
#line 237
			error("Range error: status = %d", err);
#line 237
		}
#line 237
	    } else {
#line 237
		IF (err != 0 && err != NC_ERANGE)
#line 237
		    error("OK or Range error: status = %d", err);
#line 237
	    }
#line 237
	    for (j = 0; j < nels; j++) {
#line 237
		if (inRange3(expect[j],var_type[i],NCT_DOUBLE)
#line 237
			&& expect[j] >= double_min && expect[j] <= double_max) {
#line 237
		    IF (!equal(value[j],expect[j],var_type[i],NCT_DOUBLE)){
#line 237
			error("value read not that expected");
#line 237
			if (verbose) {
#line 237
			    error("\n");
#line 237
			    error("varid: %d, ", i);
#line 237
			    error("var_name: %s, ", var_name[i]);
#line 237
			    error("element number: %d ", j);
#line 237
			    error("expect: %g", expect[j]);
#line 237
			    error("got: %g", (double) value[j]);
#line 237
			}
#line 237
		    } else {
#line 237
			nok++;
#line 237
		    }
#line 237
		}
#line 237
	    }
#line 237
	} else {
#line 237
	    IF (nels > 0 && err != NC_ECHAR)
#line 237
		error("wrong type: status = %d", err);
#line 237
	}
#line 237
    }
#line 237
    err = nc_close(ncid);
#line 237
    IF (err)
#line 237
	error("nc_close: %s", nc_strerror(err));
#line 237
    print_nok(nok);
#line 237
}
#line 237

void
#line 238
test_nc_get_var_ushort(void)
#line 238
{
#line 238
    int ncid;
#line 238
    int i;
#line 238
    int j;
#line 238
    int err;
#line 238
    int allInExtRange;	/* all values within external range? */
#line 238
    int allInIntRange;	/* all values within internal range? */
#line 238
    int nels;
#line 238
    int nok = 0;      /* count of valid comparisons */
#line 238
    size_t index[MAX_RANK];
#line 238
    int canConvert;     /* Both text or both numeric */
#line 238
    ushort value[MAX_NELS];
#line 238
    double expect[MAX_NELS];
#line 238

#line 238
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 238
    IF (err)
#line 238
	error("nc_open: %s", nc_strerror(err));
#line 238
    for (i = 0; i < numVars; i++) {
#line 238
        canConvert = (var_type[i] == NC_CHAR) == (NCT_USHORT == NCT_TEXT);
#line 238
        assert(var_rank[i] <= MAX_RANK);
#line 238
        assert(var_nels[i] <= MAX_NELS);
#line 238
        err = nc_get_var_ushort(BAD_ID, i, value);
#line 238
        IF (err != NC_EBADID)
#line 238
	    error("bad ncid: status = %d", err);
#line 238
        err = nc_get_var_ushort(ncid, BAD_VARID, value);
#line 238
        IF (err != NC_ENOTVAR)
#line 238
	    error("bad var id: status = %d", err);
#line 238

#line 238
	nels = 1;
#line 238
	for (j = 0; j < var_rank[i]; j++) {
#line 238
	    nels *= var_shape[i][j];
#line 238
	}
#line 238
	allInExtRange = allInIntRange = 1;
#line 238
	for (j = 0; j < nels; j++) {
#line 238
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 238
	    IF (err)
#line 238
		error("error in toMixedBase 1");
#line 238
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_USHORT);
#line 238
	    if (inRange3(expect[j],var_type[i], NCT_USHORT)) {
#line 238
		allInIntRange = allInIntRange && expect[j] >= ushort_min
#line 238
			    && expect[j] <= ushort_max;
#line 238
	    } else {
#line 238
		allInExtRange = 0;
#line 238
	    }
#line 238
	}
#line 238
	err = nc_get_var_ushort(ncid, i, value);
#line 238
	if (canConvert) {
#line 238
	    if (allInExtRange) {
#line 238
		if (allInIntRange) {
#line 238
		    IF (err)
#line 238
			error("%s", nc_strerror(err));
#line 238
		} else {
#line 238
		    IF (err != NC_ERANGE)
#line 238
			error("Range error: status = %d", err);
#line 238
		}
#line 238
	    } else {
#line 238
		IF (err != 0 && err != NC_ERANGE)
#line 238
		    error("OK or Range error: status = %d", err);
#line 238
	    }
#line 238
	    for (j = 0; j < nels; j++) {
#line 238
		if (inRange3(expect[j],var_type[i],NCT_USHORT)
#line 238
			&& expect[j] >= ushort_min && expect[j] <= ushort_max) {
#line 238
		    IF (!equal(value[j],expect[j],var_type[i],NCT_USHORT)){
#line 238
			error("value read not that expected");
#line 238
			if (verbose) {
#line 238
			    error("\n");
#line 238
			    error("varid: %d, ", i);
#line 238
			    error("var_name: %s, ", var_name[i]);
#line 238
			    error("element number: %d ", j);
#line 238
			    error("expect: %g", expect[j]);
#line 238
			    error("got: %g", (double) value[j]);
#line 238
			}
#line 238
		    } else {
#line 238
			nok++;
#line 238
		    }
#line 238
		}
#line 238
	    }
#line 238
	} else {
#line 238
	    IF (nels > 0 && err != NC_ECHAR)
#line 238
		error("wrong type: status = %d", err);
#line 238
	}
#line 238
    }
#line 238
    err = nc_close(ncid);
#line 238
    IF (err)
#line 238
	error("nc_close: %s", nc_strerror(err));
#line 238
    print_nok(nok);
#line 238
}
#line 238

void
#line 239
test_nc_get_var_uint(void)
#line 239
{
#line 239
    int ncid;
#line 239
    int i;
#line 239
    int j;
#line 239
    int err;
#line 239
    int allInExtRange;	/* all values within external range? */
#line 239
    int allInIntRange;	/* all values within internal range? */
#line 239
    int nels;
#line 239
    int nok = 0;      /* count of valid comparisons */
#line 239
    size_t index[MAX_RANK];
#line 239
    int canConvert;     /* Both text or both numeric */
#line 239
    uint value[MAX_NELS];
#line 239
    double expect[MAX_NELS];
#line 239

#line 239
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 239
    IF (err)
#line 239
	error("nc_open: %s", nc_strerror(err));
#line 239
    for (i = 0; i < numVars; i++) {
#line 239
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UINT == NCT_TEXT);
#line 239
        assert(var_rank[i] <= MAX_RANK);
#line 239
        assert(var_nels[i] <= MAX_NELS);
#line 239
        err = nc_get_var_uint(BAD_ID, i, value);
#line 239
        IF (err != NC_EBADID)
#line 239
	    error("bad ncid: status = %d", err);
#line 239
        err = nc_get_var_uint(ncid, BAD_VARID, value);
#line 239
        IF (err != NC_ENOTVAR)
#line 239
	    error("bad var id: status = %d", err);
#line 239

#line 239
	nels = 1;
#line 239
	for (j = 0; j < var_rank[i]; j++) {
#line 239
	    nels *= var_shape[i][j];
#line 239
	}
#line 239
	allInExtRange = allInIntRange = 1;
#line 239
	for (j = 0; j < nels; j++) {
#line 239
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 239
	    IF (err)
#line 239
		error("error in toMixedBase 1");
#line 239
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_UINT);
#line 239
	    if (inRange3(expect[j],var_type[i], NCT_UINT)) {
#line 239
		allInIntRange = allInIntRange && expect[j] >= uint_min
#line 239
			    && expect[j] <= uint_max;
#line 239
	    } else {
#line 239
		allInExtRange = 0;
#line 239
	    }
#line 239
	}
#line 239
	err = nc_get_var_uint(ncid, i, value);
#line 239
	if (canConvert) {
#line 239
	    if (allInExtRange) {
#line 239
		if (allInIntRange) {
#line 239
		    IF (err)
#line 239
			error("%s", nc_strerror(err));
#line 239
		} else {
#line 239
		    IF (err != NC_ERANGE)
#line 239
			error("Range error: status = %d", err);
#line 239
		}
#line 239
	    } else {
#line 239
		IF (err != 0 && err != NC_ERANGE)
#line 239
		    error("OK or Range error: status = %d", err);
#line 239
	    }
#line 239
	    for (j = 0; j < nels; j++) {
#line 239
		if (inRange3(expect[j],var_type[i],NCT_UINT)
#line 239
			&& expect[j] >= uint_min && expect[j] <= uint_max) {
#line 239
		    IF (!equal(value[j],expect[j],var_type[i],NCT_UINT)){
#line 239
			error("value read not that expected");
#line 239
			if (verbose) {
#line 239
			    error("\n");
#line 239
			    error("varid: %d, ", i);
#line 239
			    error("var_name: %s, ", var_name[i]);
#line 239
			    error("element number: %d ", j);
#line 239
			    error("expect: %g", expect[j]);
#line 239
			    error("got: %g", (double) value[j]);
#line 239
			}
#line 239
		    } else {
#line 239
			nok++;
#line 239
		    }
#line 239
		}
#line 239
	    }
#line 239
	} else {
#line 239
	    IF (nels > 0 && err != NC_ECHAR)
#line 239
		error("wrong type: status = %d", err);
#line 239
	}
#line 239
    }
#line 239
    err = nc_close(ncid);
#line 239
    IF (err)
#line 239
	error("nc_close: %s", nc_strerror(err));
#line 239
    print_nok(nok);
#line 239
}
#line 239

void
#line 240
test_nc_get_var_longlong(void)
#line 240
{
#line 240
    int ncid;
#line 240
    int i;
#line 240
    int j;
#line 240
    int err;
#line 240
    int allInExtRange;	/* all values within external range? */
#line 240
    int allInIntRange;	/* all values within internal range? */
#line 240
    int nels;
#line 240
    int nok = 0;      /* count of valid comparisons */
#line 240
    size_t index[MAX_RANK];
#line 240
    int canConvert;     /* Both text or both numeric */
#line 240
    longlong value[MAX_NELS];
#line 240
    double expect[MAX_NELS];
#line 240

#line 240
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 240
    IF (err)
#line 240
	error("nc_open: %s", nc_strerror(err));
#line 240
    for (i = 0; i < numVars; i++) {
#line 240
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONGLONG == NCT_TEXT);
#line 240
        assert(var_rank[i] <= MAX_RANK);
#line 240
        assert(var_nels[i] <= MAX_NELS);
#line 240
        err = nc_get_var_longlong(BAD_ID, i, value);
#line 240
        IF (err != NC_EBADID)
#line 240
	    error("bad ncid: status = %d", err);
#line 240
        err = nc_get_var_longlong(ncid, BAD_VARID, value);
#line 240
        IF (err != NC_ENOTVAR)
#line 240
	    error("bad var id: status = %d", err);
#line 240

#line 240
	nels = 1;
#line 240
	for (j = 0; j < var_rank[i]; j++) {
#line 240
	    nels *= var_shape[i][j];
#line 240
	}
#line 240
	allInExtRange = allInIntRange = 1;
#line 240
	for (j = 0; j < nels; j++) {
#line 240
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 240
	    IF (err)
#line 240
		error("error in toMixedBase 1");
#line 240
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_LONGLONG);
#line 240
	    if (inRange3(expect[j],var_type[i], NCT_LONGLONG)) {
#line 240
		allInIntRange = allInIntRange && expect[j] >= longlong_min
#line 240
			    && expect[j] <= longlong_max;
#line 240
	    } else {
#line 240
		allInExtRange = 0;
#line 240
	    }
#line 240
	}
#line 240
	err = nc_get_var_longlong(ncid, i, value);
#line 240
	if (canConvert) {
#line 240
	    if (allInExtRange) {
#line 240
		if (allInIntRange) {
#line 240
		    IF (err)
#line 240
			error("%s", nc_strerror(err));
#line 240
		} else {
#line 240
		    IF (err != NC_ERANGE)
#line 240
			error("Range error: status = %d", err);
#line 240
		}
#line 240
	    } else {
#line 240
		IF (err != 0 && err != NC_ERANGE)
#line 240
		    error("OK or Range error: status = %d", err);
#line 240
	    }
#line 240
	    for (j = 0; j < nels; j++) {
#line 240
		if (inRange3(expect[j],var_type[i],NCT_LONGLONG)
#line 240
			&& expect[j] >= longlong_min && expect[j] <= longlong_max) {
#line 240
		    IF (!equal(value[j],expect[j],var_type[i],NCT_LONGLONG)){
#line 240
			error("value read not that expected");
#line 240
			if (verbose) {
#line 240
			    error("\n");
#line 240
			    error("varid: %d, ", i);
#line 240
			    error("var_name: %s, ", var_name[i]);
#line 240
			    error("element number: %d ", j);
#line 240
			    error("expect: %g", expect[j]);
#line 240
			    error("got: %g", (double) value[j]);
#line 240
			}
#line 240
		    } else {
#line 240
			nok++;
#line 240
		    }
#line 240
		}
#line 240
	    }
#line 240
	} else {
#line 240
	    IF (nels > 0 && err != NC_ECHAR)
#line 240
		error("wrong type: status = %d", err);
#line 240
	}
#line 240
    }
#line 240
    err = nc_close(ncid);
#line 240
    IF (err)
#line 240
	error("nc_close: %s", nc_strerror(err));
#line 240
    print_nok(nok);
#line 240
}
#line 240

void
#line 241
test_nc_get_var_ulonglong(void)
#line 241
{
#line 241
    int ncid;
#line 241
    int i;
#line 241
    int j;
#line 241
    int err;
#line 241
    int allInExtRange;	/* all values within external range? */
#line 241
    int allInIntRange;	/* all values within internal range? */
#line 241
    int nels;
#line 241
    int nok = 0;      /* count of valid comparisons */
#line 241
    size_t index[MAX_RANK];
#line 241
    int canConvert;     /* Both text or both numeric */
#line 241
    ulonglong value[MAX_NELS];
#line 241
    double expect[MAX_NELS];
#line 241

#line 241
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 241
    IF (err)
#line 241
	error("nc_open: %s", nc_strerror(err));
#line 241
    for (i = 0; i < numVars; i++) {
#line 241
        canConvert = (var_type[i] == NC_CHAR) == (NCT_ULONGLONG == NCT_TEXT);
#line 241
        assert(var_rank[i] <= MAX_RANK);
#line 241
        assert(var_nels[i] <= MAX_NELS);
#line 241
        err = nc_get_var_ulonglong(BAD_ID, i, value);
#line 241
        IF (err != NC_EBADID)
#line 241
	    error("bad ncid: status = %d", err);
#line 241
        err = nc_get_var_ulonglong(ncid, BAD_VARID, value);
#line 241
        IF (err != NC_ENOTVAR)
#line 241
	    error("bad var id: status = %d", err);
#line 241

#line 241
	nels = 1;
#line 241
	for (j = 0; j < var_rank[i]; j++) {
#line 241
	    nels *= var_shape[i][j];
#line 241
	}
#line 241
	allInExtRange = allInIntRange = 1;
#line 241
	for (j = 0; j < nels; j++) {
#line 241
	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
#line 241
	    IF (err)
#line 241
		error("error in toMixedBase 1");
#line 241
	    expect[j] = hash4(var_type[i], var_rank[i], index, NCT_ULONGLONG);
#line 241
	    if (inRange3(expect[j],var_type[i], NCT_ULONGLONG)) {
#line 241
		allInIntRange = allInIntRange && expect[j] >= ulonglong_min
#line 241
			    && expect[j] <= ulonglong_max;
#line 241
	    } else {
#line 241
		allInExtRange = 0;
#line 241
	    }
#line 241
	}
#line 241
	err = nc_get_var_ulonglong(ncid, i, value);
#line 241
	if (canConvert) {
#line 241
	    if (allInExtRange) {
#line 241
		if (allInIntRange) {
#line 241
		    IF (err)
#line 241
			error("%s", nc_strerror(err));
#line 241
		} else {
#line 241
		    IF (err != NC_ERANGE)
#line 241
			error("Range error: status = %d", err);
#line 241
		}
#line 241
	    } else {
#line 241
		IF (err != 0 && err != NC_ERANGE)
#line 241
		    error("OK or Range error: status = %d", err);
#line 241
	    }
#line 241
	    for (j = 0; j < nels; j++) {
#line 241
		if (inRange3(expect[j],var_type[i],NCT_ULONGLONG)
#line 241
			&& expect[j] >= ulonglong_min && expect[j] <= ulonglong_max) {
#line 241
		    IF (!equal(value[j],expect[j],var_type[i],NCT_ULONGLONG)){
#line 241
			error("value read not that expected");
#line 241
			if (verbose) {
#line 241
			    error("\n");
#line 241
			    error("varid: %d, ", i);
#line 241
			    error("var_name: %s, ", var_name[i]);
#line 241
			    error("element number: %d ", j);
#line 241
			    error("expect: %g", expect[j]);
#line 241
			    error("got: %g", (double) value[j]);
#line 241
			}
#line 241
		    } else {
#line 241
			nok++;
#line 241
		    }
#line 241
		}
#line 241
	    }
#line 241
	} else {
#line 241
	    IF (nels > 0 && err != NC_ECHAR)
#line 241
		error("wrong type: status = %d", err);
#line 241
	}
#line 241
    }
#line 241
    err = nc_close(ncid);
#line 241
    IF (err)
#line 241
	error("nc_close: %s", nc_strerror(err));
#line 241
    print_nok(nok);
#line 241
}
#line 241



#line 413

void
#line 414
test_nc_get_vara_text(void)
#line 414
{
#line 414
    int ncid;
#line 414
    int d;
#line 414
    int i;
#line 414
    int j;
#line 414
    int k;
#line 414
    int err;
#line 414
    int allInExtRange;	/* all values within external range? */
#line 414
    int allInIntRange;	/* all values within internal range? */
#line 414
    int nels;
#line 414
    int nslabs;
#line 414
    int nok = 0;      /* count of valid comparisons */
#line 414
    size_t start[MAX_RANK];
#line 414
    size_t edge[MAX_RANK];
#line 414
    size_t index[MAX_RANK];
#line 414
    size_t mid[MAX_RANK];
#line 414
    int canConvert;     /* Both text or both numeric */
#line 414
    text value[MAX_NELS];
#line 414
    double expect[MAX_NELS];
#line 414

#line 414
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 414
    IF (err)
#line 414
	error("nc_open: %s", nc_strerror(err));
#line 414
    for (i = 0; i < numVars; i++) {
#line 414
        canConvert = (var_type[i] == NC_CHAR) == (NCT_TEXT == NCT_TEXT);
#line 414
        assert(var_rank[i] <= MAX_RANK);
#line 414
        assert(var_nels[i] <= MAX_NELS);
#line 414
	for (j = 0; j < var_rank[i]; j++) {
#line 414
	    start[j] = 0;
#line 414
	    edge[j] = 1;
#line 414
	}
#line 414
        err = nc_get_vara_text(BAD_ID, i, start, edge, value);
#line 414
        IF (err != NC_EBADID)
#line 414
	    error("bad ncid: status = %d", err);
#line 414
        err = nc_get_vara_text(ncid, BAD_VARID, start, edge, value);
#line 414
        IF (err != NC_ENOTVAR)
#line 414
	    error("bad var id: status = %d", err);
#line 414
	for (j = 0; j < var_rank[i]; j++) {
#line 414
	    start[j] = var_shape[i][j];
#line 414
	    err = nc_get_vara_text(ncid, i, start, edge, value);
#line 414
            IF (canConvert && err != NC_EINVALCOORDS)
#line 414
                error("bad index: status = %d", err);
#line 414
	    start[j] = 0;
#line 414
	    edge[j] = var_shape[i][j] + 1;
#line 414
	    err = nc_get_vara_text(ncid, i, start, edge, value);
#line 414
            IF (canConvert && err != NC_EEDGE)
#line 414
		error("bad edge: status = %d", err);
#line 414
	    edge[j] = 1;
#line 414
	}
#line 414
            /* Check non-scalars for correct error returned even when */
#line 414
            /* there is nothing to get (edge[j]==0) */
#line 414
	if(var_rank[i] > 0) {
#line 414
	    for (j = 0; j < var_rank[i]; j++) {
#line 414
		edge[j] = 0;
#line 414
	    }
#line 414
	    err = nc_get_vara_text(BAD_ID, i, start, edge, value);
#line 414
	    IF (err != NC_EBADID) 
#line 414
		error("bad ncid: status = %d", err);
#line 414
	    err = nc_get_vara_text(ncid, BAD_VARID, start, edge, value);
#line 414
	    IF (err != NC_ENOTVAR) 
#line 414
		error("bad var id: status = %d", err);
#line 414
	    for (j = 0; j < var_rank[i]; j++) {
#line 414
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 414
		    start[j] = var_shape[i][j];
#line 414
		    err = nc_get_vara_text(ncid, i, start, edge, value);
#line 414
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 414
			error("bad start: status = %d", err);
#line 414
		    start[j] = 0;
#line 414
		}
#line 414
	    }
#line 414
	    err = nc_get_vara_text(ncid, i, start, edge, value);
#line 414
	    if (canConvert) {
#line 414
		IF (err) 
#line 414
		    error("%s", nc_strerror(err));
#line 414
	    } else {
#line 414
		IF (err != NC_ECHAR)
#line 414
		    error("wrong type: status = %d", err);
#line 414
	    }
#line 414
	    for (j = 0; j < var_rank[i]; j++) {
#line 414
		edge[j] = 1;
#line 414
	    }
#line 414
	}            /* Choose a random point dividing each dim into 2 parts */
#line 414
            /* get 2^rank (nslabs) slabs so defined */
#line 414
        nslabs = 1;
#line 414
        for (j = 0; j < var_rank[i]; j++) {
#line 414
            mid[j] = roll( var_shape[i][j] );
#line 414
            nslabs *= 2;
#line 414
        }
#line 414
            /* bits of k determine whether to get lower or upper part of dim */
#line 414
        for (k = 0; k < nslabs; k++) {
#line 414
            nels = 1;
#line 414
            for (j = 0; j < var_rank[i]; j++) {
#line 414
                if ((k >> j) & 1) {
#line 414
                    start[j] = 0;
#line 414
                    edge[j] = mid[j];
#line 414
                }else{
#line 414
                    start[j] = mid[j];
#line 414
                    edge[j] = var_shape[i][j] - mid[j];
#line 414
                }
#line 414
                nels *= edge[j];
#line 414
            }
#line 414
	    allInExtRange = allInIntRange = 1;
#line 414
            for (j = 0; j < nels; j++) {
#line 414
                err = toMixedBase(j, var_rank[i], edge, index);
#line 414
                IF (err)
#line 414
                    error("error in toMixedBase 1");
#line 414
                for (d = 0; d < var_rank[i]; d++)
#line 414
                    index[d] += start[d];
#line 414
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_TEXT);
#line 414
		if (inRange3(expect[j],var_type[i], NCT_TEXT)) {
#line 414
		    allInIntRange = allInIntRange && expect[j] >= text_min
#line 414
				&& expect[j] <= text_max;
#line 414
		} else {
#line 414
		    allInExtRange = 0;
#line 414
		}
#line 414
	    }
#line 414
            if (var_rank[i] == 0 && i%2)
#line 414
		err = nc_get_vara_text(ncid, i, NULL, NULL, value);
#line 414
	    else
#line 414
		err = nc_get_vara_text(ncid, i, start, edge, value);
#line 414
            if (canConvert) {
#line 414
		if (allInExtRange) {
#line 414
		    if (allInIntRange) {
#line 414
			IF (err)
#line 414
			    error("%s", nc_strerror(err));
#line 414
		    } else {
#line 414
			IF (err != NC_ERANGE)
#line 414
			    error("Range error: status = %d", err);
#line 414
		    }
#line 414
		} else {
#line 414
		    IF (err != 0 && err != NC_ERANGE)
#line 414
			error("OK or Range error: status = %d", err);
#line 414
		}
#line 414
		for (j = 0; j < nels; j++) {
#line 414
		    if (inRange3(expect[j],var_type[i],NCT_TEXT)
#line 414
			    && expect[j] >= text_min && expect[j] <= text_max) {
#line 414
			IF (!equal(value[j],expect[j],var_type[i],NCT_TEXT)){
#line 414
			    error("value read not that expected");
#line 414
			    if (verbose) {
#line 414
				error("\n");
#line 414
				error("varid: %d, ", i);
#line 414
				error("var_name: %s, ", var_name[i]);
#line 414
				error("element number: %d ", j);
#line 414
				error("expect: %g", expect[j]);
#line 414
				error("got: %g", (double) value[j]);
#line 414
			    }
#line 414
			} else {
#line 414
			    nok++;
#line 414
			}
#line 414
		    }
#line 414
		}
#line 414
            } else {
#line 414
                IF (nels > 0 && err != NC_ECHAR)
#line 414
                    error("wrong type: status = %d", err);
#line 414
            }
#line 414
        }
#line 414
    }
#line 414
    err = nc_close(ncid);
#line 414
    IF (err)
#line 414
	error("nc_close: %s", nc_strerror(err));
#line 414
    print_nok(nok);
#line 414
}
#line 414

void
#line 415
test_nc_get_vara_uchar(void)
#line 415
{
#line 415
    int ncid;
#line 415
    int d;
#line 415
    int i;
#line 415
    int j;
#line 415
    int k;
#line 415
    int err;
#line 415
    int allInExtRange;	/* all values within external range? */
#line 415
    int allInIntRange;	/* all values within internal range? */
#line 415
    int nels;
#line 415
    int nslabs;
#line 415
    int nok = 0;      /* count of valid comparisons */
#line 415
    size_t start[MAX_RANK];
#line 415
    size_t edge[MAX_RANK];
#line 415
    size_t index[MAX_RANK];
#line 415
    size_t mid[MAX_RANK];
#line 415
    int canConvert;     /* Both text or both numeric */
#line 415
    uchar value[MAX_NELS];
#line 415
    double expect[MAX_NELS];
#line 415

#line 415
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 415
    IF (err)
#line 415
	error("nc_open: %s", nc_strerror(err));
#line 415
    for (i = 0; i < numVars; i++) {
#line 415
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UCHAR == NCT_TEXT);
#line 415
        assert(var_rank[i] <= MAX_RANK);
#line 415
        assert(var_nels[i] <= MAX_NELS);
#line 415
	for (j = 0; j < var_rank[i]; j++) {
#line 415
	    start[j] = 0;
#line 415
	    edge[j] = 1;
#line 415
	}
#line 415
        err = nc_get_vara_uchar(BAD_ID, i, start, edge, value);
#line 415
        IF (err != NC_EBADID)
#line 415
	    error("bad ncid: status = %d", err);
#line 415
        err = nc_get_vara_uchar(ncid, BAD_VARID, start, edge, value);
#line 415
        IF (err != NC_ENOTVAR)
#line 415
	    error("bad var id: status = %d", err);
#line 415
	for (j = 0; j < var_rank[i]; j++) {
#line 415
	    start[j] = var_shape[i][j];
#line 415
	    err = nc_get_vara_uchar(ncid, i, start, edge, value);
#line 415
            IF (canConvert && err != NC_EINVALCOORDS)
#line 415
                error("bad index: status = %d", err);
#line 415
	    start[j] = 0;
#line 415
	    edge[j] = var_shape[i][j] + 1;
#line 415
	    err = nc_get_vara_uchar(ncid, i, start, edge, value);
#line 415
            IF (canConvert && err != NC_EEDGE)
#line 415
		error("bad edge: status = %d", err);
#line 415
	    edge[j] = 1;
#line 415
	}
#line 415
            /* Check non-scalars for correct error returned even when */
#line 415
            /* there is nothing to get (edge[j]==0) */
#line 415
	if(var_rank[i] > 0) {
#line 415
	    for (j = 0; j < var_rank[i]; j++) {
#line 415
		edge[j] = 0;
#line 415
	    }
#line 415
	    err = nc_get_vara_uchar(BAD_ID, i, start, edge, value);
#line 415
	    IF (err != NC_EBADID) 
#line 415
		error("bad ncid: status = %d", err);
#line 415
	    err = nc_get_vara_uchar(ncid, BAD_VARID, start, edge, value);
#line 415
	    IF (err != NC_ENOTVAR) 
#line 415
		error("bad var id: status = %d", err);
#line 415
	    for (j = 0; j < var_rank[i]; j++) {
#line 415
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 415
		    start[j] = var_shape[i][j];
#line 415
		    err = nc_get_vara_uchar(ncid, i, start, edge, value);
#line 415
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 415
			error("bad start: status = %d", err);
#line 415
		    start[j] = 0;
#line 415
		}
#line 415
	    }
#line 415
	    err = nc_get_vara_uchar(ncid, i, start, edge, value);
#line 415
	    if (canConvert) {
#line 415
		IF (err) 
#line 415
		    error("%s", nc_strerror(err));
#line 415
	    } else {
#line 415
		IF (err != NC_ECHAR)
#line 415
		    error("wrong type: status = %d", err);
#line 415
	    }
#line 415
	    for (j = 0; j < var_rank[i]; j++) {
#line 415
		edge[j] = 1;
#line 415
	    }
#line 415
	}            /* Choose a random point dividing each dim into 2 parts */
#line 415
            /* get 2^rank (nslabs) slabs so defined */
#line 415
        nslabs = 1;
#line 415
        for (j = 0; j < var_rank[i]; j++) {
#line 415
            mid[j] = roll( var_shape[i][j] );
#line 415
            nslabs *= 2;
#line 415
        }
#line 415
            /* bits of k determine whether to get lower or upper part of dim */
#line 415
        for (k = 0; k < nslabs; k++) {
#line 415
            nels = 1;
#line 415
            for (j = 0; j < var_rank[i]; j++) {
#line 415
                if ((k >> j) & 1) {
#line 415
                    start[j] = 0;
#line 415
                    edge[j] = mid[j];
#line 415
                }else{
#line 415
                    start[j] = mid[j];
#line 415
                    edge[j] = var_shape[i][j] - mid[j];
#line 415
                }
#line 415
                nels *= edge[j];
#line 415
            }
#line 415
	    allInExtRange = allInIntRange = 1;
#line 415
            for (j = 0; j < nels; j++) {
#line 415
                err = toMixedBase(j, var_rank[i], edge, index);
#line 415
                IF (err)
#line 415
                    error("error in toMixedBase 1");
#line 415
                for (d = 0; d < var_rank[i]; d++)
#line 415
                    index[d] += start[d];
#line 415
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_UCHAR);
#line 415
		if (inRange3(expect[j],var_type[i], NCT_UCHAR)) {
#line 415
		    allInIntRange = allInIntRange && expect[j] >= uchar_min
#line 415
				&& expect[j] <= uchar_max;
#line 415
		} else {
#line 415
		    allInExtRange = 0;
#line 415
		}
#line 415
	    }
#line 415
            if (var_rank[i] == 0 && i%2)
#line 415
		err = nc_get_vara_uchar(ncid, i, NULL, NULL, value);
#line 415
	    else
#line 415
		err = nc_get_vara_uchar(ncid, i, start, edge, value);
#line 415
            if (canConvert) {
#line 415
		if (allInExtRange) {
#line 415
		    if (allInIntRange) {
#line 415
			IF (err)
#line 415
			    error("%s", nc_strerror(err));
#line 415
		    } else {
#line 415
			IF (err != NC_ERANGE)
#line 415
			    error("Range error: status = %d", err);
#line 415
		    }
#line 415
		} else {
#line 415
		    IF (err != 0 && err != NC_ERANGE)
#line 415
			error("OK or Range error: status = %d", err);
#line 415
		}
#line 415
		for (j = 0; j < nels; j++) {
#line 415
		    if (inRange3(expect[j],var_type[i],NCT_UCHAR)
#line 415
			    && expect[j] >= uchar_min && expect[j] <= uchar_max) {
#line 415
			IF (!equal(value[j],expect[j],var_type[i],NCT_UCHAR)){
#line 415
			    error("value read not that expected");
#line 415
			    if (verbose) {
#line 415
				error("\n");
#line 415
				error("varid: %d, ", i);
#line 415
				error("var_name: %s, ", var_name[i]);
#line 415
				error("element number: %d ", j);
#line 415
				error("expect: %g", expect[j]);
#line 415
				error("got: %g", (double) value[j]);
#line 415
			    }
#line 415
			} else {
#line 415
			    nok++;
#line 415
			}
#line 415
		    }
#line 415
		}
#line 415
            } else {
#line 415
                IF (nels > 0 && err != NC_ECHAR)
#line 415
                    error("wrong type: status = %d", err);
#line 415
            }
#line 415
        }
#line 415
    }
#line 415
    err = nc_close(ncid);
#line 415
    IF (err)
#line 415
	error("nc_close: %s", nc_strerror(err));
#line 415
    print_nok(nok);
#line 415
}
#line 415

void
#line 416
test_nc_get_vara_schar(void)
#line 416
{
#line 416
    int ncid;
#line 416
    int d;
#line 416
    int i;
#line 416
    int j;
#line 416
    int k;
#line 416
    int err;
#line 416
    int allInExtRange;	/* all values within external range? */
#line 416
    int allInIntRange;	/* all values within internal range? */
#line 416
    int nels;
#line 416
    int nslabs;
#line 416
    int nok = 0;      /* count of valid comparisons */
#line 416
    size_t start[MAX_RANK];
#line 416
    size_t edge[MAX_RANK];
#line 416
    size_t index[MAX_RANK];
#line 416
    size_t mid[MAX_RANK];
#line 416
    int canConvert;     /* Both text or both numeric */
#line 416
    schar value[MAX_NELS];
#line 416
    double expect[MAX_NELS];
#line 416

#line 416
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 416
    IF (err)
#line 416
	error("nc_open: %s", nc_strerror(err));
#line 416
    for (i = 0; i < numVars; i++) {
#line 416
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SCHAR == NCT_TEXT);
#line 416
        assert(var_rank[i] <= MAX_RANK);
#line 416
        assert(var_nels[i] <= MAX_NELS);
#line 416
	for (j = 0; j < var_rank[i]; j++) {
#line 416
	    start[j] = 0;
#line 416
	    edge[j] = 1;
#line 416
	}
#line 416
        err = nc_get_vara_schar(BAD_ID, i, start, edge, value);
#line 416
        IF (err != NC_EBADID)
#line 416
	    error("bad ncid: status = %d", err);
#line 416
        err = nc_get_vara_schar(ncid, BAD_VARID, start, edge, value);
#line 416
        IF (err != NC_ENOTVAR)
#line 416
	    error("bad var id: status = %d", err);
#line 416
	for (j = 0; j < var_rank[i]; j++) {
#line 416
	    start[j] = var_shape[i][j];
#line 416
	    err = nc_get_vara_schar(ncid, i, start, edge, value);
#line 416
            IF (canConvert && err != NC_EINVALCOORDS)
#line 416
                error("bad index: status = %d", err);
#line 416
	    start[j] = 0;
#line 416
	    edge[j] = var_shape[i][j] + 1;
#line 416
	    err = nc_get_vara_schar(ncid, i, start, edge, value);
#line 416
            IF (canConvert && err != NC_EEDGE)
#line 416
		error("bad edge: status = %d", err);
#line 416
	    edge[j] = 1;
#line 416
	}
#line 416
            /* Check non-scalars for correct error returned even when */
#line 416
            /* there is nothing to get (edge[j]==0) */
#line 416
	if(var_rank[i] > 0) {
#line 416
	    for (j = 0; j < var_rank[i]; j++) {
#line 416
		edge[j] = 0;
#line 416
	    }
#line 416
	    err = nc_get_vara_schar(BAD_ID, i, start, edge, value);
#line 416
	    IF (err != NC_EBADID) 
#line 416
		error("bad ncid: status = %d", err);
#line 416
	    err = nc_get_vara_schar(ncid, BAD_VARID, start, edge, value);
#line 416
	    IF (err != NC_ENOTVAR) 
#line 416
		error("bad var id: status = %d", err);
#line 416
	    for (j = 0; j < var_rank[i]; j++) {
#line 416
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 416
		    start[j] = var_shape[i][j];
#line 416
		    err = nc_get_vara_schar(ncid, i, start, edge, value);
#line 416
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 416
			error("bad start: status = %d", err);
#line 416
		    start[j] = 0;
#line 416
		}
#line 416
	    }
#line 416
	    err = nc_get_vara_schar(ncid, i, start, edge, value);
#line 416
	    if (canConvert) {
#line 416
		IF (err) 
#line 416
		    error("%s", nc_strerror(err));
#line 416
	    } else {
#line 416
		IF (err != NC_ECHAR)
#line 416
		    error("wrong type: status = %d", err);
#line 416
	    }
#line 416
	    for (j = 0; j < var_rank[i]; j++) {
#line 416
		edge[j] = 1;
#line 416
	    }
#line 416
	}            /* Choose a random point dividing each dim into 2 parts */
#line 416
            /* get 2^rank (nslabs) slabs so defined */
#line 416
        nslabs = 1;
#line 416
        for (j = 0; j < var_rank[i]; j++) {
#line 416
            mid[j] = roll( var_shape[i][j] );
#line 416
            nslabs *= 2;
#line 416
        }
#line 416
            /* bits of k determine whether to get lower or upper part of dim */
#line 416
        for (k = 0; k < nslabs; k++) {
#line 416
            nels = 1;
#line 416
            for (j = 0; j < var_rank[i]; j++) {
#line 416
                if ((k >> j) & 1) {
#line 416
                    start[j] = 0;
#line 416
                    edge[j] = mid[j];
#line 416
                }else{
#line 416
                    start[j] = mid[j];
#line 416
                    edge[j] = var_shape[i][j] - mid[j];
#line 416
                }
#line 416
                nels *= edge[j];
#line 416
            }
#line 416
	    allInExtRange = allInIntRange = 1;
#line 416
            for (j = 0; j < nels; j++) {
#line 416
                err = toMixedBase(j, var_rank[i], edge, index);
#line 416
                IF (err)
#line 416
                    error("error in toMixedBase 1");
#line 416
                for (d = 0; d < var_rank[i]; d++)
#line 416
                    index[d] += start[d];
#line 416
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_SCHAR);
#line 416
		if (inRange3(expect[j],var_type[i], NCT_SCHAR)) {
#line 416
		    allInIntRange = allInIntRange && expect[j] >= schar_min
#line 416
				&& expect[j] <= schar_max;
#line 416
		} else {
#line 416
		    allInExtRange = 0;
#line 416
		}
#line 416
	    }
#line 416
            if (var_rank[i] == 0 && i%2)
#line 416
		err = nc_get_vara_schar(ncid, i, NULL, NULL, value);
#line 416
	    else
#line 416
		err = nc_get_vara_schar(ncid, i, start, edge, value);
#line 416
            if (canConvert) {
#line 416
		if (allInExtRange) {
#line 416
		    if (allInIntRange) {
#line 416
			IF (err)
#line 416
			    error("%s", nc_strerror(err));
#line 416
		    } else {
#line 416
			IF (err != NC_ERANGE)
#line 416
			    error("Range error: status = %d", err);
#line 416
		    }
#line 416
		} else {
#line 416
		    IF (err != 0 && err != NC_ERANGE)
#line 416
			error("OK or Range error: status = %d", err);
#line 416
		}
#line 416
		for (j = 0; j < nels; j++) {
#line 416
		    if (inRange3(expect[j],var_type[i],NCT_SCHAR)
#line 416
			    && expect[j] >= schar_min && expect[j] <= schar_max) {
#line 416
			IF (!equal(value[j],expect[j],var_type[i],NCT_SCHAR)){
#line 416
			    error("value read not that expected");
#line 416
			    if (verbose) {
#line 416
				error("\n");
#line 416
				error("varid: %d, ", i);
#line 416
				error("var_name: %s, ", var_name[i]);
#line 416
				error("element number: %d ", j);
#line 416
				error("expect: %g", expect[j]);
#line 416
				error("got: %g", (double) value[j]);
#line 416
			    }
#line 416
			} else {
#line 416
			    nok++;
#line 416
			}
#line 416
		    }
#line 416
		}
#line 416
            } else {
#line 416
                IF (nels > 0 && err != NC_ECHAR)
#line 416
                    error("wrong type: status = %d", err);
#line 416
            }
#line 416
        }
#line 416
    }
#line 416
    err = nc_close(ncid);
#line 416
    IF (err)
#line 416
	error("nc_close: %s", nc_strerror(err));
#line 416
    print_nok(nok);
#line 416
}
#line 416

void
#line 417
test_nc_get_vara_short(void)
#line 417
{
#line 417
    int ncid;
#line 417
    int d;
#line 417
    int i;
#line 417
    int j;
#line 417
    int k;
#line 417
    int err;
#line 417
    int allInExtRange;	/* all values within external range? */
#line 417
    int allInIntRange;	/* all values within internal range? */
#line 417
    int nels;
#line 417
    int nslabs;
#line 417
    int nok = 0;      /* count of valid comparisons */
#line 417
    size_t start[MAX_RANK];
#line 417
    size_t edge[MAX_RANK];
#line 417
    size_t index[MAX_RANK];
#line 417
    size_t mid[MAX_RANK];
#line 417
    int canConvert;     /* Both text or both numeric */
#line 417
    short value[MAX_NELS];
#line 417
    double expect[MAX_NELS];
#line 417

#line 417
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 417
    IF (err)
#line 417
	error("nc_open: %s", nc_strerror(err));
#line 417
    for (i = 0; i < numVars; i++) {
#line 417
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SHORT == NCT_TEXT);
#line 417
        assert(var_rank[i] <= MAX_RANK);
#line 417
        assert(var_nels[i] <= MAX_NELS);
#line 417
	for (j = 0; j < var_rank[i]; j++) {
#line 417
	    start[j] = 0;
#line 417
	    edge[j] = 1;
#line 417
	}
#line 417
        err = nc_get_vara_short(BAD_ID, i, start, edge, value);
#line 417
        IF (err != NC_EBADID)
#line 417
	    error("bad ncid: status = %d", err);
#line 417
        err = nc_get_vara_short(ncid, BAD_VARID, start, edge, value);
#line 417
        IF (err != NC_ENOTVAR)
#line 417
	    error("bad var id: status = %d", err);
#line 417
	for (j = 0; j < var_rank[i]; j++) {
#line 417
	    start[j] = var_shape[i][j];
#line 417
	    err = nc_get_vara_short(ncid, i, start, edge, value);
#line 417
            IF (canConvert && err != NC_EINVALCOORDS)
#line 417
                error("bad index: status = %d", err);
#line 417
	    start[j] = 0;
#line 417
	    edge[j] = var_shape[i][j] + 1;
#line 417
	    err = nc_get_vara_short(ncid, i, start, edge, value);
#line 417
            IF (canConvert && err != NC_EEDGE)
#line 417
		error("bad edge: status = %d", err);
#line 417
	    edge[j] = 1;
#line 417
	}
#line 417
            /* Check non-scalars for correct error returned even when */
#line 417
            /* there is nothing to get (edge[j]==0) */
#line 417
	if(var_rank[i] > 0) {
#line 417
	    for (j = 0; j < var_rank[i]; j++) {
#line 417
		edge[j] = 0;
#line 417
	    }
#line 417
	    err = nc_get_vara_short(BAD_ID, i, start, edge, value);
#line 417
	    IF (err != NC_EBADID) 
#line 417
		error("bad ncid: status = %d", err);
#line 417
	    err = nc_get_vara_short(ncid, BAD_VARID, start, edge, value);
#line 417
	    IF (err != NC_ENOTVAR) 
#line 417
		error("bad var id: status = %d", err);
#line 417
	    for (j = 0; j < var_rank[i]; j++) {
#line 417
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 417
		    start[j] = var_shape[i][j];
#line 417
		    err = nc_get_vara_short(ncid, i, start, edge, value);
#line 417
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 417
			error("bad start: status = %d", err);
#line 417
		    start[j] = 0;
#line 417
		}
#line 417
	    }
#line 417
	    err = nc_get_vara_short(ncid, i, start, edge, value);
#line 417
	    if (canConvert) {
#line 417
		IF (err) 
#line 417
		    error("%s", nc_strerror(err));
#line 417
	    } else {
#line 417
		IF (err != NC_ECHAR)
#line 417
		    error("wrong type: status = %d", err);
#line 417
	    }
#line 417
	    for (j = 0; j < var_rank[i]; j++) {
#line 417
		edge[j] = 1;
#line 417
	    }
#line 417
	}            /* Choose a random point dividing each dim into 2 parts */
#line 417
            /* get 2^rank (nslabs) slabs so defined */
#line 417
        nslabs = 1;
#line 417
        for (j = 0; j < var_rank[i]; j++) {
#line 417
            mid[j] = roll( var_shape[i][j] );
#line 417
            nslabs *= 2;
#line 417
        }
#line 417
            /* bits of k determine whether to get lower or upper part of dim */
#line 417
        for (k = 0; k < nslabs; k++) {
#line 417
            nels = 1;
#line 417
            for (j = 0; j < var_rank[i]; j++) {
#line 417
                if ((k >> j) & 1) {
#line 417
                    start[j] = 0;
#line 417
                    edge[j] = mid[j];
#line 417
                }else{
#line 417
                    start[j] = mid[j];
#line 417
                    edge[j] = var_shape[i][j] - mid[j];
#line 417
                }
#line 417
                nels *= edge[j];
#line 417
            }
#line 417
	    allInExtRange = allInIntRange = 1;
#line 417
            for (j = 0; j < nels; j++) {
#line 417
                err = toMixedBase(j, var_rank[i], edge, index);
#line 417
                IF (err)
#line 417
                    error("error in toMixedBase 1");
#line 417
                for (d = 0; d < var_rank[i]; d++)
#line 417
                    index[d] += start[d];
#line 417
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_SHORT);
#line 417
		if (inRange3(expect[j],var_type[i], NCT_SHORT)) {
#line 417
		    allInIntRange = allInIntRange && expect[j] >= short_min
#line 417
				&& expect[j] <= short_max;
#line 417
		} else {
#line 417
		    allInExtRange = 0;
#line 417
		}
#line 417
	    }
#line 417
            if (var_rank[i] == 0 && i%2)
#line 417
		err = nc_get_vara_short(ncid, i, NULL, NULL, value);
#line 417
	    else
#line 417
		err = nc_get_vara_short(ncid, i, start, edge, value);
#line 417
            if (canConvert) {
#line 417
		if (allInExtRange) {
#line 417
		    if (allInIntRange) {
#line 417
			IF (err)
#line 417
			    error("%s", nc_strerror(err));
#line 417
		    } else {
#line 417
			IF (err != NC_ERANGE)
#line 417
			    error("Range error: status = %d", err);
#line 417
		    }
#line 417
		} else {
#line 417
		    IF (err != 0 && err != NC_ERANGE)
#line 417
			error("OK or Range error: status = %d", err);
#line 417
		}
#line 417
		for (j = 0; j < nels; j++) {
#line 417
		    if (inRange3(expect[j],var_type[i],NCT_SHORT)
#line 417
			    && expect[j] >= short_min && expect[j] <= short_max) {
#line 417
			IF (!equal(value[j],expect[j],var_type[i],NCT_SHORT)){
#line 417
			    error("value read not that expected");
#line 417
			    if (verbose) {
#line 417
				error("\n");
#line 417
				error("varid: %d, ", i);
#line 417
				error("var_name: %s, ", var_name[i]);
#line 417
				error("element number: %d ", j);
#line 417
				error("expect: %g", expect[j]);
#line 417
				error("got: %g", (double) value[j]);
#line 417
			    }
#line 417
			} else {
#line 417
			    nok++;
#line 417
			}
#line 417
		    }
#line 417
		}
#line 417
            } else {
#line 417
                IF (nels > 0 && err != NC_ECHAR)
#line 417
                    error("wrong type: status = %d", err);
#line 417
            }
#line 417
        }
#line 417
    }
#line 417
    err = nc_close(ncid);
#line 417
    IF (err)
#line 417
	error("nc_close: %s", nc_strerror(err));
#line 417
    print_nok(nok);
#line 417
}
#line 417

void
#line 418
test_nc_get_vara_int(void)
#line 418
{
#line 418
    int ncid;
#line 418
    int d;
#line 418
    int i;
#line 418
    int j;
#line 418
    int k;
#line 418
    int err;
#line 418
    int allInExtRange;	/* all values within external range? */
#line 418
    int allInIntRange;	/* all values within internal range? */
#line 418
    int nels;
#line 418
    int nslabs;
#line 418
    int nok = 0;      /* count of valid comparisons */
#line 418
    size_t start[MAX_RANK];
#line 418
    size_t edge[MAX_RANK];
#line 418
    size_t index[MAX_RANK];
#line 418
    size_t mid[MAX_RANK];
#line 418
    int canConvert;     /* Both text or both numeric */
#line 418
    int value[MAX_NELS];
#line 418
    double expect[MAX_NELS];
#line 418

#line 418
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 418
    IF (err)
#line 418
	error("nc_open: %s", nc_strerror(err));
#line 418
    for (i = 0; i < numVars; i++) {
#line 418
        canConvert = (var_type[i] == NC_CHAR) == (NCT_INT == NCT_TEXT);
#line 418
        assert(var_rank[i] <= MAX_RANK);
#line 418
        assert(var_nels[i] <= MAX_NELS);
#line 418
	for (j = 0; j < var_rank[i]; j++) {
#line 418
	    start[j] = 0;
#line 418
	    edge[j] = 1;
#line 418
	}
#line 418
        err = nc_get_vara_int(BAD_ID, i, start, edge, value);
#line 418
        IF (err != NC_EBADID)
#line 418
	    error("bad ncid: status = %d", err);
#line 418
        err = nc_get_vara_int(ncid, BAD_VARID, start, edge, value);
#line 418
        IF (err != NC_ENOTVAR)
#line 418
	    error("bad var id: status = %d", err);
#line 418
	for (j = 0; j < var_rank[i]; j++) {
#line 418
	    start[j] = var_shape[i][j];
#line 418
	    err = nc_get_vara_int(ncid, i, start, edge, value);
#line 418
            IF (canConvert && err != NC_EINVALCOORDS)
#line 418
                error("bad index: status = %d", err);
#line 418
	    start[j] = 0;
#line 418
	    edge[j] = var_shape[i][j] + 1;
#line 418
	    err = nc_get_vara_int(ncid, i, start, edge, value);
#line 418
            IF (canConvert && err != NC_EEDGE)
#line 418
		error("bad edge: status = %d", err);
#line 418
	    edge[j] = 1;
#line 418
	}
#line 418
            /* Check non-scalars for correct error returned even when */
#line 418
            /* there is nothing to get (edge[j]==0) */
#line 418
	if(var_rank[i] > 0) {
#line 418
	    for (j = 0; j < var_rank[i]; j++) {
#line 418
		edge[j] = 0;
#line 418
	    }
#line 418
	    err = nc_get_vara_int(BAD_ID, i, start, edge, value);
#line 418
	    IF (err != NC_EBADID) 
#line 418
		error("bad ncid: status = %d", err);
#line 418
	    err = nc_get_vara_int(ncid, BAD_VARID, start, edge, value);
#line 418
	    IF (err != NC_ENOTVAR) 
#line 418
		error("bad var id: status = %d", err);
#line 418
	    for (j = 0; j < var_rank[i]; j++) {
#line 418
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 418
		    start[j] = var_shape[i][j];
#line 418
		    err = nc_get_vara_int(ncid, i, start, edge, value);
#line 418
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 418
			error("bad start: status = %d", err);
#line 418
		    start[j] = 0;
#line 418
		}
#line 418
	    }
#line 418
	    err = nc_get_vara_int(ncid, i, start, edge, value);
#line 418
	    if (canConvert) {
#line 418
		IF (err) 
#line 418
		    error("%s", nc_strerror(err));
#line 418
	    } else {
#line 418
		IF (err != NC_ECHAR)
#line 418
		    error("wrong type: status = %d", err);
#line 418
	    }
#line 418
	    for (j = 0; j < var_rank[i]; j++) {
#line 418
		edge[j] = 1;
#line 418
	    }
#line 418
	}            /* Choose a random point dividing each dim into 2 parts */
#line 418
            /* get 2^rank (nslabs) slabs so defined */
#line 418
        nslabs = 1;
#line 418
        for (j = 0; j < var_rank[i]; j++) {
#line 418
            mid[j] = roll( var_shape[i][j] );
#line 418
            nslabs *= 2;
#line 418
        }
#line 418
            /* bits of k determine whether to get lower or upper part of dim */
#line 418
        for (k = 0; k < nslabs; k++) {
#line 418
            nels = 1;
#line 418
            for (j = 0; j < var_rank[i]; j++) {
#line 418
                if ((k >> j) & 1) {
#line 418
                    start[j] = 0;
#line 418
                    edge[j] = mid[j];
#line 418
                }else{
#line 418
                    start[j] = mid[j];
#line 418
                    edge[j] = var_shape[i][j] - mid[j];
#line 418
                }
#line 418
                nels *= edge[j];
#line 418
            }
#line 418
	    allInExtRange = allInIntRange = 1;
#line 418
            for (j = 0; j < nels; j++) {
#line 418
                err = toMixedBase(j, var_rank[i], edge, index);
#line 418
                IF (err)
#line 418
                    error("error in toMixedBase 1");
#line 418
                for (d = 0; d < var_rank[i]; d++)
#line 418
                    index[d] += start[d];
#line 418
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_INT);
#line 418
		if (inRange3(expect[j],var_type[i], NCT_INT)) {
#line 418
		    allInIntRange = allInIntRange && expect[j] >= int_min
#line 418
				&& expect[j] <= int_max;
#line 418
		} else {
#line 418
		    allInExtRange = 0;
#line 418
		}
#line 418
	    }
#line 418
            if (var_rank[i] == 0 && i%2)
#line 418
		err = nc_get_vara_int(ncid, i, NULL, NULL, value);
#line 418
	    else
#line 418
		err = nc_get_vara_int(ncid, i, start, edge, value);
#line 418
            if (canConvert) {
#line 418
		if (allInExtRange) {
#line 418
		    if (allInIntRange) {
#line 418
			IF (err)
#line 418
			    error("%s", nc_strerror(err));
#line 418
		    } else {
#line 418
			IF (err != NC_ERANGE)
#line 418
			    error("Range error: status = %d", err);
#line 418
		    }
#line 418
		} else {
#line 418
		    IF (err != 0 && err != NC_ERANGE)
#line 418
			error("OK or Range error: status = %d", err);
#line 418
		}
#line 418
		for (j = 0; j < nels; j++) {
#line 418
		    if (inRange3(expect[j],var_type[i],NCT_INT)
#line 418
			    && expect[j] >= int_min && expect[j] <= int_max) {
#line 418
			IF (!equal(value[j],expect[j],var_type[i],NCT_INT)){
#line 418
			    error("value read not that expected");
#line 418
			    if (verbose) {
#line 418
				error("\n");
#line 418
				error("varid: %d, ", i);
#line 418
				error("var_name: %s, ", var_name[i]);
#line 418
				error("element number: %d ", j);
#line 418
				error("expect: %g", expect[j]);
#line 418
				error("got: %g", (double) value[j]);
#line 418
			    }
#line 418
			} else {
#line 418
			    nok++;
#line 418
			}
#line 418
		    }
#line 418
		}
#line 418
            } else {
#line 418
                IF (nels > 0 && err != NC_ECHAR)
#line 418
                    error("wrong type: status = %d", err);
#line 418
            }
#line 418
        }
#line 418
    }
#line 418
    err = nc_close(ncid);
#line 418
    IF (err)
#line 418
	error("nc_close: %s", nc_strerror(err));
#line 418
    print_nok(nok);
#line 418
}
#line 418

void
#line 419
test_nc_get_vara_long(void)
#line 419
{
#line 419
    int ncid;
#line 419
    int d;
#line 419
    int i;
#line 419
    int j;
#line 419
    int k;
#line 419
    int err;
#line 419
    int allInExtRange;	/* all values within external range? */
#line 419
    int allInIntRange;	/* all values within internal range? */
#line 419
    int nels;
#line 419
    int nslabs;
#line 419
    int nok = 0;      /* count of valid comparisons */
#line 419
    size_t start[MAX_RANK];
#line 419
    size_t edge[MAX_RANK];
#line 419
    size_t index[MAX_RANK];
#line 419
    size_t mid[MAX_RANK];
#line 419
    int canConvert;     /* Both text or both numeric */
#line 419
    long value[MAX_NELS];
#line 419
    double expect[MAX_NELS];
#line 419

#line 419
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 419
    IF (err)
#line 419
	error("nc_open: %s", nc_strerror(err));
#line 419
    for (i = 0; i < numVars; i++) {
#line 419
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONG == NCT_TEXT);
#line 419
        assert(var_rank[i] <= MAX_RANK);
#line 419
        assert(var_nels[i] <= MAX_NELS);
#line 419
	for (j = 0; j < var_rank[i]; j++) {
#line 419
	    start[j] = 0;
#line 419
	    edge[j] = 1;
#line 419
	}
#line 419
        err = nc_get_vara_long(BAD_ID, i, start, edge, value);
#line 419
        IF (err != NC_EBADID)
#line 419
	    error("bad ncid: status = %d", err);
#line 419
        err = nc_get_vara_long(ncid, BAD_VARID, start, edge, value);
#line 419
        IF (err != NC_ENOTVAR)
#line 419
	    error("bad var id: status = %d", err);
#line 419
	for (j = 0; j < var_rank[i]; j++) {
#line 419
	    start[j] = var_shape[i][j];
#line 419
	    err = nc_get_vara_long(ncid, i, start, edge, value);
#line 419
            IF (canConvert && err != NC_EINVALCOORDS)
#line 419
                error("bad index: status = %d", err);
#line 419
	    start[j] = 0;
#line 419
	    edge[j] = var_shape[i][j] + 1;
#line 419
	    err = nc_get_vara_long(ncid, i, start, edge, value);
#line 419
            IF (canConvert && err != NC_EEDGE)
#line 419
		error("bad edge: status = %d", err);
#line 419
	    edge[j] = 1;
#line 419
	}
#line 419
            /* Check non-scalars for correct error returned even when */
#line 419
            /* there is nothing to get (edge[j]==0) */
#line 419
	if(var_rank[i] > 0) {
#line 419
	    for (j = 0; j < var_rank[i]; j++) {
#line 419
		edge[j] = 0;
#line 419
	    }
#line 419
	    err = nc_get_vara_long(BAD_ID, i, start, edge, value);
#line 419
	    IF (err != NC_EBADID) 
#line 419
		error("bad ncid: status = %d", err);
#line 419
	    err = nc_get_vara_long(ncid, BAD_VARID, start, edge, value);
#line 419
	    IF (err != NC_ENOTVAR) 
#line 419
		error("bad var id: status = %d", err);
#line 419
	    for (j = 0; j < var_rank[i]; j++) {
#line 419
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 419
		    start[j] = var_shape[i][j];
#line 419
		    err = nc_get_vara_long(ncid, i, start, edge, value);
#line 419
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 419
			error("bad start: status = %d", err);
#line 419
		    start[j] = 0;
#line 419
		}
#line 419
	    }
#line 419
	    err = nc_get_vara_long(ncid, i, start, edge, value);
#line 419
	    if (canConvert) {
#line 419
		IF (err) 
#line 419
		    error("%s", nc_strerror(err));
#line 419
	    } else {
#line 419
		IF (err != NC_ECHAR)
#line 419
		    error("wrong type: status = %d", err);
#line 419
	    }
#line 419
	    for (j = 0; j < var_rank[i]; j++) {
#line 419
		edge[j] = 1;
#line 419
	    }
#line 419
	}            /* Choose a random point dividing each dim into 2 parts */
#line 419
            /* get 2^rank (nslabs) slabs so defined */
#line 419
        nslabs = 1;
#line 419
        for (j = 0; j < var_rank[i]; j++) {
#line 419
            mid[j] = roll( var_shape[i][j] );
#line 419
            nslabs *= 2;
#line 419
        }
#line 419
            /* bits of k determine whether to get lower or upper part of dim */
#line 419
        for (k = 0; k < nslabs; k++) {
#line 419
            nels = 1;
#line 419
            for (j = 0; j < var_rank[i]; j++) {
#line 419
                if ((k >> j) & 1) {
#line 419
                    start[j] = 0;
#line 419
                    edge[j] = mid[j];
#line 419
                }else{
#line 419
                    start[j] = mid[j];
#line 419
                    edge[j] = var_shape[i][j] - mid[j];
#line 419
                }
#line 419
                nels *= edge[j];
#line 419
            }
#line 419
	    allInExtRange = allInIntRange = 1;
#line 419
            for (j = 0; j < nels; j++) {
#line 419
                err = toMixedBase(j, var_rank[i], edge, index);
#line 419
                IF (err)
#line 419
                    error("error in toMixedBase 1");
#line 419
                for (d = 0; d < var_rank[i]; d++)
#line 419
                    index[d] += start[d];
#line 419
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_LONG);
#line 419
		if (inRange3(expect[j],var_type[i], NCT_LONG)) {
#line 419
		    allInIntRange = allInIntRange && expect[j] >= long_min
#line 419
				&& expect[j] <= long_max;
#line 419
		} else {
#line 419
		    allInExtRange = 0;
#line 419
		}
#line 419
	    }
#line 419
            if (var_rank[i] == 0 && i%2)
#line 419
		err = nc_get_vara_long(ncid, i, NULL, NULL, value);
#line 419
	    else
#line 419
		err = nc_get_vara_long(ncid, i, start, edge, value);
#line 419
            if (canConvert) {
#line 419
		if (allInExtRange) {
#line 419
		    if (allInIntRange) {
#line 419
			IF (err)
#line 419
			    error("%s", nc_strerror(err));
#line 419
		    } else {
#line 419
			IF (err != NC_ERANGE)
#line 419
			    error("Range error: status = %d", err);
#line 419
		    }
#line 419
		} else {
#line 419
		    IF (err != 0 && err != NC_ERANGE)
#line 419
			error("OK or Range error: status = %d", err);
#line 419
		}
#line 419
		for (j = 0; j < nels; j++) {
#line 419
		    if (inRange3(expect[j],var_type[i],NCT_LONG)
#line 419
			    && expect[j] >= long_min && expect[j] <= long_max) {
#line 419
			IF (!equal(value[j],expect[j],var_type[i],NCT_LONG)){
#line 419
			    error("value read not that expected");
#line 419
			    if (verbose) {
#line 419
				error("\n");
#line 419
				error("varid: %d, ", i);
#line 419
				error("var_name: %s, ", var_name[i]);
#line 419
				error("element number: %d ", j);
#line 419
				error("expect: %g", expect[j]);
#line 419
				error("got: %g", (double) value[j]);
#line 419
			    }
#line 419
			} else {
#line 419
			    nok++;
#line 419
			}
#line 419
		    }
#line 419
		}
#line 419
            } else {
#line 419
                IF (nels > 0 && err != NC_ECHAR)
#line 419
                    error("wrong type: status = %d", err);
#line 419
            }
#line 419
        }
#line 419
    }
#line 419
    err = nc_close(ncid);
#line 419
    IF (err)
#line 419
	error("nc_close: %s", nc_strerror(err));
#line 419
    print_nok(nok);
#line 419
}
#line 419

void
#line 420
test_nc_get_vara_float(void)
#line 420
{
#line 420
    int ncid;
#line 420
    int d;
#line 420
    int i;
#line 420
    int j;
#line 420
    int k;
#line 420
    int err;
#line 420
    int allInExtRange;	/* all values within external range? */
#line 420
    int allInIntRange;	/* all values within internal range? */
#line 420
    int nels;
#line 420
    int nslabs;
#line 420
    int nok = 0;      /* count of valid comparisons */
#line 420
    size_t start[MAX_RANK];
#line 420
    size_t edge[MAX_RANK];
#line 420
    size_t index[MAX_RANK];
#line 420
    size_t mid[MAX_RANK];
#line 420
    int canConvert;     /* Both text or both numeric */
#line 420
    float value[MAX_NELS];
#line 420
    double expect[MAX_NELS];
#line 420

#line 420
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 420
    IF (err)
#line 420
	error("nc_open: %s", nc_strerror(err));
#line 420
    for (i = 0; i < numVars; i++) {
#line 420
        canConvert = (var_type[i] == NC_CHAR) == (NCT_FLOAT == NCT_TEXT);
#line 420
        assert(var_rank[i] <= MAX_RANK);
#line 420
        assert(var_nels[i] <= MAX_NELS);
#line 420
	for (j = 0; j < var_rank[i]; j++) {
#line 420
	    start[j] = 0;
#line 420
	    edge[j] = 1;
#line 420
	}
#line 420
        err = nc_get_vara_float(BAD_ID, i, start, edge, value);
#line 420
        IF (err != NC_EBADID)
#line 420
	    error("bad ncid: status = %d", err);
#line 420
        err = nc_get_vara_float(ncid, BAD_VARID, start, edge, value);
#line 420
        IF (err != NC_ENOTVAR)
#line 420
	    error("bad var id: status = %d", err);
#line 420
	for (j = 0; j < var_rank[i]; j++) {
#line 420
	    start[j] = var_shape[i][j];
#line 420
	    err = nc_get_vara_float(ncid, i, start, edge, value);
#line 420
            IF (canConvert && err != NC_EINVALCOORDS)
#line 420
                error("bad index: status = %d", err);
#line 420
	    start[j] = 0;
#line 420
	    edge[j] = var_shape[i][j] + 1;
#line 420
	    err = nc_get_vara_float(ncid, i, start, edge, value);
#line 420
            IF (canConvert && err != NC_EEDGE)
#line 420
		error("bad edge: status = %d", err);
#line 420
	    edge[j] = 1;
#line 420
	}
#line 420
            /* Check non-scalars for correct error returned even when */
#line 420
            /* there is nothing to get (edge[j]==0) */
#line 420
	if(var_rank[i] > 0) {
#line 420
	    for (j = 0; j < var_rank[i]; j++) {
#line 420
		edge[j] = 0;
#line 420
	    }
#line 420
	    err = nc_get_vara_float(BAD_ID, i, start, edge, value);
#line 420
	    IF (err != NC_EBADID) 
#line 420
		error("bad ncid: status = %d", err);
#line 420
	    err = nc_get_vara_float(ncid, BAD_VARID, start, edge, value);
#line 420
	    IF (err != NC_ENOTVAR) 
#line 420
		error("bad var id: status = %d", err);
#line 420
	    for (j = 0; j < var_rank[i]; j++) {
#line 420
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 420
		    start[j] = var_shape[i][j];
#line 420
		    err = nc_get_vara_float(ncid, i, start, edge, value);
#line 420
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 420
			error("bad start: status = %d", err);
#line 420
		    start[j] = 0;
#line 420
		}
#line 420
	    }
#line 420
	    err = nc_get_vara_float(ncid, i, start, edge, value);
#line 420
	    if (canConvert) {
#line 420
		IF (err) 
#line 420
		    error("%s", nc_strerror(err));
#line 420
	    } else {
#line 420
		IF (err != NC_ECHAR)
#line 420
		    error("wrong type: status = %d", err);
#line 420
	    }
#line 420
	    for (j = 0; j < var_rank[i]; j++) {
#line 420
		edge[j] = 1;
#line 420
	    }
#line 420
	}            /* Choose a random point dividing each dim into 2 parts */
#line 420
            /* get 2^rank (nslabs) slabs so defined */
#line 420
        nslabs = 1;
#line 420
        for (j = 0; j < var_rank[i]; j++) {
#line 420
            mid[j] = roll( var_shape[i][j] );
#line 420
            nslabs *= 2;
#line 420
        }
#line 420
            /* bits of k determine whether to get lower or upper part of dim */
#line 420
        for (k = 0; k < nslabs; k++) {
#line 420
            nels = 1;
#line 420
            for (j = 0; j < var_rank[i]; j++) {
#line 420
                if ((k >> j) & 1) {
#line 420
                    start[j] = 0;
#line 420
                    edge[j] = mid[j];
#line 420
                }else{
#line 420
                    start[j] = mid[j];
#line 420
                    edge[j] = var_shape[i][j] - mid[j];
#line 420
                }
#line 420
                nels *= edge[j];
#line 420
            }
#line 420
	    allInExtRange = allInIntRange = 1;
#line 420
            for (j = 0; j < nels; j++) {
#line 420
                err = toMixedBase(j, var_rank[i], edge, index);
#line 420
                IF (err)
#line 420
                    error("error in toMixedBase 1");
#line 420
                for (d = 0; d < var_rank[i]; d++)
#line 420
                    index[d] += start[d];
#line 420
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_FLOAT);
#line 420
		if (inRange3(expect[j],var_type[i], NCT_FLOAT)) {
#line 420
		    allInIntRange = allInIntRange && expect[j] >= float_min
#line 420
				&& expect[j] <= float_max;
#line 420
		} else {
#line 420
		    allInExtRange = 0;
#line 420
		}
#line 420
	    }
#line 420
            if (var_rank[i] == 0 && i%2)
#line 420
		err = nc_get_vara_float(ncid, i, NULL, NULL, value);
#line 420
	    else
#line 420
		err = nc_get_vara_float(ncid, i, start, edge, value);
#line 420
            if (canConvert) {
#line 420
		if (allInExtRange) {
#line 420
		    if (allInIntRange) {
#line 420
			IF (err)
#line 420
			    error("%s", nc_strerror(err));
#line 420
		    } else {
#line 420
			IF (err != NC_ERANGE)
#line 420
			    error("Range error: status = %d", err);
#line 420
		    }
#line 420
		} else {
#line 420
		    IF (err != 0 && err != NC_ERANGE)
#line 420
			error("OK or Range error: status = %d", err);
#line 420
		}
#line 420
		for (j = 0; j < nels; j++) {
#line 420
		    if (inRange3(expect[j],var_type[i],NCT_FLOAT)
#line 420
			    && expect[j] >= float_min && expect[j] <= float_max) {
#line 420
			IF (!equal(value[j],expect[j],var_type[i],NCT_FLOAT)){
#line 420
			    error("value read not that expected");
#line 420
			    if (verbose) {
#line 420
				error("\n");
#line 420
				error("varid: %d, ", i);
#line 420
				error("var_name: %s, ", var_name[i]);
#line 420
				error("element number: %d ", j);
#line 420
				error("expect: %g", expect[j]);
#line 420
				error("got: %g", (double) value[j]);
#line 420
			    }
#line 420
			} else {
#line 420
			    nok++;
#line 420
			}
#line 420
		    }
#line 420
		}
#line 420
            } else {
#line 420
                IF (nels > 0 && err != NC_ECHAR)
#line 420
                    error("wrong type: status = %d", err);
#line 420
            }
#line 420
        }
#line 420
    }
#line 420
    err = nc_close(ncid);
#line 420
    IF (err)
#line 420
	error("nc_close: %s", nc_strerror(err));
#line 420
    print_nok(nok);
#line 420
}
#line 420

void
#line 421
test_nc_get_vara_double(void)
#line 421
{
#line 421
    int ncid;
#line 421
    int d;
#line 421
    int i;
#line 421
    int j;
#line 421
    int k;
#line 421
    int err;
#line 421
    int allInExtRange;	/* all values within external range? */
#line 421
    int allInIntRange;	/* all values within internal range? */
#line 421
    int nels;
#line 421
    int nslabs;
#line 421
    int nok = 0;      /* count of valid comparisons */
#line 421
    size_t start[MAX_RANK];
#line 421
    size_t edge[MAX_RANK];
#line 421
    size_t index[MAX_RANK];
#line 421
    size_t mid[MAX_RANK];
#line 421
    int canConvert;     /* Both text or both numeric */
#line 421
    double value[MAX_NELS];
#line 421
    double expect[MAX_NELS];
#line 421

#line 421
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 421
    IF (err)
#line 421
	error("nc_open: %s", nc_strerror(err));
#line 421
    for (i = 0; i < numVars; i++) {
#line 421
        canConvert = (var_type[i] == NC_CHAR) == (NCT_DOUBLE == NCT_TEXT);
#line 421
        assert(var_rank[i] <= MAX_RANK);
#line 421
        assert(var_nels[i] <= MAX_NELS);
#line 421
	for (j = 0; j < var_rank[i]; j++) {
#line 421
	    start[j] = 0;
#line 421
	    edge[j] = 1;
#line 421
	}
#line 421
        err = nc_get_vara_double(BAD_ID, i, start, edge, value);
#line 421
        IF (err != NC_EBADID)
#line 421
	    error("bad ncid: status = %d", err);
#line 421
        err = nc_get_vara_double(ncid, BAD_VARID, start, edge, value);
#line 421
        IF (err != NC_ENOTVAR)
#line 421
	    error("bad var id: status = %d", err);
#line 421
	for (j = 0; j < var_rank[i]; j++) {
#line 421
	    start[j] = var_shape[i][j];
#line 421
	    err = nc_get_vara_double(ncid, i, start, edge, value);
#line 421
            IF (canConvert && err != NC_EINVALCOORDS)
#line 421
                error("bad index: status = %d", err);
#line 421
	    start[j] = 0;
#line 421
	    edge[j] = var_shape[i][j] + 1;
#line 421
	    err = nc_get_vara_double(ncid, i, start, edge, value);
#line 421
            IF (canConvert && err != NC_EEDGE)
#line 421
		error("bad edge: status = %d", err);
#line 421
	    edge[j] = 1;
#line 421
	}
#line 421
            /* Check non-scalars for correct error returned even when */
#line 421
            /* there is nothing to get (edge[j]==0) */
#line 421
	if(var_rank[i] > 0) {
#line 421
	    for (j = 0; j < var_rank[i]; j++) {
#line 421
		edge[j] = 0;
#line 421
	    }
#line 421
	    err = nc_get_vara_double(BAD_ID, i, start, edge, value);
#line 421
	    IF (err != NC_EBADID) 
#line 421
		error("bad ncid: status = %d", err);
#line 421
	    err = nc_get_vara_double(ncid, BAD_VARID, start, edge, value);
#line 421
	    IF (err != NC_ENOTVAR) 
#line 421
		error("bad var id: status = %d", err);
#line 421
	    for (j = 0; j < var_rank[i]; j++) {
#line 421
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 421
		    start[j] = var_shape[i][j];
#line 421
		    err = nc_get_vara_double(ncid, i, start, edge, value);
#line 421
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 421
			error("bad start: status = %d", err);
#line 421
		    start[j] = 0;
#line 421
		}
#line 421
	    }
#line 421
	    err = nc_get_vara_double(ncid, i, start, edge, value);
#line 421
	    if (canConvert) {
#line 421
		IF (err) 
#line 421
		    error("%s", nc_strerror(err));
#line 421
	    } else {
#line 421
		IF (err != NC_ECHAR)
#line 421
		    error("wrong type: status = %d", err);
#line 421
	    }
#line 421
	    for (j = 0; j < var_rank[i]; j++) {
#line 421
		edge[j] = 1;
#line 421
	    }
#line 421
	}            /* Choose a random point dividing each dim into 2 parts */
#line 421
            /* get 2^rank (nslabs) slabs so defined */
#line 421
        nslabs = 1;
#line 421
        for (j = 0; j < var_rank[i]; j++) {
#line 421
            mid[j] = roll( var_shape[i][j] );
#line 421
            nslabs *= 2;
#line 421
        }
#line 421
            /* bits of k determine whether to get lower or upper part of dim */
#line 421
        for (k = 0; k < nslabs; k++) {
#line 421
            nels = 1;
#line 421
            for (j = 0; j < var_rank[i]; j++) {
#line 421
                if ((k >> j) & 1) {
#line 421
                    start[j] = 0;
#line 421
                    edge[j] = mid[j];
#line 421
                }else{
#line 421
                    start[j] = mid[j];
#line 421
                    edge[j] = var_shape[i][j] - mid[j];
#line 421
                }
#line 421
                nels *= edge[j];
#line 421
            }
#line 421
	    allInExtRange = allInIntRange = 1;
#line 421
            for (j = 0; j < nels; j++) {
#line 421
                err = toMixedBase(j, var_rank[i], edge, index);
#line 421
                IF (err)
#line 421
                    error("error in toMixedBase 1");
#line 421
                for (d = 0; d < var_rank[i]; d++)
#line 421
                    index[d] += start[d];
#line 421
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_DOUBLE);
#line 421
		if (inRange3(expect[j],var_type[i], NCT_DOUBLE)) {
#line 421
		    allInIntRange = allInIntRange && expect[j] >= double_min
#line 421
				&& expect[j] <= double_max;
#line 421
		} else {
#line 421
		    allInExtRange = 0;
#line 421
		}
#line 421
	    }
#line 421
            if (var_rank[i] == 0 && i%2)
#line 421
		err = nc_get_vara_double(ncid, i, NULL, NULL, value);
#line 421
	    else
#line 421
		err = nc_get_vara_double(ncid, i, start, edge, value);
#line 421
            if (canConvert) {
#line 421
		if (allInExtRange) {
#line 421
		    if (allInIntRange) {
#line 421
			IF (err)
#line 421
			    error("%s", nc_strerror(err));
#line 421
		    } else {
#line 421
			IF (err != NC_ERANGE)
#line 421
			    error("Range error: status = %d", err);
#line 421
		    }
#line 421
		} else {
#line 421
		    IF (err != 0 && err != NC_ERANGE)
#line 421
			error("OK or Range error: status = %d", err);
#line 421
		}
#line 421
		for (j = 0; j < nels; j++) {
#line 421
		    if (inRange3(expect[j],var_type[i],NCT_DOUBLE)
#line 421
			    && expect[j] >= double_min && expect[j] <= double_max) {
#line 421
			IF (!equal(value[j],expect[j],var_type[i],NCT_DOUBLE)){
#line 421
			    error("value read not that expected");
#line 421
			    if (verbose) {
#line 421
				error("\n");
#line 421
				error("varid: %d, ", i);
#line 421
				error("var_name: %s, ", var_name[i]);
#line 421
				error("element number: %d ", j);
#line 421
				error("expect: %g", expect[j]);
#line 421
				error("got: %g", (double) value[j]);
#line 421
			    }
#line 421
			} else {
#line 421
			    nok++;
#line 421
			}
#line 421
		    }
#line 421
		}
#line 421
            } else {
#line 421
                IF (nels > 0 && err != NC_ECHAR)
#line 421
                    error("wrong type: status = %d", err);
#line 421
            }
#line 421
        }
#line 421
    }
#line 421
    err = nc_close(ncid);
#line 421
    IF (err)
#line 421
	error("nc_close: %s", nc_strerror(err));
#line 421
    print_nok(nok);
#line 421
}
#line 421

void
#line 422
test_nc_get_vara_ushort(void)
#line 422
{
#line 422
    int ncid;
#line 422
    int d;
#line 422
    int i;
#line 422
    int j;
#line 422
    int k;
#line 422
    int err;
#line 422
    int allInExtRange;	/* all values within external range? */
#line 422
    int allInIntRange;	/* all values within internal range? */
#line 422
    int nels;
#line 422
    int nslabs;
#line 422
    int nok = 0;      /* count of valid comparisons */
#line 422
    size_t start[MAX_RANK];
#line 422
    size_t edge[MAX_RANK];
#line 422
    size_t index[MAX_RANK];
#line 422
    size_t mid[MAX_RANK];
#line 422
    int canConvert;     /* Both text or both numeric */
#line 422
    ushort value[MAX_NELS];
#line 422
    double expect[MAX_NELS];
#line 422

#line 422
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 422
    IF (err)
#line 422
	error("nc_open: %s", nc_strerror(err));
#line 422
    for (i = 0; i < numVars; i++) {
#line 422
        canConvert = (var_type[i] == NC_CHAR) == (NCT_USHORT == NCT_TEXT);
#line 422
        assert(var_rank[i] <= MAX_RANK);
#line 422
        assert(var_nels[i] <= MAX_NELS);
#line 422
	for (j = 0; j < var_rank[i]; j++) {
#line 422
	    start[j] = 0;
#line 422
	    edge[j] = 1;
#line 422
	}
#line 422
        err = nc_get_vara_ushort(BAD_ID, i, start, edge, value);
#line 422
        IF (err != NC_EBADID)
#line 422
	    error("bad ncid: status = %d", err);
#line 422
        err = nc_get_vara_ushort(ncid, BAD_VARID, start, edge, value);
#line 422
        IF (err != NC_ENOTVAR)
#line 422
	    error("bad var id: status = %d", err);
#line 422
	for (j = 0; j < var_rank[i]; j++) {
#line 422
	    start[j] = var_shape[i][j];
#line 422
	    err = nc_get_vara_ushort(ncid, i, start, edge, value);
#line 422
            IF (canConvert && err != NC_EINVALCOORDS)
#line 422
                error("bad index: status = %d", err);
#line 422
	    start[j] = 0;
#line 422
	    edge[j] = var_shape[i][j] + 1;
#line 422
	    err = nc_get_vara_ushort(ncid, i, start, edge, value);
#line 422
            IF (canConvert && err != NC_EEDGE)
#line 422
		error("bad edge: status = %d", err);
#line 422
	    edge[j] = 1;
#line 422
	}
#line 422
            /* Check non-scalars for correct error returned even when */
#line 422
            /* there is nothing to get (edge[j]==0) */
#line 422
	if(var_rank[i] > 0) {
#line 422
	    for (j = 0; j < var_rank[i]; j++) {
#line 422
		edge[j] = 0;
#line 422
	    }
#line 422
	    err = nc_get_vara_ushort(BAD_ID, i, start, edge, value);
#line 422
	    IF (err != NC_EBADID) 
#line 422
		error("bad ncid: status = %d", err);
#line 422
	    err = nc_get_vara_ushort(ncid, BAD_VARID, start, edge, value);
#line 422
	    IF (err != NC_ENOTVAR) 
#line 422
		error("bad var id: status = %d", err);
#line 422
	    for (j = 0; j < var_rank[i]; j++) {
#line 422
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 422
		    start[j] = var_shape[i][j];
#line 422
		    err = nc_get_vara_ushort(ncid, i, start, edge, value);
#line 422
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 422
			error("bad start: status = %d", err);
#line 422
		    start[j] = 0;
#line 422
		}
#line 422
	    }
#line 422
	    err = nc_get_vara_ushort(ncid, i, start, edge, value);
#line 422
	    if (canConvert) {
#line 422
		IF (err) 
#line 422
		    error("%s", nc_strerror(err));
#line 422
	    } else {
#line 422
		IF (err != NC_ECHAR)
#line 422
		    error("wrong type: status = %d", err);
#line 422
	    }
#line 422
	    for (j = 0; j < var_rank[i]; j++) {
#line 422
		edge[j] = 1;
#line 422
	    }
#line 422
	}            /* Choose a random point dividing each dim into 2 parts */
#line 422
            /* get 2^rank (nslabs) slabs so defined */
#line 422
        nslabs = 1;
#line 422
        for (j = 0; j < var_rank[i]; j++) {
#line 422
            mid[j] = roll( var_shape[i][j] );
#line 422
            nslabs *= 2;
#line 422
        }
#line 422
            /* bits of k determine whether to get lower or upper part of dim */
#line 422
        for (k = 0; k < nslabs; k++) {
#line 422
            nels = 1;
#line 422
            for (j = 0; j < var_rank[i]; j++) {
#line 422
                if ((k >> j) & 1) {
#line 422
                    start[j] = 0;
#line 422
                    edge[j] = mid[j];
#line 422
                }else{
#line 422
                    start[j] = mid[j];
#line 422
                    edge[j] = var_shape[i][j] - mid[j];
#line 422
                }
#line 422
                nels *= edge[j];
#line 422
            }
#line 422
	    allInExtRange = allInIntRange = 1;
#line 422
            for (j = 0; j < nels; j++) {
#line 422
                err = toMixedBase(j, var_rank[i], edge, index);
#line 422
                IF (err)
#line 422
                    error("error in toMixedBase 1");
#line 422
                for (d = 0; d < var_rank[i]; d++)
#line 422
                    index[d] += start[d];
#line 422
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_USHORT);
#line 422
		if (inRange3(expect[j],var_type[i], NCT_USHORT)) {
#line 422
		    allInIntRange = allInIntRange && expect[j] >= ushort_min
#line 422
				&& expect[j] <= ushort_max;
#line 422
		} else {
#line 422
		    allInExtRange = 0;
#line 422
		}
#line 422
	    }
#line 422
            if (var_rank[i] == 0 && i%2)
#line 422
		err = nc_get_vara_ushort(ncid, i, NULL, NULL, value);
#line 422
	    else
#line 422
		err = nc_get_vara_ushort(ncid, i, start, edge, value);
#line 422
            if (canConvert) {
#line 422
		if (allInExtRange) {
#line 422
		    if (allInIntRange) {
#line 422
			IF (err)
#line 422
			    error("%s", nc_strerror(err));
#line 422
		    } else {
#line 422
			IF (err != NC_ERANGE)
#line 422
			    error("Range error: status = %d", err);
#line 422
		    }
#line 422
		} else {
#line 422
		    IF (err != 0 && err != NC_ERANGE)
#line 422
			error("OK or Range error: status = %d", err);
#line 422
		}
#line 422
		for (j = 0; j < nels; j++) {
#line 422
		    if (inRange3(expect[j],var_type[i],NCT_USHORT)
#line 422
			    && expect[j] >= ushort_min && expect[j] <= ushort_max) {
#line 422
			IF (!equal(value[j],expect[j],var_type[i],NCT_USHORT)){
#line 422
			    error("value read not that expected");
#line 422
			    if (verbose) {
#line 422
				error("\n");
#line 422
				error("varid: %d, ", i);
#line 422
				error("var_name: %s, ", var_name[i]);
#line 422
				error("element number: %d ", j);
#line 422
				error("expect: %g", expect[j]);
#line 422
				error("got: %g", (double) value[j]);
#line 422
			    }
#line 422
			} else {
#line 422
			    nok++;
#line 422
			}
#line 422
		    }
#line 422
		}
#line 422
            } else {
#line 422
                IF (nels > 0 && err != NC_ECHAR)
#line 422
                    error("wrong type: status = %d", err);
#line 422
            }
#line 422
        }
#line 422
    }
#line 422
    err = nc_close(ncid);
#line 422
    IF (err)
#line 422
	error("nc_close: %s", nc_strerror(err));
#line 422
    print_nok(nok);
#line 422
}
#line 422

void
#line 423
test_nc_get_vara_uint(void)
#line 423
{
#line 423
    int ncid;
#line 423
    int d;
#line 423
    int i;
#line 423
    int j;
#line 423
    int k;
#line 423
    int err;
#line 423
    int allInExtRange;	/* all values within external range? */
#line 423
    int allInIntRange;	/* all values within internal range? */
#line 423
    int nels;
#line 423
    int nslabs;
#line 423
    int nok = 0;      /* count of valid comparisons */
#line 423
    size_t start[MAX_RANK];
#line 423
    size_t edge[MAX_RANK];
#line 423
    size_t index[MAX_RANK];
#line 423
    size_t mid[MAX_RANK];
#line 423
    int canConvert;     /* Both text or both numeric */
#line 423
    uint value[MAX_NELS];
#line 423
    double expect[MAX_NELS];
#line 423

#line 423
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 423
    IF (err)
#line 423
	error("nc_open: %s", nc_strerror(err));
#line 423
    for (i = 0; i < numVars; i++) {
#line 423
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UINT == NCT_TEXT);
#line 423
        assert(var_rank[i] <= MAX_RANK);
#line 423
        assert(var_nels[i] <= MAX_NELS);
#line 423
	for (j = 0; j < var_rank[i]; j++) {
#line 423
	    start[j] = 0;
#line 423
	    edge[j] = 1;
#line 423
	}
#line 423
        err = nc_get_vara_uint(BAD_ID, i, start, edge, value);
#line 423
        IF (err != NC_EBADID)
#line 423
	    error("bad ncid: status = %d", err);
#line 423
        err = nc_get_vara_uint(ncid, BAD_VARID, start, edge, value);
#line 423
        IF (err != NC_ENOTVAR)
#line 423
	    error("bad var id: status = %d", err);
#line 423
	for (j = 0; j < var_rank[i]; j++) {
#line 423
	    start[j] = var_shape[i][j];
#line 423
	    err = nc_get_vara_uint(ncid, i, start, edge, value);
#line 423
            IF (canConvert && err != NC_EINVALCOORDS)
#line 423
                error("bad index: status = %d", err);
#line 423
	    start[j] = 0;
#line 423
	    edge[j] = var_shape[i][j] + 1;
#line 423
	    err = nc_get_vara_uint(ncid, i, start, edge, value);
#line 423
            IF (canConvert && err != NC_EEDGE)
#line 423
		error("bad edge: status = %d", err);
#line 423
	    edge[j] = 1;
#line 423
	}
#line 423
            /* Check non-scalars for correct error returned even when */
#line 423
            /* there is nothing to get (edge[j]==0) */
#line 423
	if(var_rank[i] > 0) {
#line 423
	    for (j = 0; j < var_rank[i]; j++) {
#line 423
		edge[j] = 0;
#line 423
	    }
#line 423
	    err = nc_get_vara_uint(BAD_ID, i, start, edge, value);
#line 423
	    IF (err != NC_EBADID) 
#line 423
		error("bad ncid: status = %d", err);
#line 423
	    err = nc_get_vara_uint(ncid, BAD_VARID, start, edge, value);
#line 423
	    IF (err != NC_ENOTVAR) 
#line 423
		error("bad var id: status = %d", err);
#line 423
	    for (j = 0; j < var_rank[i]; j++) {
#line 423
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 423
		    start[j] = var_shape[i][j];
#line 423
		    err = nc_get_vara_uint(ncid, i, start, edge, value);
#line 423
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 423
			error("bad start: status = %d", err);
#line 423
		    start[j] = 0;
#line 423
		}
#line 423
	    }
#line 423
	    err = nc_get_vara_uint(ncid, i, start, edge, value);
#line 423
	    if (canConvert) {
#line 423
		IF (err) 
#line 423
		    error("%s", nc_strerror(err));
#line 423
	    } else {
#line 423
		IF (err != NC_ECHAR)
#line 423
		    error("wrong type: status = %d", err);
#line 423
	    }
#line 423
	    for (j = 0; j < var_rank[i]; j++) {
#line 423
		edge[j] = 1;
#line 423
	    }
#line 423
	}            /* Choose a random point dividing each dim into 2 parts */
#line 423
            /* get 2^rank (nslabs) slabs so defined */
#line 423
        nslabs = 1;
#line 423
        for (j = 0; j < var_rank[i]; j++) {
#line 423
            mid[j] = roll( var_shape[i][j] );
#line 423
            nslabs *= 2;
#line 423
        }
#line 423
            /* bits of k determine whether to get lower or upper part of dim */
#line 423
        for (k = 0; k < nslabs; k++) {
#line 423
            nels = 1;
#line 423
            for (j = 0; j < var_rank[i]; j++) {
#line 423
                if ((k >> j) & 1) {
#line 423
                    start[j] = 0;
#line 423
                    edge[j] = mid[j];
#line 423
                }else{
#line 423
                    start[j] = mid[j];
#line 423
                    edge[j] = var_shape[i][j] - mid[j];
#line 423
                }
#line 423
                nels *= edge[j];
#line 423
            }
#line 423
	    allInExtRange = allInIntRange = 1;
#line 423
            for (j = 0; j < nels; j++) {
#line 423
                err = toMixedBase(j, var_rank[i], edge, index);
#line 423
                IF (err)
#line 423
                    error("error in toMixedBase 1");
#line 423
                for (d = 0; d < var_rank[i]; d++)
#line 423
                    index[d] += start[d];
#line 423
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_UINT);
#line 423
		if (inRange3(expect[j],var_type[i], NCT_UINT)) {
#line 423
		    allInIntRange = allInIntRange && expect[j] >= uint_min
#line 423
				&& expect[j] <= uint_max;
#line 423
		} else {
#line 423
		    allInExtRange = 0;
#line 423
		}
#line 423
	    }
#line 423
            if (var_rank[i] == 0 && i%2)
#line 423
		err = nc_get_vara_uint(ncid, i, NULL, NULL, value);
#line 423
	    else
#line 423
		err = nc_get_vara_uint(ncid, i, start, edge, value);
#line 423
            if (canConvert) {
#line 423
		if (allInExtRange) {
#line 423
		    if (allInIntRange) {
#line 423
			IF (err)
#line 423
			    error("%s", nc_strerror(err));
#line 423
		    } else {
#line 423
			IF (err != NC_ERANGE)
#line 423
			    error("Range error: status = %d", err);
#line 423
		    }
#line 423
		} else {
#line 423
		    IF (err != 0 && err != NC_ERANGE)
#line 423
			error("OK or Range error: status = %d", err);
#line 423
		}
#line 423
		for (j = 0; j < nels; j++) {
#line 423
		    if (inRange3(expect[j],var_type[i],NCT_UINT)
#line 423
			    && expect[j] >= uint_min && expect[j] <= uint_max) {
#line 423
			IF (!equal(value[j],expect[j],var_type[i],NCT_UINT)){
#line 423
			    error("value read not that expected");
#line 423
			    if (verbose) {
#line 423
				error("\n");
#line 423
				error("varid: %d, ", i);
#line 423
				error("var_name: %s, ", var_name[i]);
#line 423
				error("element number: %d ", j);
#line 423
				error("expect: %g", expect[j]);
#line 423
				error("got: %g", (double) value[j]);
#line 423
			    }
#line 423
			} else {
#line 423
			    nok++;
#line 423
			}
#line 423
		    }
#line 423
		}
#line 423
            } else {
#line 423
                IF (nels > 0 && err != NC_ECHAR)
#line 423
                    error("wrong type: status = %d", err);
#line 423
            }
#line 423
        }
#line 423
    }
#line 423
    err = nc_close(ncid);
#line 423
    IF (err)
#line 423
	error("nc_close: %s", nc_strerror(err));
#line 423
    print_nok(nok);
#line 423
}
#line 423

void
#line 424
test_nc_get_vara_longlong(void)
#line 424
{
#line 424
    int ncid;
#line 424
    int d;
#line 424
    int i;
#line 424
    int j;
#line 424
    int k;
#line 424
    int err;
#line 424
    int allInExtRange;	/* all values within external range? */
#line 424
    int allInIntRange;	/* all values within internal range? */
#line 424
    int nels;
#line 424
    int nslabs;
#line 424
    int nok = 0;      /* count of valid comparisons */
#line 424
    size_t start[MAX_RANK];
#line 424
    size_t edge[MAX_RANK];
#line 424
    size_t index[MAX_RANK];
#line 424
    size_t mid[MAX_RANK];
#line 424
    int canConvert;     /* Both text or both numeric */
#line 424
    longlong value[MAX_NELS];
#line 424
    double expect[MAX_NELS];
#line 424

#line 424
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 424
    IF (err)
#line 424
	error("nc_open: %s", nc_strerror(err));
#line 424
    for (i = 0; i < numVars; i++) {
#line 424
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONGLONG == NCT_TEXT);
#line 424
        assert(var_rank[i] <= MAX_RANK);
#line 424
        assert(var_nels[i] <= MAX_NELS);
#line 424
	for (j = 0; j < var_rank[i]; j++) {
#line 424
	    start[j] = 0;
#line 424
	    edge[j] = 1;
#line 424
	}
#line 424
        err = nc_get_vara_longlong(BAD_ID, i, start, edge, value);
#line 424
        IF (err != NC_EBADID)
#line 424
	    error("bad ncid: status = %d", err);
#line 424
        err = nc_get_vara_longlong(ncid, BAD_VARID, start, edge, value);
#line 424
        IF (err != NC_ENOTVAR)
#line 424
	    error("bad var id: status = %d", err);
#line 424
	for (j = 0; j < var_rank[i]; j++) {
#line 424
	    start[j] = var_shape[i][j];
#line 424
	    err = nc_get_vara_longlong(ncid, i, start, edge, value);
#line 424
            IF (canConvert && err != NC_EINVALCOORDS)
#line 424
                error("bad index: status = %d", err);
#line 424
	    start[j] = 0;
#line 424
	    edge[j] = var_shape[i][j] + 1;
#line 424
	    err = nc_get_vara_longlong(ncid, i, start, edge, value);
#line 424
            IF (canConvert && err != NC_EEDGE)
#line 424
		error("bad edge: status = %d", err);
#line 424
	    edge[j] = 1;
#line 424
	}
#line 424
            /* Check non-scalars for correct error returned even when */
#line 424
            /* there is nothing to get (edge[j]==0) */
#line 424
	if(var_rank[i] > 0) {
#line 424
	    for (j = 0; j < var_rank[i]; j++) {
#line 424
		edge[j] = 0;
#line 424
	    }
#line 424
	    err = nc_get_vara_longlong(BAD_ID, i, start, edge, value);
#line 424
	    IF (err != NC_EBADID) 
#line 424
		error("bad ncid: status = %d", err);
#line 424
	    err = nc_get_vara_longlong(ncid, BAD_VARID, start, edge, value);
#line 424
	    IF (err != NC_ENOTVAR) 
#line 424
		error("bad var id: status = %d", err);
#line 424
	    for (j = 0; j < var_rank[i]; j++) {
#line 424
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 424
		    start[j] = var_shape[i][j];
#line 424
		    err = nc_get_vara_longlong(ncid, i, start, edge, value);
#line 424
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 424
			error("bad start: status = %d", err);
#line 424
		    start[j] = 0;
#line 424
		}
#line 424
	    }
#line 424
	    err = nc_get_vara_longlong(ncid, i, start, edge, value);
#line 424
	    if (canConvert) {
#line 424
		IF (err) 
#line 424
		    error("%s", nc_strerror(err));
#line 424
	    } else {
#line 424
		IF (err != NC_ECHAR)
#line 424
		    error("wrong type: status = %d", err);
#line 424
	    }
#line 424
	    for (j = 0; j < var_rank[i]; j++) {
#line 424
		edge[j] = 1;
#line 424
	    }
#line 424
	}            /* Choose a random point dividing each dim into 2 parts */
#line 424
            /* get 2^rank (nslabs) slabs so defined */
#line 424
        nslabs = 1;
#line 424
        for (j = 0; j < var_rank[i]; j++) {
#line 424
            mid[j] = roll( var_shape[i][j] );
#line 424
            nslabs *= 2;
#line 424
        }
#line 424
            /* bits of k determine whether to get lower or upper part of dim */
#line 424
        for (k = 0; k < nslabs; k++) {
#line 424
            nels = 1;
#line 424
            for (j = 0; j < var_rank[i]; j++) {
#line 424
                if ((k >> j) & 1) {
#line 424
                    start[j] = 0;
#line 424
                    edge[j] = mid[j];
#line 424
                }else{
#line 424
                    start[j] = mid[j];
#line 424
                    edge[j] = var_shape[i][j] - mid[j];
#line 424
                }
#line 424
                nels *= edge[j];
#line 424
            }
#line 424
	    allInExtRange = allInIntRange = 1;
#line 424
            for (j = 0; j < nels; j++) {
#line 424
                err = toMixedBase(j, var_rank[i], edge, index);
#line 424
                IF (err)
#line 424
                    error("error in toMixedBase 1");
#line 424
                for (d = 0; d < var_rank[i]; d++)
#line 424
                    index[d] += start[d];
#line 424
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_LONGLONG);
#line 424
		if (inRange3(expect[j],var_type[i], NCT_LONGLONG)) {
#line 424
		    allInIntRange = allInIntRange && expect[j] >= longlong_min
#line 424
				&& expect[j] <= longlong_max;
#line 424
		} else {
#line 424
		    allInExtRange = 0;
#line 424
		}
#line 424
	    }
#line 424
            if (var_rank[i] == 0 && i%2)
#line 424
		err = nc_get_vara_longlong(ncid, i, NULL, NULL, value);
#line 424
	    else
#line 424
		err = nc_get_vara_longlong(ncid, i, start, edge, value);
#line 424
            if (canConvert) {
#line 424
		if (allInExtRange) {
#line 424
		    if (allInIntRange) {
#line 424
			IF (err)
#line 424
			    error("%s", nc_strerror(err));
#line 424
		    } else {
#line 424
			IF (err != NC_ERANGE)
#line 424
			    error("Range error: status = %d", err);
#line 424
		    }
#line 424
		} else {
#line 424
		    IF (err != 0 && err != NC_ERANGE)
#line 424
			error("OK or Range error: status = %d", err);
#line 424
		}
#line 424
		for (j = 0; j < nels; j++) {
#line 424
		    if (inRange3(expect[j],var_type[i],NCT_LONGLONG)
#line 424
			    && expect[j] >= longlong_min && expect[j] <= longlong_max) {
#line 424
			IF (!equal(value[j],expect[j],var_type[i],NCT_LONGLONG)){
#line 424
			    error("value read not that expected");
#line 424
			    if (verbose) {
#line 424
				error("\n");
#line 424
				error("varid: %d, ", i);
#line 424
				error("var_name: %s, ", var_name[i]);
#line 424
				error("element number: %d ", j);
#line 424
				error("expect: %g", expect[j]);
#line 424
				error("got: %g", (double) value[j]);
#line 424
			    }
#line 424
			} else {
#line 424
			    nok++;
#line 424
			}
#line 424
		    }
#line 424
		}
#line 424
            } else {
#line 424
                IF (nels > 0 && err != NC_ECHAR)
#line 424
                    error("wrong type: status = %d", err);
#line 424
            }
#line 424
        }
#line 424
    }
#line 424
    err = nc_close(ncid);
#line 424
    IF (err)
#line 424
	error("nc_close: %s", nc_strerror(err));
#line 424
    print_nok(nok);
#line 424
}
#line 424

void
#line 425
test_nc_get_vara_ulonglong(void)
#line 425
{
#line 425
    int ncid;
#line 425
    int d;
#line 425
    int i;
#line 425
    int j;
#line 425
    int k;
#line 425
    int err;
#line 425
    int allInExtRange;	/* all values within external range? */
#line 425
    int allInIntRange;	/* all values within internal range? */
#line 425
    int nels;
#line 425
    int nslabs;
#line 425
    int nok = 0;      /* count of valid comparisons */
#line 425
    size_t start[MAX_RANK];
#line 425
    size_t edge[MAX_RANK];
#line 425
    size_t index[MAX_RANK];
#line 425
    size_t mid[MAX_RANK];
#line 425
    int canConvert;     /* Both text or both numeric */
#line 425
    ulonglong value[MAX_NELS];
#line 425
    double expect[MAX_NELS];
#line 425

#line 425
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 425
    IF (err)
#line 425
	error("nc_open: %s", nc_strerror(err));
#line 425
    for (i = 0; i < numVars; i++) {
#line 425
        canConvert = (var_type[i] == NC_CHAR) == (NCT_ULONGLONG == NCT_TEXT);
#line 425
        assert(var_rank[i] <= MAX_RANK);
#line 425
        assert(var_nels[i] <= MAX_NELS);
#line 425
	for (j = 0; j < var_rank[i]; j++) {
#line 425
	    start[j] = 0;
#line 425
	    edge[j] = 1;
#line 425
	}
#line 425
        err = nc_get_vara_ulonglong(BAD_ID, i, start, edge, value);
#line 425
        IF (err != NC_EBADID)
#line 425
	    error("bad ncid: status = %d", err);
#line 425
        err = nc_get_vara_ulonglong(ncid, BAD_VARID, start, edge, value);
#line 425
        IF (err != NC_ENOTVAR)
#line 425
	    error("bad var id: status = %d", err);
#line 425
	for (j = 0; j < var_rank[i]; j++) {
#line 425
	    start[j] = var_shape[i][j];
#line 425
	    err = nc_get_vara_ulonglong(ncid, i, start, edge, value);
#line 425
            IF (canConvert && err != NC_EINVALCOORDS)
#line 425
                error("bad index: status = %d", err);
#line 425
	    start[j] = 0;
#line 425
	    edge[j] = var_shape[i][j] + 1;
#line 425
	    err = nc_get_vara_ulonglong(ncid, i, start, edge, value);
#line 425
            IF (canConvert && err != NC_EEDGE)
#line 425
		error("bad edge: status = %d", err);
#line 425
	    edge[j] = 1;
#line 425
	}
#line 425
            /* Check non-scalars for correct error returned even when */
#line 425
            /* there is nothing to get (edge[j]==0) */
#line 425
	if(var_rank[i] > 0) {
#line 425
	    for (j = 0; j < var_rank[i]; j++) {
#line 425
		edge[j] = 0;
#line 425
	    }
#line 425
	    err = nc_get_vara_ulonglong(BAD_ID, i, start, edge, value);
#line 425
	    IF (err != NC_EBADID) 
#line 425
		error("bad ncid: status = %d", err);
#line 425
	    err = nc_get_vara_ulonglong(ncid, BAD_VARID, start, edge, value);
#line 425
	    IF (err != NC_ENOTVAR) 
#line 425
		error("bad var id: status = %d", err);
#line 425
	    for (j = 0; j < var_rank[i]; j++) {
#line 425
		if (var_dimid[i][j] > 0) {		/* skip record dim */
#line 425
		    start[j] = var_shape[i][j];
#line 425
		    err = nc_get_vara_ulonglong(ncid, i, start, edge, value);
#line 425
		    IF (canConvert && err != NC_EINVALCOORDS)
#line 425
			error("bad start: status = %d", err);
#line 425
		    start[j] = 0;
#line 425
		}
#line 425
	    }
#line 425
	    err = nc_get_vara_ulonglong(ncid, i, start, edge, value);
#line 425
	    if (canConvert) {
#line 425
		IF (err) 
#line 425
		    error("%s", nc_strerror(err));
#line 425
	    } else {
#line 425
		IF (err != NC_ECHAR)
#line 425
		    error("wrong type: status = %d", err);
#line 425
	    }
#line 425
	    for (j = 0; j < var_rank[i]; j++) {
#line 425
		edge[j] = 1;
#line 425
	    }
#line 425
	}            /* Choose a random point dividing each dim into 2 parts */
#line 425
            /* get 2^rank (nslabs) slabs so defined */
#line 425
        nslabs = 1;
#line 425
        for (j = 0; j < var_rank[i]; j++) {
#line 425
            mid[j] = roll( var_shape[i][j] );
#line 425
            nslabs *= 2;
#line 425
        }
#line 425
            /* bits of k determine whether to get lower or upper part of dim */
#line 425
        for (k = 0; k < nslabs; k++) {
#line 425
            nels = 1;
#line 425
            for (j = 0; j < var_rank[i]; j++) {
#line 425
                if ((k >> j) & 1) {
#line 425
                    start[j] = 0;
#line 425
                    edge[j] = mid[j];
#line 425
                }else{
#line 425
                    start[j] = mid[j];
#line 425
                    edge[j] = var_shape[i][j] - mid[j];
#line 425
                }
#line 425
                nels *= edge[j];
#line 425
            }
#line 425
	    allInExtRange = allInIntRange = 1;
#line 425
            for (j = 0; j < nels; j++) {
#line 425
                err = toMixedBase(j, var_rank[i], edge, index);
#line 425
                IF (err)
#line 425
                    error("error in toMixedBase 1");
#line 425
                for (d = 0; d < var_rank[i]; d++)
#line 425
                    index[d] += start[d];
#line 425
                expect[j] = hash4(var_type[i], var_rank[i], index, NCT_ULONGLONG);
#line 425
		if (inRange3(expect[j],var_type[i], NCT_ULONGLONG)) {
#line 425
		    allInIntRange = allInIntRange && expect[j] >= ulonglong_min
#line 425
				&& expect[j] <= ulonglong_max;
#line 425
		} else {
#line 425
		    allInExtRange = 0;
#line 425
		}
#line 425
	    }
#line 425
            if (var_rank[i] == 0 && i%2)
#line 425
		err = nc_get_vara_ulonglong(ncid, i, NULL, NULL, value);
#line 425
	    else
#line 425
		err = nc_get_vara_ulonglong(ncid, i, start, edge, value);
#line 425
            if (canConvert) {
#line 425
		if (allInExtRange) {
#line 425
		    if (allInIntRange) {
#line 425
			IF (err)
#line 425
			    error("%s", nc_strerror(err));
#line 425
		    } else {
#line 425
			IF (err != NC_ERANGE)
#line 425
			    error("Range error: status = %d", err);
#line 425
		    }
#line 425
		} else {
#line 425
		    IF (err != 0 && err != NC_ERANGE)
#line 425
			error("OK or Range error: status = %d", err);
#line 425
		}
#line 425
		for (j = 0; j < nels; j++) {
#line 425
		    if (inRange3(expect[j],var_type[i],NCT_ULONGLONG)
#line 425
			    && expect[j] >= ulonglong_min && expect[j] <= ulonglong_max) {
#line 425
			IF (!equal(value[j],expect[j],var_type[i],NCT_ULONGLONG)){
#line 425
			    error("value read not that expected");
#line 425
			    if (verbose) {
#line 425
				error("\n");
#line 425
				error("varid: %d, ", i);
#line 425
				error("var_name: %s, ", var_name[i]);
#line 425
				error("element number: %d ", j);
#line 425
				error("expect: %g", expect[j]);
#line 425
				error("got: %g", (double) value[j]);
#line 425
			    }
#line 425
			} else {
#line 425
			    nok++;
#line 425
			}
#line 425
		    }
#line 425
		}
#line 425
            } else {
#line 425
                IF (nels > 0 && err != NC_ECHAR)
#line 425
                    error("wrong type: status = %d", err);
#line 425
            }
#line 425
        }
#line 425
    }
#line 425
    err = nc_close(ncid);
#line 425
    IF (err)
#line 425
	error("nc_close: %s", nc_strerror(err));
#line 425
    print_nok(nok);
#line 425
}
#line 425



#line 606

void
#line 607
test_nc_get_vars_text(void)
#line 607
{
#line 607
    int ncid;
#line 607
    int d;
#line 607
    int i;
#line 607
    int j;
#line 607
    int k;
#line 607
    int m;
#line 607
    int err;
#line 607
    int allInExtRange;	/* all values within external range? */
#line 607
    int allInIntRange;	/* all values within internal range? */
#line 607
    int nels;
#line 607
    int nslabs;
#line 607
    int nstarts;        /* number of different starts */
#line 607
    int nok = 0;      /* count of valid comparisons */
#line 607
    size_t start[MAX_RANK];
#line 607
    size_t edge[MAX_RANK];
#line 607
    size_t index[MAX_RANK];
#line 607
    size_t index2[MAX_RANK];
#line 607
    size_t mid[MAX_RANK];
#line 607
    size_t count[MAX_RANK];
#line 607
    size_t sstride[MAX_RANK];
#line 607
    ptrdiff_t stride[MAX_RANK];
#line 607
    int canConvert;     /* Both text or both numeric */
#line 607
    text value[MAX_NELS];
#line 607
    double expect[MAX_NELS];
#line 607

#line 607
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 607
    IF (err)
#line 607
        error("nc_open: %s", nc_strerror(err));
#line 607
    for (i = 0; i < numVars; i++) {
#line 607
        canConvert = (var_type[i] == NC_CHAR) == (NCT_TEXT == NCT_TEXT);
#line 607
        assert(var_rank[i] <= MAX_RANK);
#line 607
        assert(var_nels[i] <= MAX_NELS);
#line 607
        for (j = 0; j < var_rank[i]; j++) {
#line 607
            start[j] = 0;
#line 607
            edge[j] = 1;
#line 607
            stride[j] = 1;
#line 607
        }
#line 607
        err = nc_get_vars_text(BAD_ID, i, start, edge, stride, value);
#line 607
        IF (err != NC_EBADID)
#line 607
            error("bad ncid: status = %d", err);
#line 607
        err = nc_get_vars_text(ncid, BAD_VARID, start, edge, stride, value);
#line 607
        IF (err != NC_ENOTVAR)
#line 607
            error("bad var id: status = %d", err);
#line 607
        for (j = 0; j < var_rank[i]; j++) {
#line 607
            start[j] = var_shape[i][j];
#line 607
            err = nc_get_vars_text(ncid, i, start, edge, stride, value);
#line 607
	  if(!canConvert) {
#line 607
		IF (err != NC_ECHAR)
#line 607
               	    error("conversion: status = %d", err);
#line 607
	  } else {
#line 607
            IF (err != NC_EINVALCOORDS)
#line 607
                error("bad index: status = %d", err);
#line 607
            start[j] = 0;
#line 607
            edge[j] = var_shape[i][j] + 1;
#line 607
            err = nc_get_vars_text(ncid, i, start, edge, stride, value);
#line 607
            IF (err != NC_EEDGE)
#line 607
                error("bad edge: status = %d", err);
#line 607
            edge[j] = 1;
#line 607
            stride[j] = 0;
#line 607
            err = nc_get_vars_text(ncid, i, start, edge, stride, value);
#line 607
            IF (err != NC_ESTRIDE)
#line 607
                error("bad stride: status = %d", err);
#line 607
            stride[j] = 1;
#line 607
	  }
#line 607
        }
#line 607
            /* Choose a random point dividing each dim into 2 parts */
#line 607
            /* get 2^rank (nslabs) slabs so defined */
#line 607
        nslabs = 1;
#line 607
        for (j = 0; j < var_rank[i]; j++) {
#line 607
            mid[j] = roll( var_shape[i][j] );
#line 607
            nslabs *= 2;
#line 607
        }
#line 607
            /* bits of k determine whether to get lower or upper part of dim */
#line 607
            /* choose random stride from 1 to edge */
#line 607
        for (k = 0; k < nslabs; k++) {
#line 607
            nstarts = 1;
#line 607
            for (j = 0; j < var_rank[i]; j++) {
#line 607
                if ((k >> j) & 1) {
#line 607
                    start[j] = 0;
#line 607
                    edge[j] = mid[j];
#line 607
                }else{
#line 607
                    start[j] = mid[j];
#line 607
                    edge[j] = var_shape[i][j] - mid[j];
#line 607
                }
#line 607
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 607
                nstarts *= stride[j];
#line 607
            }
#line 607
            for (m = 0; m < nstarts; m++) {
#line 607
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 607
                IF (err)
#line 607
                    error("error in toMixedBase");
#line 607
                nels = 1;
#line 607
                for (j = 0; j < var_rank[i]; j++) {
#line 607
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 607
                    nels *= count[j];
#line 607
                    index[j] += start[j];
#line 607
                }
#line 607
                        /* Random choice of forward or backward */
#line 607
/* TODO
#line 607
                if ( roll(2) ) {
#line 607
                    for (j = 0; j < var_rank[i]; j++) {
#line 607
                        index[j] += (count[j] - 1) * stride[j];
#line 607
                        stride[j] = -stride[j];
#line 607
                    }
#line 607
                }
#line 607
*/
#line 607
		allInExtRange = allInIntRange = 1;
#line 607
		for (j = 0; j < nels; j++) {
#line 607
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 607
		    IF (err)
#line 607
			error("error in toMixedBase 1");
#line 607
		    for (d = 0; d < var_rank[i]; d++)
#line 607
			index2[d] = index[d] + index2[d] * stride[d];
#line 607
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 607
			NCT_TEXT);
#line 607
		    if (inRange3(expect[j],var_type[i],NCT_TEXT)) {
#line 607
			allInIntRange = allInIntRange && expect[j] >= text_min
#line 607
			    && expect[j] <= text_max;
#line 607
		    } else {
#line 607
			allInExtRange = 0;
#line 607
		    }
#line 607
		}
#line 607
                if (var_rank[i] == 0 && i%2 )
#line 607
                    err = nc_get_vars_text(ncid, i, NULL, NULL, NULL, value);
#line 607
                else
#line 607
                    err = nc_get_vars_text(ncid, i, index, count, stride, value);
#line 607
		if (canConvert) {
#line 607
		    if (allInExtRange) {
#line 607
			if (allInIntRange) {
#line 607
			    IF (err)
#line 607
				error("%s", nc_strerror(err));
#line 607
			} else {
#line 607
			    IF (err != NC_ERANGE)
#line 607
				error("Range error: status = %d", err);
#line 607
			}
#line 607
		    } else {
#line 607
			IF (err != 0 && err != NC_ERANGE)
#line 607
			    error("OK or Range error: status = %d", err);
#line 607
		    }
#line 607
		    for (j = 0; j < nels; j++) {
#line 607
			if (inRange3(expect[j],var_type[i],NCT_TEXT)
#line 607
				&& expect[j] >= text_min && expect[j] <= text_max) {
#line 607
			    IF (!equal(value[j],expect[j],var_type[i], NCT_TEXT)){
#line 607
				error("value read not that expected");
#line 607
				if (verbose) {
#line 607
				    error("\n");
#line 607
				    error("varid: %d, ", i);
#line 607
				    error("var_name: %s, ", var_name[i]);
#line 607
				    error("element number: %d ", j);
#line 607
                                    error("expect: %g, ", expect[j]);
#line 607
				    error("got: %g", (double) value[j]);
#line 607
				}
#line 607
			    } else {
#line 607
				nok++;
#line 607
			    }
#line 607
			}
#line 607
		    }
#line 607
		} else {
#line 607
		    IF (nels > 0 && err != NC_ECHAR)
#line 607
			error("wrong type: status = %d", err);
#line 607
		}
#line 607
	    }
#line 607
	}
#line 607

#line 607
    }
#line 607
    err = nc_close(ncid);
#line 607
    IF (err)
#line 607
        error("nc_close: %s", nc_strerror(err));
#line 607
    print_nok(nok);
#line 607
}
#line 607

void
#line 608
test_nc_get_vars_uchar(void)
#line 608
{
#line 608
    int ncid;
#line 608
    int d;
#line 608
    int i;
#line 608
    int j;
#line 608
    int k;
#line 608
    int m;
#line 608
    int err;
#line 608
    int allInExtRange;	/* all values within external range? */
#line 608
    int allInIntRange;	/* all values within internal range? */
#line 608
    int nels;
#line 608
    int nslabs;
#line 608
    int nstarts;        /* number of different starts */
#line 608
    int nok = 0;      /* count of valid comparisons */
#line 608
    size_t start[MAX_RANK];
#line 608
    size_t edge[MAX_RANK];
#line 608
    size_t index[MAX_RANK];
#line 608
    size_t index2[MAX_RANK];
#line 608
    size_t mid[MAX_RANK];
#line 608
    size_t count[MAX_RANK];
#line 608
    size_t sstride[MAX_RANK];
#line 608
    ptrdiff_t stride[MAX_RANK];
#line 608
    int canConvert;     /* Both text or both numeric */
#line 608
    uchar value[MAX_NELS];
#line 608
    double expect[MAX_NELS];
#line 608

#line 608
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 608
    IF (err)
#line 608
        error("nc_open: %s", nc_strerror(err));
#line 608
    for (i = 0; i < numVars; i++) {
#line 608
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UCHAR == NCT_TEXT);
#line 608
        assert(var_rank[i] <= MAX_RANK);
#line 608
        assert(var_nels[i] <= MAX_NELS);
#line 608
        for (j = 0; j < var_rank[i]; j++) {
#line 608
            start[j] = 0;
#line 608
            edge[j] = 1;
#line 608
            stride[j] = 1;
#line 608
        }
#line 608
        err = nc_get_vars_uchar(BAD_ID, i, start, edge, stride, value);
#line 608
        IF (err != NC_EBADID)
#line 608
            error("bad ncid: status = %d", err);
#line 608
        err = nc_get_vars_uchar(ncid, BAD_VARID, start, edge, stride, value);
#line 608
        IF (err != NC_ENOTVAR)
#line 608
            error("bad var id: status = %d", err);
#line 608
        for (j = 0; j < var_rank[i]; j++) {
#line 608
            start[j] = var_shape[i][j];
#line 608
            err = nc_get_vars_uchar(ncid, i, start, edge, stride, value);
#line 608
	  if(!canConvert) {
#line 608
		IF (err != NC_ECHAR)
#line 608
               	    error("conversion: status = %d", err);
#line 608
	  } else {
#line 608
            IF (err != NC_EINVALCOORDS)
#line 608
                error("bad index: status = %d", err);
#line 608
            start[j] = 0;
#line 608
            edge[j] = var_shape[i][j] + 1;
#line 608
            err = nc_get_vars_uchar(ncid, i, start, edge, stride, value);
#line 608
            IF (err != NC_EEDGE)
#line 608
                error("bad edge: status = %d", err);
#line 608
            edge[j] = 1;
#line 608
            stride[j] = 0;
#line 608
            err = nc_get_vars_uchar(ncid, i, start, edge, stride, value);
#line 608
            IF (err != NC_ESTRIDE)
#line 608
                error("bad stride: status = %d", err);
#line 608
            stride[j] = 1;
#line 608
	  }
#line 608
        }
#line 608
            /* Choose a random point dividing each dim into 2 parts */
#line 608
            /* get 2^rank (nslabs) slabs so defined */
#line 608
        nslabs = 1;
#line 608
        for (j = 0; j < var_rank[i]; j++) {
#line 608
            mid[j] = roll( var_shape[i][j] );
#line 608
            nslabs *= 2;
#line 608
        }
#line 608
            /* bits of k determine whether to get lower or upper part of dim */
#line 608
            /* choose random stride from 1 to edge */
#line 608
        for (k = 0; k < nslabs; k++) {
#line 608
            nstarts = 1;
#line 608
            for (j = 0; j < var_rank[i]; j++) {
#line 608
                if ((k >> j) & 1) {
#line 608
                    start[j] = 0;
#line 608
                    edge[j] = mid[j];
#line 608
                }else{
#line 608
                    start[j] = mid[j];
#line 608
                    edge[j] = var_shape[i][j] - mid[j];
#line 608
                }
#line 608
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 608
                nstarts *= stride[j];
#line 608
            }
#line 608
            for (m = 0; m < nstarts; m++) {
#line 608
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 608
                IF (err)
#line 608
                    error("error in toMixedBase");
#line 608
                nels = 1;
#line 608
                for (j = 0; j < var_rank[i]; j++) {
#line 608
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 608
                    nels *= count[j];
#line 608
                    index[j] += start[j];
#line 608
                }
#line 608
                        /* Random choice of forward or backward */
#line 608
/* TODO
#line 608
                if ( roll(2) ) {
#line 608
                    for (j = 0; j < var_rank[i]; j++) {
#line 608
                        index[j] += (count[j] - 1) * stride[j];
#line 608
                        stride[j] = -stride[j];
#line 608
                    }
#line 608
                }
#line 608
*/
#line 608
		allInExtRange = allInIntRange = 1;
#line 608
		for (j = 0; j < nels; j++) {
#line 608
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 608
		    IF (err)
#line 608
			error("error in toMixedBase 1");
#line 608
		    for (d = 0; d < var_rank[i]; d++)
#line 608
			index2[d] = index[d] + index2[d] * stride[d];
#line 608
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 608
			NCT_UCHAR);
#line 608
		    if (inRange3(expect[j],var_type[i],NCT_UCHAR)) {
#line 608
			allInIntRange = allInIntRange && expect[j] >= uchar_min
#line 608
			    && expect[j] <= uchar_max;
#line 608
		    } else {
#line 608
			allInExtRange = 0;
#line 608
		    }
#line 608
		}
#line 608
                if (var_rank[i] == 0 && i%2 )
#line 608
                    err = nc_get_vars_uchar(ncid, i, NULL, NULL, NULL, value);
#line 608
                else
#line 608
                    err = nc_get_vars_uchar(ncid, i, index, count, stride, value);
#line 608
		if (canConvert) {
#line 608
		    if (allInExtRange) {
#line 608
			if (allInIntRange) {
#line 608
			    IF (err)
#line 608
				error("%s", nc_strerror(err));
#line 608
			} else {
#line 608
			    IF (err != NC_ERANGE)
#line 608
				error("Range error: status = %d", err);
#line 608
			}
#line 608
		    } else {
#line 608
			IF (err != 0 && err != NC_ERANGE)
#line 608
			    error("OK or Range error: status = %d", err);
#line 608
		    }
#line 608
		    for (j = 0; j < nels; j++) {
#line 608
			if (inRange3(expect[j],var_type[i],NCT_UCHAR)
#line 608
				&& expect[j] >= uchar_min && expect[j] <= uchar_max) {
#line 608
			    IF (!equal(value[j],expect[j],var_type[i], NCT_UCHAR)){
#line 608
				error("value read not that expected");
#line 608
				if (verbose) {
#line 608
				    error("\n");
#line 608
				    error("varid: %d, ", i);
#line 608
				    error("var_name: %s, ", var_name[i]);
#line 608
				    error("element number: %d ", j);
#line 608
                                    error("expect: %g, ", expect[j]);
#line 608
				    error("got: %g", (double) value[j]);
#line 608
				}
#line 608
			    } else {
#line 608
				nok++;
#line 608
			    }
#line 608
			}
#line 608
		    }
#line 608
		} else {
#line 608
		    IF (nels > 0 && err != NC_ECHAR)
#line 608
			error("wrong type: status = %d", err);
#line 608
		}
#line 608
	    }
#line 608
	}
#line 608

#line 608
    }
#line 608
    err = nc_close(ncid);
#line 608
    IF (err)
#line 608
        error("nc_close: %s", nc_strerror(err));
#line 608
    print_nok(nok);
#line 608
}
#line 608

void
#line 609
test_nc_get_vars_schar(void)
#line 609
{
#line 609
    int ncid;
#line 609
    int d;
#line 609
    int i;
#line 609
    int j;
#line 609
    int k;
#line 609
    int m;
#line 609
    int err;
#line 609
    int allInExtRange;	/* all values within external range? */
#line 609
    int allInIntRange;	/* all values within internal range? */
#line 609
    int nels;
#line 609
    int nslabs;
#line 609
    int nstarts;        /* number of different starts */
#line 609
    int nok = 0;      /* count of valid comparisons */
#line 609
    size_t start[MAX_RANK];
#line 609
    size_t edge[MAX_RANK];
#line 609
    size_t index[MAX_RANK];
#line 609
    size_t index2[MAX_RANK];
#line 609
    size_t mid[MAX_RANK];
#line 609
    size_t count[MAX_RANK];
#line 609
    size_t sstride[MAX_RANK];
#line 609
    ptrdiff_t stride[MAX_RANK];
#line 609
    int canConvert;     /* Both text or both numeric */
#line 609
    schar value[MAX_NELS];
#line 609
    double expect[MAX_NELS];
#line 609

#line 609
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 609
    IF (err)
#line 609
        error("nc_open: %s", nc_strerror(err));
#line 609
    for (i = 0; i < numVars; i++) {
#line 609
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SCHAR == NCT_TEXT);
#line 609
        assert(var_rank[i] <= MAX_RANK);
#line 609
        assert(var_nels[i] <= MAX_NELS);
#line 609
        for (j = 0; j < var_rank[i]; j++) {
#line 609
            start[j] = 0;
#line 609
            edge[j] = 1;
#line 609
            stride[j] = 1;
#line 609
        }
#line 609
        err = nc_get_vars_schar(BAD_ID, i, start, edge, stride, value);
#line 609
        IF (err != NC_EBADID)
#line 609
            error("bad ncid: status = %d", err);
#line 609
        err = nc_get_vars_schar(ncid, BAD_VARID, start, edge, stride, value);
#line 609
        IF (err != NC_ENOTVAR)
#line 609
            error("bad var id: status = %d", err);
#line 609
        for (j = 0; j < var_rank[i]; j++) {
#line 609
            start[j] = var_shape[i][j];
#line 609
            err = nc_get_vars_schar(ncid, i, start, edge, stride, value);
#line 609
	  if(!canConvert) {
#line 609
		IF (err != NC_ECHAR)
#line 609
               	    error("conversion: status = %d", err);
#line 609
	  } else {
#line 609
            IF (err != NC_EINVALCOORDS)
#line 609
                error("bad index: status = %d", err);
#line 609
            start[j] = 0;
#line 609
            edge[j] = var_shape[i][j] + 1;
#line 609
            err = nc_get_vars_schar(ncid, i, start, edge, stride, value);
#line 609
            IF (err != NC_EEDGE)
#line 609
                error("bad edge: status = %d", err);
#line 609
            edge[j] = 1;
#line 609
            stride[j] = 0;
#line 609
            err = nc_get_vars_schar(ncid, i, start, edge, stride, value);
#line 609
            IF (err != NC_ESTRIDE)
#line 609
                error("bad stride: status = %d", err);
#line 609
            stride[j] = 1;
#line 609
	  }
#line 609
        }
#line 609
            /* Choose a random point dividing each dim into 2 parts */
#line 609
            /* get 2^rank (nslabs) slabs so defined */
#line 609
        nslabs = 1;
#line 609
        for (j = 0; j < var_rank[i]; j++) {
#line 609
            mid[j] = roll( var_shape[i][j] );
#line 609
            nslabs *= 2;
#line 609
        }
#line 609
            /* bits of k determine whether to get lower or upper part of dim */
#line 609
            /* choose random stride from 1 to edge */
#line 609
        for (k = 0; k < nslabs; k++) {
#line 609
            nstarts = 1;
#line 609
            for (j = 0; j < var_rank[i]; j++) {
#line 609
                if ((k >> j) & 1) {
#line 609
                    start[j] = 0;
#line 609
                    edge[j] = mid[j];
#line 609
                }else{
#line 609
                    start[j] = mid[j];
#line 609
                    edge[j] = var_shape[i][j] - mid[j];
#line 609
                }
#line 609
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 609
                nstarts *= stride[j];
#line 609
            }
#line 609
            for (m = 0; m < nstarts; m++) {
#line 609
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 609
                IF (err)
#line 609
                    error("error in toMixedBase");
#line 609
                nels = 1;
#line 609
                for (j = 0; j < var_rank[i]; j++) {
#line 609
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 609
                    nels *= count[j];
#line 609
                    index[j] += start[j];
#line 609
                }
#line 609
                        /* Random choice of forward or backward */
#line 609
/* TODO
#line 609
                if ( roll(2) ) {
#line 609
                    for (j = 0; j < var_rank[i]; j++) {
#line 609
                        index[j] += (count[j] - 1) * stride[j];
#line 609
                        stride[j] = -stride[j];
#line 609
                    }
#line 609
                }
#line 609
*/
#line 609
		allInExtRange = allInIntRange = 1;
#line 609
		for (j = 0; j < nels; j++) {
#line 609
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 609
		    IF (err)
#line 609
			error("error in toMixedBase 1");
#line 609
		    for (d = 0; d < var_rank[i]; d++)
#line 609
			index2[d] = index[d] + index2[d] * stride[d];
#line 609
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 609
			NCT_SCHAR);
#line 609
		    if (inRange3(expect[j],var_type[i],NCT_SCHAR)) {
#line 609
			allInIntRange = allInIntRange && expect[j] >= schar_min
#line 609
			    && expect[j] <= schar_max;
#line 609
		    } else {
#line 609
			allInExtRange = 0;
#line 609
		    }
#line 609
		}
#line 609
                if (var_rank[i] == 0 && i%2 )
#line 609
                    err = nc_get_vars_schar(ncid, i, NULL, NULL, NULL, value);
#line 609
                else
#line 609
                    err = nc_get_vars_schar(ncid, i, index, count, stride, value);
#line 609
		if (canConvert) {
#line 609
		    if (allInExtRange) {
#line 609
			if (allInIntRange) {
#line 609
			    IF (err)
#line 609
				error("%s", nc_strerror(err));
#line 609
			} else {
#line 609
			    IF (err != NC_ERANGE)
#line 609
				error("Range error: status = %d", err);
#line 609
			}
#line 609
		    } else {
#line 609
			IF (err != 0 && err != NC_ERANGE)
#line 609
			    error("OK or Range error: status = %d", err);
#line 609
		    }
#line 609
		    for (j = 0; j < nels; j++) {
#line 609
			if (inRange3(expect[j],var_type[i],NCT_SCHAR)
#line 609
				&& expect[j] >= schar_min && expect[j] <= schar_max) {
#line 609
			    IF (!equal(value[j],expect[j],var_type[i], NCT_SCHAR)){
#line 609
				error("value read not that expected");
#line 609
				if (verbose) {
#line 609
				    error("\n");
#line 609
				    error("varid: %d, ", i);
#line 609
				    error("var_name: %s, ", var_name[i]);
#line 609
				    error("element number: %d ", j);
#line 609
                                    error("expect: %g, ", expect[j]);
#line 609
				    error("got: %g", (double) value[j]);
#line 609
				}
#line 609
			    } else {
#line 609
				nok++;
#line 609
			    }
#line 609
			}
#line 609
		    }
#line 609
		} else {
#line 609
		    IF (nels > 0 && err != NC_ECHAR)
#line 609
			error("wrong type: status = %d", err);
#line 609
		}
#line 609
	    }
#line 609
	}
#line 609

#line 609
    }
#line 609
    err = nc_close(ncid);
#line 609
    IF (err)
#line 609
        error("nc_close: %s", nc_strerror(err));
#line 609
    print_nok(nok);
#line 609
}
#line 609

void
#line 610
test_nc_get_vars_short(void)
#line 610
{
#line 610
    int ncid;
#line 610
    int d;
#line 610
    int i;
#line 610
    int j;
#line 610
    int k;
#line 610
    int m;
#line 610
    int err;
#line 610
    int allInExtRange;	/* all values within external range? */
#line 610
    int allInIntRange;	/* all values within internal range? */
#line 610
    int nels;
#line 610
    int nslabs;
#line 610
    int nstarts;        /* number of different starts */
#line 610
    int nok = 0;      /* count of valid comparisons */
#line 610
    size_t start[MAX_RANK];
#line 610
    size_t edge[MAX_RANK];
#line 610
    size_t index[MAX_RANK];
#line 610
    size_t index2[MAX_RANK];
#line 610
    size_t mid[MAX_RANK];
#line 610
    size_t count[MAX_RANK];
#line 610
    size_t sstride[MAX_RANK];
#line 610
    ptrdiff_t stride[MAX_RANK];
#line 610
    int canConvert;     /* Both text or both numeric */
#line 610
    short value[MAX_NELS];
#line 610
    double expect[MAX_NELS];
#line 610

#line 610
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 610
    IF (err)
#line 610
        error("nc_open: %s", nc_strerror(err));
#line 610
    for (i = 0; i < numVars; i++) {
#line 610
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SHORT == NCT_TEXT);
#line 610
        assert(var_rank[i] <= MAX_RANK);
#line 610
        assert(var_nels[i] <= MAX_NELS);
#line 610
        for (j = 0; j < var_rank[i]; j++) {
#line 610
            start[j] = 0;
#line 610
            edge[j] = 1;
#line 610
            stride[j] = 1;
#line 610
        }
#line 610
        err = nc_get_vars_short(BAD_ID, i, start, edge, stride, value);
#line 610
        IF (err != NC_EBADID)
#line 610
            error("bad ncid: status = %d", err);
#line 610
        err = nc_get_vars_short(ncid, BAD_VARID, start, edge, stride, value);
#line 610
        IF (err != NC_ENOTVAR)
#line 610
            error("bad var id: status = %d", err);
#line 610
        for (j = 0; j < var_rank[i]; j++) {
#line 610
            start[j] = var_shape[i][j];
#line 610
            err = nc_get_vars_short(ncid, i, start, edge, stride, value);
#line 610
	  if(!canConvert) {
#line 610
		IF (err != NC_ECHAR)
#line 610
               	    error("conversion: status = %d", err);
#line 610
	  } else {
#line 610
            IF (err != NC_EINVALCOORDS)
#line 610
                error("bad index: status = %d", err);
#line 610
            start[j] = 0;
#line 610
            edge[j] = var_shape[i][j] + 1;
#line 610
            err = nc_get_vars_short(ncid, i, start, edge, stride, value);
#line 610
            IF (err != NC_EEDGE)
#line 610
                error("bad edge: status = %d", err);
#line 610
            edge[j] = 1;
#line 610
            stride[j] = 0;
#line 610
            err = nc_get_vars_short(ncid, i, start, edge, stride, value);
#line 610
            IF (err != NC_ESTRIDE)
#line 610
                error("bad stride: status = %d", err);
#line 610
            stride[j] = 1;
#line 610
	  }
#line 610
        }
#line 610
            /* Choose a random point dividing each dim into 2 parts */
#line 610
            /* get 2^rank (nslabs) slabs so defined */
#line 610
        nslabs = 1;
#line 610
        for (j = 0; j < var_rank[i]; j++) {
#line 610
            mid[j] = roll( var_shape[i][j] );
#line 610
            nslabs *= 2;
#line 610
        }
#line 610
            /* bits of k determine whether to get lower or upper part of dim */
#line 610
            /* choose random stride from 1 to edge */
#line 610
        for (k = 0; k < nslabs; k++) {
#line 610
            nstarts = 1;
#line 610
            for (j = 0; j < var_rank[i]; j++) {
#line 610
                if ((k >> j) & 1) {
#line 610
                    start[j] = 0;
#line 610
                    edge[j] = mid[j];
#line 610
                }else{
#line 610
                    start[j] = mid[j];
#line 610
                    edge[j] = var_shape[i][j] - mid[j];
#line 610
                }
#line 610
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 610
                nstarts *= stride[j];
#line 610
            }
#line 610
            for (m = 0; m < nstarts; m++) {
#line 610
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 610
                IF (err)
#line 610
                    error("error in toMixedBase");
#line 610
                nels = 1;
#line 610
                for (j = 0; j < var_rank[i]; j++) {
#line 610
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 610
                    nels *= count[j];
#line 610
                    index[j] += start[j];
#line 610
                }
#line 610
                        /* Random choice of forward or backward */
#line 610
/* TODO
#line 610
                if ( roll(2) ) {
#line 610
                    for (j = 0; j < var_rank[i]; j++) {
#line 610
                        index[j] += (count[j] - 1) * stride[j];
#line 610
                        stride[j] = -stride[j];
#line 610
                    }
#line 610
                }
#line 610
*/
#line 610
		allInExtRange = allInIntRange = 1;
#line 610
		for (j = 0; j < nels; j++) {
#line 610
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 610
		    IF (err)
#line 610
			error("error in toMixedBase 1");
#line 610
		    for (d = 0; d < var_rank[i]; d++)
#line 610
			index2[d] = index[d] + index2[d] * stride[d];
#line 610
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 610
			NCT_SHORT);
#line 610
		    if (inRange3(expect[j],var_type[i],NCT_SHORT)) {
#line 610
			allInIntRange = allInIntRange && expect[j] >= short_min
#line 610
			    && expect[j] <= short_max;
#line 610
		    } else {
#line 610
			allInExtRange = 0;
#line 610
		    }
#line 610
		}
#line 610
                if (var_rank[i] == 0 && i%2 )
#line 610
                    err = nc_get_vars_short(ncid, i, NULL, NULL, NULL, value);
#line 610
                else
#line 610
                    err = nc_get_vars_short(ncid, i, index, count, stride, value);
#line 610
		if (canConvert) {
#line 610
		    if (allInExtRange) {
#line 610
			if (allInIntRange) {
#line 610
			    IF (err)
#line 610
				error("%s", nc_strerror(err));
#line 610
			} else {
#line 610
			    IF (err != NC_ERANGE)
#line 610
				error("Range error: status = %d", err);
#line 610
			}
#line 610
		    } else {
#line 610
			IF (err != 0 && err != NC_ERANGE)
#line 610
			    error("OK or Range error: status = %d", err);
#line 610
		    }
#line 610
		    for (j = 0; j < nels; j++) {
#line 610
			if (inRange3(expect[j],var_type[i],NCT_SHORT)
#line 610
				&& expect[j] >= short_min && expect[j] <= short_max) {
#line 610
			    IF (!equal(value[j],expect[j],var_type[i], NCT_SHORT)){
#line 610
				error("value read not that expected");
#line 610
				if (verbose) {
#line 610
				    error("\n");
#line 610
				    error("varid: %d, ", i);
#line 610
				    error("var_name: %s, ", var_name[i]);
#line 610
				    error("element number: %d ", j);
#line 610
                                    error("expect: %g, ", expect[j]);
#line 610
				    error("got: %g", (double) value[j]);
#line 610
				}
#line 610
			    } else {
#line 610
				nok++;
#line 610
			    }
#line 610
			}
#line 610
		    }
#line 610
		} else {
#line 610
		    IF (nels > 0 && err != NC_ECHAR)
#line 610
			error("wrong type: status = %d", err);
#line 610
		}
#line 610
	    }
#line 610
	}
#line 610

#line 610
    }
#line 610
    err = nc_close(ncid);
#line 610
    IF (err)
#line 610
        error("nc_close: %s", nc_strerror(err));
#line 610
    print_nok(nok);
#line 610
}
#line 610

void
#line 611
test_nc_get_vars_int(void)
#line 611
{
#line 611
    int ncid;
#line 611
    int d;
#line 611
    int i;
#line 611
    int j;
#line 611
    int k;
#line 611
    int m;
#line 611
    int err;
#line 611
    int allInExtRange;	/* all values within external range? */
#line 611
    int allInIntRange;	/* all values within internal range? */
#line 611
    int nels;
#line 611
    int nslabs;
#line 611
    int nstarts;        /* number of different starts */
#line 611
    int nok = 0;      /* count of valid comparisons */
#line 611
    size_t start[MAX_RANK];
#line 611
    size_t edge[MAX_RANK];
#line 611
    size_t index[MAX_RANK];
#line 611
    size_t index2[MAX_RANK];
#line 611
    size_t mid[MAX_RANK];
#line 611
    size_t count[MAX_RANK];
#line 611
    size_t sstride[MAX_RANK];
#line 611
    ptrdiff_t stride[MAX_RANK];
#line 611
    int canConvert;     /* Both text or both numeric */
#line 611
    int value[MAX_NELS];
#line 611
    double expect[MAX_NELS];
#line 611

#line 611
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 611
    IF (err)
#line 611
        error("nc_open: %s", nc_strerror(err));
#line 611
    for (i = 0; i < numVars; i++) {
#line 611
        canConvert = (var_type[i] == NC_CHAR) == (NCT_INT == NCT_TEXT);
#line 611
        assert(var_rank[i] <= MAX_RANK);
#line 611
        assert(var_nels[i] <= MAX_NELS);
#line 611
        for (j = 0; j < var_rank[i]; j++) {
#line 611
            start[j] = 0;
#line 611
            edge[j] = 1;
#line 611
            stride[j] = 1;
#line 611
        }
#line 611
        err = nc_get_vars_int(BAD_ID, i, start, edge, stride, value);
#line 611
        IF (err != NC_EBADID)
#line 611
            error("bad ncid: status = %d", err);
#line 611
        err = nc_get_vars_int(ncid, BAD_VARID, start, edge, stride, value);
#line 611
        IF (err != NC_ENOTVAR)
#line 611
            error("bad var id: status = %d", err);
#line 611
        for (j = 0; j < var_rank[i]; j++) {
#line 611
            start[j] = var_shape[i][j];
#line 611
            err = nc_get_vars_int(ncid, i, start, edge, stride, value);
#line 611
	  if(!canConvert) {
#line 611
		IF (err != NC_ECHAR)
#line 611
               	    error("conversion: status = %d", err);
#line 611
	  } else {
#line 611
            IF (err != NC_EINVALCOORDS)
#line 611
                error("bad index: status = %d", err);
#line 611
            start[j] = 0;
#line 611
            edge[j] = var_shape[i][j] + 1;
#line 611
            err = nc_get_vars_int(ncid, i, start, edge, stride, value);
#line 611
            IF (err != NC_EEDGE)
#line 611
                error("bad edge: status = %d", err);
#line 611
            edge[j] = 1;
#line 611
            stride[j] = 0;
#line 611
            err = nc_get_vars_int(ncid, i, start, edge, stride, value);
#line 611
            IF (err != NC_ESTRIDE)
#line 611
                error("bad stride: status = %d", err);
#line 611
            stride[j] = 1;
#line 611
	  }
#line 611
        }
#line 611
            /* Choose a random point dividing each dim into 2 parts */
#line 611
            /* get 2^rank (nslabs) slabs so defined */
#line 611
        nslabs = 1;
#line 611
        for (j = 0; j < var_rank[i]; j++) {
#line 611
            mid[j] = roll( var_shape[i][j] );
#line 611
            nslabs *= 2;
#line 611
        }
#line 611
            /* bits of k determine whether to get lower or upper part of dim */
#line 611
            /* choose random stride from 1 to edge */
#line 611
        for (k = 0; k < nslabs; k++) {
#line 611
            nstarts = 1;
#line 611
            for (j = 0; j < var_rank[i]; j++) {
#line 611
                if ((k >> j) & 1) {
#line 611
                    start[j] = 0;
#line 611
                    edge[j] = mid[j];
#line 611
                }else{
#line 611
                    start[j] = mid[j];
#line 611
                    edge[j] = var_shape[i][j] - mid[j];
#line 611
                }
#line 611
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 611
                nstarts *= stride[j];
#line 611
            }
#line 611
            for (m = 0; m < nstarts; m++) {
#line 611
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 611
                IF (err)
#line 611
                    error("error in toMixedBase");
#line 611
                nels = 1;
#line 611
                for (j = 0; j < var_rank[i]; j++) {
#line 611
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 611
                    nels *= count[j];
#line 611
                    index[j] += start[j];
#line 611
                }
#line 611
                        /* Random choice of forward or backward */
#line 611
/* TODO
#line 611
                if ( roll(2) ) {
#line 611
                    for (j = 0; j < var_rank[i]; j++) {
#line 611
                        index[j] += (count[j] - 1) * stride[j];
#line 611
                        stride[j] = -stride[j];
#line 611
                    }
#line 611
                }
#line 611
*/
#line 611
		allInExtRange = allInIntRange = 1;
#line 611
		for (j = 0; j < nels; j++) {
#line 611
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 611
		    IF (err)
#line 611
			error("error in toMixedBase 1");
#line 611
		    for (d = 0; d < var_rank[i]; d++)
#line 611
			index2[d] = index[d] + index2[d] * stride[d];
#line 611
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 611
			NCT_INT);
#line 611
		    if (inRange3(expect[j],var_type[i],NCT_INT)) {
#line 611
			allInIntRange = allInIntRange && expect[j] >= int_min
#line 611
			    && expect[j] <= int_max;
#line 611
		    } else {
#line 611
			allInExtRange = 0;
#line 611
		    }
#line 611
		}
#line 611
                if (var_rank[i] == 0 && i%2 )
#line 611
                    err = nc_get_vars_int(ncid, i, NULL, NULL, NULL, value);
#line 611
                else
#line 611
                    err = nc_get_vars_int(ncid, i, index, count, stride, value);
#line 611
		if (canConvert) {
#line 611
		    if (allInExtRange) {
#line 611
			if (allInIntRange) {
#line 611
			    IF (err)
#line 611
				error("%s", nc_strerror(err));
#line 611
			} else {
#line 611
			    IF (err != NC_ERANGE)
#line 611
				error("Range error: status = %d", err);
#line 611
			}
#line 611
		    } else {
#line 611
			IF (err != 0 && err != NC_ERANGE)
#line 611
			    error("OK or Range error: status = %d", err);
#line 611
		    }
#line 611
		    for (j = 0; j < nels; j++) {
#line 611
			if (inRange3(expect[j],var_type[i],NCT_INT)
#line 611
				&& expect[j] >= int_min && expect[j] <= int_max) {
#line 611
			    IF (!equal(value[j],expect[j],var_type[i], NCT_INT)){
#line 611
				error("value read not that expected");
#line 611
				if (verbose) {
#line 611
				    error("\n");
#line 611
				    error("varid: %d, ", i);
#line 611
				    error("var_name: %s, ", var_name[i]);
#line 611
				    error("element number: %d ", j);
#line 611
                                    error("expect: %g, ", expect[j]);
#line 611
				    error("got: %g", (double) value[j]);
#line 611
				}
#line 611
			    } else {
#line 611
				nok++;
#line 611
			    }
#line 611
			}
#line 611
		    }
#line 611
		} else {
#line 611
		    IF (nels > 0 && err != NC_ECHAR)
#line 611
			error("wrong type: status = %d", err);
#line 611
		}
#line 611
	    }
#line 611
	}
#line 611

#line 611
    }
#line 611
    err = nc_close(ncid);
#line 611
    IF (err)
#line 611
        error("nc_close: %s", nc_strerror(err));
#line 611
    print_nok(nok);
#line 611
}
#line 611

void
#line 612
test_nc_get_vars_long(void)
#line 612
{
#line 612
    int ncid;
#line 612
    int d;
#line 612
    int i;
#line 612
    int j;
#line 612
    int k;
#line 612
    int m;
#line 612
    int err;
#line 612
    int allInExtRange;	/* all values within external range? */
#line 612
    int allInIntRange;	/* all values within internal range? */
#line 612
    int nels;
#line 612
    int nslabs;
#line 612
    int nstarts;        /* number of different starts */
#line 612
    int nok = 0;      /* count of valid comparisons */
#line 612
    size_t start[MAX_RANK];
#line 612
    size_t edge[MAX_RANK];
#line 612
    size_t index[MAX_RANK];
#line 612
    size_t index2[MAX_RANK];
#line 612
    size_t mid[MAX_RANK];
#line 612
    size_t count[MAX_RANK];
#line 612
    size_t sstride[MAX_RANK];
#line 612
    ptrdiff_t stride[MAX_RANK];
#line 612
    int canConvert;     /* Both text or both numeric */
#line 612
    long value[MAX_NELS];
#line 612
    double expect[MAX_NELS];
#line 612

#line 612
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 612
    IF (err)
#line 612
        error("nc_open: %s", nc_strerror(err));
#line 612
    for (i = 0; i < numVars; i++) {
#line 612
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONG == NCT_TEXT);
#line 612
        assert(var_rank[i] <= MAX_RANK);
#line 612
        assert(var_nels[i] <= MAX_NELS);
#line 612
        for (j = 0; j < var_rank[i]; j++) {
#line 612
            start[j] = 0;
#line 612
            edge[j] = 1;
#line 612
            stride[j] = 1;
#line 612
        }
#line 612
        err = nc_get_vars_long(BAD_ID, i, start, edge, stride, value);
#line 612
        IF (err != NC_EBADID)
#line 612
            error("bad ncid: status = %d", err);
#line 612
        err = nc_get_vars_long(ncid, BAD_VARID, start, edge, stride, value);
#line 612
        IF (err != NC_ENOTVAR)
#line 612
            error("bad var id: status = %d", err);
#line 612
        for (j = 0; j < var_rank[i]; j++) {
#line 612
            start[j] = var_shape[i][j];
#line 612
            err = nc_get_vars_long(ncid, i, start, edge, stride, value);
#line 612
	  if(!canConvert) {
#line 612
		IF (err != NC_ECHAR)
#line 612
               	    error("conversion: status = %d", err);
#line 612
	  } else {
#line 612
            IF (err != NC_EINVALCOORDS)
#line 612
                error("bad index: status = %d", err);
#line 612
            start[j] = 0;
#line 612
            edge[j] = var_shape[i][j] + 1;
#line 612
            err = nc_get_vars_long(ncid, i, start, edge, stride, value);
#line 612
            IF (err != NC_EEDGE)
#line 612
                error("bad edge: status = %d", err);
#line 612
            edge[j] = 1;
#line 612
            stride[j] = 0;
#line 612
            err = nc_get_vars_long(ncid, i, start, edge, stride, value);
#line 612
            IF (err != NC_ESTRIDE)
#line 612
                error("bad stride: status = %d", err);
#line 612
            stride[j] = 1;
#line 612
	  }
#line 612
        }
#line 612
            /* Choose a random point dividing each dim into 2 parts */
#line 612
            /* get 2^rank (nslabs) slabs so defined */
#line 612
        nslabs = 1;
#line 612
        for (j = 0; j < var_rank[i]; j++) {
#line 612
            mid[j] = roll( var_shape[i][j] );
#line 612
            nslabs *= 2;
#line 612
        }
#line 612
            /* bits of k determine whether to get lower or upper part of dim */
#line 612
            /* choose random stride from 1 to edge */
#line 612
        for (k = 0; k < nslabs; k++) {
#line 612
            nstarts = 1;
#line 612
            for (j = 0; j < var_rank[i]; j++) {
#line 612
                if ((k >> j) & 1) {
#line 612
                    start[j] = 0;
#line 612
                    edge[j] = mid[j];
#line 612
                }else{
#line 612
                    start[j] = mid[j];
#line 612
                    edge[j] = var_shape[i][j] - mid[j];
#line 612
                }
#line 612
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 612
                nstarts *= stride[j];
#line 612
            }
#line 612
            for (m = 0; m < nstarts; m++) {
#line 612
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 612
                IF (err)
#line 612
                    error("error in toMixedBase");
#line 612
                nels = 1;
#line 612
                for (j = 0; j < var_rank[i]; j++) {
#line 612
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 612
                    nels *= count[j];
#line 612
                    index[j] += start[j];
#line 612
                }
#line 612
                        /* Random choice of forward or backward */
#line 612
/* TODO
#line 612
                if ( roll(2) ) {
#line 612
                    for (j = 0; j < var_rank[i]; j++) {
#line 612
                        index[j] += (count[j] - 1) * stride[j];
#line 612
                        stride[j] = -stride[j];
#line 612
                    }
#line 612
                }
#line 612
*/
#line 612
		allInExtRange = allInIntRange = 1;
#line 612
		for (j = 0; j < nels; j++) {
#line 612
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 612
		    IF (err)
#line 612
			error("error in toMixedBase 1");
#line 612
		    for (d = 0; d < var_rank[i]; d++)
#line 612
			index2[d] = index[d] + index2[d] * stride[d];
#line 612
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 612
			NCT_LONG);
#line 612
		    if (inRange3(expect[j],var_type[i],NCT_LONG)) {
#line 612
			allInIntRange = allInIntRange && expect[j] >= long_min
#line 612
			    && expect[j] <= long_max;
#line 612
		    } else {
#line 612
			allInExtRange = 0;
#line 612
		    }
#line 612
		}
#line 612
                if (var_rank[i] == 0 && i%2 )
#line 612
                    err = nc_get_vars_long(ncid, i, NULL, NULL, NULL, value);
#line 612
                else
#line 612
                    err = nc_get_vars_long(ncid, i, index, count, stride, value);
#line 612
		if (canConvert) {
#line 612
		    if (allInExtRange) {
#line 612
			if (allInIntRange) {
#line 612
			    IF (err)
#line 612
				error("%s", nc_strerror(err));
#line 612
			} else {
#line 612
			    IF (err != NC_ERANGE)
#line 612
				error("Range error: status = %d", err);
#line 612
			}
#line 612
		    } else {
#line 612
			IF (err != 0 && err != NC_ERANGE)
#line 612
			    error("OK or Range error: status = %d", err);
#line 612
		    }
#line 612
		    for (j = 0; j < nels; j++) {
#line 612
			if (inRange3(expect[j],var_type[i],NCT_LONG)
#line 612
				&& expect[j] >= long_min && expect[j] <= long_max) {
#line 612
			    IF (!equal(value[j],expect[j],var_type[i], NCT_LONG)){
#line 612
				error("value read not that expected");
#line 612
				if (verbose) {
#line 612
				    error("\n");
#line 612
				    error("varid: %d, ", i);
#line 612
				    error("var_name: %s, ", var_name[i]);
#line 612
				    error("element number: %d ", j);
#line 612
                                    error("expect: %g, ", expect[j]);
#line 612
				    error("got: %g", (double) value[j]);
#line 612
				}
#line 612
			    } else {
#line 612
				nok++;
#line 612
			    }
#line 612
			}
#line 612
		    }
#line 612
		} else {
#line 612
		    IF (nels > 0 && err != NC_ECHAR)
#line 612
			error("wrong type: status = %d", err);
#line 612
		}
#line 612
	    }
#line 612
	}
#line 612

#line 612
    }
#line 612
    err = nc_close(ncid);
#line 612
    IF (err)
#line 612
        error("nc_close: %s", nc_strerror(err));
#line 612
    print_nok(nok);
#line 612
}
#line 612

void
#line 613
test_nc_get_vars_float(void)
#line 613
{
#line 613
    int ncid;
#line 613
    int d;
#line 613
    int i;
#line 613
    int j;
#line 613
    int k;
#line 613
    int m;
#line 613
    int err;
#line 613
    int allInExtRange;	/* all values within external range? */
#line 613
    int allInIntRange;	/* all values within internal range? */
#line 613
    int nels;
#line 613
    int nslabs;
#line 613
    int nstarts;        /* number of different starts */
#line 613
    int nok = 0;      /* count of valid comparisons */
#line 613
    size_t start[MAX_RANK];
#line 613
    size_t edge[MAX_RANK];
#line 613
    size_t index[MAX_RANK];
#line 613
    size_t index2[MAX_RANK];
#line 613
    size_t mid[MAX_RANK];
#line 613
    size_t count[MAX_RANK];
#line 613
    size_t sstride[MAX_RANK];
#line 613
    ptrdiff_t stride[MAX_RANK];
#line 613
    int canConvert;     /* Both text or both numeric */
#line 613
    float value[MAX_NELS];
#line 613
    double expect[MAX_NELS];
#line 613

#line 613
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 613
    IF (err)
#line 613
        error("nc_open: %s", nc_strerror(err));
#line 613
    for (i = 0; i < numVars; i++) {
#line 613
        canConvert = (var_type[i] == NC_CHAR) == (NCT_FLOAT == NCT_TEXT);
#line 613
        assert(var_rank[i] <= MAX_RANK);
#line 613
        assert(var_nels[i] <= MAX_NELS);
#line 613
        for (j = 0; j < var_rank[i]; j++) {
#line 613
            start[j] = 0;
#line 613
            edge[j] = 1;
#line 613
            stride[j] = 1;
#line 613
        }
#line 613
        err = nc_get_vars_float(BAD_ID, i, start, edge, stride, value);
#line 613
        IF (err != NC_EBADID)
#line 613
            error("bad ncid: status = %d", err);
#line 613
        err = nc_get_vars_float(ncid, BAD_VARID, start, edge, stride, value);
#line 613
        IF (err != NC_ENOTVAR)
#line 613
            error("bad var id: status = %d", err);
#line 613
        for (j = 0; j < var_rank[i]; j++) {
#line 613
            start[j] = var_shape[i][j];
#line 613
            err = nc_get_vars_float(ncid, i, start, edge, stride, value);
#line 613
	  if(!canConvert) {
#line 613
		IF (err != NC_ECHAR)
#line 613
               	    error("conversion: status = %d", err);
#line 613
	  } else {
#line 613
            IF (err != NC_EINVALCOORDS)
#line 613
                error("bad index: status = %d", err);
#line 613
            start[j] = 0;
#line 613
            edge[j] = var_shape[i][j] + 1;
#line 613
            err = nc_get_vars_float(ncid, i, start, edge, stride, value);
#line 613
            IF (err != NC_EEDGE)
#line 613
                error("bad edge: status = %d", err);
#line 613
            edge[j] = 1;
#line 613
            stride[j] = 0;
#line 613
            err = nc_get_vars_float(ncid, i, start, edge, stride, value);
#line 613
            IF (err != NC_ESTRIDE)
#line 613
                error("bad stride: status = %d", err);
#line 613
            stride[j] = 1;
#line 613
	  }
#line 613
        }
#line 613
            /* Choose a random point dividing each dim into 2 parts */
#line 613
            /* get 2^rank (nslabs) slabs so defined */
#line 613
        nslabs = 1;
#line 613
        for (j = 0; j < var_rank[i]; j++) {
#line 613
            mid[j] = roll( var_shape[i][j] );
#line 613
            nslabs *= 2;
#line 613
        }
#line 613
            /* bits of k determine whether to get lower or upper part of dim */
#line 613
            /* choose random stride from 1 to edge */
#line 613
        for (k = 0; k < nslabs; k++) {
#line 613
            nstarts = 1;
#line 613
            for (j = 0; j < var_rank[i]; j++) {
#line 613
                if ((k >> j) & 1) {
#line 613
                    start[j] = 0;
#line 613
                    edge[j] = mid[j];
#line 613
                }else{
#line 613
                    start[j] = mid[j];
#line 613
                    edge[j] = var_shape[i][j] - mid[j];
#line 613
                }
#line 613
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 613
                nstarts *= stride[j];
#line 613
            }
#line 613
            for (m = 0; m < nstarts; m++) {
#line 613
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 613
                IF (err)
#line 613
                    error("error in toMixedBase");
#line 613
                nels = 1;
#line 613
                for (j = 0; j < var_rank[i]; j++) {
#line 613
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 613
                    nels *= count[j];
#line 613
                    index[j] += start[j];
#line 613
                }
#line 613
                        /* Random choice of forward or backward */
#line 613
/* TODO
#line 613
                if ( roll(2) ) {
#line 613
                    for (j = 0; j < var_rank[i]; j++) {
#line 613
                        index[j] += (count[j] - 1) * stride[j];
#line 613
                        stride[j] = -stride[j];
#line 613
                    }
#line 613
                }
#line 613
*/
#line 613
		allInExtRange = allInIntRange = 1;
#line 613
		for (j = 0; j < nels; j++) {
#line 613
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 613
		    IF (err)
#line 613
			error("error in toMixedBase 1");
#line 613
		    for (d = 0; d < var_rank[i]; d++)
#line 613
			index2[d] = index[d] + index2[d] * stride[d];
#line 613
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 613
			NCT_FLOAT);
#line 613
		    if (inRange3(expect[j],var_type[i],NCT_FLOAT)) {
#line 613
			allInIntRange = allInIntRange && expect[j] >= float_min
#line 613
			    && expect[j] <= float_max;
#line 613
		    } else {
#line 613
			allInExtRange = 0;
#line 613
		    }
#line 613
		}
#line 613
                if (var_rank[i] == 0 && i%2 )
#line 613
                    err = nc_get_vars_float(ncid, i, NULL, NULL, NULL, value);
#line 613
                else
#line 613
                    err = nc_get_vars_float(ncid, i, index, count, stride, value);
#line 613
		if (canConvert) {
#line 613
		    if (allInExtRange) {
#line 613
			if (allInIntRange) {
#line 613
			    IF (err)
#line 613
				error("%s", nc_strerror(err));
#line 613
			} else {
#line 613
			    IF (err != NC_ERANGE)
#line 613
				error("Range error: status = %d", err);
#line 613
			}
#line 613
		    } else {
#line 613
			IF (err != 0 && err != NC_ERANGE)
#line 613
			    error("OK or Range error: status = %d", err);
#line 613
		    }
#line 613
		    for (j = 0; j < nels; j++) {
#line 613
			if (inRange3(expect[j],var_type[i],NCT_FLOAT)
#line 613
				&& expect[j] >= float_min && expect[j] <= float_max) {
#line 613
			    IF (!equal(value[j],expect[j],var_type[i], NCT_FLOAT)){
#line 613
				error("value read not that expected");
#line 613
				if (verbose) {
#line 613
				    error("\n");
#line 613
				    error("varid: %d, ", i);
#line 613
				    error("var_name: %s, ", var_name[i]);
#line 613
				    error("element number: %d ", j);
#line 613
                                    error("expect: %g, ", expect[j]);
#line 613
				    error("got: %g", (double) value[j]);
#line 613
				}
#line 613
			    } else {
#line 613
				nok++;
#line 613
			    }
#line 613
			}
#line 613
		    }
#line 613
		} else {
#line 613
		    IF (nels > 0 && err != NC_ECHAR)
#line 613
			error("wrong type: status = %d", err);
#line 613
		}
#line 613
	    }
#line 613
	}
#line 613

#line 613
    }
#line 613
    err = nc_close(ncid);
#line 613
    IF (err)
#line 613
        error("nc_close: %s", nc_strerror(err));
#line 613
    print_nok(nok);
#line 613
}
#line 613

void
#line 614
test_nc_get_vars_double(void)
#line 614
{
#line 614
    int ncid;
#line 614
    int d;
#line 614
    int i;
#line 614
    int j;
#line 614
    int k;
#line 614
    int m;
#line 614
    int err;
#line 614
    int allInExtRange;	/* all values within external range? */
#line 614
    int allInIntRange;	/* all values within internal range? */
#line 614
    int nels;
#line 614
    int nslabs;
#line 614
    int nstarts;        /* number of different starts */
#line 614
    int nok = 0;      /* count of valid comparisons */
#line 614
    size_t start[MAX_RANK];
#line 614
    size_t edge[MAX_RANK];
#line 614
    size_t index[MAX_RANK];
#line 614
    size_t index2[MAX_RANK];
#line 614
    size_t mid[MAX_RANK];
#line 614
    size_t count[MAX_RANK];
#line 614
    size_t sstride[MAX_RANK];
#line 614
    ptrdiff_t stride[MAX_RANK];
#line 614
    int canConvert;     /* Both text or both numeric */
#line 614
    double value[MAX_NELS];
#line 614
    double expect[MAX_NELS];
#line 614

#line 614
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 614
    IF (err)
#line 614
        error("nc_open: %s", nc_strerror(err));
#line 614
    for (i = 0; i < numVars; i++) {
#line 614
        canConvert = (var_type[i] == NC_CHAR) == (NCT_DOUBLE == NCT_TEXT);
#line 614
        assert(var_rank[i] <= MAX_RANK);
#line 614
        assert(var_nels[i] <= MAX_NELS);
#line 614
        for (j = 0; j < var_rank[i]; j++) {
#line 614
            start[j] = 0;
#line 614
            edge[j] = 1;
#line 614
            stride[j] = 1;
#line 614
        }
#line 614
        err = nc_get_vars_double(BAD_ID, i, start, edge, stride, value);
#line 614
        IF (err != NC_EBADID)
#line 614
            error("bad ncid: status = %d", err);
#line 614
        err = nc_get_vars_double(ncid, BAD_VARID, start, edge, stride, value);
#line 614
        IF (err != NC_ENOTVAR)
#line 614
            error("bad var id: status = %d", err);
#line 614
        for (j = 0; j < var_rank[i]; j++) {
#line 614
            start[j] = var_shape[i][j];
#line 614
            err = nc_get_vars_double(ncid, i, start, edge, stride, value);
#line 614
	  if(!canConvert) {
#line 614
		IF (err != NC_ECHAR)
#line 614
               	    error("conversion: status = %d", err);
#line 614
	  } else {
#line 614
            IF (err != NC_EINVALCOORDS)
#line 614
                error("bad index: status = %d", err);
#line 614
            start[j] = 0;
#line 614
            edge[j] = var_shape[i][j] + 1;
#line 614
            err = nc_get_vars_double(ncid, i, start, edge, stride, value);
#line 614
            IF (err != NC_EEDGE)
#line 614
                error("bad edge: status = %d", err);
#line 614
            edge[j] = 1;
#line 614
            stride[j] = 0;
#line 614
            err = nc_get_vars_double(ncid, i, start, edge, stride, value);
#line 614
            IF (err != NC_ESTRIDE)
#line 614
                error("bad stride: status = %d", err);
#line 614
            stride[j] = 1;
#line 614
	  }
#line 614
        }
#line 614
            /* Choose a random point dividing each dim into 2 parts */
#line 614
            /* get 2^rank (nslabs) slabs so defined */
#line 614
        nslabs = 1;
#line 614
        for (j = 0; j < var_rank[i]; j++) {
#line 614
            mid[j] = roll( var_shape[i][j] );
#line 614
            nslabs *= 2;
#line 614
        }
#line 614
            /* bits of k determine whether to get lower or upper part of dim */
#line 614
            /* choose random stride from 1 to edge */
#line 614
        for (k = 0; k < nslabs; k++) {
#line 614
            nstarts = 1;
#line 614
            for (j = 0; j < var_rank[i]; j++) {
#line 614
                if ((k >> j) & 1) {
#line 614
                    start[j] = 0;
#line 614
                    edge[j] = mid[j];
#line 614
                }else{
#line 614
                    start[j] = mid[j];
#line 614
                    edge[j] = var_shape[i][j] - mid[j];
#line 614
                }
#line 614
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 614
                nstarts *= stride[j];
#line 614
            }
#line 614
            for (m = 0; m < nstarts; m++) {
#line 614
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 614
                IF (err)
#line 614
                    error("error in toMixedBase");
#line 614
                nels = 1;
#line 614
                for (j = 0; j < var_rank[i]; j++) {
#line 614
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 614
                    nels *= count[j];
#line 614
                    index[j] += start[j];
#line 614
                }
#line 614
                        /* Random choice of forward or backward */
#line 614
/* TODO
#line 614
                if ( roll(2) ) {
#line 614
                    for (j = 0; j < var_rank[i]; j++) {
#line 614
                        index[j] += (count[j] - 1) * stride[j];
#line 614
                        stride[j] = -stride[j];
#line 614
                    }
#line 614
                }
#line 614
*/
#line 614
		allInExtRange = allInIntRange = 1;
#line 614
		for (j = 0; j < nels; j++) {
#line 614
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 614
		    IF (err)
#line 614
			error("error in toMixedBase 1");
#line 614
		    for (d = 0; d < var_rank[i]; d++)
#line 614
			index2[d] = index[d] + index2[d] * stride[d];
#line 614
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 614
			NCT_DOUBLE);
#line 614
		    if (inRange3(expect[j],var_type[i],NCT_DOUBLE)) {
#line 614
			allInIntRange = allInIntRange && expect[j] >= double_min
#line 614
			    && expect[j] <= double_max;
#line 614
		    } else {
#line 614
			allInExtRange = 0;
#line 614
		    }
#line 614
		}
#line 614
                if (var_rank[i] == 0 && i%2 )
#line 614
                    err = nc_get_vars_double(ncid, i, NULL, NULL, NULL, value);
#line 614
                else
#line 614
                    err = nc_get_vars_double(ncid, i, index, count, stride, value);
#line 614
		if (canConvert) {
#line 614
		    if (allInExtRange) {
#line 614
			if (allInIntRange) {
#line 614
			    IF (err)
#line 614
				error("%s", nc_strerror(err));
#line 614
			} else {
#line 614
			    IF (err != NC_ERANGE)
#line 614
				error("Range error: status = %d", err);
#line 614
			}
#line 614
		    } else {
#line 614
			IF (err != 0 && err != NC_ERANGE)
#line 614
			    error("OK or Range error: status = %d", err);
#line 614
		    }
#line 614
		    for (j = 0; j < nels; j++) {
#line 614
			if (inRange3(expect[j],var_type[i],NCT_DOUBLE)
#line 614
				&& expect[j] >= double_min && expect[j] <= double_max) {
#line 614
			    IF (!equal(value[j],expect[j],var_type[i], NCT_DOUBLE)){
#line 614
				error("value read not that expected");
#line 614
				if (verbose) {
#line 614
				    error("\n");
#line 614
				    error("varid: %d, ", i);
#line 614
				    error("var_name: %s, ", var_name[i]);
#line 614
				    error("element number: %d ", j);
#line 614
                                    error("expect: %g, ", expect[j]);
#line 614
				    error("got: %g", (double) value[j]);
#line 614
				}
#line 614
			    } else {
#line 614
				nok++;
#line 614
			    }
#line 614
			}
#line 614
		    }
#line 614
		} else {
#line 614
		    IF (nels > 0 && err != NC_ECHAR)
#line 614
			error("wrong type: status = %d", err);
#line 614
		}
#line 614
	    }
#line 614
	}
#line 614

#line 614
    }
#line 614
    err = nc_close(ncid);
#line 614
    IF (err)
#line 614
        error("nc_close: %s", nc_strerror(err));
#line 614
    print_nok(nok);
#line 614
}
#line 614

void
#line 615
test_nc_get_vars_ushort(void)
#line 615
{
#line 615
    int ncid;
#line 615
    int d;
#line 615
    int i;
#line 615
    int j;
#line 615
    int k;
#line 615
    int m;
#line 615
    int err;
#line 615
    int allInExtRange;	/* all values within external range? */
#line 615
    int allInIntRange;	/* all values within internal range? */
#line 615
    int nels;
#line 615
    int nslabs;
#line 615
    int nstarts;        /* number of different starts */
#line 615
    int nok = 0;      /* count of valid comparisons */
#line 615
    size_t start[MAX_RANK];
#line 615
    size_t edge[MAX_RANK];
#line 615
    size_t index[MAX_RANK];
#line 615
    size_t index2[MAX_RANK];
#line 615
    size_t mid[MAX_RANK];
#line 615
    size_t count[MAX_RANK];
#line 615
    size_t sstride[MAX_RANK];
#line 615
    ptrdiff_t stride[MAX_RANK];
#line 615
    int canConvert;     /* Both text or both numeric */
#line 615
    ushort value[MAX_NELS];
#line 615
    double expect[MAX_NELS];
#line 615

#line 615
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 615
    IF (err)
#line 615
        error("nc_open: %s", nc_strerror(err));
#line 615
    for (i = 0; i < numVars; i++) {
#line 615
        canConvert = (var_type[i] == NC_CHAR) == (NCT_USHORT == NCT_TEXT);
#line 615
        assert(var_rank[i] <= MAX_RANK);
#line 615
        assert(var_nels[i] <= MAX_NELS);
#line 615
        for (j = 0; j < var_rank[i]; j++) {
#line 615
            start[j] = 0;
#line 615
            edge[j] = 1;
#line 615
            stride[j] = 1;
#line 615
        }
#line 615
        err = nc_get_vars_ushort(BAD_ID, i, start, edge, stride, value);
#line 615
        IF (err != NC_EBADID)
#line 615
            error("bad ncid: status = %d", err);
#line 615
        err = nc_get_vars_ushort(ncid, BAD_VARID, start, edge, stride, value);
#line 615
        IF (err != NC_ENOTVAR)
#line 615
            error("bad var id: status = %d", err);
#line 615
        for (j = 0; j < var_rank[i]; j++) {
#line 615
            start[j] = var_shape[i][j];
#line 615
            err = nc_get_vars_ushort(ncid, i, start, edge, stride, value);
#line 615
	  if(!canConvert) {
#line 615
		IF (err != NC_ECHAR)
#line 615
               	    error("conversion: status = %d", err);
#line 615
	  } else {
#line 615
            IF (err != NC_EINVALCOORDS)
#line 615
                error("bad index: status = %d", err);
#line 615
            start[j] = 0;
#line 615
            edge[j] = var_shape[i][j] + 1;
#line 615
            err = nc_get_vars_ushort(ncid, i, start, edge, stride, value);
#line 615
            IF (err != NC_EEDGE)
#line 615
                error("bad edge: status = %d", err);
#line 615
            edge[j] = 1;
#line 615
            stride[j] = 0;
#line 615
            err = nc_get_vars_ushort(ncid, i, start, edge, stride, value);
#line 615
            IF (err != NC_ESTRIDE)
#line 615
                error("bad stride: status = %d", err);
#line 615
            stride[j] = 1;
#line 615
	  }
#line 615
        }
#line 615
            /* Choose a random point dividing each dim into 2 parts */
#line 615
            /* get 2^rank (nslabs) slabs so defined */
#line 615
        nslabs = 1;
#line 615
        for (j = 0; j < var_rank[i]; j++) {
#line 615
            mid[j] = roll( var_shape[i][j] );
#line 615
            nslabs *= 2;
#line 615
        }
#line 615
            /* bits of k determine whether to get lower or upper part of dim */
#line 615
            /* choose random stride from 1 to edge */
#line 615
        for (k = 0; k < nslabs; k++) {
#line 615
            nstarts = 1;
#line 615
            for (j = 0; j < var_rank[i]; j++) {
#line 615
                if ((k >> j) & 1) {
#line 615
                    start[j] = 0;
#line 615
                    edge[j] = mid[j];
#line 615
                }else{
#line 615
                    start[j] = mid[j];
#line 615
                    edge[j] = var_shape[i][j] - mid[j];
#line 615
                }
#line 615
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 615
                nstarts *= stride[j];
#line 615
            }
#line 615
            for (m = 0; m < nstarts; m++) {
#line 615
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 615
                IF (err)
#line 615
                    error("error in toMixedBase");
#line 615
                nels = 1;
#line 615
                for (j = 0; j < var_rank[i]; j++) {
#line 615
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 615
                    nels *= count[j];
#line 615
                    index[j] += start[j];
#line 615
                }
#line 615
                        /* Random choice of forward or backward */
#line 615
/* TODO
#line 615
                if ( roll(2) ) {
#line 615
                    for (j = 0; j < var_rank[i]; j++) {
#line 615
                        index[j] += (count[j] - 1) * stride[j];
#line 615
                        stride[j] = -stride[j];
#line 615
                    }
#line 615
                }
#line 615
*/
#line 615
		allInExtRange = allInIntRange = 1;
#line 615
		for (j = 0; j < nels; j++) {
#line 615
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 615
		    IF (err)
#line 615
			error("error in toMixedBase 1");
#line 615
		    for (d = 0; d < var_rank[i]; d++)
#line 615
			index2[d] = index[d] + index2[d] * stride[d];
#line 615
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 615
			NCT_USHORT);
#line 615
		    if (inRange3(expect[j],var_type[i],NCT_USHORT)) {
#line 615
			allInIntRange = allInIntRange && expect[j] >= ushort_min
#line 615
			    && expect[j] <= ushort_max;
#line 615
		    } else {
#line 615
			allInExtRange = 0;
#line 615
		    }
#line 615
		}
#line 615
                if (var_rank[i] == 0 && i%2 )
#line 615
                    err = nc_get_vars_ushort(ncid, i, NULL, NULL, NULL, value);
#line 615
                else
#line 615
                    err = nc_get_vars_ushort(ncid, i, index, count, stride, value);
#line 615
		if (canConvert) {
#line 615
		    if (allInExtRange) {
#line 615
			if (allInIntRange) {
#line 615
			    IF (err)
#line 615
				error("%s", nc_strerror(err));
#line 615
			} else {
#line 615
			    IF (err != NC_ERANGE)
#line 615
				error("Range error: status = %d", err);
#line 615
			}
#line 615
		    } else {
#line 615
			IF (err != 0 && err != NC_ERANGE)
#line 615
			    error("OK or Range error: status = %d", err);
#line 615
		    }
#line 615
		    for (j = 0; j < nels; j++) {
#line 615
			if (inRange3(expect[j],var_type[i],NCT_USHORT)
#line 615
				&& expect[j] >= ushort_min && expect[j] <= ushort_max) {
#line 615
			    IF (!equal(value[j],expect[j],var_type[i], NCT_USHORT)){
#line 615
				error("value read not that expected");
#line 615
				if (verbose) {
#line 615
				    error("\n");
#line 615
				    error("varid: %d, ", i);
#line 615
				    error("var_name: %s, ", var_name[i]);
#line 615
				    error("element number: %d ", j);
#line 615
                                    error("expect: %g, ", expect[j]);
#line 615
				    error("got: %g", (double) value[j]);
#line 615
				}
#line 615
			    } else {
#line 615
				nok++;
#line 615
			    }
#line 615
			}
#line 615
		    }
#line 615
		} else {
#line 615
		    IF (nels > 0 && err != NC_ECHAR)
#line 615
			error("wrong type: status = %d", err);
#line 615
		}
#line 615
	    }
#line 615
	}
#line 615

#line 615
    }
#line 615
    err = nc_close(ncid);
#line 615
    IF (err)
#line 615
        error("nc_close: %s", nc_strerror(err));
#line 615
    print_nok(nok);
#line 615
}
#line 615

void
#line 616
test_nc_get_vars_uint(void)
#line 616
{
#line 616
    int ncid;
#line 616
    int d;
#line 616
    int i;
#line 616
    int j;
#line 616
    int k;
#line 616
    int m;
#line 616
    int err;
#line 616
    int allInExtRange;	/* all values within external range? */
#line 616
    int allInIntRange;	/* all values within internal range? */
#line 616
    int nels;
#line 616
    int nslabs;
#line 616
    int nstarts;        /* number of different starts */
#line 616
    int nok = 0;      /* count of valid comparisons */
#line 616
    size_t start[MAX_RANK];
#line 616
    size_t edge[MAX_RANK];
#line 616
    size_t index[MAX_RANK];
#line 616
    size_t index2[MAX_RANK];
#line 616
    size_t mid[MAX_RANK];
#line 616
    size_t count[MAX_RANK];
#line 616
    size_t sstride[MAX_RANK];
#line 616
    ptrdiff_t stride[MAX_RANK];
#line 616
    int canConvert;     /* Both text or both numeric */
#line 616
    uint value[MAX_NELS];
#line 616
    double expect[MAX_NELS];
#line 616

#line 616
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 616
    IF (err)
#line 616
        error("nc_open: %s", nc_strerror(err));
#line 616
    for (i = 0; i < numVars; i++) {
#line 616
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UINT == NCT_TEXT);
#line 616
        assert(var_rank[i] <= MAX_RANK);
#line 616
        assert(var_nels[i] <= MAX_NELS);
#line 616
        for (j = 0; j < var_rank[i]; j++) {
#line 616
            start[j] = 0;
#line 616
            edge[j] = 1;
#line 616
            stride[j] = 1;
#line 616
        }
#line 616
        err = nc_get_vars_uint(BAD_ID, i, start, edge, stride, value);
#line 616
        IF (err != NC_EBADID)
#line 616
            error("bad ncid: status = %d", err);
#line 616
        err = nc_get_vars_uint(ncid, BAD_VARID, start, edge, stride, value);
#line 616
        IF (err != NC_ENOTVAR)
#line 616
            error("bad var id: status = %d", err);
#line 616
        for (j = 0; j < var_rank[i]; j++) {
#line 616
            start[j] = var_shape[i][j];
#line 616
            err = nc_get_vars_uint(ncid, i, start, edge, stride, value);
#line 616
	  if(!canConvert) {
#line 616
		IF (err != NC_ECHAR)
#line 616
               	    error("conversion: status = %d", err);
#line 616
	  } else {
#line 616
            IF (err != NC_EINVALCOORDS)
#line 616
                error("bad index: status = %d", err);
#line 616
            start[j] = 0;
#line 616
            edge[j] = var_shape[i][j] + 1;
#line 616
            err = nc_get_vars_uint(ncid, i, start, edge, stride, value);
#line 616
            IF (err != NC_EEDGE)
#line 616
                error("bad edge: status = %d", err);
#line 616
            edge[j] = 1;
#line 616
            stride[j] = 0;
#line 616
            err = nc_get_vars_uint(ncid, i, start, edge, stride, value);
#line 616
            IF (err != NC_ESTRIDE)
#line 616
                error("bad stride: status = %d", err);
#line 616
            stride[j] = 1;
#line 616
	  }
#line 616
        }
#line 616
            /* Choose a random point dividing each dim into 2 parts */
#line 616
            /* get 2^rank (nslabs) slabs so defined */
#line 616
        nslabs = 1;
#line 616
        for (j = 0; j < var_rank[i]; j++) {
#line 616
            mid[j] = roll( var_shape[i][j] );
#line 616
            nslabs *= 2;
#line 616
        }
#line 616
            /* bits of k determine whether to get lower or upper part of dim */
#line 616
            /* choose random stride from 1 to edge */
#line 616
        for (k = 0; k < nslabs; k++) {
#line 616
            nstarts = 1;
#line 616
            for (j = 0; j < var_rank[i]; j++) {
#line 616
                if ((k >> j) & 1) {
#line 616
                    start[j] = 0;
#line 616
                    edge[j] = mid[j];
#line 616
                }else{
#line 616
                    start[j] = mid[j];
#line 616
                    edge[j] = var_shape[i][j] - mid[j];
#line 616
                }
#line 616
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 616
                nstarts *= stride[j];
#line 616
            }
#line 616
            for (m = 0; m < nstarts; m++) {
#line 616
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 616
                IF (err)
#line 616
                    error("error in toMixedBase");
#line 616
                nels = 1;
#line 616
                for (j = 0; j < var_rank[i]; j++) {
#line 616
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 616
                    nels *= count[j];
#line 616
                    index[j] += start[j];
#line 616
                }
#line 616
                        /* Random choice of forward or backward */
#line 616
/* TODO
#line 616
                if ( roll(2) ) {
#line 616
                    for (j = 0; j < var_rank[i]; j++) {
#line 616
                        index[j] += (count[j] - 1) * stride[j];
#line 616
                        stride[j] = -stride[j];
#line 616
                    }
#line 616
                }
#line 616
*/
#line 616
		allInExtRange = allInIntRange = 1;
#line 616
		for (j = 0; j < nels; j++) {
#line 616
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 616
		    IF (err)
#line 616
			error("error in toMixedBase 1");
#line 616
		    for (d = 0; d < var_rank[i]; d++)
#line 616
			index2[d] = index[d] + index2[d] * stride[d];
#line 616
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 616
			NCT_UINT);
#line 616
		    if (inRange3(expect[j],var_type[i],NCT_UINT)) {
#line 616
			allInIntRange = allInIntRange && expect[j] >= uint_min
#line 616
			    && expect[j] <= uint_max;
#line 616
		    } else {
#line 616
			allInExtRange = 0;
#line 616
		    }
#line 616
		}
#line 616
                if (var_rank[i] == 0 && i%2 )
#line 616
                    err = nc_get_vars_uint(ncid, i, NULL, NULL, NULL, value);
#line 616
                else
#line 616
                    err = nc_get_vars_uint(ncid, i, index, count, stride, value);
#line 616
		if (canConvert) {
#line 616
		    if (allInExtRange) {
#line 616
			if (allInIntRange) {
#line 616
			    IF (err)
#line 616
				error("%s", nc_strerror(err));
#line 616
			} else {
#line 616
			    IF (err != NC_ERANGE)
#line 616
				error("Range error: status = %d", err);
#line 616
			}
#line 616
		    } else {
#line 616
			IF (err != 0 && err != NC_ERANGE)
#line 616
			    error("OK or Range error: status = %d", err);
#line 616
		    }
#line 616
		    for (j = 0; j < nels; j++) {
#line 616
			if (inRange3(expect[j],var_type[i],NCT_UINT)
#line 616
				&& expect[j] >= uint_min && expect[j] <= uint_max) {
#line 616
			    IF (!equal(value[j],expect[j],var_type[i], NCT_UINT)){
#line 616
				error("value read not that expected");
#line 616
				if (verbose) {
#line 616
				    error("\n");
#line 616
				    error("varid: %d, ", i);
#line 616
				    error("var_name: %s, ", var_name[i]);
#line 616
				    error("element number: %d ", j);
#line 616
                                    error("expect: %g, ", expect[j]);
#line 616
				    error("got: %g", (double) value[j]);
#line 616
				}
#line 616
			    } else {
#line 616
				nok++;
#line 616
			    }
#line 616
			}
#line 616
		    }
#line 616
		} else {
#line 616
		    IF (nels > 0 && err != NC_ECHAR)
#line 616
			error("wrong type: status = %d", err);
#line 616
		}
#line 616
	    }
#line 616
	}
#line 616

#line 616
    }
#line 616
    err = nc_close(ncid);
#line 616
    IF (err)
#line 616
        error("nc_close: %s", nc_strerror(err));
#line 616
    print_nok(nok);
#line 616
}
#line 616

void
#line 617
test_nc_get_vars_longlong(void)
#line 617
{
#line 617
    int ncid;
#line 617
    int d;
#line 617
    int i;
#line 617
    int j;
#line 617
    int k;
#line 617
    int m;
#line 617
    int err;
#line 617
    int allInExtRange;	/* all values within external range? */
#line 617
    int allInIntRange;	/* all values within internal range? */
#line 617
    int nels;
#line 617
    int nslabs;
#line 617
    int nstarts;        /* number of different starts */
#line 617
    int nok = 0;      /* count of valid comparisons */
#line 617
    size_t start[MAX_RANK];
#line 617
    size_t edge[MAX_RANK];
#line 617
    size_t index[MAX_RANK];
#line 617
    size_t index2[MAX_RANK];
#line 617
    size_t mid[MAX_RANK];
#line 617
    size_t count[MAX_RANK];
#line 617
    size_t sstride[MAX_RANK];
#line 617
    ptrdiff_t stride[MAX_RANK];
#line 617
    int canConvert;     /* Both text or both numeric */
#line 617
    longlong value[MAX_NELS];
#line 617
    double expect[MAX_NELS];
#line 617

#line 617
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 617
    IF (err)
#line 617
        error("nc_open: %s", nc_strerror(err));
#line 617
    for (i = 0; i < numVars; i++) {
#line 617
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONGLONG == NCT_TEXT);
#line 617
        assert(var_rank[i] <= MAX_RANK);
#line 617
        assert(var_nels[i] <= MAX_NELS);
#line 617
        for (j = 0; j < var_rank[i]; j++) {
#line 617
            start[j] = 0;
#line 617
            edge[j] = 1;
#line 617
            stride[j] = 1;
#line 617
        }
#line 617
        err = nc_get_vars_longlong(BAD_ID, i, start, edge, stride, value);
#line 617
        IF (err != NC_EBADID)
#line 617
            error("bad ncid: status = %d", err);
#line 617
        err = nc_get_vars_longlong(ncid, BAD_VARID, start, edge, stride, value);
#line 617
        IF (err != NC_ENOTVAR)
#line 617
            error("bad var id: status = %d", err);
#line 617
        for (j = 0; j < var_rank[i]; j++) {
#line 617
            start[j] = var_shape[i][j];
#line 617
            err = nc_get_vars_longlong(ncid, i, start, edge, stride, value);
#line 617
	  if(!canConvert) {
#line 617
		IF (err != NC_ECHAR)
#line 617
               	    error("conversion: status = %d", err);
#line 617
	  } else {
#line 617
            IF (err != NC_EINVALCOORDS)
#line 617
                error("bad index: status = %d", err);
#line 617
            start[j] = 0;
#line 617
            edge[j] = var_shape[i][j] + 1;
#line 617
            err = nc_get_vars_longlong(ncid, i, start, edge, stride, value);
#line 617
            IF (err != NC_EEDGE)
#line 617
                error("bad edge: status = %d", err);
#line 617
            edge[j] = 1;
#line 617
            stride[j] = 0;
#line 617
            err = nc_get_vars_longlong(ncid, i, start, edge, stride, value);
#line 617
            IF (err != NC_ESTRIDE)
#line 617
                error("bad stride: status = %d", err);
#line 617
            stride[j] = 1;
#line 617
	  }
#line 617
        }
#line 617
            /* Choose a random point dividing each dim into 2 parts */
#line 617
            /* get 2^rank (nslabs) slabs so defined */
#line 617
        nslabs = 1;
#line 617
        for (j = 0; j < var_rank[i]; j++) {
#line 617
            mid[j] = roll( var_shape[i][j] );
#line 617
            nslabs *= 2;
#line 617
        }
#line 617
            /* bits of k determine whether to get lower or upper part of dim */
#line 617
            /* choose random stride from 1 to edge */
#line 617
        for (k = 0; k < nslabs; k++) {
#line 617
            nstarts = 1;
#line 617
            for (j = 0; j < var_rank[i]; j++) {
#line 617
                if ((k >> j) & 1) {
#line 617
                    start[j] = 0;
#line 617
                    edge[j] = mid[j];
#line 617
                }else{
#line 617
                    start[j] = mid[j];
#line 617
                    edge[j] = var_shape[i][j] - mid[j];
#line 617
                }
#line 617
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 617
                nstarts *= stride[j];
#line 617
            }
#line 617
            for (m = 0; m < nstarts; m++) {
#line 617
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 617
                IF (err)
#line 617
                    error("error in toMixedBase");
#line 617
                nels = 1;
#line 617
                for (j = 0; j < var_rank[i]; j++) {
#line 617
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 617
                    nels *= count[j];
#line 617
                    index[j] += start[j];
#line 617
                }
#line 617
                        /* Random choice of forward or backward */
#line 617
/* TODO
#line 617
                if ( roll(2) ) {
#line 617
                    for (j = 0; j < var_rank[i]; j++) {
#line 617
                        index[j] += (count[j] - 1) * stride[j];
#line 617
                        stride[j] = -stride[j];
#line 617
                    }
#line 617
                }
#line 617
*/
#line 617
		allInExtRange = allInIntRange = 1;
#line 617
		for (j = 0; j < nels; j++) {
#line 617
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 617
		    IF (err)
#line 617
			error("error in toMixedBase 1");
#line 617
		    for (d = 0; d < var_rank[i]; d++)
#line 617
			index2[d] = index[d] + index2[d] * stride[d];
#line 617
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 617
			NCT_LONGLONG);
#line 617
		    if (inRange3(expect[j],var_type[i],NCT_LONGLONG)) {
#line 617
			allInIntRange = allInIntRange && expect[j] >= longlong_min
#line 617
			    && expect[j] <= longlong_max;
#line 617
		    } else {
#line 617
			allInExtRange = 0;
#line 617
		    }
#line 617
		}
#line 617
                if (var_rank[i] == 0 && i%2 )
#line 617
                    err = nc_get_vars_longlong(ncid, i, NULL, NULL, NULL, value);
#line 617
                else
#line 617
                    err = nc_get_vars_longlong(ncid, i, index, count, stride, value);
#line 617
		if (canConvert) {
#line 617
		    if (allInExtRange) {
#line 617
			if (allInIntRange) {
#line 617
			    IF (err)
#line 617
				error("%s", nc_strerror(err));
#line 617
			} else {
#line 617
			    IF (err != NC_ERANGE)
#line 617
				error("Range error: status = %d", err);
#line 617
			}
#line 617
		    } else {
#line 617
			IF (err != 0 && err != NC_ERANGE)
#line 617
			    error("OK or Range error: status = %d", err);
#line 617
		    }
#line 617
		    for (j = 0; j < nels; j++) {
#line 617
			if (inRange3(expect[j],var_type[i],NCT_LONGLONG)
#line 617
				&& expect[j] >= longlong_min && expect[j] <= longlong_max) {
#line 617
			    IF (!equal(value[j],expect[j],var_type[i], NCT_LONGLONG)){
#line 617
				error("value read not that expected");
#line 617
				if (verbose) {
#line 617
				    error("\n");
#line 617
				    error("varid: %d, ", i);
#line 617
				    error("var_name: %s, ", var_name[i]);
#line 617
				    error("element number: %d ", j);
#line 617
                                    error("expect: %g, ", expect[j]);
#line 617
				    error("got: %g", (double) value[j]);
#line 617
				}
#line 617
			    } else {
#line 617
				nok++;
#line 617
			    }
#line 617
			}
#line 617
		    }
#line 617
		} else {
#line 617
		    IF (nels > 0 && err != NC_ECHAR)
#line 617
			error("wrong type: status = %d", err);
#line 617
		}
#line 617
	    }
#line 617
	}
#line 617

#line 617
    }
#line 617
    err = nc_close(ncid);
#line 617
    IF (err)
#line 617
        error("nc_close: %s", nc_strerror(err));
#line 617
    print_nok(nok);
#line 617
}
#line 617

void
#line 618
test_nc_get_vars_ulonglong(void)
#line 618
{
#line 618
    int ncid;
#line 618
    int d;
#line 618
    int i;
#line 618
    int j;
#line 618
    int k;
#line 618
    int m;
#line 618
    int err;
#line 618
    int allInExtRange;	/* all values within external range? */
#line 618
    int allInIntRange;	/* all values within internal range? */
#line 618
    int nels;
#line 618
    int nslabs;
#line 618
    int nstarts;        /* number of different starts */
#line 618
    int nok = 0;      /* count of valid comparisons */
#line 618
    size_t start[MAX_RANK];
#line 618
    size_t edge[MAX_RANK];
#line 618
    size_t index[MAX_RANK];
#line 618
    size_t index2[MAX_RANK];
#line 618
    size_t mid[MAX_RANK];
#line 618
    size_t count[MAX_RANK];
#line 618
    size_t sstride[MAX_RANK];
#line 618
    ptrdiff_t stride[MAX_RANK];
#line 618
    int canConvert;     /* Both text or both numeric */
#line 618
    ulonglong value[MAX_NELS];
#line 618
    double expect[MAX_NELS];
#line 618

#line 618
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 618
    IF (err)
#line 618
        error("nc_open: %s", nc_strerror(err));
#line 618
    for (i = 0; i < numVars; i++) {
#line 618
        canConvert = (var_type[i] == NC_CHAR) == (NCT_ULONGLONG == NCT_TEXT);
#line 618
        assert(var_rank[i] <= MAX_RANK);
#line 618
        assert(var_nels[i] <= MAX_NELS);
#line 618
        for (j = 0; j < var_rank[i]; j++) {
#line 618
            start[j] = 0;
#line 618
            edge[j] = 1;
#line 618
            stride[j] = 1;
#line 618
        }
#line 618
        err = nc_get_vars_ulonglong(BAD_ID, i, start, edge, stride, value);
#line 618
        IF (err != NC_EBADID)
#line 618
            error("bad ncid: status = %d", err);
#line 618
        err = nc_get_vars_ulonglong(ncid, BAD_VARID, start, edge, stride, value);
#line 618
        IF (err != NC_ENOTVAR)
#line 618
            error("bad var id: status = %d", err);
#line 618
        for (j = 0; j < var_rank[i]; j++) {
#line 618
            start[j] = var_shape[i][j];
#line 618
            err = nc_get_vars_ulonglong(ncid, i, start, edge, stride, value);
#line 618
	  if(!canConvert) {
#line 618
		IF (err != NC_ECHAR)
#line 618
               	    error("conversion: status = %d", err);
#line 618
	  } else {
#line 618
            IF (err != NC_EINVALCOORDS)
#line 618
                error("bad index: status = %d", err);
#line 618
            start[j] = 0;
#line 618
            edge[j] = var_shape[i][j] + 1;
#line 618
            err = nc_get_vars_ulonglong(ncid, i, start, edge, stride, value);
#line 618
            IF (err != NC_EEDGE)
#line 618
                error("bad edge: status = %d", err);
#line 618
            edge[j] = 1;
#line 618
            stride[j] = 0;
#line 618
            err = nc_get_vars_ulonglong(ncid, i, start, edge, stride, value);
#line 618
            IF (err != NC_ESTRIDE)
#line 618
                error("bad stride: status = %d", err);
#line 618
            stride[j] = 1;
#line 618
	  }
#line 618
        }
#line 618
            /* Choose a random point dividing each dim into 2 parts */
#line 618
            /* get 2^rank (nslabs) slabs so defined */
#line 618
        nslabs = 1;
#line 618
        for (j = 0; j < var_rank[i]; j++) {
#line 618
            mid[j] = roll( var_shape[i][j] );
#line 618
            nslabs *= 2;
#line 618
        }
#line 618
            /* bits of k determine whether to get lower or upper part of dim */
#line 618
            /* choose random stride from 1 to edge */
#line 618
        for (k = 0; k < nslabs; k++) {
#line 618
            nstarts = 1;
#line 618
            for (j = 0; j < var_rank[i]; j++) {
#line 618
                if ((k >> j) & 1) {
#line 618
                    start[j] = 0;
#line 618
                    edge[j] = mid[j];
#line 618
                }else{
#line 618
                    start[j] = mid[j];
#line 618
                    edge[j] = var_shape[i][j] - mid[j];
#line 618
                }
#line 618
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 618
                nstarts *= stride[j];
#line 618
            }
#line 618
            for (m = 0; m < nstarts; m++) {
#line 618
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 618
                IF (err)
#line 618
                    error("error in toMixedBase");
#line 618
                nels = 1;
#line 618
                for (j = 0; j < var_rank[i]; j++) {
#line 618
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 618
                    nels *= count[j];
#line 618
                    index[j] += start[j];
#line 618
                }
#line 618
                        /* Random choice of forward or backward */
#line 618
/* TODO
#line 618
                if ( roll(2) ) {
#line 618
                    for (j = 0; j < var_rank[i]; j++) {
#line 618
                        index[j] += (count[j] - 1) * stride[j];
#line 618
                        stride[j] = -stride[j];
#line 618
                    }
#line 618
                }
#line 618
*/
#line 618
		allInExtRange = allInIntRange = 1;
#line 618
		for (j = 0; j < nels; j++) {
#line 618
		    err = toMixedBase(j, var_rank[i], count, index2);
#line 618
		    IF (err)
#line 618
			error("error in toMixedBase 1");
#line 618
		    for (d = 0; d < var_rank[i]; d++)
#line 618
			index2[d] = index[d] + index2[d] * stride[d];
#line 618
		    expect[j] = hash4(var_type[i], var_rank[i], index2, 
#line 618
			NCT_ULONGLONG);
#line 618
		    if (inRange3(expect[j],var_type[i],NCT_ULONGLONG)) {
#line 618
			allInIntRange = allInIntRange && expect[j] >= ulonglong_min
#line 618
			    && expect[j] <= ulonglong_max;
#line 618
		    } else {
#line 618
			allInExtRange = 0;
#line 618
		    }
#line 618
		}
#line 618
                if (var_rank[i] == 0 && i%2 )
#line 618
                    err = nc_get_vars_ulonglong(ncid, i, NULL, NULL, NULL, value);
#line 618
                else
#line 618
                    err = nc_get_vars_ulonglong(ncid, i, index, count, stride, value);
#line 618
		if (canConvert) {
#line 618
		    if (allInExtRange) {
#line 618
			if (allInIntRange) {
#line 618
			    IF (err)
#line 618
				error("%s", nc_strerror(err));
#line 618
			} else {
#line 618
			    IF (err != NC_ERANGE)
#line 618
				error("Range error: status = %d", err);
#line 618
			}
#line 618
		    } else {
#line 618
			IF (err != 0 && err != NC_ERANGE)
#line 618
			    error("OK or Range error: status = %d", err);
#line 618
		    }
#line 618
		    for (j = 0; j < nels; j++) {
#line 618
			if (inRange3(expect[j],var_type[i],NCT_ULONGLONG)
#line 618
				&& expect[j] >= ulonglong_min && expect[j] <= ulonglong_max) {
#line 618
			    IF (!equal(value[j],expect[j],var_type[i], NCT_ULONGLONG)){
#line 618
				error("value read not that expected");
#line 618
				if (verbose) {
#line 618
				    error("\n");
#line 618
				    error("varid: %d, ", i);
#line 618
				    error("var_name: %s, ", var_name[i]);
#line 618
				    error("element number: %d ", j);
#line 618
                                    error("expect: %g, ", expect[j]);
#line 618
				    error("got: %g", (double) value[j]);
#line 618
				}
#line 618
			    } else {
#line 618
				nok++;
#line 618
			    }
#line 618
			}
#line 618
		    }
#line 618
		} else {
#line 618
		    IF (nels > 0 && err != NC_ECHAR)
#line 618
			error("wrong type: status = %d", err);
#line 618
		}
#line 618
	    }
#line 618
	}
#line 618

#line 618
    }
#line 618
    err = nc_close(ncid);
#line 618
    IF (err)
#line 618
        error("nc_close: %s", nc_strerror(err));
#line 618
    print_nok(nok);
#line 618
}
#line 618



#line 807

void
#line 808
test_nc_get_varm_text(void)
#line 808
{
#line 808
    int ncid;
#line 808
    int d;
#line 808
    int i;
#line 808
    int j;
#line 808
    int k;
#line 808
    int m;
#line 808
    int err;
#line 808
    int allInExtRange;	/* all values within external range? */
#line 808
    int allInIntRange;	/* all values within internal range? */
#line 808
    int nels;
#line 808
    int nslabs;
#line 808
    int nstarts;        /* number of different starts */
#line 808
    int nok = 0;      /* count of valid comparisons */
#line 808
    size_t start[MAX_RANK];
#line 808
    size_t edge[MAX_RANK];
#line 808
    size_t index[MAX_RANK];
#line 808
    size_t index2[MAX_RANK];
#line 808
    size_t mid[MAX_RANK];
#line 808
    size_t count[MAX_RANK];
#line 808
    size_t sstride[MAX_RANK];
#line 808
    ptrdiff_t stride[MAX_RANK];
#line 808
    ptrdiff_t imap[MAX_RANK];
#line 808
    int canConvert;     /* Both text or both numeric */
#line 808
    text value[MAX_NELS];
#line 808
    double expect[MAX_NELS];
#line 808

#line 808
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 808
    IF (err)
#line 808
        error("nc_open: %s", nc_strerror(err));
#line 808
    for (i = 0; i < numVars; i++) {
#line 808
        canConvert = (var_type[i] == NC_CHAR) == (NCT_TEXT == NCT_TEXT);
#line 808
        assert(var_rank[i] <= MAX_RANK);
#line 808
        assert(var_nels[i] <= MAX_NELS);
#line 808
        for (j = 0; j < var_rank[i]; j++) {
#line 808
            start[j] = 0;
#line 808
            edge[j] = 1;
#line 808
            stride[j] = 1;
#line 808
            imap[j] = 1;
#line 808
        }
#line 808
        err = nc_get_varm_text(BAD_ID, i, start, edge, stride, imap, value);
#line 808
        IF (err != NC_EBADID)
#line 808
            error("bad ncid: status = %d", err);
#line 808
        err = nc_get_varm_text(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 808
        IF (err != NC_ENOTVAR)
#line 808
            error("bad var id: status = %d", err);
#line 808
        for (j = 0; j < var_rank[i]; j++) {
#line 808
            start[j] = var_shape[i][j];
#line 808
            err = nc_get_varm_text(ncid, i, start, edge, stride, imap, value);
#line 808
	  if(!canConvert) {
#line 808
		IF (err != NC_ECHAR)
#line 808
               	    error("conversion: status = %d", err);
#line 808
	  } else {
#line 808
	    IF (err != NC_EINVALCOORDS)
#line 808
                error("bad index: status = %d", err);
#line 808
            start[j] = 0;
#line 808
            edge[j] = var_shape[i][j] + 1;
#line 808
            err = nc_get_varm_text(ncid, i, start, edge, stride, imap, value);
#line 808
            IF (err != NC_EEDGE)
#line 808
                error("bad edge: status = %d", err);
#line 808
            edge[j] = 1;
#line 808
            stride[j] = 0;
#line 808
            err = nc_get_varm_text(ncid, i, start, edge, stride, imap, value);
#line 808
            IF (err != NC_ESTRIDE)
#line 808
                error("bad stride: status = %d", err);
#line 808
            stride[j] = 1;
#line 808
           }
#line 808
        }
#line 808
            /* Choose a random point dividing each dim into 2 parts */
#line 808
            /* get 2^rank (nslabs) slabs so defined */
#line 808
        nslabs = 1;
#line 808
        for (j = 0; j < var_rank[i]; j++) {
#line 808
            mid[j] = roll( var_shape[i][j] );
#line 808
            nslabs *= 2;
#line 808
        }
#line 808
            /* bits of k determine whether to get lower or upper part of dim */
#line 808
            /* choose random stride from 1 to edge */
#line 808
        for (k = 0; k < nslabs; k++) {
#line 808
            nstarts = 1;
#line 808
            for (j = 0; j < var_rank[i]; j++) {
#line 808
                if ((k >> j) & 1) {
#line 808
                    start[j] = 0;
#line 808
                    edge[j] = mid[j];
#line 808
                }else{
#line 808
                    start[j] = mid[j];
#line 808
                    edge[j] = var_shape[i][j] - mid[j];
#line 808
                }
#line 808
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 808
                nstarts *= stride[j];
#line 808
            }
#line 808
            for (m = 0; m < nstarts; m++) {
#line 808
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 808
                IF (err)
#line 808
                    error("error in toMixedBase");
#line 808
                nels = 1;
#line 808
                for (j = 0; j < var_rank[i]; j++) {
#line 808
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 808
                    nels *= count[j];
#line 808
                    index[j] += start[j];
#line 808
                }
#line 808
		    /* Random choice of forward or backward */
#line 808
/* TODO
#line 808
		if ( roll(2) ) {
#line 808
		    for (j = 0; j < var_rank[i]; j++) {
#line 808
			index[j] += (count[j] - 1) * stride[j];
#line 808
			stride[j] = -stride[j];
#line 808
		    }
#line 808
		}
#line 808
 */
#line 808
		if (var_rank[i] > 0) {
#line 808
		    j = var_rank[i] - 1;
#line 808
		    imap[j] = 1;
#line 808
		    for (; j > 0; j--)
#line 808
			imap[j-1] = imap[j] * count[j];
#line 808
		}
#line 808
                allInExtRange = allInIntRange = 1;
#line 808
                for (j = 0; j < nels; j++) {
#line 808
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 808
                    IF (err)
#line 808
                        error("error in toMixedBase 1");
#line 808
                    for (d = 0; d < var_rank[i]; d++)
#line 808
                        index2[d] = index[d] + index2[d] * stride[d];
#line 808
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 808
                        NCT_TEXT);
#line 808
                    if (inRange3(expect[j],var_type[i],NCT_TEXT)) {
#line 808
                        allInIntRange = allInIntRange && expect[j] >= text_min
#line 808
                            && expect[j] <= text_max;
#line 808
                    } else {
#line 808
                        allInExtRange = 0;
#line 808
                    }
#line 808
                }
#line 808
                if (var_rank[i] == 0 && i%2 )
#line 808
                    err = nc_get_varm_text(ncid,i,NULL,NULL,NULL,NULL,value);
#line 808
                else
#line 808
                    err = nc_get_varm_text(ncid,i,index,count,stride,imap,value);
#line 808
                if (canConvert) {
#line 808
                    if (allInExtRange) {
#line 808
                        if (allInIntRange) {
#line 808
                            IF (err)
#line 808
                                error("%s", nc_strerror(err));
#line 808
                        } else {
#line 808
                            IF (err != NC_ERANGE)
#line 808
                                error("Range error: status = %d", err);
#line 808
                        }
#line 808
                    } else {
#line 808
                        IF (err != 0 && err != NC_ERANGE)
#line 808
                            error("OK or Range error: status = %d", err);
#line 808
                    }
#line 808
                    for (j = 0; j < nels; j++) {
#line 808
                        if (inRange3(expect[j],var_type[i],NCT_TEXT)
#line 808
                                && expect[j] >= text_min 
#line 808
				&& expect[j] <= text_max) {
#line 808
			    IF (!equal(value[j],expect[j],var_type[i], NCT_TEXT)){
#line 808
                                error("value read not that expected");
#line 808
                                if (verbose) {
#line 808
                                    error("\n");
#line 808
                                    error("varid: %d, ", i);
#line 808
                                    error("var_name: %s, ", var_name[i]);
#line 808
                                    error("element number: %d ", j);
#line 808
                                    error("expect: %g, ", expect[j]);
#line 808
                                    error("got: %g", (double) value[j]);
#line 808
                                }
#line 808
                            } else {
#line 808
                                nok++;
#line 808
                            }
#line 808
                        }
#line 808
                    }
#line 808
                } else {
#line 808
                    IF (nels > 0 && err != NC_ECHAR)
#line 808
                        error("wrong type: status = %d", err);
#line 808
                }
#line 808
            }
#line 808
        }
#line 808
    }
#line 808
    err = nc_close(ncid);
#line 808
    IF (err)
#line 808
        error("nc_close: %s", nc_strerror(err));
#line 808
    print_nok(nok);
#line 808
}
#line 808

void
#line 809
test_nc_get_varm_uchar(void)
#line 809
{
#line 809
    int ncid;
#line 809
    int d;
#line 809
    int i;
#line 809
    int j;
#line 809
    int k;
#line 809
    int m;
#line 809
    int err;
#line 809
    int allInExtRange;	/* all values within external range? */
#line 809
    int allInIntRange;	/* all values within internal range? */
#line 809
    int nels;
#line 809
    int nslabs;
#line 809
    int nstarts;        /* number of different starts */
#line 809
    int nok = 0;      /* count of valid comparisons */
#line 809
    size_t start[MAX_RANK];
#line 809
    size_t edge[MAX_RANK];
#line 809
    size_t index[MAX_RANK];
#line 809
    size_t index2[MAX_RANK];
#line 809
    size_t mid[MAX_RANK];
#line 809
    size_t count[MAX_RANK];
#line 809
    size_t sstride[MAX_RANK];
#line 809
    ptrdiff_t stride[MAX_RANK];
#line 809
    ptrdiff_t imap[MAX_RANK];
#line 809
    int canConvert;     /* Both text or both numeric */
#line 809
    uchar value[MAX_NELS];
#line 809
    double expect[MAX_NELS];
#line 809

#line 809
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 809
    IF (err)
#line 809
        error("nc_open: %s", nc_strerror(err));
#line 809
    for (i = 0; i < numVars; i++) {
#line 809
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UCHAR == NCT_TEXT);
#line 809
        assert(var_rank[i] <= MAX_RANK);
#line 809
        assert(var_nels[i] <= MAX_NELS);
#line 809
        for (j = 0; j < var_rank[i]; j++) {
#line 809
            start[j] = 0;
#line 809
            edge[j] = 1;
#line 809
            stride[j] = 1;
#line 809
            imap[j] = 1;
#line 809
        }
#line 809
        err = nc_get_varm_uchar(BAD_ID, i, start, edge, stride, imap, value);
#line 809
        IF (err != NC_EBADID)
#line 809
            error("bad ncid: status = %d", err);
#line 809
        err = nc_get_varm_uchar(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 809
        IF (err != NC_ENOTVAR)
#line 809
            error("bad var id: status = %d", err);
#line 809
        for (j = 0; j < var_rank[i]; j++) {
#line 809
            start[j] = var_shape[i][j];
#line 809
            err = nc_get_varm_uchar(ncid, i, start, edge, stride, imap, value);
#line 809
	  if(!canConvert) {
#line 809
		IF (err != NC_ECHAR)
#line 809
               	    error("conversion: status = %d", err);
#line 809
	  } else {
#line 809
	    IF (err != NC_EINVALCOORDS)
#line 809
                error("bad index: status = %d", err);
#line 809
            start[j] = 0;
#line 809
            edge[j] = var_shape[i][j] + 1;
#line 809
            err = nc_get_varm_uchar(ncid, i, start, edge, stride, imap, value);
#line 809
            IF (err != NC_EEDGE)
#line 809
                error("bad edge: status = %d", err);
#line 809
            edge[j] = 1;
#line 809
            stride[j] = 0;
#line 809
            err = nc_get_varm_uchar(ncid, i, start, edge, stride, imap, value);
#line 809
            IF (err != NC_ESTRIDE)
#line 809
                error("bad stride: status = %d", err);
#line 809
            stride[j] = 1;
#line 809
           }
#line 809
        }
#line 809
            /* Choose a random point dividing each dim into 2 parts */
#line 809
            /* get 2^rank (nslabs) slabs so defined */
#line 809
        nslabs = 1;
#line 809
        for (j = 0; j < var_rank[i]; j++) {
#line 809
            mid[j] = roll( var_shape[i][j] );
#line 809
            nslabs *= 2;
#line 809
        }
#line 809
            /* bits of k determine whether to get lower or upper part of dim */
#line 809
            /* choose random stride from 1 to edge */
#line 809
        for (k = 0; k < nslabs; k++) {
#line 809
            nstarts = 1;
#line 809
            for (j = 0; j < var_rank[i]; j++) {
#line 809
                if ((k >> j) & 1) {
#line 809
                    start[j] = 0;
#line 809
                    edge[j] = mid[j];
#line 809
                }else{
#line 809
                    start[j] = mid[j];
#line 809
                    edge[j] = var_shape[i][j] - mid[j];
#line 809
                }
#line 809
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 809
                nstarts *= stride[j];
#line 809
            }
#line 809
            for (m = 0; m < nstarts; m++) {
#line 809
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 809
                IF (err)
#line 809
                    error("error in toMixedBase");
#line 809
                nels = 1;
#line 809
                for (j = 0; j < var_rank[i]; j++) {
#line 809
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 809
                    nels *= count[j];
#line 809
                    index[j] += start[j];
#line 809
                }
#line 809
		    /* Random choice of forward or backward */
#line 809
/* TODO
#line 809
		if ( roll(2) ) {
#line 809
		    for (j = 0; j < var_rank[i]; j++) {
#line 809
			index[j] += (count[j] - 1) * stride[j];
#line 809
			stride[j] = -stride[j];
#line 809
		    }
#line 809
		}
#line 809
 */
#line 809
		if (var_rank[i] > 0) {
#line 809
		    j = var_rank[i] - 1;
#line 809
		    imap[j] = 1;
#line 809
		    for (; j > 0; j--)
#line 809
			imap[j-1] = imap[j] * count[j];
#line 809
		}
#line 809
                allInExtRange = allInIntRange = 1;
#line 809
                for (j = 0; j < nels; j++) {
#line 809
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 809
                    IF (err)
#line 809
                        error("error in toMixedBase 1");
#line 809
                    for (d = 0; d < var_rank[i]; d++)
#line 809
                        index2[d] = index[d] + index2[d] * stride[d];
#line 809
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 809
                        NCT_UCHAR);
#line 809
                    if (inRange3(expect[j],var_type[i],NCT_UCHAR)) {
#line 809
                        allInIntRange = allInIntRange && expect[j] >= uchar_min
#line 809
                            && expect[j] <= uchar_max;
#line 809
                    } else {
#line 809
                        allInExtRange = 0;
#line 809
                    }
#line 809
                }
#line 809
                if (var_rank[i] == 0 && i%2 )
#line 809
                    err = nc_get_varm_uchar(ncid,i,NULL,NULL,NULL,NULL,value);
#line 809
                else
#line 809
                    err = nc_get_varm_uchar(ncid,i,index,count,stride,imap,value);
#line 809
                if (canConvert) {
#line 809
                    if (allInExtRange) {
#line 809
                        if (allInIntRange) {
#line 809
                            IF (err)
#line 809
                                error("%s", nc_strerror(err));
#line 809
                        } else {
#line 809
                            IF (err != NC_ERANGE)
#line 809
                                error("Range error: status = %d", err);
#line 809
                        }
#line 809
                    } else {
#line 809
                        IF (err != 0 && err != NC_ERANGE)
#line 809
                            error("OK or Range error: status = %d", err);
#line 809
                    }
#line 809
                    for (j = 0; j < nels; j++) {
#line 809
                        if (inRange3(expect[j],var_type[i],NCT_UCHAR)
#line 809
                                && expect[j] >= uchar_min 
#line 809
				&& expect[j] <= uchar_max) {
#line 809
			    IF (!equal(value[j],expect[j],var_type[i], NCT_UCHAR)){
#line 809
                                error("value read not that expected");
#line 809
                                if (verbose) {
#line 809
                                    error("\n");
#line 809
                                    error("varid: %d, ", i);
#line 809
                                    error("var_name: %s, ", var_name[i]);
#line 809
                                    error("element number: %d ", j);
#line 809
                                    error("expect: %g, ", expect[j]);
#line 809
                                    error("got: %g", (double) value[j]);
#line 809
                                }
#line 809
                            } else {
#line 809
                                nok++;
#line 809
                            }
#line 809
                        }
#line 809
                    }
#line 809
                } else {
#line 809
                    IF (nels > 0 && err != NC_ECHAR)
#line 809
                        error("wrong type: status = %d", err);
#line 809
                }
#line 809
            }
#line 809
        }
#line 809
    }
#line 809
    err = nc_close(ncid);
#line 809
    IF (err)
#line 809
        error("nc_close: %s", nc_strerror(err));
#line 809
    print_nok(nok);
#line 809
}
#line 809

void
#line 810
test_nc_get_varm_schar(void)
#line 810
{
#line 810
    int ncid;
#line 810
    int d;
#line 810
    int i;
#line 810
    int j;
#line 810
    int k;
#line 810
    int m;
#line 810
    int err;
#line 810
    int allInExtRange;	/* all values within external range? */
#line 810
    int allInIntRange;	/* all values within internal range? */
#line 810
    int nels;
#line 810
    int nslabs;
#line 810
    int nstarts;        /* number of different starts */
#line 810
    int nok = 0;      /* count of valid comparisons */
#line 810
    size_t start[MAX_RANK];
#line 810
    size_t edge[MAX_RANK];
#line 810
    size_t index[MAX_RANK];
#line 810
    size_t index2[MAX_RANK];
#line 810
    size_t mid[MAX_RANK];
#line 810
    size_t count[MAX_RANK];
#line 810
    size_t sstride[MAX_RANK];
#line 810
    ptrdiff_t stride[MAX_RANK];
#line 810
    ptrdiff_t imap[MAX_RANK];
#line 810
    int canConvert;     /* Both text or both numeric */
#line 810
    schar value[MAX_NELS];
#line 810
    double expect[MAX_NELS];
#line 810

#line 810
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 810
    IF (err)
#line 810
        error("nc_open: %s", nc_strerror(err));
#line 810
    for (i = 0; i < numVars; i++) {
#line 810
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SCHAR == NCT_TEXT);
#line 810
        assert(var_rank[i] <= MAX_RANK);
#line 810
        assert(var_nels[i] <= MAX_NELS);
#line 810
        for (j = 0; j < var_rank[i]; j++) {
#line 810
            start[j] = 0;
#line 810
            edge[j] = 1;
#line 810
            stride[j] = 1;
#line 810
            imap[j] = 1;
#line 810
        }
#line 810
        err = nc_get_varm_schar(BAD_ID, i, start, edge, stride, imap, value);
#line 810
        IF (err != NC_EBADID)
#line 810
            error("bad ncid: status = %d", err);
#line 810
        err = nc_get_varm_schar(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 810
        IF (err != NC_ENOTVAR)
#line 810
            error("bad var id: status = %d", err);
#line 810
        for (j = 0; j < var_rank[i]; j++) {
#line 810
            start[j] = var_shape[i][j];
#line 810
            err = nc_get_varm_schar(ncid, i, start, edge, stride, imap, value);
#line 810
	  if(!canConvert) {
#line 810
		IF (err != NC_ECHAR)
#line 810
               	    error("conversion: status = %d", err);
#line 810
	  } else {
#line 810
	    IF (err != NC_EINVALCOORDS)
#line 810
                error("bad index: status = %d", err);
#line 810
            start[j] = 0;
#line 810
            edge[j] = var_shape[i][j] + 1;
#line 810
            err = nc_get_varm_schar(ncid, i, start, edge, stride, imap, value);
#line 810
            IF (err != NC_EEDGE)
#line 810
                error("bad edge: status = %d", err);
#line 810
            edge[j] = 1;
#line 810
            stride[j] = 0;
#line 810
            err = nc_get_varm_schar(ncid, i, start, edge, stride, imap, value);
#line 810
            IF (err != NC_ESTRIDE)
#line 810
                error("bad stride: status = %d", err);
#line 810
            stride[j] = 1;
#line 810
           }
#line 810
        }
#line 810
            /* Choose a random point dividing each dim into 2 parts */
#line 810
            /* get 2^rank (nslabs) slabs so defined */
#line 810
        nslabs = 1;
#line 810
        for (j = 0; j < var_rank[i]; j++) {
#line 810
            mid[j] = roll( var_shape[i][j] );
#line 810
            nslabs *= 2;
#line 810
        }
#line 810
            /* bits of k determine whether to get lower or upper part of dim */
#line 810
            /* choose random stride from 1 to edge */
#line 810
        for (k = 0; k < nslabs; k++) {
#line 810
            nstarts = 1;
#line 810
            for (j = 0; j < var_rank[i]; j++) {
#line 810
                if ((k >> j) & 1) {
#line 810
                    start[j] = 0;
#line 810
                    edge[j] = mid[j];
#line 810
                }else{
#line 810
                    start[j] = mid[j];
#line 810
                    edge[j] = var_shape[i][j] - mid[j];
#line 810
                }
#line 810
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 810
                nstarts *= stride[j];
#line 810
            }
#line 810
            for (m = 0; m < nstarts; m++) {
#line 810
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 810
                IF (err)
#line 810
                    error("error in toMixedBase");
#line 810
                nels = 1;
#line 810
                for (j = 0; j < var_rank[i]; j++) {
#line 810
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 810
                    nels *= count[j];
#line 810
                    index[j] += start[j];
#line 810
                }
#line 810
		    /* Random choice of forward or backward */
#line 810
/* TODO
#line 810
		if ( roll(2) ) {
#line 810
		    for (j = 0; j < var_rank[i]; j++) {
#line 810
			index[j] += (count[j] - 1) * stride[j];
#line 810
			stride[j] = -stride[j];
#line 810
		    }
#line 810
		}
#line 810
 */
#line 810
		if (var_rank[i] > 0) {
#line 810
		    j = var_rank[i] - 1;
#line 810
		    imap[j] = 1;
#line 810
		    for (; j > 0; j--)
#line 810
			imap[j-1] = imap[j] * count[j];
#line 810
		}
#line 810
                allInExtRange = allInIntRange = 1;
#line 810
                for (j = 0; j < nels; j++) {
#line 810
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 810
                    IF (err)
#line 810
                        error("error in toMixedBase 1");
#line 810
                    for (d = 0; d < var_rank[i]; d++)
#line 810
                        index2[d] = index[d] + index2[d] * stride[d];
#line 810
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 810
                        NCT_SCHAR);
#line 810
                    if (inRange3(expect[j],var_type[i],NCT_SCHAR)) {
#line 810
                        allInIntRange = allInIntRange && expect[j] >= schar_min
#line 810
                            && expect[j] <= schar_max;
#line 810
                    } else {
#line 810
                        allInExtRange = 0;
#line 810
                    }
#line 810
                }
#line 810
                if (var_rank[i] == 0 && i%2 )
#line 810
                    err = nc_get_varm_schar(ncid,i,NULL,NULL,NULL,NULL,value);
#line 810
                else
#line 810
                    err = nc_get_varm_schar(ncid,i,index,count,stride,imap,value);
#line 810
                if (canConvert) {
#line 810
                    if (allInExtRange) {
#line 810
                        if (allInIntRange) {
#line 810
                            IF (err)
#line 810
                                error("%s", nc_strerror(err));
#line 810
                        } else {
#line 810
                            IF (err != NC_ERANGE)
#line 810
                                error("Range error: status = %d", err);
#line 810
                        }
#line 810
                    } else {
#line 810
                        IF (err != 0 && err != NC_ERANGE)
#line 810
                            error("OK or Range error: status = %d", err);
#line 810
                    }
#line 810
                    for (j = 0; j < nels; j++) {
#line 810
                        if (inRange3(expect[j],var_type[i],NCT_SCHAR)
#line 810
                                && expect[j] >= schar_min 
#line 810
				&& expect[j] <= schar_max) {
#line 810
			    IF (!equal(value[j],expect[j],var_type[i], NCT_SCHAR)){
#line 810
                                error("value read not that expected");
#line 810
                                if (verbose) {
#line 810
                                    error("\n");
#line 810
                                    error("varid: %d, ", i);
#line 810
                                    error("var_name: %s, ", var_name[i]);
#line 810
                                    error("element number: %d ", j);
#line 810
                                    error("expect: %g, ", expect[j]);
#line 810
                                    error("got: %g", (double) value[j]);
#line 810
                                }
#line 810
                            } else {
#line 810
                                nok++;
#line 810
                            }
#line 810
                        }
#line 810
                    }
#line 810
                } else {
#line 810
                    IF (nels > 0 && err != NC_ECHAR)
#line 810
                        error("wrong type: status = %d", err);
#line 810
                }
#line 810
            }
#line 810
        }
#line 810
    }
#line 810
    err = nc_close(ncid);
#line 810
    IF (err)
#line 810
        error("nc_close: %s", nc_strerror(err));
#line 810
    print_nok(nok);
#line 810
}
#line 810

void
#line 811
test_nc_get_varm_short(void)
#line 811
{
#line 811
    int ncid;
#line 811
    int d;
#line 811
    int i;
#line 811
    int j;
#line 811
    int k;
#line 811
    int m;
#line 811
    int err;
#line 811
    int allInExtRange;	/* all values within external range? */
#line 811
    int allInIntRange;	/* all values within internal range? */
#line 811
    int nels;
#line 811
    int nslabs;
#line 811
    int nstarts;        /* number of different starts */
#line 811
    int nok = 0;      /* count of valid comparisons */
#line 811
    size_t start[MAX_RANK];
#line 811
    size_t edge[MAX_RANK];
#line 811
    size_t index[MAX_RANK];
#line 811
    size_t index2[MAX_RANK];
#line 811
    size_t mid[MAX_RANK];
#line 811
    size_t count[MAX_RANK];
#line 811
    size_t sstride[MAX_RANK];
#line 811
    ptrdiff_t stride[MAX_RANK];
#line 811
    ptrdiff_t imap[MAX_RANK];
#line 811
    int canConvert;     /* Both text or both numeric */
#line 811
    short value[MAX_NELS];
#line 811
    double expect[MAX_NELS];
#line 811

#line 811
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 811
    IF (err)
#line 811
        error("nc_open: %s", nc_strerror(err));
#line 811
    for (i = 0; i < numVars; i++) {
#line 811
        canConvert = (var_type[i] == NC_CHAR) == (NCT_SHORT == NCT_TEXT);
#line 811
        assert(var_rank[i] <= MAX_RANK);
#line 811
        assert(var_nels[i] <= MAX_NELS);
#line 811
        for (j = 0; j < var_rank[i]; j++) {
#line 811
            start[j] = 0;
#line 811
            edge[j] = 1;
#line 811
            stride[j] = 1;
#line 811
            imap[j] = 1;
#line 811
        }
#line 811
        err = nc_get_varm_short(BAD_ID, i, start, edge, stride, imap, value);
#line 811
        IF (err != NC_EBADID)
#line 811
            error("bad ncid: status = %d", err);
#line 811
        err = nc_get_varm_short(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 811
        IF (err != NC_ENOTVAR)
#line 811
            error("bad var id: status = %d", err);
#line 811
        for (j = 0; j < var_rank[i]; j++) {
#line 811
            start[j] = var_shape[i][j];
#line 811
            err = nc_get_varm_short(ncid, i, start, edge, stride, imap, value);
#line 811
	  if(!canConvert) {
#line 811
		IF (err != NC_ECHAR)
#line 811
               	    error("conversion: status = %d", err);
#line 811
	  } else {
#line 811
	    IF (err != NC_EINVALCOORDS)
#line 811
                error("bad index: status = %d", err);
#line 811
            start[j] = 0;
#line 811
            edge[j] = var_shape[i][j] + 1;
#line 811
            err = nc_get_varm_short(ncid, i, start, edge, stride, imap, value);
#line 811
            IF (err != NC_EEDGE)
#line 811
                error("bad edge: status = %d", err);
#line 811
            edge[j] = 1;
#line 811
            stride[j] = 0;
#line 811
            err = nc_get_varm_short(ncid, i, start, edge, stride, imap, value);
#line 811
            IF (err != NC_ESTRIDE)
#line 811
                error("bad stride: status = %d", err);
#line 811
            stride[j] = 1;
#line 811
           }
#line 811
        }
#line 811
            /* Choose a random point dividing each dim into 2 parts */
#line 811
            /* get 2^rank (nslabs) slabs so defined */
#line 811
        nslabs = 1;
#line 811
        for (j = 0; j < var_rank[i]; j++) {
#line 811
            mid[j] = roll( var_shape[i][j] );
#line 811
            nslabs *= 2;
#line 811
        }
#line 811
            /* bits of k determine whether to get lower or upper part of dim */
#line 811
            /* choose random stride from 1 to edge */
#line 811
        for (k = 0; k < nslabs; k++) {
#line 811
            nstarts = 1;
#line 811
            for (j = 0; j < var_rank[i]; j++) {
#line 811
                if ((k >> j) & 1) {
#line 811
                    start[j] = 0;
#line 811
                    edge[j] = mid[j];
#line 811
                }else{
#line 811
                    start[j] = mid[j];
#line 811
                    edge[j] = var_shape[i][j] - mid[j];
#line 811
                }
#line 811
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 811
                nstarts *= stride[j];
#line 811
            }
#line 811
            for (m = 0; m < nstarts; m++) {
#line 811
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 811
                IF (err)
#line 811
                    error("error in toMixedBase");
#line 811
                nels = 1;
#line 811
                for (j = 0; j < var_rank[i]; j++) {
#line 811
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 811
                    nels *= count[j];
#line 811
                    index[j] += start[j];
#line 811
                }
#line 811
		    /* Random choice of forward or backward */
#line 811
/* TODO
#line 811
		if ( roll(2) ) {
#line 811
		    for (j = 0; j < var_rank[i]; j++) {
#line 811
			index[j] += (count[j] - 1) * stride[j];
#line 811
			stride[j] = -stride[j];
#line 811
		    }
#line 811
		}
#line 811
 */
#line 811
		if (var_rank[i] > 0) {
#line 811
		    j = var_rank[i] - 1;
#line 811
		    imap[j] = 1;
#line 811
		    for (; j > 0; j--)
#line 811
			imap[j-1] = imap[j] * count[j];
#line 811
		}
#line 811
                allInExtRange = allInIntRange = 1;
#line 811
                for (j = 0; j < nels; j++) {
#line 811
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 811
                    IF (err)
#line 811
                        error("error in toMixedBase 1");
#line 811
                    for (d = 0; d < var_rank[i]; d++)
#line 811
                        index2[d] = index[d] + index2[d] * stride[d];
#line 811
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 811
                        NCT_SHORT);
#line 811
                    if (inRange3(expect[j],var_type[i],NCT_SHORT)) {
#line 811
                        allInIntRange = allInIntRange && expect[j] >= short_min
#line 811
                            && expect[j] <= short_max;
#line 811
                    } else {
#line 811
                        allInExtRange = 0;
#line 811
                    }
#line 811
                }
#line 811
                if (var_rank[i] == 0 && i%2 )
#line 811
                    err = nc_get_varm_short(ncid,i,NULL,NULL,NULL,NULL,value);
#line 811
                else
#line 811
                    err = nc_get_varm_short(ncid,i,index,count,stride,imap,value);
#line 811
                if (canConvert) {
#line 811
                    if (allInExtRange) {
#line 811
                        if (allInIntRange) {
#line 811
                            IF (err)
#line 811
                                error("%s", nc_strerror(err));
#line 811
                        } else {
#line 811
                            IF (err != NC_ERANGE)
#line 811
                                error("Range error: status = %d", err);
#line 811
                        }
#line 811
                    } else {
#line 811
                        IF (err != 0 && err != NC_ERANGE)
#line 811
                            error("OK or Range error: status = %d", err);
#line 811
                    }
#line 811
                    for (j = 0; j < nels; j++) {
#line 811
                        if (inRange3(expect[j],var_type[i],NCT_SHORT)
#line 811
                                && expect[j] >= short_min 
#line 811
				&& expect[j] <= short_max) {
#line 811
			    IF (!equal(value[j],expect[j],var_type[i], NCT_SHORT)){
#line 811
                                error("value read not that expected");
#line 811
                                if (verbose) {
#line 811
                                    error("\n");
#line 811
                                    error("varid: %d, ", i);
#line 811
                                    error("var_name: %s, ", var_name[i]);
#line 811
                                    error("element number: %d ", j);
#line 811
                                    error("expect: %g, ", expect[j]);
#line 811
                                    error("got: %g", (double) value[j]);
#line 811
                                }
#line 811
                            } else {
#line 811
                                nok++;
#line 811
                            }
#line 811
                        }
#line 811
                    }
#line 811
                } else {
#line 811
                    IF (nels > 0 && err != NC_ECHAR)
#line 811
                        error("wrong type: status = %d", err);
#line 811
                }
#line 811
            }
#line 811
        }
#line 811
    }
#line 811
    err = nc_close(ncid);
#line 811
    IF (err)
#line 811
        error("nc_close: %s", nc_strerror(err));
#line 811
    print_nok(nok);
#line 811
}
#line 811

void
#line 812
test_nc_get_varm_int(void)
#line 812
{
#line 812
    int ncid;
#line 812
    int d;
#line 812
    int i;
#line 812
    int j;
#line 812
    int k;
#line 812
    int m;
#line 812
    int err;
#line 812
    int allInExtRange;	/* all values within external range? */
#line 812
    int allInIntRange;	/* all values within internal range? */
#line 812
    int nels;
#line 812
    int nslabs;
#line 812
    int nstarts;        /* number of different starts */
#line 812
    int nok = 0;      /* count of valid comparisons */
#line 812
    size_t start[MAX_RANK];
#line 812
    size_t edge[MAX_RANK];
#line 812
    size_t index[MAX_RANK];
#line 812
    size_t index2[MAX_RANK];
#line 812
    size_t mid[MAX_RANK];
#line 812
    size_t count[MAX_RANK];
#line 812
    size_t sstride[MAX_RANK];
#line 812
    ptrdiff_t stride[MAX_RANK];
#line 812
    ptrdiff_t imap[MAX_RANK];
#line 812
    int canConvert;     /* Both text or both numeric */
#line 812
    int value[MAX_NELS];
#line 812
    double expect[MAX_NELS];
#line 812

#line 812
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 812
    IF (err)
#line 812
        error("nc_open: %s", nc_strerror(err));
#line 812
    for (i = 0; i < numVars; i++) {
#line 812
        canConvert = (var_type[i] == NC_CHAR) == (NCT_INT == NCT_TEXT);
#line 812
        assert(var_rank[i] <= MAX_RANK);
#line 812
        assert(var_nels[i] <= MAX_NELS);
#line 812
        for (j = 0; j < var_rank[i]; j++) {
#line 812
            start[j] = 0;
#line 812
            edge[j] = 1;
#line 812
            stride[j] = 1;
#line 812
            imap[j] = 1;
#line 812
        }
#line 812
        err = nc_get_varm_int(BAD_ID, i, start, edge, stride, imap, value);
#line 812
        IF (err != NC_EBADID)
#line 812
            error("bad ncid: status = %d", err);
#line 812
        err = nc_get_varm_int(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 812
        IF (err != NC_ENOTVAR)
#line 812
            error("bad var id: status = %d", err);
#line 812
        for (j = 0; j < var_rank[i]; j++) {
#line 812
            start[j] = var_shape[i][j];
#line 812
            err = nc_get_varm_int(ncid, i, start, edge, stride, imap, value);
#line 812
	  if(!canConvert) {
#line 812
		IF (err != NC_ECHAR)
#line 812
               	    error("conversion: status = %d", err);
#line 812
	  } else {
#line 812
	    IF (err != NC_EINVALCOORDS)
#line 812
                error("bad index: status = %d", err);
#line 812
            start[j] = 0;
#line 812
            edge[j] = var_shape[i][j] + 1;
#line 812
            err = nc_get_varm_int(ncid, i, start, edge, stride, imap, value);
#line 812
            IF (err != NC_EEDGE)
#line 812
                error("bad edge: status = %d", err);
#line 812
            edge[j] = 1;
#line 812
            stride[j] = 0;
#line 812
            err = nc_get_varm_int(ncid, i, start, edge, stride, imap, value);
#line 812
            IF (err != NC_ESTRIDE)
#line 812
                error("bad stride: status = %d", err);
#line 812
            stride[j] = 1;
#line 812
           }
#line 812
        }
#line 812
            /* Choose a random point dividing each dim into 2 parts */
#line 812
            /* get 2^rank (nslabs) slabs so defined */
#line 812
        nslabs = 1;
#line 812
        for (j = 0; j < var_rank[i]; j++) {
#line 812
            mid[j] = roll( var_shape[i][j] );
#line 812
            nslabs *= 2;
#line 812
        }
#line 812
            /* bits of k determine whether to get lower or upper part of dim */
#line 812
            /* choose random stride from 1 to edge */
#line 812
        for (k = 0; k < nslabs; k++) {
#line 812
            nstarts = 1;
#line 812
            for (j = 0; j < var_rank[i]; j++) {
#line 812
                if ((k >> j) & 1) {
#line 812
                    start[j] = 0;
#line 812
                    edge[j] = mid[j];
#line 812
                }else{
#line 812
                    start[j] = mid[j];
#line 812
                    edge[j] = var_shape[i][j] - mid[j];
#line 812
                }
#line 812
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 812
                nstarts *= stride[j];
#line 812
            }
#line 812
            for (m = 0; m < nstarts; m++) {
#line 812
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 812
                IF (err)
#line 812
                    error("error in toMixedBase");
#line 812
                nels = 1;
#line 812
                for (j = 0; j < var_rank[i]; j++) {
#line 812
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 812
                    nels *= count[j];
#line 812
                    index[j] += start[j];
#line 812
                }
#line 812
		    /* Random choice of forward or backward */
#line 812
/* TODO
#line 812
		if ( roll(2) ) {
#line 812
		    for (j = 0; j < var_rank[i]; j++) {
#line 812
			index[j] += (count[j] - 1) * stride[j];
#line 812
			stride[j] = -stride[j];
#line 812
		    }
#line 812
		}
#line 812
 */
#line 812
		if (var_rank[i] > 0) {
#line 812
		    j = var_rank[i] - 1;
#line 812
		    imap[j] = 1;
#line 812
		    for (; j > 0; j--)
#line 812
			imap[j-1] = imap[j] * count[j];
#line 812
		}
#line 812
                allInExtRange = allInIntRange = 1;
#line 812
                for (j = 0; j < nels; j++) {
#line 812
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 812
                    IF (err)
#line 812
                        error("error in toMixedBase 1");
#line 812
                    for (d = 0; d < var_rank[i]; d++)
#line 812
                        index2[d] = index[d] + index2[d] * stride[d];
#line 812
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 812
                        NCT_INT);
#line 812
                    if (inRange3(expect[j],var_type[i],NCT_INT)) {
#line 812
                        allInIntRange = allInIntRange && expect[j] >= int_min
#line 812
                            && expect[j] <= int_max;
#line 812
                    } else {
#line 812
                        allInExtRange = 0;
#line 812
                    }
#line 812
                }
#line 812
                if (var_rank[i] == 0 && i%2 )
#line 812
                    err = nc_get_varm_int(ncid,i,NULL,NULL,NULL,NULL,value);
#line 812
                else
#line 812
                    err = nc_get_varm_int(ncid,i,index,count,stride,imap,value);
#line 812
                if (canConvert) {
#line 812
                    if (allInExtRange) {
#line 812
                        if (allInIntRange) {
#line 812
                            IF (err)
#line 812
                                error("%s", nc_strerror(err));
#line 812
                        } else {
#line 812
                            IF (err != NC_ERANGE)
#line 812
                                error("Range error: status = %d", err);
#line 812
                        }
#line 812
                    } else {
#line 812
                        IF (err != 0 && err != NC_ERANGE)
#line 812
                            error("OK or Range error: status = %d", err);
#line 812
                    }
#line 812
                    for (j = 0; j < nels; j++) {
#line 812
                        if (inRange3(expect[j],var_type[i],NCT_INT)
#line 812
                                && expect[j] >= int_min 
#line 812
				&& expect[j] <= int_max) {
#line 812
			    IF (!equal(value[j],expect[j],var_type[i], NCT_INT)){
#line 812
                                error("value read not that expected");
#line 812
                                if (verbose) {
#line 812
                                    error("\n");
#line 812
                                    error("varid: %d, ", i);
#line 812
                                    error("var_name: %s, ", var_name[i]);
#line 812
                                    error("element number: %d ", j);
#line 812
                                    error("expect: %g, ", expect[j]);
#line 812
                                    error("got: %g", (double) value[j]);
#line 812
                                }
#line 812
                            } else {
#line 812
                                nok++;
#line 812
                            }
#line 812
                        }
#line 812
                    }
#line 812
                } else {
#line 812
                    IF (nels > 0 && err != NC_ECHAR)
#line 812
                        error("wrong type: status = %d", err);
#line 812
                }
#line 812
            }
#line 812
        }
#line 812
    }
#line 812
    err = nc_close(ncid);
#line 812
    IF (err)
#line 812
        error("nc_close: %s", nc_strerror(err));
#line 812
    print_nok(nok);
#line 812
}
#line 812

void
#line 813
test_nc_get_varm_long(void)
#line 813
{
#line 813
    int ncid;
#line 813
    int d;
#line 813
    int i;
#line 813
    int j;
#line 813
    int k;
#line 813
    int m;
#line 813
    int err;
#line 813
    int allInExtRange;	/* all values within external range? */
#line 813
    int allInIntRange;	/* all values within internal range? */
#line 813
    int nels;
#line 813
    int nslabs;
#line 813
    int nstarts;        /* number of different starts */
#line 813
    int nok = 0;      /* count of valid comparisons */
#line 813
    size_t start[MAX_RANK];
#line 813
    size_t edge[MAX_RANK];
#line 813
    size_t index[MAX_RANK];
#line 813
    size_t index2[MAX_RANK];
#line 813
    size_t mid[MAX_RANK];
#line 813
    size_t count[MAX_RANK];
#line 813
    size_t sstride[MAX_RANK];
#line 813
    ptrdiff_t stride[MAX_RANK];
#line 813
    ptrdiff_t imap[MAX_RANK];
#line 813
    int canConvert;     /* Both text or both numeric */
#line 813
    long value[MAX_NELS];
#line 813
    double expect[MAX_NELS];
#line 813

#line 813
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 813
    IF (err)
#line 813
        error("nc_open: %s", nc_strerror(err));
#line 813
    for (i = 0; i < numVars; i++) {
#line 813
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONG == NCT_TEXT);
#line 813
        assert(var_rank[i] <= MAX_RANK);
#line 813
        assert(var_nels[i] <= MAX_NELS);
#line 813
        for (j = 0; j < var_rank[i]; j++) {
#line 813
            start[j] = 0;
#line 813
            edge[j] = 1;
#line 813
            stride[j] = 1;
#line 813
            imap[j] = 1;
#line 813
        }
#line 813
        err = nc_get_varm_long(BAD_ID, i, start, edge, stride, imap, value);
#line 813
        IF (err != NC_EBADID)
#line 813
            error("bad ncid: status = %d", err);
#line 813
        err = nc_get_varm_long(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 813
        IF (err != NC_ENOTVAR)
#line 813
            error("bad var id: status = %d", err);
#line 813
        for (j = 0; j < var_rank[i]; j++) {
#line 813
            start[j] = var_shape[i][j];
#line 813
            err = nc_get_varm_long(ncid, i, start, edge, stride, imap, value);
#line 813
	  if(!canConvert) {
#line 813
		IF (err != NC_ECHAR)
#line 813
               	    error("conversion: status = %d", err);
#line 813
	  } else {
#line 813
	    IF (err != NC_EINVALCOORDS)
#line 813
                error("bad index: status = %d", err);
#line 813
            start[j] = 0;
#line 813
            edge[j] = var_shape[i][j] + 1;
#line 813
            err = nc_get_varm_long(ncid, i, start, edge, stride, imap, value);
#line 813
            IF (err != NC_EEDGE)
#line 813
                error("bad edge: status = %d", err);
#line 813
            edge[j] = 1;
#line 813
            stride[j] = 0;
#line 813
            err = nc_get_varm_long(ncid, i, start, edge, stride, imap, value);
#line 813
            IF (err != NC_ESTRIDE)
#line 813
                error("bad stride: status = %d", err);
#line 813
            stride[j] = 1;
#line 813
           }
#line 813
        }
#line 813
            /* Choose a random point dividing each dim into 2 parts */
#line 813
            /* get 2^rank (nslabs) slabs so defined */
#line 813
        nslabs = 1;
#line 813
        for (j = 0; j < var_rank[i]; j++) {
#line 813
            mid[j] = roll( var_shape[i][j] );
#line 813
            nslabs *= 2;
#line 813
        }
#line 813
            /* bits of k determine whether to get lower or upper part of dim */
#line 813
            /* choose random stride from 1 to edge */
#line 813
        for (k = 0; k < nslabs; k++) {
#line 813
            nstarts = 1;
#line 813
            for (j = 0; j < var_rank[i]; j++) {
#line 813
                if ((k >> j) & 1) {
#line 813
                    start[j] = 0;
#line 813
                    edge[j] = mid[j];
#line 813
                }else{
#line 813
                    start[j] = mid[j];
#line 813
                    edge[j] = var_shape[i][j] - mid[j];
#line 813
                }
#line 813
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 813
                nstarts *= stride[j];
#line 813
            }
#line 813
            for (m = 0; m < nstarts; m++) {
#line 813
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 813
                IF (err)
#line 813
                    error("error in toMixedBase");
#line 813
                nels = 1;
#line 813
                for (j = 0; j < var_rank[i]; j++) {
#line 813
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 813
                    nels *= count[j];
#line 813
                    index[j] += start[j];
#line 813
                }
#line 813
		    /* Random choice of forward or backward */
#line 813
/* TODO
#line 813
		if ( roll(2) ) {
#line 813
		    for (j = 0; j < var_rank[i]; j++) {
#line 813
			index[j] += (count[j] - 1) * stride[j];
#line 813
			stride[j] = -stride[j];
#line 813
		    }
#line 813
		}
#line 813
 */
#line 813
		if (var_rank[i] > 0) {
#line 813
		    j = var_rank[i] - 1;
#line 813
		    imap[j] = 1;
#line 813
		    for (; j > 0; j--)
#line 813
			imap[j-1] = imap[j] * count[j];
#line 813
		}
#line 813
                allInExtRange = allInIntRange = 1;
#line 813
                for (j = 0; j < nels; j++) {
#line 813
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 813
                    IF (err)
#line 813
                        error("error in toMixedBase 1");
#line 813
                    for (d = 0; d < var_rank[i]; d++)
#line 813
                        index2[d] = index[d] + index2[d] * stride[d];
#line 813
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 813
                        NCT_LONG);
#line 813
                    if (inRange3(expect[j],var_type[i],NCT_LONG)) {
#line 813
                        allInIntRange = allInIntRange && expect[j] >= long_min
#line 813
                            && expect[j] <= long_max;
#line 813
                    } else {
#line 813
                        allInExtRange = 0;
#line 813
                    }
#line 813
                }
#line 813
                if (var_rank[i] == 0 && i%2 )
#line 813
                    err = nc_get_varm_long(ncid,i,NULL,NULL,NULL,NULL,value);
#line 813
                else
#line 813
                    err = nc_get_varm_long(ncid,i,index,count,stride,imap,value);
#line 813
                if (canConvert) {
#line 813
                    if (allInExtRange) {
#line 813
                        if (allInIntRange) {
#line 813
                            IF (err)
#line 813
                                error("%s", nc_strerror(err));
#line 813
                        } else {
#line 813
                            IF (err != NC_ERANGE)
#line 813
                                error("Range error: status = %d", err);
#line 813
                        }
#line 813
                    } else {
#line 813
                        IF (err != 0 && err != NC_ERANGE)
#line 813
                            error("OK or Range error: status = %d", err);
#line 813
                    }
#line 813
                    for (j = 0; j < nels; j++) {
#line 813
                        if (inRange3(expect[j],var_type[i],NCT_LONG)
#line 813
                                && expect[j] >= long_min 
#line 813
				&& expect[j] <= long_max) {
#line 813
			    IF (!equal(value[j],expect[j],var_type[i], NCT_LONG)){
#line 813
                                error("value read not that expected");
#line 813
                                if (verbose) {
#line 813
                                    error("\n");
#line 813
                                    error("varid: %d, ", i);
#line 813
                                    error("var_name: %s, ", var_name[i]);
#line 813
                                    error("element number: %d ", j);
#line 813
                                    error("expect: %g, ", expect[j]);
#line 813
                                    error("got: %g", (double) value[j]);
#line 813
                                }
#line 813
                            } else {
#line 813
                                nok++;
#line 813
                            }
#line 813
                        }
#line 813
                    }
#line 813
                } else {
#line 813
                    IF (nels > 0 && err != NC_ECHAR)
#line 813
                        error("wrong type: status = %d", err);
#line 813
                }
#line 813
            }
#line 813
        }
#line 813
    }
#line 813
    err = nc_close(ncid);
#line 813
    IF (err)
#line 813
        error("nc_close: %s", nc_strerror(err));
#line 813
    print_nok(nok);
#line 813
}
#line 813

void
#line 814
test_nc_get_varm_float(void)
#line 814
{
#line 814
    int ncid;
#line 814
    int d;
#line 814
    int i;
#line 814
    int j;
#line 814
    int k;
#line 814
    int m;
#line 814
    int err;
#line 814
    int allInExtRange;	/* all values within external range? */
#line 814
    int allInIntRange;	/* all values within internal range? */
#line 814
    int nels;
#line 814
    int nslabs;
#line 814
    int nstarts;        /* number of different starts */
#line 814
    int nok = 0;      /* count of valid comparisons */
#line 814
    size_t start[MAX_RANK];
#line 814
    size_t edge[MAX_RANK];
#line 814
    size_t index[MAX_RANK];
#line 814
    size_t index2[MAX_RANK];
#line 814
    size_t mid[MAX_RANK];
#line 814
    size_t count[MAX_RANK];
#line 814
    size_t sstride[MAX_RANK];
#line 814
    ptrdiff_t stride[MAX_RANK];
#line 814
    ptrdiff_t imap[MAX_RANK];
#line 814
    int canConvert;     /* Both text or both numeric */
#line 814
    float value[MAX_NELS];
#line 814
    double expect[MAX_NELS];
#line 814

#line 814
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 814
    IF (err)
#line 814
        error("nc_open: %s", nc_strerror(err));
#line 814
    for (i = 0; i < numVars; i++) {
#line 814
        canConvert = (var_type[i] == NC_CHAR) == (NCT_FLOAT == NCT_TEXT);
#line 814
        assert(var_rank[i] <= MAX_RANK);
#line 814
        assert(var_nels[i] <= MAX_NELS);
#line 814
        for (j = 0; j < var_rank[i]; j++) {
#line 814
            start[j] = 0;
#line 814
            edge[j] = 1;
#line 814
            stride[j] = 1;
#line 814
            imap[j] = 1;
#line 814
        }
#line 814
        err = nc_get_varm_float(BAD_ID, i, start, edge, stride, imap, value);
#line 814
        IF (err != NC_EBADID)
#line 814
            error("bad ncid: status = %d", err);
#line 814
        err = nc_get_varm_float(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 814
        IF (err != NC_ENOTVAR)
#line 814
            error("bad var id: status = %d", err);
#line 814
        for (j = 0; j < var_rank[i]; j++) {
#line 814
            start[j] = var_shape[i][j];
#line 814
            err = nc_get_varm_float(ncid, i, start, edge, stride, imap, value);
#line 814
	  if(!canConvert) {
#line 814
		IF (err != NC_ECHAR)
#line 814
               	    error("conversion: status = %d", err);
#line 814
	  } else {
#line 814
	    IF (err != NC_EINVALCOORDS)
#line 814
                error("bad index: status = %d", err);
#line 814
            start[j] = 0;
#line 814
            edge[j] = var_shape[i][j] + 1;
#line 814
            err = nc_get_varm_float(ncid, i, start, edge, stride, imap, value);
#line 814
            IF (err != NC_EEDGE)
#line 814
                error("bad edge: status = %d", err);
#line 814
            edge[j] = 1;
#line 814
            stride[j] = 0;
#line 814
            err = nc_get_varm_float(ncid, i, start, edge, stride, imap, value);
#line 814
            IF (err != NC_ESTRIDE)
#line 814
                error("bad stride: status = %d", err);
#line 814
            stride[j] = 1;
#line 814
           }
#line 814
        }
#line 814
            /* Choose a random point dividing each dim into 2 parts */
#line 814
            /* get 2^rank (nslabs) slabs so defined */
#line 814
        nslabs = 1;
#line 814
        for (j = 0; j < var_rank[i]; j++) {
#line 814
            mid[j] = roll( var_shape[i][j] );
#line 814
            nslabs *= 2;
#line 814
        }
#line 814
            /* bits of k determine whether to get lower or upper part of dim */
#line 814
            /* choose random stride from 1 to edge */
#line 814
        for (k = 0; k < nslabs; k++) {
#line 814
            nstarts = 1;
#line 814
            for (j = 0; j < var_rank[i]; j++) {
#line 814
                if ((k >> j) & 1) {
#line 814
                    start[j] = 0;
#line 814
                    edge[j] = mid[j];
#line 814
                }else{
#line 814
                    start[j] = mid[j];
#line 814
                    edge[j] = var_shape[i][j] - mid[j];
#line 814
                }
#line 814
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 814
                nstarts *= stride[j];
#line 814
            }
#line 814
            for (m = 0; m < nstarts; m++) {
#line 814
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 814
                IF (err)
#line 814
                    error("error in toMixedBase");
#line 814
                nels = 1;
#line 814
                for (j = 0; j < var_rank[i]; j++) {
#line 814
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 814
                    nels *= count[j];
#line 814
                    index[j] += start[j];
#line 814
                }
#line 814
		    /* Random choice of forward or backward */
#line 814
/* TODO
#line 814
		if ( roll(2) ) {
#line 814
		    for (j = 0; j < var_rank[i]; j++) {
#line 814
			index[j] += (count[j] - 1) * stride[j];
#line 814
			stride[j] = -stride[j];
#line 814
		    }
#line 814
		}
#line 814
 */
#line 814
		if (var_rank[i] > 0) {
#line 814
		    j = var_rank[i] - 1;
#line 814
		    imap[j] = 1;
#line 814
		    for (; j > 0; j--)
#line 814
			imap[j-1] = imap[j] * count[j];
#line 814
		}
#line 814
                allInExtRange = allInIntRange = 1;
#line 814
                for (j = 0; j < nels; j++) {
#line 814
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 814
                    IF (err)
#line 814
                        error("error in toMixedBase 1");
#line 814
                    for (d = 0; d < var_rank[i]; d++)
#line 814
                        index2[d] = index[d] + index2[d] * stride[d];
#line 814
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 814
                        NCT_FLOAT);
#line 814
                    if (inRange3(expect[j],var_type[i],NCT_FLOAT)) {
#line 814
                        allInIntRange = allInIntRange && expect[j] >= float_min
#line 814
                            && expect[j] <= float_max;
#line 814
                    } else {
#line 814
                        allInExtRange = 0;
#line 814
                    }
#line 814
                }
#line 814
                if (var_rank[i] == 0 && i%2 )
#line 814
                    err = nc_get_varm_float(ncid,i,NULL,NULL,NULL,NULL,value);
#line 814
                else
#line 814
                    err = nc_get_varm_float(ncid,i,index,count,stride,imap,value);
#line 814
                if (canConvert) {
#line 814
                    if (allInExtRange) {
#line 814
                        if (allInIntRange) {
#line 814
                            IF (err)
#line 814
                                error("%s", nc_strerror(err));
#line 814
                        } else {
#line 814
                            IF (err != NC_ERANGE)
#line 814
                                error("Range error: status = %d", err);
#line 814
                        }
#line 814
                    } else {
#line 814
                        IF (err != 0 && err != NC_ERANGE)
#line 814
                            error("OK or Range error: status = %d", err);
#line 814
                    }
#line 814
                    for (j = 0; j < nels; j++) {
#line 814
                        if (inRange3(expect[j],var_type[i],NCT_FLOAT)
#line 814
                                && expect[j] >= float_min 
#line 814
				&& expect[j] <= float_max) {
#line 814
			    IF (!equal(value[j],expect[j],var_type[i], NCT_FLOAT)){
#line 814
                                error("value read not that expected");
#line 814
                                if (verbose) {
#line 814
                                    error("\n");
#line 814
                                    error("varid: %d, ", i);
#line 814
                                    error("var_name: %s, ", var_name[i]);
#line 814
                                    error("element number: %d ", j);
#line 814
                                    error("expect: %g, ", expect[j]);
#line 814
                                    error("got: %g", (double) value[j]);
#line 814
                                }
#line 814
                            } else {
#line 814
                                nok++;
#line 814
                            }
#line 814
                        }
#line 814
                    }
#line 814
                } else {
#line 814
                    IF (nels > 0 && err != NC_ECHAR)
#line 814
                        error("wrong type: status = %d", err);
#line 814
                }
#line 814
            }
#line 814
        }
#line 814
    }
#line 814
    err = nc_close(ncid);
#line 814
    IF (err)
#line 814
        error("nc_close: %s", nc_strerror(err));
#line 814
    print_nok(nok);
#line 814
}
#line 814

void
#line 815
test_nc_get_varm_double(void)
#line 815
{
#line 815
    int ncid;
#line 815
    int d;
#line 815
    int i;
#line 815
    int j;
#line 815
    int k;
#line 815
    int m;
#line 815
    int err;
#line 815
    int allInExtRange;	/* all values within external range? */
#line 815
    int allInIntRange;	/* all values within internal range? */
#line 815
    int nels;
#line 815
    int nslabs;
#line 815
    int nstarts;        /* number of different starts */
#line 815
    int nok = 0;      /* count of valid comparisons */
#line 815
    size_t start[MAX_RANK];
#line 815
    size_t edge[MAX_RANK];
#line 815
    size_t index[MAX_RANK];
#line 815
    size_t index2[MAX_RANK];
#line 815
    size_t mid[MAX_RANK];
#line 815
    size_t count[MAX_RANK];
#line 815
    size_t sstride[MAX_RANK];
#line 815
    ptrdiff_t stride[MAX_RANK];
#line 815
    ptrdiff_t imap[MAX_RANK];
#line 815
    int canConvert;     /* Both text or both numeric */
#line 815
    double value[MAX_NELS];
#line 815
    double expect[MAX_NELS];
#line 815

#line 815
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 815
    IF (err)
#line 815
        error("nc_open: %s", nc_strerror(err));
#line 815
    for (i = 0; i < numVars; i++) {
#line 815
        canConvert = (var_type[i] == NC_CHAR) == (NCT_DOUBLE == NCT_TEXT);
#line 815
        assert(var_rank[i] <= MAX_RANK);
#line 815
        assert(var_nels[i] <= MAX_NELS);
#line 815
        for (j = 0; j < var_rank[i]; j++) {
#line 815
            start[j] = 0;
#line 815
            edge[j] = 1;
#line 815
            stride[j] = 1;
#line 815
            imap[j] = 1;
#line 815
        }
#line 815
        err = nc_get_varm_double(BAD_ID, i, start, edge, stride, imap, value);
#line 815
        IF (err != NC_EBADID)
#line 815
            error("bad ncid: status = %d", err);
#line 815
        err = nc_get_varm_double(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 815
        IF (err != NC_ENOTVAR)
#line 815
            error("bad var id: status = %d", err);
#line 815
        for (j = 0; j < var_rank[i]; j++) {
#line 815
            start[j] = var_shape[i][j];
#line 815
            err = nc_get_varm_double(ncid, i, start, edge, stride, imap, value);
#line 815
	  if(!canConvert) {
#line 815
		IF (err != NC_ECHAR)
#line 815
               	    error("conversion: status = %d", err);
#line 815
	  } else {
#line 815
	    IF (err != NC_EINVALCOORDS)
#line 815
                error("bad index: status = %d", err);
#line 815
            start[j] = 0;
#line 815
            edge[j] = var_shape[i][j] + 1;
#line 815
            err = nc_get_varm_double(ncid, i, start, edge, stride, imap, value);
#line 815
            IF (err != NC_EEDGE)
#line 815
                error("bad edge: status = %d", err);
#line 815
            edge[j] = 1;
#line 815
            stride[j] = 0;
#line 815
            err = nc_get_varm_double(ncid, i, start, edge, stride, imap, value);
#line 815
            IF (err != NC_ESTRIDE)
#line 815
                error("bad stride: status = %d", err);
#line 815
            stride[j] = 1;
#line 815
           }
#line 815
        }
#line 815
            /* Choose a random point dividing each dim into 2 parts */
#line 815
            /* get 2^rank (nslabs) slabs so defined */
#line 815
        nslabs = 1;
#line 815
        for (j = 0; j < var_rank[i]; j++) {
#line 815
            mid[j] = roll( var_shape[i][j] );
#line 815
            nslabs *= 2;
#line 815
        }
#line 815
            /* bits of k determine whether to get lower or upper part of dim */
#line 815
            /* choose random stride from 1 to edge */
#line 815
        for (k = 0; k < nslabs; k++) {
#line 815
            nstarts = 1;
#line 815
            for (j = 0; j < var_rank[i]; j++) {
#line 815
                if ((k >> j) & 1) {
#line 815
                    start[j] = 0;
#line 815
                    edge[j] = mid[j];
#line 815
                }else{
#line 815
                    start[j] = mid[j];
#line 815
                    edge[j] = var_shape[i][j] - mid[j];
#line 815
                }
#line 815
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 815
                nstarts *= stride[j];
#line 815
            }
#line 815
            for (m = 0; m < nstarts; m++) {
#line 815
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 815
                IF (err)
#line 815
                    error("error in toMixedBase");
#line 815
                nels = 1;
#line 815
                for (j = 0; j < var_rank[i]; j++) {
#line 815
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 815
                    nels *= count[j];
#line 815
                    index[j] += start[j];
#line 815
                }
#line 815
		    /* Random choice of forward or backward */
#line 815
/* TODO
#line 815
		if ( roll(2) ) {
#line 815
		    for (j = 0; j < var_rank[i]; j++) {
#line 815
			index[j] += (count[j] - 1) * stride[j];
#line 815
			stride[j] = -stride[j];
#line 815
		    }
#line 815
		}
#line 815
 */
#line 815
		if (var_rank[i] > 0) {
#line 815
		    j = var_rank[i] - 1;
#line 815
		    imap[j] = 1;
#line 815
		    for (; j > 0; j--)
#line 815
			imap[j-1] = imap[j] * count[j];
#line 815
		}
#line 815
                allInExtRange = allInIntRange = 1;
#line 815
                for (j = 0; j < nels; j++) {
#line 815
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 815
                    IF (err)
#line 815
                        error("error in toMixedBase 1");
#line 815
                    for (d = 0; d < var_rank[i]; d++)
#line 815
                        index2[d] = index[d] + index2[d] * stride[d];
#line 815
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 815
                        NCT_DOUBLE);
#line 815
                    if (inRange3(expect[j],var_type[i],NCT_DOUBLE)) {
#line 815
                        allInIntRange = allInIntRange && expect[j] >= double_min
#line 815
                            && expect[j] <= double_max;
#line 815
                    } else {
#line 815
                        allInExtRange = 0;
#line 815
                    }
#line 815
                }
#line 815
                if (var_rank[i] == 0 && i%2 )
#line 815
                    err = nc_get_varm_double(ncid,i,NULL,NULL,NULL,NULL,value);
#line 815
                else
#line 815
                    err = nc_get_varm_double(ncid,i,index,count,stride,imap,value);
#line 815
                if (canConvert) {
#line 815
                    if (allInExtRange) {
#line 815
                        if (allInIntRange) {
#line 815
                            IF (err)
#line 815
                                error("%s", nc_strerror(err));
#line 815
                        } else {
#line 815
                            IF (err != NC_ERANGE)
#line 815
                                error("Range error: status = %d", err);
#line 815
                        }
#line 815
                    } else {
#line 815
                        IF (err != 0 && err != NC_ERANGE)
#line 815
                            error("OK or Range error: status = %d", err);
#line 815
                    }
#line 815
                    for (j = 0; j < nels; j++) {
#line 815
                        if (inRange3(expect[j],var_type[i],NCT_DOUBLE)
#line 815
                                && expect[j] >= double_min 
#line 815
				&& expect[j] <= double_max) {
#line 815
			    IF (!equal(value[j],expect[j],var_type[i], NCT_DOUBLE)){
#line 815
                                error("value read not that expected");
#line 815
                                if (verbose) {
#line 815
                                    error("\n");
#line 815
                                    error("varid: %d, ", i);
#line 815
                                    error("var_name: %s, ", var_name[i]);
#line 815
                                    error("element number: %d ", j);
#line 815
                                    error("expect: %g, ", expect[j]);
#line 815
                                    error("got: %g", (double) value[j]);
#line 815
                                }
#line 815
                            } else {
#line 815
                                nok++;
#line 815
                            }
#line 815
                        }
#line 815
                    }
#line 815
                } else {
#line 815
                    IF (nels > 0 && err != NC_ECHAR)
#line 815
                        error("wrong type: status = %d", err);
#line 815
                }
#line 815
            }
#line 815
        }
#line 815
    }
#line 815
    err = nc_close(ncid);
#line 815
    IF (err)
#line 815
        error("nc_close: %s", nc_strerror(err));
#line 815
    print_nok(nok);
#line 815
}
#line 815

void
#line 816
test_nc_get_varm_ushort(void)
#line 816
{
#line 816
    int ncid;
#line 816
    int d;
#line 816
    int i;
#line 816
    int j;
#line 816
    int k;
#line 816
    int m;
#line 816
    int err;
#line 816
    int allInExtRange;	/* all values within external range? */
#line 816
    int allInIntRange;	/* all values within internal range? */
#line 816
    int nels;
#line 816
    int nslabs;
#line 816
    int nstarts;        /* number of different starts */
#line 816
    int nok = 0;      /* count of valid comparisons */
#line 816
    size_t start[MAX_RANK];
#line 816
    size_t edge[MAX_RANK];
#line 816
    size_t index[MAX_RANK];
#line 816
    size_t index2[MAX_RANK];
#line 816
    size_t mid[MAX_RANK];
#line 816
    size_t count[MAX_RANK];
#line 816
    size_t sstride[MAX_RANK];
#line 816
    ptrdiff_t stride[MAX_RANK];
#line 816
    ptrdiff_t imap[MAX_RANK];
#line 816
    int canConvert;     /* Both text or both numeric */
#line 816
    ushort value[MAX_NELS];
#line 816
    double expect[MAX_NELS];
#line 816

#line 816
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 816
    IF (err)
#line 816
        error("nc_open: %s", nc_strerror(err));
#line 816
    for (i = 0; i < numVars; i++) {
#line 816
        canConvert = (var_type[i] == NC_CHAR) == (NCT_USHORT == NCT_TEXT);
#line 816
        assert(var_rank[i] <= MAX_RANK);
#line 816
        assert(var_nels[i] <= MAX_NELS);
#line 816
        for (j = 0; j < var_rank[i]; j++) {
#line 816
            start[j] = 0;
#line 816
            edge[j] = 1;
#line 816
            stride[j] = 1;
#line 816
            imap[j] = 1;
#line 816
        }
#line 816
        err = nc_get_varm_ushort(BAD_ID, i, start, edge, stride, imap, value);
#line 816
        IF (err != NC_EBADID)
#line 816
            error("bad ncid: status = %d", err);
#line 816
        err = nc_get_varm_ushort(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 816
        IF (err != NC_ENOTVAR)
#line 816
            error("bad var id: status = %d", err);
#line 816
        for (j = 0; j < var_rank[i]; j++) {
#line 816
            start[j] = var_shape[i][j];
#line 816
            err = nc_get_varm_ushort(ncid, i, start, edge, stride, imap, value);
#line 816
	  if(!canConvert) {
#line 816
		IF (err != NC_ECHAR)
#line 816
               	    error("conversion: status = %d", err);
#line 816
	  } else {
#line 816
	    IF (err != NC_EINVALCOORDS)
#line 816
                error("bad index: status = %d", err);
#line 816
            start[j] = 0;
#line 816
            edge[j] = var_shape[i][j] + 1;
#line 816
            err = nc_get_varm_ushort(ncid, i, start, edge, stride, imap, value);
#line 816
            IF (err != NC_EEDGE)
#line 816
                error("bad edge: status = %d", err);
#line 816
            edge[j] = 1;
#line 816
            stride[j] = 0;
#line 816
            err = nc_get_varm_ushort(ncid, i, start, edge, stride, imap, value);
#line 816
            IF (err != NC_ESTRIDE)
#line 816
                error("bad stride: status = %d", err);
#line 816
            stride[j] = 1;
#line 816
           }
#line 816
        }
#line 816
            /* Choose a random point dividing each dim into 2 parts */
#line 816
            /* get 2^rank (nslabs) slabs so defined */
#line 816
        nslabs = 1;
#line 816
        for (j = 0; j < var_rank[i]; j++) {
#line 816
            mid[j] = roll( var_shape[i][j] );
#line 816
            nslabs *= 2;
#line 816
        }
#line 816
            /* bits of k determine whether to get lower or upper part of dim */
#line 816
            /* choose random stride from 1 to edge */
#line 816
        for (k = 0; k < nslabs; k++) {
#line 816
            nstarts = 1;
#line 816
            for (j = 0; j < var_rank[i]; j++) {
#line 816
                if ((k >> j) & 1) {
#line 816
                    start[j] = 0;
#line 816
                    edge[j] = mid[j];
#line 816
                }else{
#line 816
                    start[j] = mid[j];
#line 816
                    edge[j] = var_shape[i][j] - mid[j];
#line 816
                }
#line 816
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 816
                nstarts *= stride[j];
#line 816
            }
#line 816
            for (m = 0; m < nstarts; m++) {
#line 816
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 816
                IF (err)
#line 816
                    error("error in toMixedBase");
#line 816
                nels = 1;
#line 816
                for (j = 0; j < var_rank[i]; j++) {
#line 816
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 816
                    nels *= count[j];
#line 816
                    index[j] += start[j];
#line 816
                }
#line 816
		    /* Random choice of forward or backward */
#line 816
/* TODO
#line 816
		if ( roll(2) ) {
#line 816
		    for (j = 0; j < var_rank[i]; j++) {
#line 816
			index[j] += (count[j] - 1) * stride[j];
#line 816
			stride[j] = -stride[j];
#line 816
		    }
#line 816
		}
#line 816
 */
#line 816
		if (var_rank[i] > 0) {
#line 816
		    j = var_rank[i] - 1;
#line 816
		    imap[j] = 1;
#line 816
		    for (; j > 0; j--)
#line 816
			imap[j-1] = imap[j] * count[j];
#line 816
		}
#line 816
                allInExtRange = allInIntRange = 1;
#line 816
                for (j = 0; j < nels; j++) {
#line 816
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 816
                    IF (err)
#line 816
                        error("error in toMixedBase 1");
#line 816
                    for (d = 0; d < var_rank[i]; d++)
#line 816
                        index2[d] = index[d] + index2[d] * stride[d];
#line 816
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 816
                        NCT_USHORT);
#line 816
                    if (inRange3(expect[j],var_type[i],NCT_USHORT)) {
#line 816
                        allInIntRange = allInIntRange && expect[j] >= ushort_min
#line 816
                            && expect[j] <= ushort_max;
#line 816
                    } else {
#line 816
                        allInExtRange = 0;
#line 816
                    }
#line 816
                }
#line 816
                if (var_rank[i] == 0 && i%2 )
#line 816
                    err = nc_get_varm_ushort(ncid,i,NULL,NULL,NULL,NULL,value);
#line 816
                else
#line 816
                    err = nc_get_varm_ushort(ncid,i,index,count,stride,imap,value);
#line 816
                if (canConvert) {
#line 816
                    if (allInExtRange) {
#line 816
                        if (allInIntRange) {
#line 816
                            IF (err)
#line 816
                                error("%s", nc_strerror(err));
#line 816
                        } else {
#line 816
                            IF (err != NC_ERANGE)
#line 816
                                error("Range error: status = %d", err);
#line 816
                        }
#line 816
                    } else {
#line 816
                        IF (err != 0 && err != NC_ERANGE)
#line 816
                            error("OK or Range error: status = %d", err);
#line 816
                    }
#line 816
                    for (j = 0; j < nels; j++) {
#line 816
                        if (inRange3(expect[j],var_type[i],NCT_USHORT)
#line 816
                                && expect[j] >= ushort_min 
#line 816
				&& expect[j] <= ushort_max) {
#line 816
			    IF (!equal(value[j],expect[j],var_type[i], NCT_USHORT)){
#line 816
                                error("value read not that expected");
#line 816
                                if (verbose) {
#line 816
                                    error("\n");
#line 816
                                    error("varid: %d, ", i);
#line 816
                                    error("var_name: %s, ", var_name[i]);
#line 816
                                    error("element number: %d ", j);
#line 816
                                    error("expect: %g, ", expect[j]);
#line 816
                                    error("got: %g", (double) value[j]);
#line 816
                                }
#line 816
                            } else {
#line 816
                                nok++;
#line 816
                            }
#line 816
                        }
#line 816
                    }
#line 816
                } else {
#line 816
                    IF (nels > 0 && err != NC_ECHAR)
#line 816
                        error("wrong type: status = %d", err);
#line 816
                }
#line 816
            }
#line 816
        }
#line 816
    }
#line 816
    err = nc_close(ncid);
#line 816
    IF (err)
#line 816
        error("nc_close: %s", nc_strerror(err));
#line 816
    print_nok(nok);
#line 816
}
#line 816

void
#line 817
test_nc_get_varm_uint(void)
#line 817
{
#line 817
    int ncid;
#line 817
    int d;
#line 817
    int i;
#line 817
    int j;
#line 817
    int k;
#line 817
    int m;
#line 817
    int err;
#line 817
    int allInExtRange;	/* all values within external range? */
#line 817
    int allInIntRange;	/* all values within internal range? */
#line 817
    int nels;
#line 817
    int nslabs;
#line 817
    int nstarts;        /* number of different starts */
#line 817
    int nok = 0;      /* count of valid comparisons */
#line 817
    size_t start[MAX_RANK];
#line 817
    size_t edge[MAX_RANK];
#line 817
    size_t index[MAX_RANK];
#line 817
    size_t index2[MAX_RANK];
#line 817
    size_t mid[MAX_RANK];
#line 817
    size_t count[MAX_RANK];
#line 817
    size_t sstride[MAX_RANK];
#line 817
    ptrdiff_t stride[MAX_RANK];
#line 817
    ptrdiff_t imap[MAX_RANK];
#line 817
    int canConvert;     /* Both text or both numeric */
#line 817
    uint value[MAX_NELS];
#line 817
    double expect[MAX_NELS];
#line 817

#line 817
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 817
    IF (err)
#line 817
        error("nc_open: %s", nc_strerror(err));
#line 817
    for (i = 0; i < numVars; i++) {
#line 817
        canConvert = (var_type[i] == NC_CHAR) == (NCT_UINT == NCT_TEXT);
#line 817
        assert(var_rank[i] <= MAX_RANK);
#line 817
        assert(var_nels[i] <= MAX_NELS);
#line 817
        for (j = 0; j < var_rank[i]; j++) {
#line 817
            start[j] = 0;
#line 817
            edge[j] = 1;
#line 817
            stride[j] = 1;
#line 817
            imap[j] = 1;
#line 817
        }
#line 817
        err = nc_get_varm_uint(BAD_ID, i, start, edge, stride, imap, value);
#line 817
        IF (err != NC_EBADID)
#line 817
            error("bad ncid: status = %d", err);
#line 817
        err = nc_get_varm_uint(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 817
        IF (err != NC_ENOTVAR)
#line 817
            error("bad var id: status = %d", err);
#line 817
        for (j = 0; j < var_rank[i]; j++) {
#line 817
            start[j] = var_shape[i][j];
#line 817
            err = nc_get_varm_uint(ncid, i, start, edge, stride, imap, value);
#line 817
	  if(!canConvert) {
#line 817
		IF (err != NC_ECHAR)
#line 817
               	    error("conversion: status = %d", err);
#line 817
	  } else {
#line 817
	    IF (err != NC_EINVALCOORDS)
#line 817
                error("bad index: status = %d", err);
#line 817
            start[j] = 0;
#line 817
            edge[j] = var_shape[i][j] + 1;
#line 817
            err = nc_get_varm_uint(ncid, i, start, edge, stride, imap, value);
#line 817
            IF (err != NC_EEDGE)
#line 817
                error("bad edge: status = %d", err);
#line 817
            edge[j] = 1;
#line 817
            stride[j] = 0;
#line 817
            err = nc_get_varm_uint(ncid, i, start, edge, stride, imap, value);
#line 817
            IF (err != NC_ESTRIDE)
#line 817
                error("bad stride: status = %d", err);
#line 817
            stride[j] = 1;
#line 817
           }
#line 817
        }
#line 817
            /* Choose a random point dividing each dim into 2 parts */
#line 817
            /* get 2^rank (nslabs) slabs so defined */
#line 817
        nslabs = 1;
#line 817
        for (j = 0; j < var_rank[i]; j++) {
#line 817
            mid[j] = roll( var_shape[i][j] );
#line 817
            nslabs *= 2;
#line 817
        }
#line 817
            /* bits of k determine whether to get lower or upper part of dim */
#line 817
            /* choose random stride from 1 to edge */
#line 817
        for (k = 0; k < nslabs; k++) {
#line 817
            nstarts = 1;
#line 817
            for (j = 0; j < var_rank[i]; j++) {
#line 817
                if ((k >> j) & 1) {
#line 817
                    start[j] = 0;
#line 817
                    edge[j] = mid[j];
#line 817
                }else{
#line 817
                    start[j] = mid[j];
#line 817
                    edge[j] = var_shape[i][j] - mid[j];
#line 817
                }
#line 817
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 817
                nstarts *= stride[j];
#line 817
            }
#line 817
            for (m = 0; m < nstarts; m++) {
#line 817
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 817
                IF (err)
#line 817
                    error("error in toMixedBase");
#line 817
                nels = 1;
#line 817
                for (j = 0; j < var_rank[i]; j++) {
#line 817
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 817
                    nels *= count[j];
#line 817
                    index[j] += start[j];
#line 817
                }
#line 817
		    /* Random choice of forward or backward */
#line 817
/* TODO
#line 817
		if ( roll(2) ) {
#line 817
		    for (j = 0; j < var_rank[i]; j++) {
#line 817
			index[j] += (count[j] - 1) * stride[j];
#line 817
			stride[j] = -stride[j];
#line 817
		    }
#line 817
		}
#line 817
 */
#line 817
		if (var_rank[i] > 0) {
#line 817
		    j = var_rank[i] - 1;
#line 817
		    imap[j] = 1;
#line 817
		    for (; j > 0; j--)
#line 817
			imap[j-1] = imap[j] * count[j];
#line 817
		}
#line 817
                allInExtRange = allInIntRange = 1;
#line 817
                for (j = 0; j < nels; j++) {
#line 817
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 817
                    IF (err)
#line 817
                        error("error in toMixedBase 1");
#line 817
                    for (d = 0; d < var_rank[i]; d++)
#line 817
                        index2[d] = index[d] + index2[d] * stride[d];
#line 817
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 817
                        NCT_UINT);
#line 817
                    if (inRange3(expect[j],var_type[i],NCT_UINT)) {
#line 817
                        allInIntRange = allInIntRange && expect[j] >= uint_min
#line 817
                            && expect[j] <= uint_max;
#line 817
                    } else {
#line 817
                        allInExtRange = 0;
#line 817
                    }
#line 817
                }
#line 817
                if (var_rank[i] == 0 && i%2 )
#line 817
                    err = nc_get_varm_uint(ncid,i,NULL,NULL,NULL,NULL,value);
#line 817
                else
#line 817
                    err = nc_get_varm_uint(ncid,i,index,count,stride,imap,value);
#line 817
                if (canConvert) {
#line 817
                    if (allInExtRange) {
#line 817
                        if (allInIntRange) {
#line 817
                            IF (err)
#line 817
                                error("%s", nc_strerror(err));
#line 817
                        } else {
#line 817
                            IF (err != NC_ERANGE)
#line 817
                                error("Range error: status = %d", err);
#line 817
                        }
#line 817
                    } else {
#line 817
                        IF (err != 0 && err != NC_ERANGE)
#line 817
                            error("OK or Range error: status = %d", err);
#line 817
                    }
#line 817
                    for (j = 0; j < nels; j++) {
#line 817
                        if (inRange3(expect[j],var_type[i],NCT_UINT)
#line 817
                                && expect[j] >= uint_min 
#line 817
				&& expect[j] <= uint_max) {
#line 817
			    IF (!equal(value[j],expect[j],var_type[i], NCT_UINT)){
#line 817
                                error("value read not that expected");
#line 817
                                if (verbose) {
#line 817
                                    error("\n");
#line 817
                                    error("varid: %d, ", i);
#line 817
                                    error("var_name: %s, ", var_name[i]);
#line 817
                                    error("element number: %d ", j);
#line 817
                                    error("expect: %g, ", expect[j]);
#line 817
                                    error("got: %g", (double) value[j]);
#line 817
                                }
#line 817
                            } else {
#line 817
                                nok++;
#line 817
                            }
#line 817
                        }
#line 817
                    }
#line 817
                } else {
#line 817
                    IF (nels > 0 && err != NC_ECHAR)
#line 817
                        error("wrong type: status = %d", err);
#line 817
                }
#line 817
            }
#line 817
        }
#line 817
    }
#line 817
    err = nc_close(ncid);
#line 817
    IF (err)
#line 817
        error("nc_close: %s", nc_strerror(err));
#line 817
    print_nok(nok);
#line 817
}
#line 817

void
#line 818
test_nc_get_varm_longlong(void)
#line 818
{
#line 818
    int ncid;
#line 818
    int d;
#line 818
    int i;
#line 818
    int j;
#line 818
    int k;
#line 818
    int m;
#line 818
    int err;
#line 818
    int allInExtRange;	/* all values within external range? */
#line 818
    int allInIntRange;	/* all values within internal range? */
#line 818
    int nels;
#line 818
    int nslabs;
#line 818
    int nstarts;        /* number of different starts */
#line 818
    int nok = 0;      /* count of valid comparisons */
#line 818
    size_t start[MAX_RANK];
#line 818
    size_t edge[MAX_RANK];
#line 818
    size_t index[MAX_RANK];
#line 818
    size_t index2[MAX_RANK];
#line 818
    size_t mid[MAX_RANK];
#line 818
    size_t count[MAX_RANK];
#line 818
    size_t sstride[MAX_RANK];
#line 818
    ptrdiff_t stride[MAX_RANK];
#line 818
    ptrdiff_t imap[MAX_RANK];
#line 818
    int canConvert;     /* Both text or both numeric */
#line 818
    longlong value[MAX_NELS];
#line 818
    double expect[MAX_NELS];
#line 818

#line 818
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 818
    IF (err)
#line 818
        error("nc_open: %s", nc_strerror(err));
#line 818
    for (i = 0; i < numVars; i++) {
#line 818
        canConvert = (var_type[i] == NC_CHAR) == (NCT_LONGLONG == NCT_TEXT);
#line 818
        assert(var_rank[i] <= MAX_RANK);
#line 818
        assert(var_nels[i] <= MAX_NELS);
#line 818
        for (j = 0; j < var_rank[i]; j++) {
#line 818
            start[j] = 0;
#line 818
            edge[j] = 1;
#line 818
            stride[j] = 1;
#line 818
            imap[j] = 1;
#line 818
        }
#line 818
        err = nc_get_varm_longlong(BAD_ID, i, start, edge, stride, imap, value);
#line 818
        IF (err != NC_EBADID)
#line 818
            error("bad ncid: status = %d", err);
#line 818
        err = nc_get_varm_longlong(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 818
        IF (err != NC_ENOTVAR)
#line 818
            error("bad var id: status = %d", err);
#line 818
        for (j = 0; j < var_rank[i]; j++) {
#line 818
            start[j] = var_shape[i][j];
#line 818
            err = nc_get_varm_longlong(ncid, i, start, edge, stride, imap, value);
#line 818
	  if(!canConvert) {
#line 818
		IF (err != NC_ECHAR)
#line 818
               	    error("conversion: status = %d", err);
#line 818
	  } else {
#line 818
	    IF (err != NC_EINVALCOORDS)
#line 818
                error("bad index: status = %d", err);
#line 818
            start[j] = 0;
#line 818
            edge[j] = var_shape[i][j] + 1;
#line 818
            err = nc_get_varm_longlong(ncid, i, start, edge, stride, imap, value);
#line 818
            IF (err != NC_EEDGE)
#line 818
                error("bad edge: status = %d", err);
#line 818
            edge[j] = 1;
#line 818
            stride[j] = 0;
#line 818
            err = nc_get_varm_longlong(ncid, i, start, edge, stride, imap, value);
#line 818
            IF (err != NC_ESTRIDE)
#line 818
                error("bad stride: status = %d", err);
#line 818
            stride[j] = 1;
#line 818
           }
#line 818
        }
#line 818
            /* Choose a random point dividing each dim into 2 parts */
#line 818
            /* get 2^rank (nslabs) slabs so defined */
#line 818
        nslabs = 1;
#line 818
        for (j = 0; j < var_rank[i]; j++) {
#line 818
            mid[j] = roll( var_shape[i][j] );
#line 818
            nslabs *= 2;
#line 818
        }
#line 818
            /* bits of k determine whether to get lower or upper part of dim */
#line 818
            /* choose random stride from 1 to edge */
#line 818
        for (k = 0; k < nslabs; k++) {
#line 818
            nstarts = 1;
#line 818
            for (j = 0; j < var_rank[i]; j++) {
#line 818
                if ((k >> j) & 1) {
#line 818
                    start[j] = 0;
#line 818
                    edge[j] = mid[j];
#line 818
                }else{
#line 818
                    start[j] = mid[j];
#line 818
                    edge[j] = var_shape[i][j] - mid[j];
#line 818
                }
#line 818
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 818
                nstarts *= stride[j];
#line 818
            }
#line 818
            for (m = 0; m < nstarts; m++) {
#line 818
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 818
                IF (err)
#line 818
                    error("error in toMixedBase");
#line 818
                nels = 1;
#line 818
                for (j = 0; j < var_rank[i]; j++) {
#line 818
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 818
                    nels *= count[j];
#line 818
                    index[j] += start[j];
#line 818
                }
#line 818
		    /* Random choice of forward or backward */
#line 818
/* TODO
#line 818
		if ( roll(2) ) {
#line 818
		    for (j = 0; j < var_rank[i]; j++) {
#line 818
			index[j] += (count[j] - 1) * stride[j];
#line 818
			stride[j] = -stride[j];
#line 818
		    }
#line 818
		}
#line 818
 */
#line 818
		if (var_rank[i] > 0) {
#line 818
		    j = var_rank[i] - 1;
#line 818
		    imap[j] = 1;
#line 818
		    for (; j > 0; j--)
#line 818
			imap[j-1] = imap[j] * count[j];
#line 818
		}
#line 818
                allInExtRange = allInIntRange = 1;
#line 818
                for (j = 0; j < nels; j++) {
#line 818
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 818
                    IF (err)
#line 818
                        error("error in toMixedBase 1");
#line 818
                    for (d = 0; d < var_rank[i]; d++)
#line 818
                        index2[d] = index[d] + index2[d] * stride[d];
#line 818
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 818
                        NCT_LONGLONG);
#line 818
                    if (inRange3(expect[j],var_type[i],NCT_LONGLONG)) {
#line 818
                        allInIntRange = allInIntRange && expect[j] >= longlong_min
#line 818
                            && expect[j] <= longlong_max;
#line 818
                    } else {
#line 818
                        allInExtRange = 0;
#line 818
                    }
#line 818
                }
#line 818
                if (var_rank[i] == 0 && i%2 )
#line 818
                    err = nc_get_varm_longlong(ncid,i,NULL,NULL,NULL,NULL,value);
#line 818
                else
#line 818
                    err = nc_get_varm_longlong(ncid,i,index,count,stride,imap,value);
#line 818
                if (canConvert) {
#line 818
                    if (allInExtRange) {
#line 818
                        if (allInIntRange) {
#line 818
                            IF (err)
#line 818
                                error("%s", nc_strerror(err));
#line 818
                        } else {
#line 818
                            IF (err != NC_ERANGE)
#line 818
                                error("Range error: status = %d", err);
#line 818
                        }
#line 818
                    } else {
#line 818
                        IF (err != 0 && err != NC_ERANGE)
#line 818
                            error("OK or Range error: status = %d", err);
#line 818
                    }
#line 818
                    for (j = 0; j < nels; j++) {
#line 818
                        if (inRange3(expect[j],var_type[i],NCT_LONGLONG)
#line 818
                                && expect[j] >= longlong_min 
#line 818
				&& expect[j] <= longlong_max) {
#line 818
			    IF (!equal(value[j],expect[j],var_type[i], NCT_LONGLONG)){
#line 818
                                error("value read not that expected");
#line 818
                                if (verbose) {
#line 818
                                    error("\n");
#line 818
                                    error("varid: %d, ", i);
#line 818
                                    error("var_name: %s, ", var_name[i]);
#line 818
                                    error("element number: %d ", j);
#line 818
                                    error("expect: %g, ", expect[j]);
#line 818
                                    error("got: %g", (double) value[j]);
#line 818
                                }
#line 818
                            } else {
#line 818
                                nok++;
#line 818
                            }
#line 818
                        }
#line 818
                    }
#line 818
                } else {
#line 818
                    IF (nels > 0 && err != NC_ECHAR)
#line 818
                        error("wrong type: status = %d", err);
#line 818
                }
#line 818
            }
#line 818
        }
#line 818
    }
#line 818
    err = nc_close(ncid);
#line 818
    IF (err)
#line 818
        error("nc_close: %s", nc_strerror(err));
#line 818
    print_nok(nok);
#line 818
}
#line 818

void
#line 819
test_nc_get_varm_ulonglong(void)
#line 819
{
#line 819
    int ncid;
#line 819
    int d;
#line 819
    int i;
#line 819
    int j;
#line 819
    int k;
#line 819
    int m;
#line 819
    int err;
#line 819
    int allInExtRange;	/* all values within external range? */
#line 819
    int allInIntRange;	/* all values within internal range? */
#line 819
    int nels;
#line 819
    int nslabs;
#line 819
    int nstarts;        /* number of different starts */
#line 819
    int nok = 0;      /* count of valid comparisons */
#line 819
    size_t start[MAX_RANK];
#line 819
    size_t edge[MAX_RANK];
#line 819
    size_t index[MAX_RANK];
#line 819
    size_t index2[MAX_RANK];
#line 819
    size_t mid[MAX_RANK];
#line 819
    size_t count[MAX_RANK];
#line 819
    size_t sstride[MAX_RANK];
#line 819
    ptrdiff_t stride[MAX_RANK];
#line 819
    ptrdiff_t imap[MAX_RANK];
#line 819
    int canConvert;     /* Both text or both numeric */
#line 819
    ulonglong value[MAX_NELS];
#line 819
    double expect[MAX_NELS];
#line 819

#line 819
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 819
    IF (err)
#line 819
        error("nc_open: %s", nc_strerror(err));
#line 819
    for (i = 0; i < numVars; i++) {
#line 819
        canConvert = (var_type[i] == NC_CHAR) == (NCT_ULONGLONG == NCT_TEXT);
#line 819
        assert(var_rank[i] <= MAX_RANK);
#line 819
        assert(var_nels[i] <= MAX_NELS);
#line 819
        for (j = 0; j < var_rank[i]; j++) {
#line 819
            start[j] = 0;
#line 819
            edge[j] = 1;
#line 819
            stride[j] = 1;
#line 819
            imap[j] = 1;
#line 819
        }
#line 819
        err = nc_get_varm_ulonglong(BAD_ID, i, start, edge, stride, imap, value);
#line 819
        IF (err != NC_EBADID)
#line 819
            error("bad ncid: status = %d", err);
#line 819
        err = nc_get_varm_ulonglong(ncid, BAD_VARID, start, edge, stride, imap, value);
#line 819
        IF (err != NC_ENOTVAR)
#line 819
            error("bad var id: status = %d", err);
#line 819
        for (j = 0; j < var_rank[i]; j++) {
#line 819
            start[j] = var_shape[i][j];
#line 819
            err = nc_get_varm_ulonglong(ncid, i, start, edge, stride, imap, value);
#line 819
	  if(!canConvert) {
#line 819
		IF (err != NC_ECHAR)
#line 819
               	    error("conversion: status = %d", err);
#line 819
	  } else {
#line 819
	    IF (err != NC_EINVALCOORDS)
#line 819
                error("bad index: status = %d", err);
#line 819
            start[j] = 0;
#line 819
            edge[j] = var_shape[i][j] + 1;
#line 819
            err = nc_get_varm_ulonglong(ncid, i, start, edge, stride, imap, value);
#line 819
            IF (err != NC_EEDGE)
#line 819
                error("bad edge: status = %d", err);
#line 819
            edge[j] = 1;
#line 819
            stride[j] = 0;
#line 819
            err = nc_get_varm_ulonglong(ncid, i, start, edge, stride, imap, value);
#line 819
            IF (err != NC_ESTRIDE)
#line 819
                error("bad stride: status = %d", err);
#line 819
            stride[j] = 1;
#line 819
           }
#line 819
        }
#line 819
            /* Choose a random point dividing each dim into 2 parts */
#line 819
            /* get 2^rank (nslabs) slabs so defined */
#line 819
        nslabs = 1;
#line 819
        for (j = 0; j < var_rank[i]; j++) {
#line 819
            mid[j] = roll( var_shape[i][j] );
#line 819
            nslabs *= 2;
#line 819
        }
#line 819
            /* bits of k determine whether to get lower or upper part of dim */
#line 819
            /* choose random stride from 1 to edge */
#line 819
        for (k = 0; k < nslabs; k++) {
#line 819
            nstarts = 1;
#line 819
            for (j = 0; j < var_rank[i]; j++) {
#line 819
                if ((k >> j) & 1) {
#line 819
                    start[j] = 0;
#line 819
                    edge[j] = mid[j];
#line 819
                }else{
#line 819
                    start[j] = mid[j];
#line 819
                    edge[j] = var_shape[i][j] - mid[j];
#line 819
                }
#line 819
                sstride[j] = stride[j] = edge[j] > 0 ? 1+roll(edge[j]) : 1;
#line 819
                nstarts *= stride[j];
#line 819
            }
#line 819
            for (m = 0; m < nstarts; m++) {
#line 819
                err = toMixedBase(m, var_rank[i], sstride, index);
#line 819
                IF (err)
#line 819
                    error("error in toMixedBase");
#line 819
                nels = 1;
#line 819
                for (j = 0; j < var_rank[i]; j++) {
#line 819
                    count[j] = 1 + (edge[j] - index[j] - 1) / stride[j];
#line 819
                    nels *= count[j];
#line 819
                    index[j] += start[j];
#line 819
                }
#line 819
		    /* Random choice of forward or backward */
#line 819
/* TODO
#line 819
		if ( roll(2) ) {
#line 819
		    for (j = 0; j < var_rank[i]; j++) {
#line 819
			index[j] += (count[j] - 1) * stride[j];
#line 819
			stride[j] = -stride[j];
#line 819
		    }
#line 819
		}
#line 819
 */
#line 819
		if (var_rank[i] > 0) {
#line 819
		    j = var_rank[i] - 1;
#line 819
		    imap[j] = 1;
#line 819
		    for (; j > 0; j--)
#line 819
			imap[j-1] = imap[j] * count[j];
#line 819
		}
#line 819
                allInExtRange = allInIntRange = 1;
#line 819
                for (j = 0; j < nels; j++) {
#line 819
                    err = toMixedBase(j, var_rank[i], count, index2);
#line 819
                    IF (err)
#line 819
                        error("error in toMixedBase 1");
#line 819
                    for (d = 0; d < var_rank[i]; d++)
#line 819
                        index2[d] = index[d] + index2[d] * stride[d];
#line 819
                    expect[j] = hash4(var_type[i], var_rank[i], index2,
#line 819
                        NCT_ULONGLONG);
#line 819
                    if (inRange3(expect[j],var_type[i],NCT_ULONGLONG)) {
#line 819
                        allInIntRange = allInIntRange && expect[j] >= ulonglong_min
#line 819
                            && expect[j] <= ulonglong_max;
#line 819
                    } else {
#line 819
                        allInExtRange = 0;
#line 819
                    }
#line 819
                }
#line 819
                if (var_rank[i] == 0 && i%2 )
#line 819
                    err = nc_get_varm_ulonglong(ncid,i,NULL,NULL,NULL,NULL,value);
#line 819
                else
#line 819
                    err = nc_get_varm_ulonglong(ncid,i,index,count,stride,imap,value);
#line 819
                if (canConvert) {
#line 819
                    if (allInExtRange) {
#line 819
                        if (allInIntRange) {
#line 819
                            IF (err)
#line 819
                                error("%s", nc_strerror(err));
#line 819
                        } else {
#line 819
                            IF (err != NC_ERANGE)
#line 819
                                error("Range error: status = %d", err);
#line 819
                        }
#line 819
                    } else {
#line 819
                        IF (err != 0 && err != NC_ERANGE)
#line 819
                            error("OK or Range error: status = %d", err);
#line 819
                    }
#line 819
                    for (j = 0; j < nels; j++) {
#line 819
                        if (inRange3(expect[j],var_type[i],NCT_ULONGLONG)
#line 819
                                && expect[j] >= ulonglong_min 
#line 819
				&& expect[j] <= ulonglong_max) {
#line 819
			    IF (!equal(value[j],expect[j],var_type[i], NCT_ULONGLONG)){
#line 819
                                error("value read not that expected");
#line 819
                                if (verbose) {
#line 819
                                    error("\n");
#line 819
                                    error("varid: %d, ", i);
#line 819
                                    error("var_name: %s, ", var_name[i]);
#line 819
                                    error("element number: %d ", j);
#line 819
                                    error("expect: %g, ", expect[j]);
#line 819
                                    error("got: %g", (double) value[j]);
#line 819
                                }
#line 819
                            } else {
#line 819
                                nok++;
#line 819
                            }
#line 819
                        }
#line 819
                    }
#line 819
                } else {
#line 819
                    IF (nels > 0 && err != NC_ECHAR)
#line 819
                        error("wrong type: status = %d", err);
#line 819
                }
#line 819
            }
#line 819
        }
#line 819
    }
#line 819
    err = nc_close(ncid);
#line 819
    IF (err)
#line 819
        error("nc_close: %s", nc_strerror(err));
#line 819
    print_nok(nok);
#line 819
}
#line 819



#line 912

void
#line 913
test_nc_get_att_text(void)
#line 913
{
#line 913
    int ncid;
#line 913
    int i;
#line 913
    int j;
#line 913
    size_t k;
#line 913
    int err;
#line 913
    int allInExtRange;
#line 913
    int allInIntRange;
#line 913
    int canConvert;     /* Both text or both numeric */
#line 913
    text value[MAX_NELS];
#line 913
    double expect[MAX_NELS];
#line 913
    int nok = 0;      /* count of valid comparisons */
#line 913

#line 913
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 913
    IF (err) 
#line 913
	error("nc_open: %s", nc_strerror(err));
#line 913

#line 913
    for (i = -1; i < numVars; i++) {
#line 913
        for (j = 0; j < NATTS(i); j++) {
#line 913
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_TEXT == NCT_TEXT);
#line 913
	    err = nc_get_att_text(BAD_ID, i, ATT_NAME(i,j), value);
#line 913
	    IF (err != NC_EBADID) 
#line 913
		error("bad ncid: status = %d", err);
#line 913
	    err = nc_get_att_text(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 913
	    IF (err != NC_ENOTVAR) 
#line 913
		error("bad var id: status = %d", err);
#line 913
	    err = nc_get_att_text(ncid, i, "noSuch", value);
#line 913
	    IF (err != NC_ENOTATT) 
#line 913
		error("Bad attribute name: status = %d", err);
#line 913
	    allInExtRange = allInIntRange = 1;
#line 913
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 913
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_TEXT);
#line 913
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_TEXT)) {
#line 913
                    allInIntRange = allInIntRange && expect[k] >= text_min
#line 913
                                && expect[k] <= text_max;
#line 913
                } else {
#line 913
                    allInExtRange = 0;
#line 913
                }
#line 913
	    }
#line 913
	    err = nc_get_att_text(ncid, i, ATT_NAME(i,j), value);
#line 913
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 913
                if (allInExtRange) {
#line 913
                    if (allInIntRange) {
#line 913
                        IF (err)
#line 913
                            error("%s", nc_strerror(err));
#line 913
                    } else {
#line 913
                        IF (err != NC_ERANGE)
#line 913
                            error("Range error: status = %d", err);
#line 913
                    }
#line 913
                } else {
#line 913
                    IF (err != 0 && err != NC_ERANGE)
#line 913
                        error("OK or Range error: status = %d", err);
#line 913
                }
#line 913
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 913
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_TEXT)
#line 913
                            && expect[k] >= text_min && expect[k] <= text_max) {
#line 913
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_TEXT)){
#line 913
			    error("value read not that expected");
#line 913
                            if (verbose) {
#line 913
                                error("\n");
#line 913
                                error("varid: %d, ", i);
#line 913
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 913
                                error("element number: %d ", k);
#line 913
                                error("expect: %g", expect[k]);
#line 913
                                error("got: %g", (double) value[k]);
#line 913
                            }
#line 913
			} else {
#line 913
			    nok++;
#line 913
                        }
#line 913
		    }
#line 913
		}
#line 913
	    } else {
#line 913
		IF (err != NC_ECHAR)
#line 913
		    error("wrong type: status = %d", err);
#line 913
	    }
#line 913
	}
#line 913
    }
#line 913

#line 913
    err = nc_close(ncid);
#line 913
    IF (err)
#line 913
	error("nc_close: %s", nc_strerror(err));
#line 913
    print_nok(nok);
#line 913
}
#line 913

void
#line 914
test_nc_get_att_uchar(void)
#line 914
{
#line 914
    int ncid;
#line 914
    int i;
#line 914
    int j;
#line 914
    size_t k;
#line 914
    int err;
#line 914
    int allInExtRange;
#line 914
    int allInIntRange;
#line 914
    int canConvert;     /* Both text or both numeric */
#line 914
    uchar value[MAX_NELS];
#line 914
    double expect[MAX_NELS];
#line 914
    int nok = 0;      /* count of valid comparisons */
#line 914

#line 914
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 914
    IF (err) 
#line 914
	error("nc_open: %s", nc_strerror(err));
#line 914

#line 914
    for (i = -1; i < numVars; i++) {
#line 914
        for (j = 0; j < NATTS(i); j++) {
#line 914
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_UCHAR == NCT_TEXT);
#line 914
	    err = nc_get_att_uchar(BAD_ID, i, ATT_NAME(i,j), value);
#line 914
	    IF (err != NC_EBADID) 
#line 914
		error("bad ncid: status = %d", err);
#line 914
	    err = nc_get_att_uchar(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 914
	    IF (err != NC_ENOTVAR) 
#line 914
		error("bad var id: status = %d", err);
#line 914
	    err = nc_get_att_uchar(ncid, i, "noSuch", value);
#line 914
	    IF (err != NC_ENOTATT) 
#line 914
		error("Bad attribute name: status = %d", err);
#line 914
	    allInExtRange = allInIntRange = 1;
#line 914
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 914
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_UCHAR);
#line 914
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_UCHAR)) {
#line 914
                    allInIntRange = allInIntRange && expect[k] >= uchar_min
#line 914
                                && expect[k] <= uchar_max;
#line 914
                } else {
#line 914
                    allInExtRange = 0;
#line 914
                }
#line 914
	    }
#line 914
	    err = nc_get_att_uchar(ncid, i, ATT_NAME(i,j), value);
#line 914
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 914
                if (allInExtRange) {
#line 914
                    if (allInIntRange) {
#line 914
                        IF (err)
#line 914
                            error("%s", nc_strerror(err));
#line 914
                    } else {
#line 914
                        IF (err != NC_ERANGE)
#line 914
                            error("Range error: status = %d", err);
#line 914
                    }
#line 914
                } else {
#line 914
                    IF (err != 0 && err != NC_ERANGE)
#line 914
                        error("OK or Range error: status = %d", err);
#line 914
                }
#line 914
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 914
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_UCHAR)
#line 914
                            && expect[k] >= uchar_min && expect[k] <= uchar_max) {
#line 914
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_UCHAR)){
#line 914
			    error("value read not that expected");
#line 914
                            if (verbose) {
#line 914
                                error("\n");
#line 914
                                error("varid: %d, ", i);
#line 914
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 914
                                error("element number: %d ", k);
#line 914
                                error("expect: %g", expect[k]);
#line 914
                                error("got: %g", (double) value[k]);
#line 914
                            }
#line 914
			} else {
#line 914
			    nok++;
#line 914
                        }
#line 914
		    }
#line 914
		}
#line 914
	    } else {
#line 914
		IF (err != NC_ECHAR)
#line 914
		    error("wrong type: status = %d", err);
#line 914
	    }
#line 914
	}
#line 914
    }
#line 914

#line 914
    err = nc_close(ncid);
#line 914
    IF (err)
#line 914
	error("nc_close: %s", nc_strerror(err));
#line 914
    print_nok(nok);
#line 914
}
#line 914

void
#line 915
test_nc_get_att_schar(void)
#line 915
{
#line 915
    int ncid;
#line 915
    int i;
#line 915
    int j;
#line 915
    size_t k;
#line 915
    int err;
#line 915
    int allInExtRange;
#line 915
    int allInIntRange;
#line 915
    int canConvert;     /* Both text or both numeric */
#line 915
    schar value[MAX_NELS];
#line 915
    double expect[MAX_NELS];
#line 915
    int nok = 0;      /* count of valid comparisons */
#line 915

#line 915
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 915
    IF (err) 
#line 915
	error("nc_open: %s", nc_strerror(err));
#line 915

#line 915
    for (i = -1; i < numVars; i++) {
#line 915
        for (j = 0; j < NATTS(i); j++) {
#line 915
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_SCHAR == NCT_TEXT);
#line 915
	    err = nc_get_att_schar(BAD_ID, i, ATT_NAME(i,j), value);
#line 915
	    IF (err != NC_EBADID) 
#line 915
		error("bad ncid: status = %d", err);
#line 915
	    err = nc_get_att_schar(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 915
	    IF (err != NC_ENOTVAR) 
#line 915
		error("bad var id: status = %d", err);
#line 915
	    err = nc_get_att_schar(ncid, i, "noSuch", value);
#line 915
	    IF (err != NC_ENOTATT) 
#line 915
		error("Bad attribute name: status = %d", err);
#line 915
	    allInExtRange = allInIntRange = 1;
#line 915
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 915
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_SCHAR);
#line 915
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_SCHAR)) {
#line 915
                    allInIntRange = allInIntRange && expect[k] >= schar_min
#line 915
                                && expect[k] <= schar_max;
#line 915
                } else {
#line 915
                    allInExtRange = 0;
#line 915
                }
#line 915
	    }
#line 915
	    err = nc_get_att_schar(ncid, i, ATT_NAME(i,j), value);
#line 915
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 915
                if (allInExtRange) {
#line 915
                    if (allInIntRange) {
#line 915
                        IF (err)
#line 915
                            error("%s", nc_strerror(err));
#line 915
                    } else {
#line 915
                        IF (err != NC_ERANGE)
#line 915
                            error("Range error: status = %d", err);
#line 915
                    }
#line 915
                } else {
#line 915
                    IF (err != 0 && err != NC_ERANGE)
#line 915
                        error("OK or Range error: status = %d", err);
#line 915
                }
#line 915
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 915
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_SCHAR)
#line 915
                            && expect[k] >= schar_min && expect[k] <= schar_max) {
#line 915
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_SCHAR)){
#line 915
			    error("value read not that expected");
#line 915
                            if (verbose) {
#line 915
                                error("\n");
#line 915
                                error("varid: %d, ", i);
#line 915
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 915
                                error("element number: %d ", k);
#line 915
                                error("expect: %g", expect[k]);
#line 915
                                error("got: %g", (double) value[k]);
#line 915
                            }
#line 915
			} else {
#line 915
			    nok++;
#line 915
                        }
#line 915
		    }
#line 915
		}
#line 915
	    } else {
#line 915
		IF (err != NC_ECHAR)
#line 915
		    error("wrong type: status = %d", err);
#line 915
	    }
#line 915
	}
#line 915
    }
#line 915

#line 915
    err = nc_close(ncid);
#line 915
    IF (err)
#line 915
	error("nc_close: %s", nc_strerror(err));
#line 915
    print_nok(nok);
#line 915
}
#line 915

void
#line 916
test_nc_get_att_short(void)
#line 916
{
#line 916
    int ncid;
#line 916
    int i;
#line 916
    int j;
#line 916
    size_t k;
#line 916
    int err;
#line 916
    int allInExtRange;
#line 916
    int allInIntRange;
#line 916
    int canConvert;     /* Both text or both numeric */
#line 916
    short value[MAX_NELS];
#line 916
    double expect[MAX_NELS];
#line 916
    int nok = 0;      /* count of valid comparisons */
#line 916

#line 916
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 916
    IF (err) 
#line 916
	error("nc_open: %s", nc_strerror(err));
#line 916

#line 916
    for (i = -1; i < numVars; i++) {
#line 916
        for (j = 0; j < NATTS(i); j++) {
#line 916
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_SHORT == NCT_TEXT);
#line 916
	    err = nc_get_att_short(BAD_ID, i, ATT_NAME(i,j), value);
#line 916
	    IF (err != NC_EBADID) 
#line 916
		error("bad ncid: status = %d", err);
#line 916
	    err = nc_get_att_short(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 916
	    IF (err != NC_ENOTVAR) 
#line 916
		error("bad var id: status = %d", err);
#line 916
	    err = nc_get_att_short(ncid, i, "noSuch", value);
#line 916
	    IF (err != NC_ENOTATT) 
#line 916
		error("Bad attribute name: status = %d", err);
#line 916
	    allInExtRange = allInIntRange = 1;
#line 916
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 916
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_SHORT);
#line 916
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_SHORT)) {
#line 916
                    allInIntRange = allInIntRange && expect[k] >= short_min
#line 916
                                && expect[k] <= short_max;
#line 916
                } else {
#line 916
                    allInExtRange = 0;
#line 916
                }
#line 916
	    }
#line 916
	    err = nc_get_att_short(ncid, i, ATT_NAME(i,j), value);
#line 916
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 916
                if (allInExtRange) {
#line 916
                    if (allInIntRange) {
#line 916
                        IF (err)
#line 916
                            error("%s", nc_strerror(err));
#line 916
                    } else {
#line 916
                        IF (err != NC_ERANGE)
#line 916
                            error("Range error: status = %d", err);
#line 916
                    }
#line 916
                } else {
#line 916
                    IF (err != 0 && err != NC_ERANGE)
#line 916
                        error("OK or Range error: status = %d", err);
#line 916
                }
#line 916
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 916
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_SHORT)
#line 916
                            && expect[k] >= short_min && expect[k] <= short_max) {
#line 916
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_SHORT)){
#line 916
			    error("value read not that expected");
#line 916
                            if (verbose) {
#line 916
                                error("\n");
#line 916
                                error("varid: %d, ", i);
#line 916
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 916
                                error("element number: %d ", k);
#line 916
                                error("expect: %g", expect[k]);
#line 916
                                error("got: %g", (double) value[k]);
#line 916
                            }
#line 916
			} else {
#line 916
			    nok++;
#line 916
                        }
#line 916
		    }
#line 916
		}
#line 916
	    } else {
#line 916
		IF (err != NC_ECHAR)
#line 916
		    error("wrong type: status = %d", err);
#line 916
	    }
#line 916
	}
#line 916
    }
#line 916

#line 916
    err = nc_close(ncid);
#line 916
    IF (err)
#line 916
	error("nc_close: %s", nc_strerror(err));
#line 916
    print_nok(nok);
#line 916
}
#line 916

void
#line 917
test_nc_get_att_int(void)
#line 917
{
#line 917
    int ncid;
#line 917
    int i;
#line 917
    int j;
#line 917
    size_t k;
#line 917
    int err;
#line 917
    int allInExtRange;
#line 917
    int allInIntRange;
#line 917
    int canConvert;     /* Both text or both numeric */
#line 917
    int value[MAX_NELS];
#line 917
    double expect[MAX_NELS];
#line 917
    int nok = 0;      /* count of valid comparisons */
#line 917

#line 917
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 917
    IF (err) 
#line 917
	error("nc_open: %s", nc_strerror(err));
#line 917

#line 917
    for (i = -1; i < numVars; i++) {
#line 917
        for (j = 0; j < NATTS(i); j++) {
#line 917
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_INT == NCT_TEXT);
#line 917
	    err = nc_get_att_int(BAD_ID, i, ATT_NAME(i,j), value);
#line 917
	    IF (err != NC_EBADID) 
#line 917
		error("bad ncid: status = %d", err);
#line 917
	    err = nc_get_att_int(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 917
	    IF (err != NC_ENOTVAR) 
#line 917
		error("bad var id: status = %d", err);
#line 917
	    err = nc_get_att_int(ncid, i, "noSuch", value);
#line 917
	    IF (err != NC_ENOTATT) 
#line 917
		error("Bad attribute name: status = %d", err);
#line 917
	    allInExtRange = allInIntRange = 1;
#line 917
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 917
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_INT);
#line 917
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_INT)) {
#line 917
                    allInIntRange = allInIntRange && expect[k] >= int_min
#line 917
                                && expect[k] <= int_max;
#line 917
                } else {
#line 917
                    allInExtRange = 0;
#line 917
                }
#line 917
	    }
#line 917
	    err = nc_get_att_int(ncid, i, ATT_NAME(i,j), value);
#line 917
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 917
                if (allInExtRange) {
#line 917
                    if (allInIntRange) {
#line 917
                        IF (err)
#line 917
                            error("%s", nc_strerror(err));
#line 917
                    } else {
#line 917
                        IF (err != NC_ERANGE)
#line 917
                            error("Range error: status = %d", err);
#line 917
                    }
#line 917
                } else {
#line 917
                    IF (err != 0 && err != NC_ERANGE)
#line 917
                        error("OK or Range error: status = %d", err);
#line 917
                }
#line 917
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 917
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_INT)
#line 917
                            && expect[k] >= int_min && expect[k] <= int_max) {
#line 917
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_INT)){
#line 917
			    error("value read not that expected");
#line 917
                            if (verbose) {
#line 917
                                error("\n");
#line 917
                                error("varid: %d, ", i);
#line 917
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 917
                                error("element number: %d ", k);
#line 917
                                error("expect: %g", expect[k]);
#line 917
                                error("got: %g", (double) value[k]);
#line 917
                            }
#line 917
			} else {
#line 917
			    nok++;
#line 917
                        }
#line 917
		    }
#line 917
		}
#line 917
	    } else {
#line 917
		IF (err != NC_ECHAR)
#line 917
		    error("wrong type: status = %d", err);
#line 917
	    }
#line 917
	}
#line 917
    }
#line 917

#line 917
    err = nc_close(ncid);
#line 917
    IF (err)
#line 917
	error("nc_close: %s", nc_strerror(err));
#line 917
    print_nok(nok);
#line 917
}
#line 917

void
#line 918
test_nc_get_att_long(void)
#line 918
{
#line 918
    int ncid;
#line 918
    int i;
#line 918
    int j;
#line 918
    size_t k;
#line 918
    int err;
#line 918
    int allInExtRange;
#line 918
    int allInIntRange;
#line 918
    int canConvert;     /* Both text or both numeric */
#line 918
    long value[MAX_NELS];
#line 918
    double expect[MAX_NELS];
#line 918
    int nok = 0;      /* count of valid comparisons */
#line 918

#line 918
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 918
    IF (err) 
#line 918
	error("nc_open: %s", nc_strerror(err));
#line 918

#line 918
    for (i = -1; i < numVars; i++) {
#line 918
        for (j = 0; j < NATTS(i); j++) {
#line 918
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_LONG == NCT_TEXT);
#line 918
	    err = nc_get_att_long(BAD_ID, i, ATT_NAME(i,j), value);
#line 918
	    IF (err != NC_EBADID) 
#line 918
		error("bad ncid: status = %d", err);
#line 918
	    err = nc_get_att_long(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 918
	    IF (err != NC_ENOTVAR) 
#line 918
		error("bad var id: status = %d", err);
#line 918
	    err = nc_get_att_long(ncid, i, "noSuch", value);
#line 918
	    IF (err != NC_ENOTATT) 
#line 918
		error("Bad attribute name: status = %d", err);
#line 918
	    allInExtRange = allInIntRange = 1;
#line 918
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 918
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_LONG);
#line 918
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_LONG)) {
#line 918
                    allInIntRange = allInIntRange && expect[k] >= long_min
#line 918
                                && expect[k] <= long_max;
#line 918
                } else {
#line 918
                    allInExtRange = 0;
#line 918
                }
#line 918
	    }
#line 918
	    err = nc_get_att_long(ncid, i, ATT_NAME(i,j), value);
#line 918
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 918
                if (allInExtRange) {
#line 918
                    if (allInIntRange) {
#line 918
                        IF (err)
#line 918
                            error("%s", nc_strerror(err));
#line 918
                    } else {
#line 918
                        IF (err != NC_ERANGE)
#line 918
                            error("Range error: status = %d", err);
#line 918
                    }
#line 918
                } else {
#line 918
                    IF (err != 0 && err != NC_ERANGE)
#line 918
                        error("OK or Range error: status = %d", err);
#line 918
                }
#line 918
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 918
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_LONG)
#line 918
                            && expect[k] >= long_min && expect[k] <= long_max) {
#line 918
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_LONG)){
#line 918
			    error("value read not that expected");
#line 918
                            if (verbose) {
#line 918
                                error("\n");
#line 918
                                error("varid: %d, ", i);
#line 918
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 918
                                error("element number: %d ", k);
#line 918
                                error("expect: %g", expect[k]);
#line 918
                                error("got: %g", (double) value[k]);
#line 918
                            }
#line 918
			} else {
#line 918
			    nok++;
#line 918
                        }
#line 918
		    }
#line 918
		}
#line 918
	    } else {
#line 918
		IF (err != NC_ECHAR)
#line 918
		    error("wrong type: status = %d", err);
#line 918
	    }
#line 918
	}
#line 918
    }
#line 918

#line 918
    err = nc_close(ncid);
#line 918
    IF (err)
#line 918
	error("nc_close: %s", nc_strerror(err));
#line 918
    print_nok(nok);
#line 918
}
#line 918

void
#line 919
test_nc_get_att_float(void)
#line 919
{
#line 919
    int ncid;
#line 919
    int i;
#line 919
    int j;
#line 919
    size_t k;
#line 919
    int err;
#line 919
    int allInExtRange;
#line 919
    int allInIntRange;
#line 919
    int canConvert;     /* Both text or both numeric */
#line 919
    float value[MAX_NELS];
#line 919
    double expect[MAX_NELS];
#line 919
    int nok = 0;      /* count of valid comparisons */
#line 919

#line 919
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 919
    IF (err) 
#line 919
	error("nc_open: %s", nc_strerror(err));
#line 919

#line 919
    for (i = -1; i < numVars; i++) {
#line 919
        for (j = 0; j < NATTS(i); j++) {
#line 919
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_FLOAT == NCT_TEXT);
#line 919
	    err = nc_get_att_float(BAD_ID, i, ATT_NAME(i,j), value);
#line 919
	    IF (err != NC_EBADID) 
#line 919
		error("bad ncid: status = %d", err);
#line 919
	    err = nc_get_att_float(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 919
	    IF (err != NC_ENOTVAR) 
#line 919
		error("bad var id: status = %d", err);
#line 919
	    err = nc_get_att_float(ncid, i, "noSuch", value);
#line 919
	    IF (err != NC_ENOTATT) 
#line 919
		error("Bad attribute name: status = %d", err);
#line 919
	    allInExtRange = allInIntRange = 1;
#line 919
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 919
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_FLOAT);
#line 919
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_FLOAT)) {
#line 919
                    allInIntRange = allInIntRange && expect[k] >= float_min
#line 919
                                && expect[k] <= float_max;
#line 919
                } else {
#line 919
                    allInExtRange = 0;
#line 919
                }
#line 919
	    }
#line 919
	    err = nc_get_att_float(ncid, i, ATT_NAME(i,j), value);
#line 919
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 919
                if (allInExtRange) {
#line 919
                    if (allInIntRange) {
#line 919
                        IF (err)
#line 919
                            error("%s", nc_strerror(err));
#line 919
                    } else {
#line 919
                        IF (err != NC_ERANGE)
#line 919
                            error("Range error: status = %d", err);
#line 919
                    }
#line 919
                } else {
#line 919
                    IF (err != 0 && err != NC_ERANGE)
#line 919
                        error("OK or Range error: status = %d", err);
#line 919
                }
#line 919
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 919
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_FLOAT)
#line 919
                            && expect[k] >= float_min && expect[k] <= float_max) {
#line 919
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_FLOAT)){
#line 919
			    error("value read not that expected");
#line 919
                            if (verbose) {
#line 919
                                error("\n");
#line 919
                                error("varid: %d, ", i);
#line 919
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 919
                                error("element number: %d ", k);
#line 919
                                error("expect: %g", expect[k]);
#line 919
                                error("got: %g", (double) value[k]);
#line 919
                            }
#line 919
			} else {
#line 919
			    nok++;
#line 919
                        }
#line 919
		    }
#line 919
		}
#line 919
	    } else {
#line 919
		IF (err != NC_ECHAR)
#line 919
		    error("wrong type: status = %d", err);
#line 919
	    }
#line 919
	}
#line 919
    }
#line 919

#line 919
    err = nc_close(ncid);
#line 919
    IF (err)
#line 919
	error("nc_close: %s", nc_strerror(err));
#line 919
    print_nok(nok);
#line 919
}
#line 919

void
#line 920
test_nc_get_att_double(void)
#line 920
{
#line 920
    int ncid;
#line 920
    int i;
#line 920
    int j;
#line 920
    size_t k;
#line 920
    int err;
#line 920
    int allInExtRange;
#line 920
    int allInIntRange;
#line 920
    int canConvert;     /* Both text or both numeric */
#line 920
    double value[MAX_NELS];
#line 920
    double expect[MAX_NELS];
#line 920
    int nok = 0;      /* count of valid comparisons */
#line 920

#line 920
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 920
    IF (err) 
#line 920
	error("nc_open: %s", nc_strerror(err));
#line 920

#line 920
    for (i = -1; i < numVars; i++) {
#line 920
        for (j = 0; j < NATTS(i); j++) {
#line 920
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_DOUBLE == NCT_TEXT);
#line 920
	    err = nc_get_att_double(BAD_ID, i, ATT_NAME(i,j), value);
#line 920
	    IF (err != NC_EBADID) 
#line 920
		error("bad ncid: status = %d", err);
#line 920
	    err = nc_get_att_double(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 920
	    IF (err != NC_ENOTVAR) 
#line 920
		error("bad var id: status = %d", err);
#line 920
	    err = nc_get_att_double(ncid, i, "noSuch", value);
#line 920
	    IF (err != NC_ENOTATT) 
#line 920
		error("Bad attribute name: status = %d", err);
#line 920
	    allInExtRange = allInIntRange = 1;
#line 920
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 920
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_DOUBLE);
#line 920
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_DOUBLE)) {
#line 920
                    allInIntRange = allInIntRange && expect[k] >= double_min
#line 920
                                && expect[k] <= double_max;
#line 920
                } else {
#line 920
                    allInExtRange = 0;
#line 920
                }
#line 920
	    }
#line 920
	    err = nc_get_att_double(ncid, i, ATT_NAME(i,j), value);
#line 920
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 920
                if (allInExtRange) {
#line 920
                    if (allInIntRange) {
#line 920
                        IF (err)
#line 920
                            error("%s", nc_strerror(err));
#line 920
                    } else {
#line 920
                        IF (err != NC_ERANGE)
#line 920
                            error("Range error: status = %d", err);
#line 920
                    }
#line 920
                } else {
#line 920
                    IF (err != 0 && err != NC_ERANGE)
#line 920
                        error("OK or Range error: status = %d", err);
#line 920
                }
#line 920
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 920
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_DOUBLE)
#line 920
                            && expect[k] >= double_min && expect[k] <= double_max) {
#line 920
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_DOUBLE)){
#line 920
			    error("value read not that expected");
#line 920
                            if (verbose) {
#line 920
                                error("\n");
#line 920
                                error("varid: %d, ", i);
#line 920
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 920
                                error("element number: %d ", k);
#line 920
                                error("expect: %g", expect[k]);
#line 920
                                error("got: %g", (double) value[k]);
#line 920
                            }
#line 920
			} else {
#line 920
			    nok++;
#line 920
                        }
#line 920
		    }
#line 920
		}
#line 920
	    } else {
#line 920
		IF (err != NC_ECHAR)
#line 920
		    error("wrong type: status = %d", err);
#line 920
	    }
#line 920
	}
#line 920
    }
#line 920

#line 920
    err = nc_close(ncid);
#line 920
    IF (err)
#line 920
	error("nc_close: %s", nc_strerror(err));
#line 920
    print_nok(nok);
#line 920
}
#line 920

void
#line 921
test_nc_get_att_ushort(void)
#line 921
{
#line 921
    int ncid;
#line 921
    int i;
#line 921
    int j;
#line 921
    size_t k;
#line 921
    int err;
#line 921
    int allInExtRange;
#line 921
    int allInIntRange;
#line 921
    int canConvert;     /* Both text or both numeric */
#line 921
    ushort value[MAX_NELS];
#line 921
    double expect[MAX_NELS];
#line 921
    int nok = 0;      /* count of valid comparisons */
#line 921

#line 921
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 921
    IF (err) 
#line 921
	error("nc_open: %s", nc_strerror(err));
#line 921

#line 921
    for (i = -1; i < numVars; i++) {
#line 921
        for (j = 0; j < NATTS(i); j++) {
#line 921
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_USHORT == NCT_TEXT);
#line 921
	    err = nc_get_att_ushort(BAD_ID, i, ATT_NAME(i,j), value);
#line 921
	    IF (err != NC_EBADID) 
#line 921
		error("bad ncid: status = %d", err);
#line 921
	    err = nc_get_att_ushort(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 921
	    IF (err != NC_ENOTVAR) 
#line 921
		error("bad var id: status = %d", err);
#line 921
	    err = nc_get_att_ushort(ncid, i, "noSuch", value);
#line 921
	    IF (err != NC_ENOTATT) 
#line 921
		error("Bad attribute name: status = %d", err);
#line 921
	    allInExtRange = allInIntRange = 1;
#line 921
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 921
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_USHORT);
#line 921
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_USHORT)) {
#line 921
                    allInIntRange = allInIntRange && expect[k] >= ushort_min
#line 921
                                && expect[k] <= ushort_max;
#line 921
                } else {
#line 921
                    allInExtRange = 0;
#line 921
                }
#line 921
	    }
#line 921
	    err = nc_get_att_ushort(ncid, i, ATT_NAME(i,j), value);
#line 921
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 921
                if (allInExtRange) {
#line 921
                    if (allInIntRange) {
#line 921
                        IF (err)
#line 921
                            error("%s", nc_strerror(err));
#line 921
                    } else {
#line 921
                        IF (err != NC_ERANGE)
#line 921
                            error("Range error: status = %d", err);
#line 921
                    }
#line 921
                } else {
#line 921
                    IF (err != 0 && err != NC_ERANGE)
#line 921
                        error("OK or Range error: status = %d", err);
#line 921
                }
#line 921
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 921
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_USHORT)
#line 921
                            && expect[k] >= ushort_min && expect[k] <= ushort_max) {
#line 921
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_USHORT)){
#line 921
			    error("value read not that expected");
#line 921
                            if (verbose) {
#line 921
                                error("\n");
#line 921
                                error("varid: %d, ", i);
#line 921
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 921
                                error("element number: %d ", k);
#line 921
                                error("expect: %g", expect[k]);
#line 921
                                error("got: %g", (double) value[k]);
#line 921
                            }
#line 921
			} else {
#line 921
			    nok++;
#line 921
                        }
#line 921
		    }
#line 921
		}
#line 921
	    } else {
#line 921
		IF (err != NC_ECHAR)
#line 921
		    error("wrong type: status = %d", err);
#line 921
	    }
#line 921
	}
#line 921
    }
#line 921

#line 921
    err = nc_close(ncid);
#line 921
    IF (err)
#line 921
	error("nc_close: %s", nc_strerror(err));
#line 921
    print_nok(nok);
#line 921
}
#line 921

void
#line 922
test_nc_get_att_uint(void)
#line 922
{
#line 922
    int ncid;
#line 922
    int i;
#line 922
    int j;
#line 922
    size_t k;
#line 922
    int err;
#line 922
    int allInExtRange;
#line 922
    int allInIntRange;
#line 922
    int canConvert;     /* Both text or both numeric */
#line 922
    uint value[MAX_NELS];
#line 922
    double expect[MAX_NELS];
#line 922
    int nok = 0;      /* count of valid comparisons */
#line 922

#line 922
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 922
    IF (err) 
#line 922
	error("nc_open: %s", nc_strerror(err));
#line 922

#line 922
    for (i = -1; i < numVars; i++) {
#line 922
        for (j = 0; j < NATTS(i); j++) {
#line 922
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_UINT == NCT_TEXT);
#line 922
	    err = nc_get_att_uint(BAD_ID, i, ATT_NAME(i,j), value);
#line 922
	    IF (err != NC_EBADID) 
#line 922
		error("bad ncid: status = %d", err);
#line 922
	    err = nc_get_att_uint(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 922
	    IF (err != NC_ENOTVAR) 
#line 922
		error("bad var id: status = %d", err);
#line 922
	    err = nc_get_att_uint(ncid, i, "noSuch", value);
#line 922
	    IF (err != NC_ENOTATT) 
#line 922
		error("Bad attribute name: status = %d", err);
#line 922
	    allInExtRange = allInIntRange = 1;
#line 922
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 922
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_UINT);
#line 922
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_UINT)) {
#line 922
                    allInIntRange = allInIntRange && expect[k] >= uint_min
#line 922
                                && expect[k] <= uint_max;
#line 922
                } else {
#line 922
                    allInExtRange = 0;
#line 922
                }
#line 922
	    }
#line 922
	    err = nc_get_att_uint(ncid, i, ATT_NAME(i,j), value);
#line 922
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 922
                if (allInExtRange) {
#line 922
                    if (allInIntRange) {
#line 922
                        IF (err)
#line 922
                            error("%s", nc_strerror(err));
#line 922
                    } else {
#line 922
                        IF (err != NC_ERANGE)
#line 922
                            error("Range error: status = %d", err);
#line 922
                    }
#line 922
                } else {
#line 922
                    IF (err != 0 && err != NC_ERANGE)
#line 922
                        error("OK or Range error: status = %d", err);
#line 922
                }
#line 922
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 922
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_UINT)
#line 922
                            && expect[k] >= uint_min && expect[k] <= uint_max) {
#line 922
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_UINT)){
#line 922
			    error("value read not that expected");
#line 922
                            if (verbose) {
#line 922
                                error("\n");
#line 922
                                error("varid: %d, ", i);
#line 922
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 922
                                error("element number: %d ", k);
#line 922
                                error("expect: %g", expect[k]);
#line 922
                                error("got: %g", (double) value[k]);
#line 922
                            }
#line 922
			} else {
#line 922
			    nok++;
#line 922
                        }
#line 922
		    }
#line 922
		}
#line 922
	    } else {
#line 922
		IF (err != NC_ECHAR)
#line 922
		    error("wrong type: status = %d", err);
#line 922
	    }
#line 922
	}
#line 922
    }
#line 922

#line 922
    err = nc_close(ncid);
#line 922
    IF (err)
#line 922
	error("nc_close: %s", nc_strerror(err));
#line 922
    print_nok(nok);
#line 922
}
#line 922

void
#line 923
test_nc_get_att_longlong(void)
#line 923
{
#line 923
    int ncid;
#line 923
    int i;
#line 923
    int j;
#line 923
    size_t k;
#line 923
    int err;
#line 923
    int allInExtRange;
#line 923
    int allInIntRange;
#line 923
    int canConvert;     /* Both text or both numeric */
#line 923
    longlong value[MAX_NELS];
#line 923
    double expect[MAX_NELS];
#line 923
    int nok = 0;      /* count of valid comparisons */
#line 923

#line 923
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 923
    IF (err) 
#line 923
	error("nc_open: %s", nc_strerror(err));
#line 923

#line 923
    for (i = -1; i < numVars; i++) {
#line 923
        for (j = 0; j < NATTS(i); j++) {
#line 923
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_LONGLONG == NCT_TEXT);
#line 923
	    err = nc_get_att_longlong(BAD_ID, i, ATT_NAME(i,j), value);
#line 923
	    IF (err != NC_EBADID) 
#line 923
		error("bad ncid: status = %d", err);
#line 923
	    err = nc_get_att_longlong(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 923
	    IF (err != NC_ENOTVAR) 
#line 923
		error("bad var id: status = %d", err);
#line 923
	    err = nc_get_att_longlong(ncid, i, "noSuch", value);
#line 923
	    IF (err != NC_ENOTATT) 
#line 923
		error("Bad attribute name: status = %d", err);
#line 923
	    allInExtRange = allInIntRange = 1;
#line 923
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 923
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_LONGLONG);
#line 923
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_LONGLONG)) {
#line 923
                    allInIntRange = allInIntRange && expect[k] >= longlong_min
#line 923
                                && expect[k] <= longlong_max;
#line 923
                } else {
#line 923
                    allInExtRange = 0;
#line 923
                }
#line 923
	    }
#line 923
	    err = nc_get_att_longlong(ncid, i, ATT_NAME(i,j), value);
#line 923
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 923
                if (allInExtRange) {
#line 923
                    if (allInIntRange) {
#line 923
                        IF (err)
#line 923
                            error("%s", nc_strerror(err));
#line 923
                    } else {
#line 923
                        IF (err != NC_ERANGE)
#line 923
                            error("Range error: status = %d", err);
#line 923
                    }
#line 923
                } else {
#line 923
                    IF (err != 0 && err != NC_ERANGE)
#line 923
                        error("OK or Range error: status = %d", err);
#line 923
                }
#line 923
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 923
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_LONGLONG)
#line 923
                            && expect[k] >= longlong_min && expect[k] <= longlong_max) {
#line 923
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_LONGLONG)){
#line 923
			    error("value read not that expected");
#line 923
                            if (verbose) {
#line 923
                                error("\n");
#line 923
                                error("varid: %d, ", i);
#line 923
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 923
                                error("element number: %d ", k);
#line 923
                                error("expect: %g", expect[k]);
#line 923
                                error("got: %g", (double) value[k]);
#line 923
                            }
#line 923
			} else {
#line 923
			    nok++;
#line 923
                        }
#line 923
		    }
#line 923
		}
#line 923
	    } else {
#line 923
		IF (err != NC_ECHAR)
#line 923
		    error("wrong type: status = %d", err);
#line 923
	    }
#line 923
	}
#line 923
    }
#line 923

#line 923
    err = nc_close(ncid);
#line 923
    IF (err)
#line 923
	error("nc_close: %s", nc_strerror(err));
#line 923
    print_nok(nok);
#line 923
}
#line 923

void
#line 924
test_nc_get_att_ulonglong(void)
#line 924
{
#line 924
    int ncid;
#line 924
    int i;
#line 924
    int j;
#line 924
    size_t k;
#line 924
    int err;
#line 924
    int allInExtRange;
#line 924
    int allInIntRange;
#line 924
    int canConvert;     /* Both text or both numeric */
#line 924
    ulonglong value[MAX_NELS];
#line 924
    double expect[MAX_NELS];
#line 924
    int nok = 0;      /* count of valid comparisons */
#line 924

#line 924
    err = file_open(testfile, NC_NOWRITE, &ncid);
#line 924
    IF (err) 
#line 924
	error("nc_open: %s", nc_strerror(err));
#line 924

#line 924
    for (i = -1; i < numVars; i++) {
#line 924
        for (j = 0; j < NATTS(i); j++) {
#line 924
	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_ULONGLONG == NCT_TEXT);
#line 924
	    err = nc_get_att_ulonglong(BAD_ID, i, ATT_NAME(i,j), value);
#line 924
	    IF (err != NC_EBADID) 
#line 924
		error("bad ncid: status = %d", err);
#line 924
	    err = nc_get_att_ulonglong(ncid, BAD_VARID, ATT_NAME(i,j), value);
#line 924
	    IF (err != NC_ENOTVAR) 
#line 924
		error("bad var id: status = %d", err);
#line 924
	    err = nc_get_att_ulonglong(ncid, i, "noSuch", value);
#line 924
	    IF (err != NC_ENOTATT) 
#line 924
		error("Bad attribute name: status = %d", err);
#line 924
	    allInExtRange = allInIntRange = 1;
#line 924
            for (k = 0; k < ATT_LEN(i,j); k++) {
#line 924
		expect[k] = hash4(ATT_TYPE(i,j), -1, &k, NCT_ULONGLONG);
#line 924
                if (inRange3(expect[k],ATT_TYPE(i,j),NCT_ULONGLONG)) {
#line 924
                    allInIntRange = allInIntRange && expect[k] >= ulonglong_min
#line 924
                                && expect[k] <= ulonglong_max;
#line 924
                } else {
#line 924
                    allInExtRange = 0;
#line 924
                }
#line 924
	    }
#line 924
	    err = nc_get_att_ulonglong(ncid, i, ATT_NAME(i,j), value);
#line 924
            if (canConvert || ATT_LEN(i,j) == 0) {
#line 924
                if (allInExtRange) {
#line 924
                    if (allInIntRange) {
#line 924
                        IF (err)
#line 924
                            error("%s", nc_strerror(err));
#line 924
                    } else {
#line 924
                        IF (err != NC_ERANGE)
#line 924
                            error("Range error: status = %d", err);
#line 924
                    }
#line 924
                } else {
#line 924
                    IF (err != 0 && err != NC_ERANGE)
#line 924
                        error("OK or Range error: status = %d", err);
#line 924
                }
#line 924
		for (k = 0; k < ATT_LEN(i,j); k++) {
#line 924
		    if (inRange3(expect[k],ATT_TYPE(i,j),NCT_ULONGLONG)
#line 924
                            && expect[k] >= ulonglong_min && expect[k] <= ulonglong_max) {
#line 924
			IF (!equal(value[k],expect[k],ATT_TYPE(i,j), NCT_ULONGLONG)){
#line 924
			    error("value read not that expected");
#line 924
                            if (verbose) {
#line 924
                                error("\n");
#line 924
                                error("varid: %d, ", i);
#line 924
                                error("att_name: %s, ", ATT_NAME(i,j));
#line 924
                                error("element number: %d ", k);
#line 924
                                error("expect: %g", expect[k]);
#line 924
                                error("got: %g", (double) value[k]);
#line 924
                            }
#line 924
			} else {
#line 924
			    nok++;
#line 924
                        }
#line 924
		    }
#line 924
		}
#line 924
	    } else {
#line 924
		IF (err != NC_ECHAR)
#line 924
		    error("wrong type: status = %d", err);
#line 924
	    }
#line 924
	}
#line 924
    }
#line 924

#line 924
    err = nc_close(ncid);
#line 924
    IF (err)
#line 924
	error("nc_close: %s", nc_strerror(err));
#line 924
    print_nok(nok);
#line 924
}
#line 924


