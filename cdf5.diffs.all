diff netcdf-c/configure.ac cdf5/configure.ac
--- netcdf-c/configure.ac	2015-03-09 13:48:02.638959500 -0600
+++ cdf5/configure.ac	2014-11-14 14:54:45.975684700 -0700
@@ -766,7 +766,7 @@
 UD_CHECK_IEEE
 AC_TYPE_SIZE_T
 AC_TYPE_OFF_T
-AC_CHECK_TYPES([ssize_t, ptrdiff_t, uchar, longlong])
+AC_CHECK_TYPES([ssize_t, ptrdiff_t, uchar, longlong, ushort, uint, int64, uint64])
 AC_C_CHAR_UNSIGNED
 AC_C_BIGENDIAN
 AC_CHECK_SIZEOF(short)
@@ -777,6 +777,18 @@
 AC_CHECK_SIZEOF(double)
 AC_CHECK_SIZEOF(off_t)
 AC_CHECK_SIZEOF(size_t)
+AC_CHECK_SIZEOF(unsigned long long)
+
+if test "$ac_cv_type_ushort" = yes ; then
+   AC_CHECK_SIZEOF(ushort)
+else
+   AC_CHECK_SIZEOF(unsigned short int)
+fi
+if test "$ac_cv_type_uint" = yes ; then
+   AC_CHECK_SIZEOF(uint)
+else
+   AC_CHECK_SIZEOF(unsigned int)
+fi
 
 if test "x$enable_netcdf_4" = xyes || test "x$enable_dap" = xyes; then
    AC_SEARCH_LIBS([deflate], [zlibwapi zlibstat zlib zlib1 z], [], [
diff netcdf-c/docs/guide.dox cdf5/docs/guide.dox
--- netcdf-c/docs/guide.dox	2015-03-09 13:48:02.654584600 -0600
+++ cdf5/docs/guide.dox	2014-11-14 14:54:45.977637700 -0700
@@ -3639,6 +3639,7 @@
         2, 64-bit-offset, '64-bit offset' – Produce a netcdf 64 bit classic file format file.
         3, hdf5, netCDF-4, enhanced – Produce a netcdf-4 format file.
         4, hdf5-nc3, 'netCDF-4 classic model', enhanced-nc3 – Produce a netcdf-4 file format, but restricted to netcdf-3 classic CDL input.
+        5, 64-bit-data, '64-bit data' – Produce a netcdf 64 bit classic CDF-5 file format file.
 
 Note that the -v flag is a deprecated alias for -k.
 
@@ -3695,7 +3696,7 @@
 UNIX syntax for invoking ncgen3:
 
 \code
-     ncgen3 [-b] [-o netcdf-file] [-c] [-f] [-v2|-v3] [-x] [input-file]
+     ncgen3 [-b] [-o netcdf-file] [-c] [-f] [-v2|-v3|-v5] [-x] [input-file]
 \endcode
 
 where:
@@ -3738,6 +3739,12 @@
 are not as portable as classic format netCDF files, because they
 require version 4.0 or later of the netCDF library.
 
+-v5
+The generated netCDF file or program will use the version of the
+format with 64-bit integers, to allow for the creation of very large
+variables. These files are not as portable as classic format netCDF files,
+because they require version 4.4.0 or later of the netCDF library.
+
 -x
 Use “no fill” mode, omitting the initialization of variable values
 with fill values. This can make the creation of large files much
diff netcdf-c/include/nc3internal.h cdf5/include/nc3internal.h
--- netcdf-c/include/nc3internal.h	2014-11-14 15:14:32.020910100 -0700
+++ cdf5/include/nc3internal.h	2014-11-14 14:54:45.978614200 -0700
@@ -39,6 +39,7 @@
  * The initial value of ncp->xsz.
  */
 #define MIN_NC_XSZ 32
+#define MIN_NC5_XSZ 48
 
 /* Forward */
 struct ncio;
@@ -327,7 +328,7 @@
 /* Begin defined in nc.c */
 
 extern int
-nc_cktype(nc_type datatype);
+nc_cktype(int mode, nc_type datatype);
 
 extern size_t
 ncx_howmany(nc_type type, size_t xbufsize);
diff netcdf-c/include/ncconfigure.h cdf5/include/ncconfigure.h
--- netcdf-c/include/ncconfigure.h	2014-11-14 15:14:32.020910100 -0700
+++ cdf5/include/ncconfigure.h	2014-11-14 14:54:45.979590700 -0700
@@ -66,4 +66,8 @@
 typedef unsigned int uint;
 #endif
 
+#ifndef HAVE_USHORT
+typedef unsigned short ushort;
+#endif
+
 #endif /* NCCONFIGURE_H */
diff netcdf-c/include/ncdispatch.h cdf5/include/ncdispatch.h
--- netcdf-c/include/ncdispatch.h	2015-02-19 15:13:49.763334700 -0700
+++ cdf5/include/ncdispatch.h	2014-11-14 14:54:45.980567200 -0700
@@ -80,7 +80,7 @@
 #ifdef USE_NETCDF4
 #define ATOMICTYPEMAX NC_STRING
 #else
-#define ATOMICTYPEMAX NC_DOUBLE
+#define ATOMICTYPEMAX NC_UINT64
 #endif
 
 /* Define an alias for int to indicate an error return */
diff netcdf-c/include/netcdf.h cdf5/include/netcdf.h
--- netcdf-c/include/netcdf.h	2015-03-09 13:48:02.685834800 -0600
+++ cdf5/include/netcdf.h	2014-11-14 14:54:45.992285200 -0700
@@ -135,6 +135,7 @@
 
 #define NC_CLASSIC_MODEL 0x0100 /**< Enforce classic model. Mode flag for nc_create(). */
 #define NC_64BIT_OFFSET  0x0200  /**< Use large (64-bit) file offsets. Mode flag for nc_create(). */
+#define NC_64BIT_DATA    0x0010  /**< CDF-5 format: classic model but 64 bit dimensions and sizes */
 
 /** \deprecated The following flag currently is ignored, but use in
  * nc_open() or nc_create() may someday support use of advisory
@@ -167,6 +168,8 @@
 #define NC_FORMAT_64BIT   (2)
 #define NC_FORMAT_NETCDF4 (3)
 #define NC_FORMAT_NETCDF4_CLASSIC  (4)
+#define NC_FORMAT_CDF2    NC_FORMAT_64BIT
+#define NC_FORMAT_CDF5    (5)
 
 /**@}*/
 
@@ -831,7 +834,7 @@
 nc_set_fill(int ncid, int fillmode, int *old_modep);
 
 /* Set the default nc_create format to NC_FORMAT_CLASSIC,
- * NC_FORMAT_64BIT, NC_FORMAT_NETCDF4, NC_FORMAT_NETCDF4_CLASSIC. */
+ * NC_FORMAT_CDF2, NC_FORMAT_CDF5, NC_FORMAT_NETCDF4, NC_FORMAT_NETCDF4_CLASSIC. */
 EXTERNL int
 nc_set_default_format(int format, int *old_formatp);
 
diff netcdf-c/libdispatch/dcopy.c cdf5/libdispatch/dcopy.c
--- netcdf-c/libdispatch/dcopy.c	2014-11-14 15:14:32.020910100 -0700
+++ cdf5/libdispatch/dcopy.c	2014-11-14 14:54:45.993261700 -0700
@@ -291,7 +291,7 @@
       return retval;
    if ((retval = nc_inq_format(ncid_out, &dest_format)))
       return retval;
-   if ((dest_format == NC_FORMAT_CLASSIC || dest_format == NC_FORMAT_64BIT) &&
+   if ((dest_format == NC_FORMAT_CLASSIC || dest_format == NC_FORMAT_CDF2) &&
        src_format == NC_FORMAT_NETCDF4 && xtype > NC_DOUBLE)
       return NC_ENOTNC4;
 
diff netcdf-c/libdispatch/derror.c cdf5/libdispatch/derror.c
--- netcdf-c/libdispatch/derror.c	2015-03-09 13:48:02.701459900 -0600
+++ cdf5/libdispatch/derror.c	2014-11-14 14:54:45.994238200 -0700
@@ -8,6 +8,9 @@
 */
 
 #include "ncdispatch.h"
+#ifdef USE_PNETCDF
+#include <pnetcdf.h>  /* ncmpi_strerror() */
+#endif
 
 /* Tell the user the version of netCDF. */
 static const char nc_libvers[] = PACKAGE_VERSION " of "__DATE__" "__TIME__" $";
@@ -254,7 +257,11 @@
       case NC_EDISKLESS:
 	 return "NetCDF: Error in using diskless access";
       default:
+#ifdef USE_PNETCDF
+	return ncmpi_strerror(ncerr1);
+#else
 	 return "Unknown Error";
+#endif
    }
 }
 
diff netcdf-c/libdispatch/dfile.c cdf5/libdispatch/dfile.c
--- netcdf-c/libdispatch/dfile.c	2014-11-14 15:15:16.644196500 -0700
+++ cdf5/libdispatch/dfile.c	2014-11-14 14:54:45.995214700 -0700
@@ -168,13 +168,11 @@
             *version = 1; /* netcdf classic version 1 */
          else if(magic[3] == '\002')
             *version = 2; /* netcdf classic version 2 */
-#ifdef USE_PNETCDF
          else if(magic[3] == '\005')
-            *version = 5; /* pnetcdf file */
-#endif
+            *version = 5; /* netcdf classic version 5 */
 	 else
 	    {status = NC_ENOTNC; goto done;}
-	 *model = (use_parallel || *version == 5)?NC_DISPATCH_NC5:NC_DISPATCH_NC3;
+	 *model = (use_parallel) ? NC_DISPATCH_NC5 : NC_DISPATCH_NC3;
      } else
         {status = NC_ENOTNC; goto done;}
 
@@ -196,7 +194,8 @@
 \param cmode The creation mode flag. The following flags are
 available: NC_NOCLOBBER (do not overwrite existing file), NC_SHARE
 (limit write caching - netcdf classic files onlt), NC_64BIT_OFFSET
-(create 64-bit offset file), NC_NETCDF4 (create netCDF-4/HDF5 file),
+(create 64-bit offset file), NC_64BIT_DATA (create CDF-5 file),
+NC_NETCDF4 (create netCDF-4/HDF5 file),
 NC_CLASSIC_MODEL (enforce netCDF classic mode on netCDF-4/HDF5
 files), NC_DISKLESS (store data only in memory), NC_MMAP (use MMAP
 for NC_DISKLESS), and NC_WRITE.
@@ -227,6 +226,10 @@
 format imposes far fewer restrictions on very large (i.e. over 2 GB)
 data files. See Large File Support.
 
+Setting NC_64BIT_DATA causes netCDF to create a CDF-5 file format that
+supports large files (i.e. over 2GB) and large variables (over 2B
+array elements.). See Large File Support.
+
 A zero value (defined for convenience as NC_CLOBBER) specifies the
 default behavior: overwrite any existing dataset with the same file
 name and buffer and cache accesses for efficiency. The dataset will be
@@ -449,6 +452,10 @@
 nc__create(const char *path, int cmode, size_t initialsz,
 	   size_t *chunksizehintp, int *ncidp)
 {
+   /* this API is for non-parallel access, should we check for illegal cmode
+    * flags, such as NC_PNETCDF, NC_MPIIO, or NC_MPIPOSIX, before entering
+    * NC_create()? Note nc_create_par() also calls NC_create().
+    */
    return NC_create(path, cmode, initialsz, 0, 
 		    chunksizehintp, 0, NULL, ncidp);
 
@@ -586,6 +593,10 @@
 int
 nc_open(const char *path, int mode, int *ncidp)
 {
+   /* this API is for non-parallel access, should we check for illegal cmode
+    * flags, such as NC_PNETCDF, NC_MPIIO, or NC_MPIPOSIX, before entering
+    * NC_open()? Note nc_open_par() also calls NC_open().
+    */
    return NC_open(path, mode, 0, NULL, 0, NULL, ncidp);
 }
 
@@ -644,6 +655,10 @@
 nc__open(const char *path, int mode,
 	 size_t *chunksizehintp, int *ncidp)
 {
+   /* this API is for non-parallel access, should we check for illegal cmode
+    * flags, such as NC_PNETCDF, NC_MPIIO, or NC_MPIPOSIX, before entering
+    * NC_open()? Note nc_open_par() also calls NC_open().
+    */
    return NC_open(path, mode, 0, chunksizehintp, 0, 
 		  NULL, ncidp);
 }
@@ -1265,7 +1280,7 @@
 nc_create().
 
 \param formatp Pointer to location for returned format version, one of
-NC_FORMAT_CLASSIC, NC_FORMAT_64BIT, NC_FORMAT_NETCDF4,
+NC_FORMAT_CLASSIC, NC_FORMAT_CDF2, NC_FORMAT_CDF5, NC_FORMAT_NETCDF4,
 NC_FORMAT_NETCDF4_CLASSIC.
 
 \returns ::NC_NOERR No error.
@@ -1447,9 +1462,15 @@
 nc_inq_type(int ncid, nc_type xtype, char *name, size_t *size)
 {
    NC* ncp;
+   int format, ub=ATOMICTYPEMAX;
+
+   /* CDF-1 and CDF-2 support types up tp NC_DOUBLE */
+   nc_inq_format(ncid, &format);
+   if (format != NC_FORMAT_CDF5) ub = NC_DOUBLE;
+
    /* For compatibility, we need to allow inq about
       atomic types, even if ncid is ill-defined */
-   if(xtype <= ATOMICTYPEMAX) {
+   if(xtype <= ub) {
       if(xtype <= NC_NAT) return NC_EBADTYPE;
       if(name) strncpy(name,NC_atomictypename(xtype),NC_MAX_NAME);
       if(size) *size = NC_atomictypelen(xtype);
@@ -1561,8 +1582,10 @@
 	    model = NC_DISPATCH_NC4;
 	    break;
 #endif
-	 case NC_FORMAT_64BIT:
+	 case NC_FORMAT_CDF2:
 	    xcmode |= NC_64BIT_OFFSET;
+	 case NC_FORMAT_CDF5:
+	    xcmode |= NC_64BIT_DATA;
 	    /* fall thru */
 	 case NC_FORMAT_CLASSIC:
 	 default:
@@ -1695,41 +1718,33 @@
 	return stat;
    }
 
-#if 1
    if(model == 0) {
 	fprintf(stderr,"Model != 0\n");
 	return NC_ENOTNC;
    }
-#else
-Not longer needed
-   /* Look to the incoming cmode for hints */
-   if(model == 0) {
-      if(cmode & NC_PNETCDF) model = NC_DISPATCH_NC5;
-      else if(cmode & NC_NETCDF4) model = NC_DISPATCH_NC4;
-    }
-   if(model == 0) model = NC_DISPATCH_NC3; /* final default */
-#endif
 
    /* Force flag consistentcy */
    if(model & NC_DISPATCH_NC4)
       cmode |= NC_NETCDF4;
    else if(model & NC_DISPATCH_NC3) {
-      cmode &= ~NC_NETCDF4; /* must be netcdf-3 */
+      cmode &= ~NC_NETCDF4; /* must be netcdf-3 (CDF-1, CDF-2, CDF-5) */
       if(version == 2) cmode |= NC_64BIT_OFFSET;
+      else if(version == 5) cmode |= NC_64BIT_DATA;
    } else if(model & NC_DISPATCH_NC5) {
-#if 0
-It appears that pnetcdf can read NC_64_BIT_OFFSET
-      cmode &= ~(NC_NETCDF4 | NC_64BIT_OFFSET); /* must be pnetcdf */ 
-#else
-      cmode &= ~(NC_NETCDF4);
-#endif
+      cmode &= ~NC_NETCDF4; /* must be netcdf-3 (CDF-1, CDF-2, CDF-5) */
+      if(version == 2) cmode |= NC_64BIT_OFFSET;
+      else if(version == 5) cmode |= NC_64BIT_DATA;
       cmode |= NC_PNETCDF;
    }
 
    if((cmode & NC_MPIIO && cmode & NC_MPIPOSIX))
       return  NC_EINVAL;
 
-   /* override overrides any other table choice */
+   if((cmode & NC_64BIT_OFFSET && cmode & NC_64BIT_DATA))
+      /* cannot have both CDF-2 and CDF-5 */
+      return  NC_EINVAL;
+
+   /* override any other table choice */
    dispatcher = NC_get_dispatch_override();
    if(dispatcher != NULL) goto havetable;
 
diff netcdf-c/libdispatch/dv2i.c cdf5/libdispatch/dv2i.c
--- netcdf-c/libdispatch/dv2i.c	2014-11-14 15:14:32.020910100 -0700
+++ cdf5/libdispatch/dv2i.c	2014-11-14 14:54:45.996191200 -0700
@@ -868,19 +868,28 @@
 		return ncvarputs(ncid, varid, start, count, stride, value);
 	/* else */
 	{
-	NDIMS_DECL
+	long *imp=NULL;
+	if (map != NULL) {
+		/* make map[ndims-1] number of elements instead of bytes */
+		int i, ndims, el_size;
+		nc_type type;
+		nc_inq_varndims(ncid, varid, &ndims);
+		nc_inq_vartype(ncid, varid, &type);
+		el_size = nctypelen(type);
+		imp = (long*) malloc(ndims * sizeof(long));
+		for (i=0; i<ndims; i++) imp[i] = map[i] / el_size;
+	}
+
 	A_DECL(stp, size_t, ndims, start);
 	A_DECL(cntp, size_t, ndims, count);
 	A_DECL(strdp, ptrdiff_t, ndims, stride);
-	A_DECL(imp, ptrdiff_t, ndims, map);
 	A_INIT(stp, size_t, ndims, start);
 	A_INIT(cntp, size_t, ndims, count);
 	A_INIT(strdp, ptrdiff_t, ndims, stride);
-	A_INIT(imp, ptrdiff_t, ndims, map);
 	{
 	const int status = nc_put_varm(ncid, varid,
 			 stp, cntp, strdp, imp, value);
-	A_FREE(imp);
+	if (imp!=NULL) free(imp);
 	A_FREE(strdp);
 	A_FREE(cntp);
 	A_FREE(stp);
@@ -910,19 +919,28 @@
 		return ncvargets(ncid, varid, start, count, stride, value);
 	/* else */
 	{
-	NDIMS_DECL
+	long *imp=NULL;
+	if (map != NULL) {
+		/* make map[ndims-1] number of elements instead of bytes */
+		int i, ndims, el_size;
+		nc_type type;
+		nc_inq_varndims(ncid, varid, &ndims);
+		nc_inq_vartype(ncid, varid, &type);
+		el_size = nctypelen(type);
+		imp = (long*) malloc(ndims * sizeof(long));
+		for (i=0; i<ndims; i++) imp[i] = map[i] / el_size;
+	}
+
 	A_DECL(stp, size_t, ndims, start);
 	A_DECL(cntp, size_t, ndims, count);
 	A_DECL(strdp, ptrdiff_t, ndims, stride);
-	A_DECL(imp, ptrdiff_t, ndims, map);
 	A_INIT(stp, size_t, ndims, start);
 	A_INIT(cntp, size_t, ndims, count);
 	A_INIT(strdp, ptrdiff_t, ndims, stride);
-	A_INIT(imp, ptrdiff_t, ndims, map);
 	{
 	const int status = nc_get_varm(ncid, varid,
 			stp, cntp, strdp, imp, value);
-	A_FREE(imp);
+	if (imp!=NULL) free(imp);
 	A_FREE(strdp);
 	A_FREE(cntp);
 	A_FREE(stp);
diff netcdf-c/libdispatch/dvarget.c cdf5/libdispatch/dvarget.c
--- netcdf-c/libdispatch/dvarget.c	2015-03-09 13:48:02.701459900 -0600
+++ cdf5/libdispatch/dvarget.c	2014-11-14 14:54:45.998144200 -0700
@@ -277,7 +277,6 @@
    int varndims,maxidim;
    NC* ncp;
    int memtypelen;
-   ptrdiff_t cvtmap[NC_MAX_VAR_DIMS];
    char* value = (char*)value0;
 
    status = NC_check_id (ncid, &ncp);
@@ -297,21 +296,6 @@
    if(status != NC_NOERR) return status;
 
    if(memtype == NC_NAT) {
-      if(imapp != NULL && varndims != 0) {
-	 /*
-	  * convert map units from bytes to units of sizeof(type)
-	  */
-	 size_t ii;
-	 const ptrdiff_t szof = (ptrdiff_t) nctypelen(vartype);
-	 for(ii = 0; ii < varndims; ii++) {
-	    if(imapp[ii] % szof != 0) {
-	       /*free(cvtmap);*/
-	       return NC_EINVAL;
-	    }
-	    cvtmap[ii] = imapp[ii] / szof;
-	 }
-	 imapp = cvtmap;
-      }
       memtype = vartype;
    }
 
@@ -424,7 +408,8 @@
 	    ? stride[idim]
 	    : 1;
 
-	 /* Remember: imapp is byte oriented, not index oriented */
+	 /* Remember: in netCDF-2 imapp is byte oriented, not index oriented
+	  *           Starting from netCDF-3, imapp is index oriented */
 #ifdef COMPLEX
 	 mymap[idim] = (imapp != NULL
 			? imapp[idim]
diff netcdf-c/libdispatch/dvarput.c cdf5/libdispatch/dvarput.c
--- netcdf-c/libdispatch/dvarput.c	2014-11-14 15:15:16.659820900 -0700
+++ cdf5/libdispatch/dvarput.c	2014-11-14 14:54:45.998144200 -0700
@@ -268,7 +268,6 @@
    int maxidim = 0;
    NC* ncp;
    int memtypelen;
-   ptrdiff_t cvtmap[NC_MAX_VAR_DIMS];
    const char* value = (char*)value0;
 
    status = NC_check_id (ncid, &ncp);
@@ -290,21 +289,6 @@
    if(status != NC_NOERR) return status;
 
    if(memtype == NC_NAT) {
-      if(imapp != NULL && varndims != 0) {
-	 /*
-	  * convert map units from bytes to units of sizeof(type)
-	  */
-	 size_t ii;
-	 const ptrdiff_t szof = (ptrdiff_t) nctypelen(vartype);
-	 for(ii = 0; ii < varndims; ii++) {
-	    if(imapp[ii] % szof != 0) {
-	       /*free(cvtmap);*/
-	       return NC_EINVAL;
-	    }
-	    cvtmap[ii] = imapp[ii] / szof;
-	 }
-	 imapp = cvtmap;
-      }
       memtype = vartype;
    }
 
diff netcdf-c/libdispatch/nc.c cdf5/libdispatch/nc.c
--- netcdf-c/libdispatch/nc.c	2014-11-14 15:14:32.020910100 -0700
+++ cdf5/libdispatch/nc.c	2014-11-14 14:54:45.999120700 -0700
@@ -85,11 +85,13 @@
 
     /* Make sure only valid format is set. */
 #ifdef USE_NETCDF4
-    if (format != NC_FORMAT_CLASSIC && format != NC_FORMAT_64BIT &&
-	format != NC_FORMAT_NETCDF4 && format != NC_FORMAT_NETCDF4_CLASSIC)
+    if (format != NC_FORMAT_CLASSIC && format != NC_FORMAT_CDF2 &&
+	format != NC_FORMAT_NETCDF4 && format != NC_FORMAT_NETCDF4_CLASSIC &&
+	format != NC_FORMAT_CDF5)
       return NC_EINVAL;
 #else
-    if (format != NC_FORMAT_CLASSIC && format != NC_FORMAT_64BIT)
+    if (format != NC_FORMAT_CLASSIC && format != NC_FORMAT_CDF2 &&
+	format != NC_FORMAT_CDF5)
       return NC_EINVAL;
 #endif
     default_create_format = format;
diff netcdf-c/liblib/CMakeLists.txt cdf5/liblib/CMakeLists.txt
--- netcdf-c/liblib/CMakeLists.txt	2015-03-09 13:48:02.717085000 -0600
+++ cdf5/liblib/CMakeLists.txt	2014-11-14 13:32:33.591337200 -0700
@@ -77,9 +77,6 @@
 IF(ENABLE_PNETCDF AND PNETCDF)
   SET(TLL_LIBS ${TLL_LIBS} ${PNETCDF})
 ENDIF()
-
-LIST(REMOVE_DUPLICATES TLL_LIBS)
-
 TARGET_LINK_LIBRARIES(netcdf ${TLL_LIBS})
 
 IF(MSVC)
diff netcdf-c/libsrc/attr.m4 cdf5/libsrc/attr.m4
--- netcdf-c/libsrc/attr.m4	2015-03-09 13:48:02.717085000 -0600
+++ cdf5/libsrc/attr.m4	2014-11-14 14:54:46.000097200 -0700
@@ -8,7 +8,7 @@
  *	Copyright 1996, University Corporation for Atmospheric Research
  *      See netcdf/COPYRIGHT file for copying and redistribution conditions.
  */
-/* $Id: attr.m4,v 2.39 2010/05/26 18:11:08 dmh Exp $ */
+/* $Id: attr.m4 2783 2014-10-26 05:19:35Z wkliao $ */
 
 #include "nc3internal.h"
 #include "ncdispatch.h"
@@ -57,6 +57,16 @@
 		return ncx_len_float(nelems);
 	case NC_DOUBLE:
 		return ncx_len_double(nelems);
+	case NC_UBYTE:
+		return ncx_len_ubyte(nelems);
+	case NC_USHORT:
+		return ncx_len_ushort(nelems);
+	case NC_UINT:
+		return ncx_len_uint(nelems);
+	case NC_INT64:
+		return ncx_len_int64(nelems);
+	case NC_UINT64:
+		return ncx_len_uint64(nelems);
 	default:
 	        assert("ncx_len_NC_attr bad type" == 0);
 	}
@@ -636,6 +646,16 @@
 		return ncx_putn_float_$1(xpp, nelems, tp);
 	case NC_DOUBLE:
 		return ncx_putn_double_$1(xpp, nelems, tp);
+	case NC_UBYTE:
+		return ncx_pad_putn_uchar_$1(xpp, nelems, tp);
+	case NC_USHORT:
+		return ncx_putn_ushort_$1(xpp, nelems, tp);
+	case NC_UINT:
+		return ncx_putn_uint_$1(xpp, nelems, tp);
+	case NC_INT64:
+		return ncx_putn_longlong_$1(xpp, nelems, tp);
+	case NC_UINT64:
+		return ncx_putn_ulonglong_$1(xpp, nelems, tp);
 	default:
                 assert("ncx_pad_putn_I$1 invalid type" == 0);
 	}
@@ -653,6 +673,8 @@
 	switch(type) {
 	case NC_CHAR:
 		return NC_ECHAR;
+	case NC_UBYTE:
+		return ncx_pad_getn_uchar_$1(xpp, nelems, tp);
 	case NC_BYTE:
 		return ncx_pad_getn_schar_$1(xpp, nelems, tp);
 	case NC_SHORT:
@@ -663,6 +685,14 @@
 		return ncx_getn_float_$1(xpp, nelems, tp);
 	case NC_DOUBLE:
 		return ncx_getn_double_$1(xpp, nelems, tp);
+	case NC_USHORT:
+		return ncx_getn_ushort_$1(xpp, nelems, tp);
+	case NC_UINT:
+		return ncx_getn_uint_$1(xpp, nelems, tp);
+	case NC_INT64:
+		return ncx_getn_longlong_$1(xpp, nelems, tp);
+	case NC_UINT64:
+		return ncx_getn_ulonglong_$1(xpp, nelems, tp);
 	default:
 	        assert("ncx_pad_getn_I$1 invalid type" == 0);
 	}
@@ -697,6 +727,15 @@
 XNCX_PAD_PUTN(longlong)
 XNCX_PAD_GETN(longlong)
 
+XNCX_PAD_PUTN(ushort)
+XNCX_PAD_GETN(ushort)
+
+XNCX_PAD_PUTN(uint)
+XNCX_PAD_GETN(uint)
+
+XNCX_PAD_PUTN(ulonglong)
+XNCX_PAD_GETN(ulonglong)
+
 
 /* Common dispatcher for put cases */
 static int
@@ -718,8 +757,14 @@
         return ncx_pad_putn_Idouble(xpp, nelems, (double*)tp, atype);
     case NC_UBYTE: /*Synthetic*/
         return ncx_pad_putn_Iuchar(xpp,nelems, (uchar *)tp, atype);
+    case NC_USHORT:
+          return ncx_pad_putn_Iushort(xpp, nelems, (ushort*)tp, atype);
+    case NC_UINT:
+          return ncx_pad_putn_Iuint(xpp, nelems, (uint*)tp, atype);
     case NC_INT64:
           return ncx_pad_putn_Ilonglong(xpp, nelems, (longlong*)tp, atype);
+    case NC_UINT64:
+          return ncx_pad_putn_Iulonglong(xpp, nelems, (ulonglong*)tp, atype);
     case NC_NAT:
         return NC_EBADTYPE;
     default:
@@ -758,7 +803,7 @@
     if(ncap == NULL)
 	return NC_ENOTVAR;
 
-    status = nc_cktype(type);
+    status = nc_cktype(nc->mode, type);
     if(status != NC_NOERR)
 	return status;
 
@@ -885,10 +930,16 @@
         return ncx_pad_getn_Ifloat(&xp,attrp->nelems,(float*)value,attrp->type);
     case NC_DOUBLE:
         return ncx_pad_getn_Idouble(&xp,attrp->nelems,(double*)value,attrp->type);
-    case NC_INT64:
-          return ncx_pad_getn_Ilonglong(&xp,attrp->nelems,(longlong*)value,attrp->type);
     case NC_UBYTE: /* Synthetic */
         return ncx_pad_getn_Iuchar(&xp, attrp->nelems , (uchar *)value, attrp->type);
+    case NC_USHORT:
+          return ncx_pad_getn_Iushort(&xp,attrp->nelems,(ushort*)value,attrp->type);
+    case NC_UINT:
+          return ncx_pad_getn_Iuint(&xp,attrp->nelems,(uint*)value,attrp->type);
+    case NC_INT64:
+          return ncx_pad_getn_Ilonglong(&xp,attrp->nelems,(longlong*)value,attrp->type);
+    case NC_UINT64:
+          return ncx_pad_getn_Iulonglong(&xp,attrp->nelems,(ulonglong*)value,attrp->type);
     case NC_NAT:
         return NC_EBADTYPE;
     default:
diff netcdf-c/libsrc/mmapio.c cdf5/libsrc/mmapio.c
--- netcdf-c/libsrc/mmapio.c	2014-11-14 15:14:32.020910100 -0700
+++ cdf5/libsrc/mmapio.c	2014-11-14 14:54:46.001073700 -0700
@@ -168,7 +168,8 @@
     mmapio->persist = fIsSet(ioflags,NC_WRITE);
 
     /* See if ok to use mmap */
-    if(sizeof(void*) < 8 && fIsSet(ioflags,NC_64BIT_OFFSET))
+    if(sizeof(void*) < 8 &&
+       (fIsSet(ioflags,NC_64BIT_OFFSET) || fIsSet(ioflags,NC_64BIT_DATA)))
 	return NC_DISKLESS; /* cannot support */
     mmapio->mapfd = -1;
 
diff netcdf-c/libsrc/nc3internal.c cdf5/libsrc/nc3internal.c
--- netcdf-c/libsrc/nc3internal.c	2015-03-09 13:48:02.732710100 -0600
+++ cdf5/libsrc/nc3internal.c	2014-11-14 14:54:46.002050200 -0700
@@ -48,8 +48,10 @@
 	NC3_INFO *ncp;
 	ncp = (NC3_INFO*)calloc(1,sizeof(NC3_INFO));
 	if(ncp == NULL) return ncp;
+/* delay this setting
 	ncp->xsz = MIN_NC_XSZ;
 	assert(ncp->xsz == ncx_len_NC(ncp,0));
+*/
         ncp->chunk = chunkp != NULL ? *chunkp : NC_SIZEHINT_DEFAULT;
 	return ncp;
 }
@@ -87,18 +89,16 @@
  * Sense of the return is changed.
  */
 int
-nc_cktype(nc_type type)
+nc_cktype(int mode, nc_type type)
 {
-	switch((int)type){
-	case NC_BYTE:
-	case NC_CHAR:
-	case NC_SHORT:
-	case NC_INT:
-	case NC_FLOAT:
-	case NC_DOUBLE:
-		return(NC_NOERR);
+    if (mode & NC_64BIT_OFFSET) { /* CDF-1 and CDF-2 format */
+        if (type >= NC_BYTE && type <= NC_DOUBLE) return NC_NOERR;
+	return NC_EBADTYPE;
+    }
+    else {  /* CDF-5 format */
+        if (type >= NC_BYTE && type <= NC_STRING) return NC_NOERR;
+	return NC_EBADTYPE;
 	}
-	return(NC_EBADTYPE);
 }
 
 
@@ -112,6 +112,7 @@
 	switch(type){
 	case NC_BYTE:
 	case NC_CHAR:
+	case NC_UBYTE:
 		return xbufsize;
 	case NC_SHORT:
 		return xbufsize/X_SIZEOF_SHORT;
@@ -121,6 +122,14 @@
 		return xbufsize/X_SIZEOF_FLOAT;
 	case NC_DOUBLE:
 		return xbufsize/X_SIZEOF_DOUBLE;
+	case NC_USHORT:
+		return xbufsize/X_SIZEOF_USHORT;
+	case NC_UINT:
+		return xbufsize/X_SIZEOF_UINT;
+	case NC_INT64:
+		return xbufsize/X_SIZEOF_LONGLONG;
+	case NC_UINT64:
+		return xbufsize/X_SIZEOF_ULONGLONG;
 	default:
 	        assert("ncx_howmany: Bad type" == 0);
 		return(0);
@@ -151,7 +160,7 @@
 	if(r_align == NC_ALIGN_CHUNK)
 		r_align = ncp->chunk;
 
-	if (fIsSet(ncp->flags, NC_64BIT_OFFSET)) {
+	if (fIsSet(ncp->flags, NC_64BIT_OFFSET) || fIsSet(ncp->flags, NC_64BIT_DATA)) {
 	  sizeof_off_t = 8;
 	} else {
 	  sizeof_off_t = 4;
@@ -321,25 +330,34 @@
 {
 	int status = NC_NOERR;
 	const void *xp = NULL;
-	size_t nrecs = NC_get_numrecs(ncp);
+	size_t new_nrecs, old_nrecs = NC_get_numrecs(ncp);
+	size_t nc_numrecs_extent=4; /* CDF-1 and CDF-2 */
 
 	assert(!NC_indef(ncp));
 
+	if (fIsSet(ncp->flags, NC_64BIT_DATA))
+		nc_numrecs_extent = 8; /* CDF-5 */
+
 #define NC_NUMRECS_OFFSET 4
-#define NC_NUMRECS_EXTENT 4
 	status = ncio_get(ncp->nciop,
-		 NC_NUMRECS_OFFSET, NC_NUMRECS_EXTENT, 0, (void **)&xp);
+		 NC_NUMRECS_OFFSET, nc_numrecs_extent, 0, (void **)&xp);
 					/* cast away const */
 	if(status != NC_NOERR)
 		return status;
 
-	status = ncx_get_size_t(&xp, &nrecs);
+	if (fIsSet(ncp->flags, NC_64BIT_DATA)) {
+		long long tmp=0;
+		status = ncx_get_int64(&xp, &tmp);
+		new_nrecs = tmp;
+        }
+	else
+		status = ncx_get_size_t(&xp, &new_nrecs);
 
 	(void) ncio_rel(ncp->nciop, NC_NUMRECS_OFFSET, 0);
 
-	if(status == NC_NOERR)
+	if(status == NC_NOERR && old_nrecs != new_nrecs)
 	{
-		NC_set_numrecs(ncp, nrecs);
+		NC_set_numrecs(ncp, new_nrecs);
 		fClr(ncp->flags, NC_NDIRTY);
 	}
 
@@ -356,17 +374,24 @@
 {
 	int status = NC_NOERR;
 	void *xp = NULL;
+	size_t nc_numrecs_extent=4; /* CDF-1 and CDF-2 */
 
 	assert(!NC_readonly(ncp));
 	assert(!NC_indef(ncp));
 
+	if (fIsSet(ncp->flags, NC_64BIT_DATA))
+		nc_numrecs_extent = 8; /* CDF-5 */
+
 	status = ncio_get(ncp->nciop,
-		 NC_NUMRECS_OFFSET, NC_NUMRECS_EXTENT, RGN_WRITE, &xp);
+		 NC_NUMRECS_OFFSET, nc_numrecs_extent, RGN_WRITE, &xp);
 	if(status != NC_NOERR)
 		return status;
 
 	{
 		const size_t nrecs = NC_get_numrecs(ncp);
+		if (fIsSet(ncp->flags, NC_64BIT_DATA))
+			status = ncx_put_int64(&xp, nrecs);
+		else
 		status = ncx_put_size_t(&xp, &nrecs);
 	}
 
@@ -667,7 +692,11 @@
     if(ncp->vars.nelems == 0)
 	return NC_NOERR;
 
-    if ((ncp->flags & NC_64BIT_OFFSET) && sizeof(off_t) > 4) {
+    if (ncp->flags & NC_64BIT_DATA) {
+	/* CDF5 format allows many large vars */
+        return NC_NOERR;
+    }
+    else if ((ncp->flags & NC_64BIT_OFFSET) && sizeof(off_t) > 4) {
 	/* CDF2 format and LFS */
 	vlen_max = X_UINT_MAX - 3; /* "- 3" handles rounded-up size */
     } else {
@@ -810,8 +839,7 @@
 				return status;
 
 		}
-		else if(ncp->old == (void*)0 ?
-                0 : (ncp->vars.nelems > ncp->old->vars.nelems))
+		else if(ncp->vars.nelems > ncp->old->vars.nelems)
           {
             status = fill_added(ncp, ncp->old);
             if(status != NC_NOERR)
@@ -881,7 +909,7 @@
 	    if(last_fix->len == X_UINT_MAX) { /* huge last fixed var */
           int i;
           varsize = 1;
-          for(i = 0; i < last_fix->ndims, last_fix->shape != NULL; i++ ) {
+		    for(i = 0; i < last_fix->ndims; i++ ) {
             varsize *= last_fix->shape[i];
           }
 	    }
@@ -948,21 +976,26 @@
 	/*
 	 * !_CRAYMPP, only pe 0 is valid
 	 */
-	if(basepe != 0) {
-      free(nc3);
+	if(basepe != 0)
       return NC_EINVAL;
-    }
 #endif
 
 	assert(nc3->flags == 0);
 
 	/* Apply default create format. */
-	if (nc_get_default_format() == NC_FORMAT_64BIT)
+	if (nc_get_default_format() == NC_FORMAT_CDF2)
 	  ioflags |= NC_64BIT_OFFSET;
+	else if (nc_get_default_format() == NC_FORMAT_CDF5)
+	  ioflags |= NC_64BIT_DATA;
 
+	nc3->xsz = MIN_NC_XSZ;
 	if (fIsSet(ioflags, NC_64BIT_OFFSET)) {
 	  fSet(nc3->flags, NC_64BIT_OFFSET);
 	  sizeof_off_t = 8;
+	} else if (fIsSet(ioflags, NC_64BIT_DATA)) {
+		fSet(nc3->flags, NC_64BIT_DATA);
+		sizeof_off_t = 8;
+		nc3->xsz = MIN_NC5_XSZ; /* CDF-5 has minimum 16 extra bytes */
 	} else {
 	  sizeof_off_t = 4;
 	}
@@ -1024,7 +1057,7 @@
 /* This function sets a default create flag that will be logically
    or'd to whatever flags are passed into nc_create for all future
    calls to nc_create.
-   Valid default create flags are NC_64BIT_OFFSET, NC_CLOBBER,
+   Valid default create flags are NC_64BIT_OFFSET, NC_64BIT_DATA, NC_CLOBBER,
    NC_LOCK, NC_SHARE. */
 int
 nc_set_default_format(int format, int *old_formatp)
@@ -1035,11 +1068,12 @@
 
     /* Make sure only valid format is set. */
 #ifdef USE_NETCDF4
-    if (format != NC_FORMAT_CLASSIC && format != NC_FORMAT_64BIT &&
+    if (format != NC_FORMAT_CLASSIC && format != NC_FORMAT_CDF2 &&
 	format != NC_FORMAT_NETCDF4 && format != NC_FORMAT_NETCDF4_CLASSIC)
       return NC_EINVAL;
 #else
-    if (format != NC_FORMAT_CLASSIC && format != NC_FORMAT_64BIT)
+    if (format != NC_FORMAT_CLASSIC && format != NC_FORMAT_CDF2 &&
+        format != NC_FORMAT_CDF5)
       return NC_EINVAL;
 #endif
     default_create_format = format;
@@ -1071,10 +1105,8 @@
 	/*
 	 * !_CRAYMPP, only pe 0 is valid
 	 */
-	if(basepe != 0) {
-      free(nc3);
+	if(basepe != 0)
       return NC_EINVAL;
-    }
 #endif
 
 	status = ncio_open(path, ioflags, 0, 0, &nc3->chunk, &nc3->nciop, 0);
@@ -1533,10 +1565,14 @@
 		return status;
 	nc3 = NC3_DATA(nc);
 
-	/* only need to check for netCDF-3 variants, since this is never called for netCDF-4
-	   files */
-	*formatp = fIsSet(nc3->flags, NC_64BIT_OFFSET) ? NC_FORMAT_64BIT
-	    : NC_FORMAT_CLASSIC;
+	/* only need to check for netCDF-3 variants, since this is never
+	   called for netCDF-4 files */
+	if (fIsSet(nc3->flags, NC_64BIT_DATA))
+		*formatp = NC_FORMAT_CDF5;
+	else if (fIsSet(nc3->flags, NC_64BIT_OFFSET))
+		*formatp = NC_FORMAT_CDF2;
+	else
+		*formatp = NC_FORMAT_CLASSIC; 
 	return NC_NOERR;
 }
 
diff netcdf-c/libsrc/ncx.h cdf5/libsrc/ncx.h
--- netcdf-c/libsrc/ncx.h	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/libsrc/ncx.h	2014-11-14 14:54:46.003026700 -0700
@@ -2,7 +2,7 @@
  *	Copyright 1996, University Corporation for Atmospheric Research
  *	See netcdf/COPYRIGHT file for copying and redistribution conditions.
  */
-/* "$Id: ncx.h,v 1.65 2010/05/26 18:11:08 dmh Exp $" */
+/* "$Id: ncx.h 2781 2014-10-24 19:12:09Z wkliao $" */
 
 #ifndef _NCX_H_
 #define _NCX_H_
@@ -33,7 +33,13 @@
 #include <errno.h>
 #include <sys/types.h> /* off_t */
 #include <ncdispatch.h>
+
+#ifndef longlong
 #define longlong long long
+#endif
+#ifndef ulonglong
+#define ulonglong unsigned long long
+#endif
 
 #if defined(_CRAY) && !defined(_CRAYIEEE) && !defined(__crayx1)
 #define CRAYFLOAT 1 /* CRAY Floating point */
@@ -69,6 +75,15 @@
 #define X_SIZEOF_FLOAT		4
 #define X_SIZEOF_DOUBLE		8
 
+/* additional data types in CDF-5 */
+#define X_SIZEOF_UBYTE		1
+#define X_SIZEOF_USHORT		2
+#define X_SIZEOF_UINT		4
+#define X_SIZEOF_LONGLONG	8
+#define X_SIZEOF_ULONGLONG	8
+#define X_SIZEOF_INT64		8
+#define X_SIZEOF_UINT64		8
+
 /*
  * For now, netcdf is limited to 32 bit sizes,
  * If compiled with support for "large files", then
@@ -141,6 +156,21 @@
 #define ncx_len_double(nelems) \
 	((nelems) * X_SIZEOF_DOUBLE)
 
+#define ncx_len_ubyte(nelems) \
+	_RNDUP((nelems), X_ALIGN)
+
+#define ncx_len_ushort(nelems) \
+	(((nelems) + (nelems)%2)  * X_SIZEOF_USHORT)
+
+#define ncx_len_uint(nelems) \
+	((nelems) * X_SIZEOF_UINT)
+
+#define ncx_len_int64(nelems) \
+	((nelems) * X_SIZEOF_LONGLONG)
+
+#define ncx_len_uint64(nelems) \
+	((nelems) * X_SIZEOF_ULONGLONG)
+
 /* End ncx_len */
 
 #if __CHAR_UNSIGNED__
@@ -201,162 +231,10 @@
  *
  */
 
-#if 0
-extern int
-ncx_get_schar_schar(const void *xp, schar *ip);
-extern int
-ncx_get_schar_uchar(const void *xp, uchar *ip);
-extern int
-ncx_get_schar_short(const void *xp, short *ip);
-extern int
-ncx_get_schar_int(const void *xp, int *ip);
-extern int
-ncx_get_schar_long(const void *xp, long *ip);
-extern int
-ncx_get_schar_float(const void *xp, float *ip);
-extern int
-ncx_get_schar_double(const void *xp, double *ip);
-
-extern int
-ncx_put_schar_schar(void *xp, const schar *ip);
-extern int
-ncx_put_schar_uchar(void *xp, const uchar *ip);
-extern int
-ncx_put_schar_short(void *xp, const short *ip);
-extern int
-ncx_put_schar_int(void *xp, const int *ip);
-extern int
-ncx_put_schar_long(void *xp, const long *ip);
-extern int
-ncx_put_schar_float(void *xp, const float *ip);
-extern int
-ncx_put_schar_double(void *xp, const double *ip);
-#endif
- 
-
-extern int
-ncx_get_short_schar(const void *xp, schar *ip);
-extern int
-ncx_get_short_uchar(const void *xp, uchar *ip);
-extern int
-ncx_get_short_short(const void *xp, short *ip);
-extern int
-ncx_get_short_int(const void *xp, int *ip);
-extern int
-ncx_get_short_long(const void *xp, long *ip);
-extern int
-ncx_get_short_float(const void *xp, float *ip);
-extern int
-ncx_get_short_double(const void *xp, double *ip);
-
-extern int
-ncx_put_short_schar(void *xp, const schar *ip);
-extern int
-ncx_put_short_uchar(void *xp, const uchar *ip);
-extern int
-ncx_put_short_short(void *xp, const short *ip);
-extern int
-ncx_put_short_int(void *xp, const int *ip);
-extern int
-ncx_put_short_long(void *xp, const long *ip);
-extern int
-ncx_put_short_float(void *xp, const float *ip);
-extern int
-ncx_put_short_double(void *xp, const double *ip);
- 
-
-extern int
-ncx_get_int_schar(const void *xp, schar *ip);
-extern int
-ncx_get_int_uchar(const void *xp, uchar *ip);
-extern int
-ncx_get_int_short(const void *xp, short *ip);
-extern int
-ncx_get_int_int(const void *xp, int *ip);
-extern int
-ncx_get_int_long(const void *xp, long *ip);
-extern int
-ncx_get_int_float(const void *xp, float *ip);
-extern int
-ncx_get_int_double(const void *xp, double *ip);
-
-extern int
-ncx_put_int_schar(void *xp, const schar *ip);
-extern int
-ncx_put_int_uchar(void *xp, const uchar *ip);
-extern int
-ncx_put_int_short(void *xp, const short *ip);
 extern int
 ncx_put_int_int(void *xp, const int *ip);
 extern int
-ncx_put_int_long(void *xp, const long *ip);
-extern int
-ncx_put_int_float(void *xp, const float *ip);
-extern int
-ncx_put_int_double(void *xp, const double *ip);
- 
-
-extern int
-ncx_get_float_schar(const void *xp, schar *ip);
-extern int
-ncx_get_float_uchar(const void *xp, uchar *ip);
-extern int
-ncx_get_float_short(const void *xp, short *ip);
-extern int
-ncx_get_float_int(const void *xp, int *ip);
-extern int
-ncx_get_float_long(const void *xp, long *ip);
-extern int
-ncx_get_float_float(const void *xp, float *ip);
-extern int
-ncx_get_float_double(const void *xp, double *ip);
-
-extern int
-ncx_put_float_schar(void *xp, const schar *ip);
-extern int
-ncx_put_float_uchar(void *xp, const uchar *ip);
-extern int
-ncx_put_float_short(void *xp, const short *ip);
-extern int
-ncx_put_float_int(void *xp, const int *ip);
-extern int
-ncx_put_float_long(void *xp, const long *ip);
-extern int
-ncx_put_float_float(void *xp, const float *ip);
-extern int
-ncx_put_float_double(void *xp, const double *ip);
- 
-
-extern int
-ncx_get_double_schar(const void *xp, schar *ip);
-extern int
-ncx_get_double_uchar(const void *xp, uchar *ip);
-extern int
-ncx_get_double_short(const void *xp, short *ip);
-extern int
-ncx_get_double_int(const void *xp, int *ip);
-extern int
-ncx_get_double_long(const void *xp, long *ip);
-extern int
-ncx_get_double_float(const void *xp, float *ip);
-extern int
-ncx_get_double_double(const void *xp, double *ip);
-
-extern int
-ncx_put_double_schar(void *xp, const schar *ip);
-extern int
-ncx_put_double_uchar(void *xp, const uchar *ip);
-extern int
-ncx_put_double_short(void *xp, const short *ip);
-extern int
-ncx_put_double_int(void *xp, const int *ip);
-extern int
-ncx_put_double_long(void *xp, const long *ip);
-extern int
-ncx_put_double_float(void *xp, const float *ip);
-extern int
-ncx_put_double_double(void *xp, const double *ip);
- 
+ncx_get_int_int(const void *xp, int *ip);
 
 /*
  * Other primitive conversion functions
@@ -378,6 +256,15 @@
 extern int
 ncx_put_off_t(void **xpp, const off_t *lp, size_t sizeof_off_t);
 
+extern int
+ncx_get_int32(const void **xpp, int *ip);
+extern int
+ncx_get_int64(const void **xpp, long long *ip);
+extern int
+ncx_put_int32(void **xpp, const int ip);
+extern int
+ncx_put_int64(void **xpp, const long long ip);
+
 
 /*
  * Aggregate numeric conversion functions.
@@ -419,6 +306,7 @@
  *
  */
 
+/*---- schar ----------------------------------------------------------------*/
 extern int
 ncx_getn_schar_schar(const void **xpp, size_t nelems, schar *ip);
 extern int
@@ -426,16 +314,18 @@
 extern int
 ncx_getn_schar_short(const void **xpp, size_t nelems, short *ip);
 extern int
+ncx_getn_schar_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
 ncx_getn_schar_int(const void **xpp, size_t nelems, int *ip);
 extern int
+ncx_getn_schar_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
 ncx_getn_schar_long(const void **xpp, size_t nelems, long *ip);
 extern int
 ncx_getn_schar_float(const void **xpp, size_t nelems, float *ip);
 extern int
 ncx_getn_schar_double(const void **xpp, size_t nelems, double *ip);
 extern int
-ncx_getn_schar_uint(const void **xpp, size_t nelems, unsigned int *ip);
-extern int
 ncx_getn_schar_longlong(const void **xpp, size_t nelems, longlong *ip);
 extern int
 ncx_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
@@ -447,16 +337,18 @@
 extern int
 ncx_pad_getn_schar_short(const void **xpp, size_t nelems, short *ip);
 extern int
+ncx_pad_getn_schar_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
 ncx_pad_getn_schar_int(const void **xpp, size_t nelems, int *ip);
 extern int
+ncx_pad_getn_schar_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
 ncx_pad_getn_schar_long(const void **xpp, size_t nelems, long *ip);
 extern int
 ncx_pad_getn_schar_float(const void **xpp, size_t nelems, float *ip);
 extern int
 ncx_pad_getn_schar_double(const void **xpp, size_t nelems, double *ip);
 extern int
-ncx_pad_getn_schar_uint(const void **xpp, size_t nelems, unsigned int *ip);
-extern int
 ncx_pad_getn_schar_longlong(const void **xpp, size_t nelems, longlong *ip);
 extern int
 ncx_pad_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
@@ -468,16 +360,18 @@
 extern int
 ncx_putn_schar_short(void **xpp, size_t nelems, const short *ip);
 extern int
+ncx_putn_schar_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
 ncx_putn_schar_int(void **xpp, size_t nelems, const int *ip);
 extern int
+ncx_putn_schar_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
 ncx_putn_schar_long(void **xpp, size_t nelems, const long *ip);
 extern int
 ncx_putn_schar_float(void **xpp, size_t nelems, const float *ip);
 extern int
 ncx_putn_schar_double(void **xpp, size_t nelems, const double *ip);
 extern int
-ncx_putn_schar_uint(void **xpp, size_t nelems, const unsigned int *ip);
-extern int
 ncx_putn_schar_longlong(void **xpp, size_t nelems, const longlong *ip);
 extern int
 ncx_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
@@ -489,38 +383,135 @@
 extern int
 ncx_pad_putn_schar_short(void **xpp, size_t nelems, const short *ip);
 extern int
+ncx_pad_putn_schar_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
 ncx_pad_putn_schar_int(void **xpp, size_t nelems, const int *ip);
 extern int
+ncx_pad_putn_schar_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
 ncx_pad_putn_schar_long(void **xpp, size_t nelems, const long *ip);
 extern int
 ncx_pad_putn_schar_float(void **xpp, size_t nelems, const float *ip);
 extern int
 ncx_pad_putn_schar_double(void **xpp, size_t nelems, const double *ip);
 extern int
-ncx_pad_putn_schar_uint(void **xpp, size_t nelems, const unsigned int *ip);
-extern int
 ncx_pad_putn_schar_longlong(void **xpp, size_t nelems, const longlong *ip);
 extern int
 ncx_pad_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
 
+/*---- uchar ----------------------------------------------------------------*/
+extern int
+ncx_getn_uchar_schar (const void **xpp, size_t nelems, schar  *ip);
+extern int
+ncx_getn_uchar_uchar (const void **xpp, size_t nelems, uchar  *ip);
+extern int
+ncx_getn_uchar_short (const void **xpp, size_t nelems, short  *ip);
+extern int
+ncx_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
+ncx_getn_uchar_int   (const void **xpp, size_t nelems, int    *ip);
+extern int
+ncx_getn_uchar_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
+ncx_getn_uchar_long  (const void **xpp, size_t nelems, long   *ip);
+extern int
+ncx_getn_uchar_float (const void **xpp, size_t nelems, float  *ip);
+extern int
+ncx_getn_uchar_double(const void **xpp, size_t nelems, double *ip);
+extern int
+ncx_getn_uchar_longlong (const void **xpp, size_t nelems, longlong  *ip);
+extern int
+ncx_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
+
+extern int
+ncx_pad_getn_uchar_schar (const void **xpp, size_t nelems, schar  *ip);
+extern int
+ncx_pad_getn_uchar_uchar (const void **xpp, size_t nelems, uchar  *ip);
+extern int
+ncx_pad_getn_uchar_short (const void **xpp, size_t nelems, short  *ip);
+extern int
+ncx_pad_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
+ncx_pad_getn_uchar_int   (const void **xpp, size_t nelems, int    *ip);
+extern int
+ncx_pad_getn_uchar_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
+ncx_pad_getn_uchar_long  (const void **xpp, size_t nelems, long   *ip);
+extern int
+ncx_pad_getn_uchar_float (const void **xpp, size_t nelems, float  *ip);
+extern int
+ncx_pad_getn_uchar_double(const void **xpp, size_t nelems, double *ip);
+extern int
+ncx_pad_getn_uchar_longlong (const void **xpp, size_t nelems, longlong  *ip);
+extern int
+ncx_pad_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
 
 extern int
+ncx_putn_uchar_schar (void **xpp, size_t nelems, const schar   *ip);
+extern int
+ncx_putn_uchar_uchar (void **xpp, size_t nelems, const uchar  *ip);
+extern int
+ncx_putn_uchar_short (void **xpp, size_t nelems, const short  *ip);
+extern int
+ncx_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
+ncx_putn_uchar_int   (void **xpp, size_t nelems, const int    *ip);
+extern int
+ncx_putn_uchar_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
+ncx_putn_uchar_long  (void **xpp, size_t nelems, const long   *ip);
+extern int
+ncx_putn_uchar_float (void **xpp, size_t nelems, const float  *ip);
+extern int
+ncx_putn_uchar_double(void **xpp, size_t nelems, const double  *ip);
+extern int
+ncx_putn_uchar_longlong (void **xpp, size_t nelems, const longlong  *ip);
+extern int
+ncx_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
+ 
+extern int
+ncx_pad_putn_uchar_schar (void **xpp, size_t nelems, const schar  *ip);
+extern int
+ncx_pad_putn_uchar_uchar (void **xpp, size_t nelems, const uchar  *ip);
+extern int
+ncx_pad_putn_uchar_short (void **xpp, size_t nelems, const short  *ip);
+extern int
+ncx_pad_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
+ncx_pad_putn_uchar_int   (void **xpp, size_t nelems, const int    *ip);
+extern int
+ncx_pad_putn_uchar_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
+ncx_pad_putn_uchar_long  (void **xpp, size_t nelems, const long   *ip);
+extern int
+ncx_pad_putn_uchar_float (void **xpp, size_t nelems, const float  *ip);
+extern int
+ncx_pad_putn_uchar_double(void **xpp, size_t nelems, const double *ip);
+extern int
+ncx_pad_putn_uchar_longlong (void **xpp, size_t nelems, const longlong  *ip);
+extern int
+ncx_pad_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
+
+/*---- short ----------------------------------------------------------------*/
+extern int
 ncx_getn_short_schar(const void **xpp, size_t nelems, schar *ip);
 extern int
 ncx_getn_short_uchar(const void **xpp, size_t nelems, uchar *ip);
 extern int
 ncx_getn_short_short(const void **xpp, size_t nelems, short *ip);
 extern int
+ncx_getn_short_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
 ncx_getn_short_int(const void **xpp, size_t nelems, int *ip);
 extern int
+ncx_getn_short_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
 ncx_getn_short_long(const void **xpp, size_t nelems, long *ip);
 extern int
 ncx_getn_short_float(const void **xpp, size_t nelems, float *ip);
 extern int
 ncx_getn_short_double(const void **xpp, size_t nelems, double *ip);
 extern int
-ncx_getn_short_uint(const void **xpp, size_t nelems, unsigned int *ip);
-extern int
 ncx_getn_short_longlong(const void **xpp, size_t nelems, longlong *ip);
 extern int
 ncx_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
@@ -532,16 +523,18 @@
 extern int
 ncx_pad_getn_short_short(const void **xpp, size_t nelems, short *ip);
 extern int
+ncx_pad_getn_short_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
 ncx_pad_getn_short_int(const void **xpp, size_t nelems, int *ip);
 extern int
+ncx_pad_getn_short_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
 ncx_pad_getn_short_long(const void **xpp, size_t nelems, long *ip);
 extern int
 ncx_pad_getn_short_float(const void **xpp, size_t nelems, float *ip);
 extern int
 ncx_pad_getn_short_double(const void **xpp, size_t nelems, double *ip);
 extern int
-ncx_pad_getn_short_uint(const void **xpp, size_t nelems, unsigned int *ip);
-extern int
 ncx_pad_getn_short_longlong(const void **xpp, size_t nelems, longlong *ip);
 extern int
 ncx_pad_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
@@ -553,16 +546,18 @@
 extern int
 ncx_putn_short_short(void **xpp, size_t nelems, const short *ip);
 extern int
+ncx_putn_short_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
 ncx_putn_short_int(void **xpp, size_t nelems, const int *ip);
 extern int
+ncx_putn_short_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
 ncx_putn_short_long(void **xpp, size_t nelems, const long *ip);
 extern int
 ncx_putn_short_float(void **xpp, size_t nelems, const float *ip);
 extern int
 ncx_putn_short_double(void **xpp, size_t nelems, const double *ip);
 extern int
-ncx_putn_short_uint(void **xpp, size_t nelems, const unsigned int *ip);
-extern int
 ncx_putn_short_longlong(void **xpp, size_t nelems, const longlong *ip);
 extern int
 ncx_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
@@ -574,21 +569,116 @@
 extern int
 ncx_pad_putn_short_short(void **xpp, size_t nelems, const short *ip);
 extern int
+ncx_pad_putn_short_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
 ncx_pad_putn_short_int(void **xpp, size_t nelems, const int *ip);
 extern int
+ncx_pad_putn_short_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
 ncx_pad_putn_short_long(void **xpp, size_t nelems, const long *ip);
 extern int
 ncx_pad_putn_short_float(void **xpp, size_t nelems, const float *ip);
 extern int
 ncx_pad_putn_short_double(void **xpp, size_t nelems, const double *ip);
 extern int
-ncx_pad_putn_short_uint(void **xpp, size_t nelems, const unsigned int *ip);
-extern int
 ncx_pad_putn_short_longlong(void **xpp, size_t nelems, const longlong *ip);
 extern int
 ncx_pad_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
 
+/*---- ushort ---------------------------------------------------------------*/
+extern int
+ncx_getn_ushort_schar (const void **xpp, size_t nelems, schar  *ip);
+extern int
+ncx_getn_ushort_uchar (const void **xpp, size_t nelems, uchar  *ip);
+extern int
+ncx_getn_ushort_short (const void **xpp, size_t nelems, short  *ip);
+extern int
+ncx_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
+ncx_getn_ushort_int   (const void **xpp, size_t nelems, int    *ip);
+extern int
+ncx_getn_ushort_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
+ncx_getn_ushort_long  (const void **xpp, size_t nelems, long   *ip);
+extern int
+ncx_getn_ushort_float (const void **xpp, size_t nelems, float  *ip);
+extern int
+ncx_getn_ushort_double(const void **xpp, size_t nelems, double *ip);
+extern int
+ncx_getn_ushort_longlong (const void **xpp, size_t nelems, longlong  *ip);
+extern int
+ncx_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
+
+extern int
+ncx_pad_getn_ushort_schar (const void **xpp, size_t nelems, schar  *ip);
+extern int
+ncx_pad_getn_ushort_uchar (const void **xpp, size_t nelems, uchar  *ip);
+extern int
+ncx_pad_getn_ushort_short (const void **xpp, size_t nelems, short  *ip);
+extern int
+ncx_pad_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
+ncx_pad_getn_ushort_int   (const void **xpp, size_t nelems, int    *ip);
+extern int
+ncx_pad_getn_ushort_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
+ncx_pad_getn_ushort_long  (const void **xpp, size_t nelems, long   *ip);
+extern int
+ncx_pad_getn_ushort_float (const void **xpp, size_t nelems, float  *ip);
+extern int
+ncx_pad_getn_ushort_double(const void **xpp, size_t nelems, double *ip);
+extern int
+ncx_pad_getn_ushort_longlong (const void **xpp, size_t nelems, longlong  *ip);
+extern int
+ncx_pad_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
+
+extern int
+ncx_putn_ushort_schar (void **xpp, size_t nelems, const schar  *ip);
+extern int
+ncx_putn_ushort_uchar (void **xpp, size_t nelems, const uchar  *ip);
+extern int
+ncx_putn_ushort_short (void **xpp, size_t nelems, const short  *ip);
+extern int
+ncx_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
+ncx_putn_ushort_int   (void **xpp, size_t nelems, const int    *ip);
+extern int
+ncx_putn_ushort_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
+ncx_putn_ushort_long  (void **xpp, size_t nelems, const long   *ip);
+extern int
+ncx_putn_ushort_float (void **xpp, size_t nelems, const float  *ip);
+extern int
+ncx_putn_ushort_double(void **xpp, size_t nelems, const double *ip);
+extern int
+ncx_putn_ushort_longlong (void **xpp, size_t nelems, const longlong  *ip);
+extern int
+ncx_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
+ 
+extern int
+ncx_pad_putn_ushort_schar (void **xpp, size_t nelems, const schar  *ip);
+extern int
+ncx_pad_putn_ushort_uchar (void **xpp, size_t nelems, const uchar  *ip);
+extern int
+ncx_pad_putn_ushort_short (void **xpp, size_t nelems, const short  *ip);
+extern int
+ncx_pad_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
+ncx_pad_putn_ushort_int   (void **xpp, size_t nelems, const int    *ip);
+extern int
+ncx_pad_putn_ushort_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
+ncx_pad_putn_ushort_long  (void **xpp, size_t nelems, const long   *ip);
+extern int
+ncx_pad_putn_ushort_float (void **xpp, size_t nelems, const float  *ip);
+extern int
+ncx_pad_putn_ushort_double(void **xpp, size_t nelems, const double *ip);
+extern int
+ncx_pad_putn_ushort_longlong (void **xpp, size_t nelems, const longlong  *ip);
+extern int
+ncx_pad_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
 
+/*---- int ------------------------------------------------------------------*/
 extern int
 ncx_getn_int_schar(const void **xpp, size_t nelems, schar *ip);
 extern int
@@ -596,16 +686,20 @@
 extern int
 ncx_getn_int_short(const void **xpp, size_t nelems, short *ip);
 extern int
+ncx_getn_int_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
 ncx_getn_int_int(const void **xpp, size_t nelems, int *ip);
 extern int
+ncx_getn_int_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
 ncx_getn_int_long(const void **xpp, size_t nelems, long *ip);
 extern int
+ncx_getn_long_long (const void **xpp, size_t nelems, long   *ip);
+extern int
 ncx_getn_int_float(const void **xpp, size_t nelems, float *ip);
 extern int
 ncx_getn_int_double(const void **xpp, size_t nelems, double *ip);
 extern int
-ncx_getn_int_uint(const void **xpp, size_t nelems, unsigned int *ip);
-extern int
 ncx_getn_int_longlong(const void **xpp, size_t nelems, longlong *ip);
 extern int
 ncx_getn_int_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
@@ -617,21 +711,76 @@
 extern int
 ncx_putn_int_short(void **xpp, size_t nelems, const short *ip);
 extern int
+ncx_putn_int_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
 ncx_putn_int_int(void **xpp, size_t nelems, const int *ip);
 extern int
+ncx_putn_int_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
 ncx_putn_int_long(void **xpp, size_t nelems, const long *ip);
 extern int
+ncx_putn_long_long (void **xpp, size_t nelems, const long   *ip);
+extern int
 ncx_putn_int_float(void **xpp, size_t nelems, const float *ip);
 extern int
 ncx_putn_int_double(void **xpp, size_t nelems, const double *ip);
 extern int
-ncx_putn_int_uint(void **xpp, size_t nelems, const unsigned int *ip);
-extern int
 ncx_putn_int_longlong(void **xpp, size_t nelems, const longlong *ip);
 extern int
 ncx_putn_int_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
  
+/*---- uint -----------------------------------------------------------------*/
+extern int
+ncx_getn_uint_schar (const void **xpp, size_t nelems, schar  *ip);
+extern int
+ncx_getn_uint_uchar (const void **xpp, size_t nelems, uchar  *ip);
+extern int
+ncx_getn_uint_short (const void **xpp, size_t nelems, short  *ip);
+extern int
+ncx_getn_uint_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
+ncx_getn_uint_int   (const void **xpp, size_t nelems, int    *ip);
+extern int
+ncx_getn_uint_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
+ncx_getn_uint_long  (const void **xpp, size_t nelems, long   *ip);
+extern int
+ncx_getn_long_long (const void **xpp, size_t nelems, long   *ip);
+extern int
+ncx_getn_uint_float (const void **xpp, size_t nelems, float  *ip);
+extern int
+ncx_getn_uint_double(const void **xpp, size_t nelems, double *ip);
+extern int
+ncx_getn_uint_longlong (const void **xpp, size_t nelems, longlong  *ip);
+extern int
+ncx_getn_uint_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
+
+extern int
+ncx_putn_uint_schar (void **xpp, size_t nelems, const schar  *ip);
+extern int
+ncx_putn_uint_uchar (void **xpp, size_t nelems, const uchar  *ip);
+extern int
+ncx_putn_uint_short (void **xpp, size_t nelems, const short  *ip);
+extern int
+ncx_putn_uint_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
+ncx_putn_uint_int   (void **xpp, size_t nelems, const int    *ip);
+extern int
+ncx_putn_uint_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
+ncx_putn_uint_long  (void **xpp, size_t nelems, const long   *ip);
+extern int
+ncx_putn_long_long (void **xpp, size_t nelems, const long   *ip);
+extern int
+ncx_putn_uint_float (void **xpp, size_t nelems, const float  *ip);
+extern int
+ncx_putn_uint_double(void **xpp, size_t nelems, const double *ip);
+extern int
+ncx_putn_uint_longlong (void **xpp, size_t nelems, const longlong  *ip);
+extern int
+ncx_putn_uint_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
 
+/*---- float ----------------------------------------------------------------*/
 extern int
 ncx_getn_float_schar(const void **xpp, size_t nelems, schar *ip);
 extern int
@@ -639,16 +788,18 @@
 extern int
 ncx_getn_float_short(const void **xpp, size_t nelems, short *ip);
 extern int
+ncx_getn_float_ushort(const void **xpp, size_t nelems, ushort *ip);
+extern int
 ncx_getn_float_int(const void **xpp, size_t nelems, int *ip);
 extern int
+ncx_getn_float_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
 ncx_getn_float_long(const void **xpp, size_t nelems, long *ip);
 extern int
 ncx_getn_float_float(const void **xpp, size_t nelems, float *ip);
 extern int
 ncx_getn_float_double(const void **xpp, size_t nelems, double *ip);
 extern int
-ncx_getn_float_uint(const void **xpp, size_t nelems, unsigned int *ip);
-extern int
 ncx_getn_float_longlong(const void **xpp, size_t nelems, longlong *ip);
 extern int
 ncx_getn_float_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
@@ -660,21 +811,23 @@
 extern int
 ncx_putn_float_short(void **xpp, size_t nelems, const short *ip);
 extern int
+ncx_putn_float_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
 ncx_putn_float_int(void **xpp, size_t nelems, const int *ip);
 extern int
+ncx_putn_float_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
 ncx_putn_float_long(void **xpp, size_t nelems, const long *ip);
 extern int
 ncx_putn_float_float(void **xpp, size_t nelems, const float *ip);
 extern int
 ncx_putn_float_double(void **xpp, size_t nelems, const double *ip);
 extern int
-ncx_putn_float_uint(void **xpp, size_t nelems, const unsigned int *ip);
-extern int
 ncx_putn_float_longlong(void **xpp, size_t nelems, const longlong *ip);
 extern int
 ncx_putn_float_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
  
-
+/*---- double ---------------------------------------------------------------*/
 extern int
 ncx_getn_double_schar(const void **xpp, size_t nelems, schar *ip);
 extern int
@@ -682,16 +835,18 @@
 extern int
 ncx_getn_double_short(const void **xpp, size_t nelems, short *ip);
 extern int
+ncx_getn_double_ushort(const void **xpp, size_t nelems, ushort  *ip);
+extern int
 ncx_getn_double_int(const void **xpp, size_t nelems, int *ip);
 extern int
+ncx_getn_double_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
 ncx_getn_double_long(const void **xpp, size_t nelems, long *ip);
 extern int
 ncx_getn_double_float(const void **xpp, size_t nelems, float *ip);
 extern int
 ncx_getn_double_double(const void **xpp, size_t nelems, double *ip);
 extern int
-ncx_getn_double_uint(const void **xpp, size_t nelems, unsigned int *ip);
-extern int
 ncx_getn_double_longlong(const void **xpp, size_t nelems, longlong *ip);
 extern int
 ncx_getn_double_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
@@ -703,20 +858,116 @@
 extern int
 ncx_putn_double_short(void **xpp, size_t nelems, const short *ip);
 extern int
+ncx_putn_double_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
 ncx_putn_double_int(void **xpp, size_t nelems, const int *ip);
 extern int
+ncx_putn_double_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
 ncx_putn_double_long(void **xpp, size_t nelems, const long *ip);
 extern int
 ncx_putn_double_float(void **xpp, size_t nelems, const float *ip);
 extern int
 ncx_putn_double_double(void **xpp, size_t nelems, const double *ip);
 extern int
-ncx_putn_double_uint(void **xpp, size_t nelems, const unsigned int *ip);
-extern int
 ncx_putn_double_longlong(void **xpp, size_t nelems, const longlong *ip);
 extern int
 ncx_putn_double_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
  
+/*---- longlong ----------------------------------------------------------------*/
+extern int
+ncx_getn_longlong_schar (const void **xpp, size_t nelems, schar  *ip);
+extern int
+ncx_getn_longlong_uchar (const void **xpp, size_t nelems, uchar  *ip);
+extern int
+ncx_getn_longlong_short (const void **xpp, size_t nelems, short  *ip);
+extern int
+ncx_getn_longlong_ushort(const void **xpp, size_t nelems, ushort  *ip);
+extern int
+ncx_getn_longlong_int   (const void **xpp, size_t nelems, int    *ip);
+extern int
+ncx_getn_longlong_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
+ncx_getn_longlong_long  (const void **xpp, size_t nelems, long   *ip);
+extern int
+ncx_getn_longlong_float (const void **xpp, size_t nelems, float  *ip);
+extern int
+ncx_getn_longlong_double(const void **xpp, size_t nelems, double *ip);
+extern int
+ncx_getn_longlong_longlong (const void **xpp, size_t nelems, longlong  *ip);
+extern int
+ncx_getn_longlong_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
+
+extern int
+ncx_putn_longlong_schar (void **xpp, size_t nelems, const schar  *ip);
+extern int
+ncx_putn_longlong_uchar (void **xpp, size_t nelems, const uchar  *ip);
+extern int
+ncx_putn_longlong_short (void **xpp, size_t nelems, const short  *ip);
+extern int
+ncx_putn_longlong_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
+ncx_putn_longlong_int   (void **xpp, size_t nelems, const int    *ip);
+extern int
+ncx_putn_longlong_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
+ncx_putn_longlong_long  (void **xpp, size_t nelems, const long   *ip);
+extern int
+ncx_putn_longlong_float (void **xpp, size_t nelems, const float  *ip);
+extern int
+ncx_putn_longlong_double(void **xpp, size_t nelems, const double *ip);
+extern int
+ncx_putn_longlong_longlong (void **xpp, size_t nelems, const longlong  *ip);
+extern int
+ncx_putn_longlong_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
+
+/*---- ulonglong ---------------------------------------------------------------*/
+extern int
+ncx_getn_ulonglong_schar (const void **xpp, size_t nelems, schar  *ip);
+extern int
+ncx_getn_ulonglong_uchar (const void **xpp, size_t nelems, uchar  *ip);
+extern int
+ncx_getn_ulonglong_short (const void **xpp, size_t nelems, short  *ip);
+extern int
+ncx_getn_ulonglong_ushort(const void **xpp, size_t nelems, ushort  *ip);
+extern int
+ncx_getn_ulonglong_int   (const void **xpp, size_t nelems, int    *ip);
+extern int
+ncx_getn_ulonglong_uint  (const void **xpp, size_t nelems, uint   *ip);
+extern int
+ncx_getn_ulonglong_long  (const void **xpp, size_t nelems, long   *ip);
+extern int
+ncx_getn_ulonglong_float (const void **xpp, size_t nelems, float  *ip);
+extern int
+ncx_getn_ulonglong_double(const void **xpp, size_t nelems, double *ip);
+extern int
+ncx_getn_ulonglong_longlong (const void **xpp, size_t nelems, longlong  *ip);
+extern int
+ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, ulonglong *ip);
+
+extern int
+ncx_putn_ulonglong_schar (void **xpp, size_t nelems, const schar  *ip);
+extern int
+ncx_putn_ulonglong_uchar (void **xpp, size_t nelems, const uchar  *ip);
+extern int
+ncx_putn_ulonglong_short (void **xpp, size_t nelems, const short  *ip);
+extern int
+ncx_putn_ulonglong_ushort(void **xpp, size_t nelems, const ushort *ip);
+extern int
+ncx_putn_ulonglong_int   (void **xpp, size_t nelems, const int    *ip);
+extern int
+ncx_putn_ulonglong_uint  (void **xpp, size_t nelems, const uint   *ip);
+extern int
+ncx_putn_ulonglong_long  (void **xpp, size_t nelems, const long   *ip);
+extern int
+ncx_putn_ulonglong_float (void **xpp, size_t nelems, const float  *ip);
+extern int
+ncx_putn_ulonglong_double(void **xpp, size_t nelems, const double *ip);
+extern int
+ncx_putn_ulonglong_longlong (void **xpp, size_t nelems, const longlong  *ip);
+extern int
+ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const ulonglong *ip);
+ 
 
 /*
  * Other aggregate conversion functions.
diff netcdf-c/libsrc/ncx.m4 cdf5/libsrc/ncx.m4
--- netcdf-c/libsrc/ncx.m4	2015-03-09 13:48:02.732710100 -0600
+++ cdf5/libsrc/ncx.m4	2014-11-14 14:54:46.004979700 -0700
@@ -32,7 +32,7 @@
  *	they handle IEEE subnormals properly, and their "n" versions
  *	operate speedily on arrays.
  */
-/* $Id: ncx.m4,v 2.58 2010/05/26 18:11:08 dmh Exp $ */
+/* $Id: ncx.m4 2795 2014-10-27 23:12:51Z wkliao $ */
 
 /*
  * An external data representation interface.
@@ -55,12 +55,21 @@
 #ifndef LONG_LONG_MAX
 #define LONG_LONG_MAX LLONG_MAX
 #endif
+#ifndef LONGLONG_MAX
+#define LONGLONG_MAX LONG_LONG_MAX
+#endif
 #ifndef LONG_LONG_MIN
 #define LONG_LONG_MIN LLONG_MIN
 #endif
+#ifndef LONGLONG_MIN
+#define LONGLONG_MIN LONG_LONG_MIN
+#endif
 #ifndef ULONG_LONG_MAX
 #define ULONG_LONG_MAX ULLONG_MAX
 #endif
+#ifndef ULONGLONG_MAX
+#define ULONGLONG_MAX ULONG_LONG_MAX
+#endif
 #include <float.h>
 #ifndef FLT_MAX /* This POSIX macro missing on some systems */
 # ifndef NO_IEEE_FLOAT
@@ -81,6 +90,16 @@
 #define Min(a,b) ((a) < (b) ? (a) : (b))
 #define Max(a,b) ((a) > (b) ? (a) : (b))
 
+#ifndef SIZEOF_USHORT
+#define SIZEOF_USHORT SIZEOF_UNSIGNED_SHORT_INT
+#endif
+#ifndef SIZEOF_UINT
+#define SIZEOF_UINT SIZEOF_UNSIGNED_INT
+#endif
+#ifndef SIZEOF_ULONG_LONG
+#define SIZEOF_ULONG_LONG SIZEOF_UNSIGNED_LONG_LONG
+#endif
+
 /*
  * If the machine's float domain is "smaller" than the external one
  * use the machine domain
@@ -334,17 +353,173 @@
 
 #endif /* LITTLE_ENDIAN */
 
+dnl dnl dnl
+dnl
+dnl Upcase(str)
+dnl
+define(`Upcase',dnl
+`dnl
+translit($1, abcdefghijklmnopqrstuvwxyz, ABCDEFGHIJKLMNOPQRSTUVWXYZ)')dnl
+dnl
+dnl dnl dnl
+dnl
+define(`Isizeof',     ``SIZEOF_'Upcase($1)')dnl
+define(`Xsizeof',   ``X_SIZEOF_'Upcase($1)')dnl
+define(`IXsizeof', ``SIZEOF_IX_'Upcase($1)')dnl
+define(`Imax',                 `Upcase($1)`_MAX'')dnl
+define(`Imin',                 `Upcase($1)`_MIN'')dnl
+define(`Xmax',             ``X_'Upcase($1)`_MAX'')dnl
+define(`Xmin',             ``X_'Upcase($1)`_MIN'')dnl
+define(`IXmax',           ``IX_'Upcase($1)`_MAX'')dnl
+dnl
+define(`Fmin',  `ifelse(index(`$1',`u'), 0, `0', `(double)Imin($1)')')dnl
+define(`Dmin',  `ifelse(index(`$1',`u'), 0, `0',         `Imin($1)')')dnl
+define(`FXmin', `ifelse(index(`$1',`u'), 0, `0', `(double)Xmin($1)')')dnl
+define(`DXmin', `ifelse(index(`$1',`u'), 0, `0',         `Xmin($1)')')dnl
+
+dnl
+dnl For GET APIs:
+dnl       check for negative xx if xp is   signed && ip is unsigned
+dnl Don't check for negative xx if xp is   signed && ip is   signed
+dnl Don't check for negative xx if xp is unsigned
+dnl
+define(`GETI_CheckNeg', `ifelse(index(`$1',`u'), 0, , `ifelse(index(`$2',`u'), 0, `	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */')')')dnl
+
+dnl
+dnl For PUT APIs:
+dnl       check for negative ip if xp is unsigned && ip is   signed
+dnl Don't check for negative ip if xp is unsigned && ip is unsigned
+dnl Don't check for negative ip if xp is   signed
+dnl
+define(`PUTI_CheckNeg', `ifelse(index(`$1',`u'), 0, `ifelse(index(`$2',`u'), 0, , `	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */')')')dnl
+
+dnl
+dnl For GET APIs and either $1 and $2 is float or double:
+dnl
+define(`GETF_CheckBND',
+`ifelse(`$1', `double', `	if(xx > Upcase($2)_MAX || xx < Dmin($2)) return NC_ERANGE;',
+		       `ifelse(`$1', `float', `ifelse(`$2', `double',,`	if(xx > (double)Upcase($2)_MAX || xx < Fmin($2)) return NC_ERANGE;')')'dnl
+)')
+
+dnl
+dnl For PUT APIs and either $1 and $2 is float or double:
+dnl
+define(`PUTF_CheckBND',
+`ifelse(`$2', `double', `	if(*ip > Xmax($1) || *ip < DXmin($1)) return NC_ERANGE;',
+		       `ifelse(`$2', `float', `	if(*ip > (double)Xmax($1) || *ip < FXmin($1)) return NC_ERANGE;')'dnl
+)')
+
+dnl
+dnl For GET APIs and $1 and $2 are not float or double
+dnl
+define(`GETI_CheckBND',
+``#'if IXmax($1) > Imax($2)
+	if (xx > Imax($2)'`ifelse(index(`$1',`u'), 0, , `ifelse(index(`$2',`u'), 0, , ` || xx < Imin($2)')')'`) return NC_ERANGE;'
+`#'endif)
+
+dnl
+dnl For PUT APIs and $1 and $2 are not float or double
+dnl
+define(`PUTI_CheckBND',
+``#'if IXmax($1) < Imax($2)
+	if (*ip > IXmax($1)'`ifelse(index(`$1',`u'), 0, , `ifelse(index(`$2',`u'), 0, , ` || *ip < Xmin($1)')')'`) return NC_ERANGE;'
+`#'endif)
 
 /*
  * Primitive numeric conversion functions.
  */
 
+dnl dnl dnl
+dnl
+dnl NCX_GET1F(xtype, itype) for floating-point types
+dnl
+define(`NCX_GET1F',dnl
+`dnl
+int
+ncx_get_$1_$2(const void *xp, $2 *ip)
+{
+	ix_$1 xx;
+	get_ix_$1(xp, &xx);
+	*ip = ($2) xx;
+GETF_CheckBND($1, $2)
+	return ENOERR;
+}
+')dnl
+
+dnl dnl dnl
+dnl
+dnl NCX_GET1I(xtype, itype, isComptable) for integral types
+dnl
+define(`NCX_GET1I',dnl
+`dnl
+int
+ncx_get_$1_$2(const void *xp, $2 *ip)
+{
+ifelse(`$3', `1',
+``#'if IXsizeof($1) == Isizeof($2) && IXmax($1) == Upcase($2)_MAX
+	get_ix_$1(xp, (ix_$1 *)ip);
+	return ENOERR;
+`#'else
+')dnl
+	ix_$1 xx;
+	get_ix_$1(xp, &xx);
+	*ip = ($2) xx;
+GETI_CheckBND($1, $2)
+GETI_CheckNeg($1, $2)
+ifelse(`$3', `1', ``#'endif
+')dnl
+	return ENOERR;
+}
+')dnl
+
+dnl dnl dnl
+dnl
+dnl NCX_PUT1F(xtype, itype) for floating-point types
+dnl
+define(`NCX_PUT1F',dnl
+`dnl
+int
+ncx_put_$1_$2(void *xp, const $2 *ip)
+{
+	ix_$1 xx = (ix_$1)*ip;
+	put_ix_$1(xp, &xx);
+PUTF_CheckBND($1, $2)
+	return ENOERR;
+}
+')dnl
+
+dnl dnl dnl
+dnl
+dnl NCX_PUT1I(xtype, itype, isComptable) for integral types
+dnl
+define(`NCX_PUT1I',dnl
+`dnl
+int
+ncx_put_$1_$2(void *xp, const $2 *ip)
+{
+ifelse(`$3', `1',
+``#'if IXsizeof($1) == Isizeof($2) && IXmax($1) == Upcase($2)_MAX
+	put_ix_$1(xp, (const ix_$1 *)ip);
+	return ENOERR;
+`#'else
+')dnl
+	ix_$1 xx = (ix_$1)*ip;
+	put_ix_$1(xp, &xx);
+PUTI_CheckBND($1, $2)
+PUTI_CheckNeg($1, $2)
+ifelse(`$3', `1', ``#'endif
+')dnl
+	return ENOERR;
+}
+')dnl
+
 /* x_schar */
+/* x_uchar */
 
-/* We don't implement any x_schar primitives. */
+/* We don't implement any x_schar and x_uchar primitives. */
 
 
-/* x_short */
+/* x_short -------------------------------------------------------------------*/
 
 #if SHORT_MAX == X_SHORT_MAX
 typedef short ix_short;
@@ -389,140 +564,105 @@
 	*cp = (*ip) & 0xff;
 }
 
+static NCX_GET1I(short, schar,     0)
+static NCX_GET1I(short, short,     1)
+static NCX_GET1I(short, int,       1)
+static NCX_GET1I(short, longlong,  1)
+static NCX_GET1I(short, ushort,    0)
+static NCX_GET1I(short, uchar,     0)
+static NCX_GET1I(short, uint,      0)
+static NCX_GET1I(short, ulonglong, 0)
+static NCX_GET1F(short, float)
+static NCX_GET1F(short, double)
 
-int
-ncx_get_short_schar(const void *xp, schar *ip)
+static int
+ncx_put_short_schar(void *xp, const schar *ip)
 {
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-	if(xx > SCHAR_MAX || xx < SCHAR_MIN)
-		return NC_ERANGE;
+	uchar *cp = (uchar *) xp;
+	if(*ip & 0x80)
+		*cp++ = 0xff;
+	else
+		*cp++ = 0;
+	*cp = (uchar)*ip;
 	return ENOERR;
 }
 
-int
-ncx_get_short_uchar(const void *xp, uchar *ip)
+static int
+ncx_put_short_uchar(void *xp, const uchar *ip)
 {
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-	if(xx > UCHAR_MAX || xx < 0)
-		return NC_ERANGE;
+	uchar *cp = (uchar *) xp;
+	*cp++ = 0;
+	*cp = *ip;
 	return ENOERR;
 }
 
-int
-ncx_get_short_short(const void *xp, short *ip)
-{
-#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
-	get_ix_short(xp, (ix_short *)ip);
-	return ENOERR;
-#else
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-#   if IX_SHORT_MAX > SHORT_MAX
-	if(xx > SHORT_MAX || xx < SHORT_MIN)
-		return NC_ERANGE;
-#   endif
-	return ENOERR;
-#endif
-}
+static NCX_PUT1I(short, short,     1)
+static NCX_PUT1I(short, int,       1)
+static NCX_PUT1I(short, longlong,  1)
+static NCX_PUT1I(short, ushort,    0)
+static NCX_PUT1I(short, uint,      0)
+static NCX_PUT1I(short, ulonglong, 0)
+static NCX_PUT1F(short, float)
+static NCX_PUT1F(short, double)
 
-int
-ncx_get_short_int(const void *xp, int *ip)
-{
-#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
-	get_ix_short(xp, (ix_short *)ip);
-	return ENOERR;
-#else
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-#   if IX_SHORT_MAX > INT_MAX
-	if(xx > INT_MAX || xx < INT_MIN)
-		return NC_ERANGE;
-#   endif
-	return ENOERR;
-#endif
-}
+/* x_ushort ------------------------------------------------------------------*/
 
-int
-ncx_get_short_uint(const void *xp, unsigned int *ip)
-{
-#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
-	get_ix_short(xp, (ix_short *)ip);
-	return ENOERR;
+#if USHORT_MAX == X_USHORT_MAX
+typedef unsigned short ix_ushort;
+#define SIZEOF_IX_USHORT SIZEOF_USHORT
+#define IX_USHORT_MAX USHORT_MAX
+#elif UINT_MAX >= X_USHORT_MAX
+typedef unsigned int ix_ushort;
+#define SIZEOF_IX_USHORT SIZEOF_UINT
+#define IX_USHORT_MAX UINT_MAX
+#elif ULONG_MAX >= X_USHORT_MAX
+typedef unsigned long ix_ushort;
+#define SIZEOF_IX_USHORT SIZEOF_ULONG
+#define IX_USHORT_MAX ULONG_MAX
+#elif ULLONG_MAX >= X_USHORT_MAX
+typedef unsigned long long ix_ushort;
+#define SIZEOF_IX_USHORT SIZEOF_ULONG_LONG
+#define IX_USHORT_MAX ULLONG_MAX
 #else
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-#   if IX_SHORT_MAX > INT_MAX
-	if(xx > UINT_MAX || xx < 0)
-		return NC_ERANGE;
-#   endif
-	return ENOERR;
+#error "ix_ushort implementation"
 #endif
-}
 
-int
-ncx_get_short_longlong(const void *xp, long long *ip)
+static void
+get_ix_ushort(const void *xp, ix_ushort *ip)
 {
-#if SIZEOF_IX_SHORT == SIZEOF_LONG_LONG && IX_SHORT_MAX == LONG_LONG_MAX
-	get_ix_short(xp, (ix_short *)ip);
-	return ENOERR;
-#else
-	/* assert(LONG_LONG_MAX >= X_SHORT_MAX); */
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-	return ENOERR;
-#endif
-}
-
-int
-ncx_get_short_ulonglong(const void *xp, unsigned long long *ip)
+	const uchar *cp = (const uchar *) xp;
+	*ip = *cp++ << 8;
+#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
+	if(*ip & 0x8000)
 {
-#if SIZEOF_IX_SHORT == SIZEOF_LONG && IX_SHORT_MAX == LONG_MAX
-	get_ix_short(xp, (ix_short *)ip);
-	return ENOERR;
-#else
-	/* assert(LONG_LONG_MAX >= X_SHORT_MAX); */
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-	if(xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-#endif
+		/* extern is negative */
+		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
 }
-
-int
-ncx_get_short_float(const void *xp, float *ip)
-{
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-#if 0	/* TODO: determine when necessary */
-	if(xx > FLT_MAX || xx < (-FLT_MAX))
-		return NC_ERANGE;
 #endif
-	return ENOERR;
+	*ip |= *cp; 
 }
 
-int
-ncx_get_short_double(const void *xp, double *ip)
+static void
+put_ix_ushort(void *xp, const ix_ushort *ip)
 {
-	/* assert(DBL_MAX >= X_SHORT_MAX); */
-	ix_short xx;
-	get_ix_short(xp, &xx);
-	*ip = xx;
-	return ENOERR;
+	uchar *cp = (uchar *) xp;
+	*cp++ = (*ip) >> 8;
+	*cp = (*ip) & 0xff;
 }
 
-int
-ncx_put_short_schar(void *xp, const schar *ip)
+static NCX_GET1I(ushort, schar,     0)
+static NCX_GET1I(ushort, short,     0)
+static NCX_GET1I(ushort, int,       0)
+static NCX_GET1I(ushort, longlong,  0)
+static NCX_GET1I(ushort, ushort,    1)
+static NCX_GET1I(ushort, uchar,     1)
+static NCX_GET1I(ushort, uint,      1)
+static NCX_GET1I(ushort, ulonglong, 1)
+static NCX_GET1F(ushort, float)
+static NCX_GET1F(ushort, double)
+
+static int
+ncx_put_ushort_schar(void *xp, const schar *ip)
 {
 	uchar *cp = (uchar *) xp;
 	if(*ip & 0x80)
@@ -530,11 +670,13 @@
 	else
 		*cp++ = 0;
 	*cp = (uchar)*ip;
+        if (*ip < 0) return NC_ERANGE;
+
 	return ENOERR;
 }
 
-int
-ncx_put_short_uchar(void *xp, const uchar *ip)
+static int
+ncx_put_ushort_uchar(void *xp, const uchar *ip)
 {
 	uchar *cp = (uchar *) xp;
 	*cp++ = 0;
@@ -542,112 +684,16 @@
 	return ENOERR;
 }
 
-int
-ncx_put_short_short(void *xp, const short *ip)
-{
-#if SIZEOF_IX_SHORT == SIZEOF_SHORT && X_SHORT_MAX == SHORT_MAX
-	put_ix_short(xp, (const ix_short *)ip);
-	return ENOERR;
-#else
-	ix_short xx = (ix_short)*ip;
-	put_ix_short(xp, &xx);
-# if X_SHORT_MAX < SHORT_MAX
-	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
-		return NC_ERANGE;
-# endif
-	return ENOERR;
-#endif
-}
-
-int
-ncx_put_short_int(void *xp, const int *ip)
-{
-#if SIZEOF_IX_SHORT == SIZEOF_INT && X_SHORT_MAX == INT_MAX
-	put_ix_short(xp, (const ix_short *)ip);
-	return ENOERR;
-#else
-	ix_short xx = (ix_short)*ip;
-	put_ix_short(xp, &xx);
-# if X_SHORT_MAX < INT_MAX
-	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
-		return NC_ERANGE;
-# endif
-	return ENOERR;
-#endif
-}
-
-int
-ncx_put_short_uint(void *xp, const unsigned int *ip)
-{
-#if SIZEOF_IX_SHORT == SIZEOF_INT && X_SHORT_MAX == INT_MAX
-	put_ix_short(xp, (const ix_short *)ip);
-	return ENOERR;
-#else
-	ix_short xx = (ix_short)*ip;
-	put_ix_short(xp, &xx);
-# if X_SHORT_MAX < INT_MAX
-	if(*ip > X_SHORT_MAX)
-		return NC_ERANGE;
-# endif
-	return ENOERR;
-#endif
-}
-
-int
-ncx_put_short_longlong(void *xp, const long long *ip)
-{
-#if SIZEOF_IX_SHORT == SIZEOF_LONG_LONG && X_SHORT_MAX == LONG_LONG_MAX
-	put_ix_short(xp, (const ix_short *)ip);
-	return ENOERR;
-#else
-	ix_short xx = (ix_short)*ip;
-	put_ix_short(xp, &xx);
-# if X_SHORT_MAX < LONG_LONG_MAX
-	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
-		return NC_ERANGE;
-# endif
-	return ENOERR;
-#endif
-}
-
-int
-ncx_put_short_ulonglong(void *xp, const unsigned long long *ip)
-{
-#if SIZEOF_IX_SHORT == SIZEOF_LONG_LONG && X_SHORT_MAX == LONG_LONG_MAX
-	put_ix_short(xp, (const ix_short *)ip);
-	return ENOERR;
-#else
-	ix_short xx = (ix_short)*ip;
-	put_ix_short(xp, &xx);
-# if X_SHORT_MAX < LONG_LONG_MAX
-	if(*ip > X_SHORT_MAX)
-		return NC_ERANGE;
-# endif
-	return ENOERR;
-#endif
-}
-
-int
-ncx_put_short_float(void *xp, const float *ip)
-{
-	ix_short xx = *ip;
-	put_ix_short(xp, &xx);
-	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_put_short_double(void *xp, const double *ip)
-{
-	ix_short xx = *ip;
-	put_ix_short(xp, &xx);
-	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
+static NCX_PUT1I(ushort, short,     0)
+static NCX_PUT1I(ushort, int,       0)
+static NCX_PUT1I(ushort, longlong,  0)
+static NCX_PUT1I(ushort, ushort,    1)
+static NCX_PUT1I(ushort, uint,      1)
+static NCX_PUT1I(ushort, ulonglong, 1)
+static NCX_PUT1F(ushort, float)
+static NCX_PUT1F(ushort, double)
 
-/* x_int */
+/* x_int ---------------------------------------------------------------------*/
 
 #if SHORT_MAX == X_INT_MAX
 typedef short ix_int;
@@ -695,120 +741,18 @@
 	*cp   = ((*ip) & 0x000000ff);
 }
 
+static NCX_GET1I(int, schar,     0)
+static NCX_GET1I(int, short,     1)
+       NCX_GET1I(int, int,       1)
+static NCX_GET1I(int, longlong,  1)
+static NCX_GET1I(int, ushort,    0)
+static NCX_GET1I(int, uchar,     0)
+static NCX_GET1I(int, uint,      0)
+static NCX_GET1I(int, ulonglong, 0)
+static NCX_GET1F(int, float)
+static NCX_GET1F(int, double)
 
-int
-ncx_get_int_schar(const void *xp, schar *ip)
-{
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-	if(xx > SCHAR_MAX || xx < SCHAR_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_int_uchar(const void *xp, uchar *ip)
-{
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-	if(xx > UCHAR_MAX || xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_int_short(const void *xp, short *ip)
-{
-#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
-	get_ix_int(xp, (ix_int *)ip);
-	return ENOERR;
-#else
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-#  if IX_INT_MAX > SHORT_MAX
-	if(xx > SHORT_MAX || xx < SHORT_MIN)
-		return NC_ERANGE;
-#  endif
-	return ENOERR;
-#endif
-}
-
-int
-ncx_get_int_int(const void *xp, int *ip)
-{
-#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
-	get_ix_int(xp, (ix_int *)ip);
-	return ENOERR;
-#else
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-#  if IX_INT_MAX > INT_MAX
-	if(xx > INT_MAX || xx < INT_MIN)
-		return NC_ERANGE;
-#  endif
-	return ENOERR;
-#endif
-}
-
-int
-ncx_get_int_uint(const void *xp, unsigned int *ip)
-{
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-	if(xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_int_longlong(const void *xp, long long *ip)
-{
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-	return ENOERR;
-}
-
-int
-ncx_get_int_ulonglong(const void *xp, unsigned long long *ip)
-{
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-	if(xx < 0)
-	      return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_int_float(const void *xp, float *ip)
-{
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-#if 0	/* TODO: determine when necessary */
-	if(xx > FLT_MAX || xx < (-FLT_MAX))
-		return NC_ERANGE;
-#endif
-	return ENOERR;
-}
-
-int
-ncx_get_int_double(const void *xp, double *ip)
-{
-	/* assert((DBL_MAX >= X_INT_MAX); */
-	ix_int xx;
-	get_ix_int(xp, &xx);
-	*ip = xx;
-	return ENOERR;
-}
-
-int
+static int
 ncx_put_int_schar(void *xp, const schar *ip)
 {
 	uchar *cp = (uchar *) xp;
@@ -828,7 +772,7 @@
 	return ENOERR;
 }
 
-int
+static int
 ncx_put_int_uchar(void *xp, const uchar *ip)
 {
 	uchar *cp = (uchar *) xp;
@@ -839,111 +783,110 @@
 	return ENOERR;
 }
 
-int
-ncx_put_int_short(void *xp, const short *ip)
-{
-#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
-	put_ix_int(xp, (ix_int *)ip);
-	return ENOERR;
-#else
-	ix_int xx = (ix_int)(*ip);
-	put_ix_int(xp, &xx);
-#   if IX_INT_MAX < SHORT_MAX
-	if(*ip > X_INT_MAX || *ip < X_INT_MIN)
-		return NC_ERANGE;
-#   endif
-	return ENOERR;
-#endif
-}
+static NCX_PUT1I(int, short,     1)
+       NCX_PUT1I(int, int,       1)
+static NCX_PUT1I(int, longlong,  1)
+static NCX_PUT1I(int, ushort,    0)
+static NCX_PUT1I(int, uint,      0)
+static NCX_PUT1I(int, ulonglong, 0)
+static NCX_PUT1F(int, float)
+static NCX_PUT1F(int, double)
 
-int
-ncx_put_int_int(void *xp, const int *ip)
-{
-#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
-	put_ix_int(xp, (ix_int *)ip);
-	return ENOERR;
+
+/* x_uint --------------------------------------------------------------------*/
+
+#if USHORT_MAX == X_UINT_MAX
+typedef ushort ix_uint;
+#define SIZEOF_IX_UINT SIZEOF_USHORT
+#define IX_UINT_MAX USHORT_MAX
+#elif UINT_MAX  >= X_UINT_MAX
+typedef uint ix_uint;
+#define SIZEOF_IX_UINT SIZEOF_UINT
+#define IX_UINT_MAX UINT_MAX
+#elif ULONG_MAX  >= X_UINT_MAX
+typedef ulong ix_uint;
+#define SIZEOF_IX_UINT SIZEOF_ULONG
+#define IX_UINT_MAX ULONG_MAX
 #else
-	ix_int xx = (ix_int)(*ip);
-	put_ix_int(xp, &xx);
-#   if IX_INT_MAX < INT_MAX
-	if(*ip > X_INT_MAX || *ip < X_INT_MIN)
-		return NC_ERANGE;
-#   endif
-	return ENOERR;
+#error "ix_uint implementation"
 #endif
-}
 
-int
-ncx_put_int_uint(void *xp, const unsigned int *ip)
+
+static void
+get_ix_uint(const void *xp, ix_uint *ip)
 {
-#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
-	put_ix_int(xp, (ix_int *)ip);
-	return ENOERR;
-#else
-	ix_int xx = (ix_int)(*ip);
-	put_ix_int(xp, &xx);
-	if(*ip > X_UINT_MAX)
-		return NC_ERANGE;
-	return ENOERR;
-#endif
+	const uchar *cp = (const uchar *) xp;
+
+	*ip = *cp++ << 24;
+	*ip |= (*cp++ << 16);
+	*ip |= (*cp++ << 8);
+	*ip |= *cp; 
 }
 
-int
-ncx_put_int_longlong(void *xp, const longlong *ip)
+static void
+put_ix_uint(void *xp, const ix_uint *ip)
 {
-#if SIZEOF_IX_INT == SIZEOF_LONG && IX_INT_MAX == LONG_MAX
-	put_ix_int(xp, (ix_int *)ip);
-	return ENOERR;
-#else
-	ix_int xx = (ix_int)(*ip);
-	put_ix_int(xp, &xx);
-#   if IX_INT_MAX < LONG_LONG_MAX
-	if(*ip > X_INT_MAX || *ip < X_INT_MIN)
-		return NC_ERANGE;
-#   endif
-	return ENOERR;
-#endif
+	uchar *cp = (uchar *) xp;
+
+	*cp++ = (*ip) >> 24;
+	*cp++ = ((*ip) & 0x00ff0000) >> 16;
+	*cp++ = ((*ip) & 0x0000ff00) >>  8;
+	*cp   = ((*ip) & 0x000000ff);
 }
 
-int
-ncx_put_int_ulonglong(void *xp, const unsigned long long *ip)
-{
-#if SIZEOF_IX_INT == SIZEOF_LONG && IX_INT_MAX == LONG_MAX
-	put_ix_int(xp, (ix_int *)ip);
-	return ENOERR;
-#else
-	ix_int xx = (ix_int)(*ip);
-	put_ix_int(xp, &xx);
-#   if IX_INT_MAX < LONG_MAX
-	if(*ip > X_INT_MAX)
-		return NC_ERANGE;
-#   endif
-	return ENOERR;
+#if X_SIZEOF_UINT != SIZEOF_UINT
+static NCX_GET1I(uint, uint,      1)
 #endif
-}
 
-int
-ncx_put_int_float(void *xp, const float *ip)
+static NCX_GET1I(uint, schar,     0)
+static NCX_GET1I(uint, short,     0)
+static NCX_GET1I(uint, int,       0)
+static NCX_GET1I(uint, longlong,  0)
+static NCX_GET1I(uint, ushort,    1)
+static NCX_GET1I(uint, uchar,     1)
+static NCX_GET1I(uint, ulonglong, 1)
+static NCX_GET1F(uint, float)
+static NCX_GET1F(uint, double)
+
+static int
+ncx_put_uint_schar(void *xp, const schar *ip)
 {
-	ix_int xx = (ix_int)(*ip);
-	put_ix_int(xp, &xx);
-	if(*ip > (double)X_INT_MAX || *ip < (double)X_INT_MIN)
-		return NC_ERANGE;
+	uchar *cp = (uchar *) xp;
+	*cp++ = 0x00;
+	*cp++ = 0x00;
+	*cp++ = 0x00;
+	*cp = (uchar)*ip;
+
+	if (*ip < 0) return NC_ERANGE;
+
 	return ENOERR;
 }
 
-int
-ncx_put_int_double(void *xp, const double *ip)
+static int
+ncx_put_uint_uchar(void *xp, const uchar *ip)
 {
-	ix_int xx = (ix_int)(*ip);
-	put_ix_int(xp, &xx);
-	if(*ip > X_INT_MAX || *ip < X_INT_MIN)
-		return NC_ERANGE;
+	uchar *cp = (uchar *) xp;
+	*cp++ = 0x00;
+	*cp++ = 0x00;
+	*cp++ = 0x00;
+	*cp   = *ip;
 	return ENOERR;
 }
  
+#if X_SIZEOF_UINT != SIZEOF_UINT
+static NCX_PUT1I(uint, uint,      1)
+#endif
+#
+static NCX_PUT1I(uint, short,     0)
+static NCX_PUT1I(uint, int,       0)
+static NCX_PUT1I(uint, longlong,  0)
+static NCX_PUT1I(uint, ushort,    1)
+static NCX_PUT1I(uint, ulonglong, 1)
+static NCX_PUT1F(uint, float)
+static NCX_PUT1F(uint, double)
 
-/* x_float */
+
+/* x_float -------------------------------------------------------------------*/
 
 #if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
 
@@ -1353,180 +1296,30 @@
 #error "ix_float implementation"
 #endif
 
-
-int
-ncx_get_float_schar(const void *xp, schar *ip)
-{
-	float xx;
-	get_ix_float(xp, &xx);
-	*ip = (schar) xx;
-	if(xx > SCHAR_MAX || xx < SCHAR_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_float_uchar(const void *xp, uchar *ip)
-{
-	float xx;
-	get_ix_float(xp, &xx);
-	*ip = (uchar) xx;
-	if(xx > UCHAR_MAX || xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_float_short(const void *xp, short *ip)
-{
-	float xx;
-	get_ix_float(xp, &xx);
-	*ip = (short) xx;
-	if(xx > SHORT_MAX || xx < SHORT_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_float_int(const void *xp, int *ip)
-{
-	float xx;
-	get_ix_float(xp, &xx);
-	*ip = (int) xx;
-	if(xx > (double)INT_MAX || xx < (double)INT_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_float_uint(const void *xp, unsigned int *ip)
-{
-	float xx;
-	get_ix_float(xp, &xx);
-	*ip = (unsigned int) xx;
-	if(xx > (double)UINT_MAX || xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_float_longlong(const void *xp, longlong *ip)
-{
-	float xx;
-	get_ix_float(xp, &xx);
-	*ip = (longlong) xx;
-	if(xx > (double)LONG_LONG_MAX || xx < (double)LONG_LONG_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_float_ulonglong(const void *xp, unsigned long long *ip)
-{
-	float xx;
-	get_ix_float(xp, &xx);
-	*ip = (longlong) xx;
-	if(xx > (double)ULONG_LONG_MAX || xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
+#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
+static int
 ncx_get_float_float(const void *xp, float *ip)
 {
 	/* TODO */
 	get_ix_float(xp, ip);
 	return ENOERR;
 }
-
-int
-ncx_get_float_double(const void *xp, double *ip)
-{
-	/* TODO */
-	float xx;
-	get_ix_float(xp, &xx);
-	*ip = xx;
-	return ENOERR;
-}
-
-
-int
-ncx_put_float_schar(void *xp, const schar *ip)
-{
-	float xx = (float) *ip;
-	put_ix_float(xp, &xx);
-	return ENOERR;
-}
-
-int
-ncx_put_float_uchar(void *xp, const uchar *ip)
-{
-	float xx = (float) *ip;
-	put_ix_float(xp, &xx);
-	return ENOERR;
-}
-
-int
-ncx_put_float_short(void *xp, const short *ip)
-{
-	float xx = (float) *ip;
-	put_ix_float(xp, &xx);
-#if 0	/* TODO: figure this out */
-	if((float)(*ip) > X_FLOAT_MAX || (float)(*ip) < X_FLOAT_MIN)
-		return NC_ERANGE;
-#endif
-	return ENOERR;
-}
-
-int
-ncx_put_float_int(void *xp, const int *ip)
-{
-	float xx = (float) *ip;
-	put_ix_float(xp, &xx);
-#if 1	/* TODO: figure this out */
-	if((float)(*ip) > X_FLOAT_MAX || (float)(*ip) < X_FLOAT_MIN)
-		return NC_ERANGE;
-#endif
-	return ENOERR;
-}
-
-int
-ncx_put_float_uint(void *xp, const unsigned int *ip)
-{
-	float xx = (float) *ip;
-	put_ix_float(xp, &xx);
-#if 1	/* TODO: figure this out */
-	if((float)(*ip) > X_FLOAT_MAX)
-		return NC_ERANGE;
 #endif
-	return ENOERR;
-}
 
-int
-ncx_put_float_longlong(void *xp, const longlong *ip)
-{
-	float xx = (float) *ip;
-	put_ix_float(xp, &xx);
-#if 1	/* TODO: figure this out */
-	if((float)(*ip) > X_FLOAT_MAX || (float)(*ip) < X_FLOAT_MIN)
-		return NC_ERANGE;
-#endif
-	return ENOERR;
-}
+#define ix_float float
 
-int
-ncx_put_float_ulonglong(void *xp, const unsigned long long *ip)
-{
-	float xx = (float) *ip;
-	put_ix_float(xp, &xx);
-#if 1	/* TODO: figure this out */
-	if((float)(*ip) > X_FLOAT_MAX)
-		return NC_ERANGE;
-#endif
-	return ENOERR;
-}
+static NCX_GET1F(float, schar)
+static NCX_GET1F(float, short)
+static NCX_GET1F(float, int)
+static NCX_GET1F(float, double)
+static NCX_GET1F(float, longlong)
+static NCX_GET1F(float, uchar)
+static NCX_GET1F(float, ushort)
+static NCX_GET1F(float, uint)
+static NCX_GET1F(float, ulonglong)
 
-int
+#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
+static int
 ncx_put_float_float(void *xp, const float *ip)
 {
 	put_ix_float(xp, ip);
@@ -1536,18 +1329,20 @@
 #endif
 	return ENOERR;
 }
+#endif
 
-int
-ncx_put_float_double(void *xp, const double *ip)
-{
-	float xx = (float) *ip;
-	put_ix_float(xp, &xx);
-	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
+static NCX_PUT1F(float, schar)
+static NCX_PUT1F(float, short)
+static NCX_PUT1F(float, int)
+static NCX_PUT1F(float, double)
+static NCX_PUT1F(float, longlong)
+static NCX_PUT1F(float, uchar)
+static NCX_PUT1F(float, ushort)
+static NCX_PUT1F(float, uint)
+static NCX_PUT1F(float, ulonglong)
 
-/* x_double */
+
+/* x_double ------------------------------------------------------------------*/
 
 #if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE  && !defined(NO_IEEE_FLOAT)
 
@@ -1824,84 +1619,18 @@
 #error "ix_double implementation"
 #endif
 
-int
-ncx_get_double_schar(const void *xp, schar *ip)
-{
-	double xx;
-	get_ix_double(xp, &xx);
-	*ip = (schar) xx;
-	if(xx > SCHAR_MAX || xx < SCHAR_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_double_uchar(const void *xp, uchar *ip)
-{
-	double xx;
-	get_ix_double(xp, &xx);
-	*ip = (uchar) xx;
-	if(xx > UCHAR_MAX || xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_double_short(const void *xp, short *ip)
-{
-	double xx;
-	get_ix_double(xp, &xx);
-	*ip = (short) xx;
-	if(xx > SHORT_MAX || xx < SHORT_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_double_int(const void *xp, int *ip)
-{
-	double xx;
-	get_ix_double(xp, &xx);
-	*ip = (int) xx;
-	if(xx > INT_MAX || xx < INT_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_double_uint(const void *xp, unsigned int *ip)
-{
-	double xx;
-	get_ix_double(xp, &xx);
-	*ip = (unsigned int) xx;
-	if(xx > UINT_MAX || xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-}
-
-int
-ncx_get_double_longlong(const void *xp, longlong *ip)
-{
-	double xx;
-	get_ix_double(xp, &xx);
-	*ip = (longlong) xx;
-	if(xx > LONG_LONG_MAX || xx < LONG_LONG_MIN)
-		return NC_ERANGE;
-	return ENOERR;
-}
+#define ix_double double
 
-int
-ncx_get_double_ulonglong(const void *xp, unsigned long long *ip)
-{
-	double xx;
-	get_ix_double(xp, &xx);
-	*ip = (unsigned longlong) xx;
-	if(xx > ULONG_LONG_MAX || xx < 0)
-		return NC_ERANGE;
-	return ENOERR;
-}
+static NCX_GET1F(double, schar)
+static NCX_GET1F(double, short)
+static NCX_GET1F(double, int)
+static NCX_GET1F(double, longlong)
+static NCX_GET1F(double, uchar)
+static NCX_GET1F(double, ushort)
+static NCX_GET1F(double, uint)
+static NCX_GET1F(double, ulonglong)
 
-int
+static int
 ncx_get_double_float(const void *xp, float *ip)
 {
 	double xx;
@@ -1920,114 +1649,194 @@
 	return ENOERR;
 }
 
-int
+#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
+static int
 ncx_get_double_double(const void *xp, double *ip)
 {
 	/* TODO */
 	get_ix_double(xp, ip);
 	return ENOERR;
 }
+#endif
 
+static NCX_PUT1F(double, schar)
+static NCX_PUT1F(double, uchar)
+static NCX_PUT1F(double, short)
+static NCX_PUT1F(double, ushort)
+static NCX_PUT1F(double, int)
+static NCX_PUT1F(double, uint)
+static NCX_PUT1F(double, longlong)
+static NCX_PUT1F(double, ulonglong)
 
-int
-ncx_put_double_schar(void *xp, const schar *ip)
-{
-	double xx = (double) *ip;
-	put_ix_double(xp, &xx);
-	return ENOERR;
-}
-
-int
-ncx_put_double_uchar(void *xp, const uchar *ip)
-{
-	double xx = (double) *ip;
-	put_ix_double(xp, &xx);
-	return ENOERR;
-}
-
-int
-ncx_put_double_short(void *xp, const short *ip)
+static int
+ncx_put_double_float(void *xp, const float *ip)
 {
 	double xx = (double) *ip;
 	put_ix_double(xp, &xx);
-#if 0	/* TODO: figure this out */
+#if 1	/* TODO: figure this out */
 	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
 		return NC_ERANGE;
 #endif
 	return ENOERR;
 }
 
-int
-ncx_put_double_int(void *xp, const int *ip)
+#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
+static int
+ncx_put_double_double(void *xp, const double *ip)
 {
-	double xx = (double) *ip;
-	put_ix_double(xp, &xx);
-#if 0	/* TODO: figure this out */
-	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
+	put_ix_double(xp, ip);
+#ifdef NO_IEEE_FLOAT
+	if(*ip > X_DOUBLE_MAX || *ip < X_DOUBLE_MIN)
 		return NC_ERANGE;
 #endif
 	return ENOERR;
 }
+#endif
 
-int
-ncx_put_double_uint(void *xp, const unsigned int *ip)
-{
-	double xx = (double) *ip;
-	put_ix_double(xp, &xx);
-#if 0	/* TODO: figure this out */
-	if((double)(*ip) > X_DOUBLE_MAX)
-		return NC_ERANGE;
+
+/* x_longlong ---------------------------------------------------------------------*/
+
+#if SHORT_MAX == X_LONGLONG_MAX
+typedef short ix_longlong;
+#define SIZEOF_IX_LONGLONG SIZEOF_SHORT
+#define IX_LONGLONG_MAX SHORT_MAX
+#elif LONG_LONG_MAX  >= X_LONGLONG_MAX
+typedef longlong ix_longlong;
+#define SIZEOF_IX_LONGLONG SIZEOF_LONGLONG
+#define IX_LONGLONG_MAX LONG_LONG_MAX
+#elif LONG_MAX  >= X_LONGLONG_MAX
+typedef long ix_longlong;
+#define SIZEOF_IX_LONGLONG SIZEOF_LONG
+#define IX_LONGLONG_MAX LONG_MAX
+#else
+#error "ix_longlong implementation"
 #endif
-	return ENOERR;
-}
 
-int
-ncx_put_double_longlong(void *xp, const longlong *ip)
+
+static void
+get_ix_longlong(const void *xp, ix_longlong *ip)
 {
-	double xx = (double) *ip;
-	put_ix_double(xp, &xx);
-#if 1	/* TODO: figure this out */
-	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
-		return NC_ERANGE;
-#endif
-	return ENOERR;
+    const uchar *cp = (const uchar *) xp;
+
+    *ip  = ((long long)(*cp++) << 56);
+    *ip |= ((long long)(*cp++) << 48);
+    *ip |= ((long long)(*cp++) << 40);
+    *ip |= ((long long)(*cp++) << 32);
+    *ip |= ((long long)(*cp++) << 24);
+    *ip |= ((long long)(*cp++) << 16);
+    *ip |= ((long long)(*cp++) <<  8);
+    *ip |=  (long long)*cp;
 }
 
-int
-ncx_put_double_ulonglong(void *xp, const unsigned long long *ip)
+static void
+put_ix_longlong(void *xp, const ix_longlong *ip)
 {
-	double xx = (double) *ip;
-	put_ix_double(xp, &xx);
-#if 1	/* TODO: figure this out */
-	if((double)(*ip) > X_DOUBLE_MAX)
-		return NC_ERANGE;
-#endif
-	return ENOERR;
+    uchar *cp = (uchar *) xp;
+
+    *cp++ = (*ip) >> 56;
+    *cp++ = ((*ip) & 0x00ff000000000000LL) >> 48;
+    *cp++ = ((*ip) & 0x0000ff0000000000LL) >> 40;
+    *cp++ = ((*ip) & 0x000000ff00000000LL) >> 32;
+    *cp++ = ((*ip) & 0x00000000ff000000LL) >> 24;
+    *cp++ = ((*ip) & 0x0000000000ff0000LL) >> 16;
+    *cp++ = ((*ip) & 0x000000000000ff00LL) >>  8;
+    *cp   = ((*ip) & 0x00000000000000ffLL);
 }
 
-int
-ncx_put_double_float(void *xp, const float *ip)
-{
-	double xx = (double) *ip;
-	put_ix_double(xp, &xx);
-#if 1	/* TODO: figure this out */
-	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
-		return NC_ERANGE;
+static NCX_GET1I(longlong, schar,     0)
+static NCX_GET1I(longlong, short,     1)
+static NCX_GET1I(longlong, int,       1)
+static NCX_GET1I(longlong, longlong,  1)
+static NCX_GET1I(longlong, ushort,    0)
+static NCX_GET1I(longlong, uchar,     0)
+static NCX_GET1I(longlong, uint,      0)
+static NCX_GET1I(longlong, ulonglong, 0)
+static NCX_GET1F(longlong, float)
+static NCX_GET1F(longlong, double)
+
+static NCX_PUT1I(longlong, schar,     0)
+static NCX_PUT1I(longlong, short,     1)
+static NCX_PUT1I(longlong, int,       1)
+static NCX_PUT1I(longlong, longlong,  1)
+static NCX_PUT1I(longlong, ushort,    0)
+static NCX_PUT1I(longlong, uchar,     0)
+static NCX_PUT1I(longlong, uint,      0)
+static NCX_PUT1I(longlong, ulonglong, 0)
+static NCX_PUT1F(longlong, float)
+static NCX_PUT1F(longlong, double)
+ 
+
+/* x_ulonglong --------------------------------------------------------------------*/
+
+#if USHORT_MAX == X_ULONGLONG_MAX
+typedef ushort ix_ulonglong;
+#define SIZEOF_IX_ULONGLONG SIZEOF_USHORT
+#define IX_ULONGLONG_MAX USHORT_MAX
+#elif ULONG_LONG_MAX  >= X_ULONGLONG_MAX
+typedef ulonglong ix_ulonglong;
+#define SIZEOF_IX_ULONGLONG SIZEOF_ULONGLONG
+#define IX_ULONGLONG_MAX ULONG_LONG_MAX
+#elif ULONG_MAX  >= X_ULONGLONG_MAX
+typedef ulong ix_ulonglong;
+#define SIZEOF_IX_ULONGLONG SIZEOF_ULONG
+#define IX_ULONGLONG_MAX ULONG_MAX
+#else
+#error "ix_ulonglong implementation"
 #endif
-	return ENOERR;
+
+
+static void
+get_ix_ulonglong(const void *xp, ix_ulonglong *ip)
+{
+    const uchar *cp = (const uchar *) xp;
+
+    *ip  = ((unsigned long long)(*cp++) << 56);
+    *ip |= ((unsigned long long)(*cp++) << 48);
+    *ip |= ((unsigned long long)(*cp++) << 40);
+    *ip |= ((unsigned long long)(*cp++) << 32);
+    *ip |= ((unsigned long long)(*cp++) << 24);
+    *ip |= ((unsigned long long)(*cp++) << 16);
+    *ip |= ((unsigned long long)(*cp++) <<  8);
+    *ip |=  (unsigned long long)*cp;
 }
 
-int
-ncx_put_double_double(void *xp, const double *ip)
+static void
+put_ix_ulonglong(void *xp, const ix_ulonglong *ip)
 {
-	put_ix_double(xp, ip);
-#ifdef NO_IEEE_FLOAT
-	if(*ip > X_DOUBLE_MAX || *ip < X_DOUBLE_MIN)
-		return NC_ERANGE;
-#endif
-	return ENOERR;
+    uchar *cp = (uchar *) xp;
+
+    *cp++ = (*ip) >> 56;
+    *cp++ = ((*ip) & 0x00ff000000000000ULL) >> 48;
+    *cp++ = ((*ip) & 0x0000ff0000000000ULL) >> 40;
+    *cp++ = ((*ip) & 0x000000ff00000000ULL) >> 32;
+    *cp++ = ((*ip) & 0x00000000ff000000ULL) >> 24;
+    *cp++ = ((*ip) & 0x0000000000ff0000ULL) >> 16;
+    *cp++ = ((*ip) & 0x000000000000ff00ULL) >>  8;
+    *cp   = ((*ip) & 0x00000000000000ffULL);
 }
 
+static NCX_GET1I(ulonglong, schar,     0)
+static NCX_GET1I(ulonglong, short,     0)
+static NCX_GET1I(ulonglong, int,       0)
+static NCX_GET1I(ulonglong, longlong,  0)
+static NCX_GET1I(ulonglong, ushort,    1)
+static NCX_GET1I(ulonglong, uchar,     1)
+static NCX_GET1I(ulonglong, uint,      1)
+static NCX_GET1I(ulonglong, ulonglong, 1)
+static NCX_GET1F(ulonglong, float)
+static NCX_GET1F(ulonglong, double)
+
+static NCX_PUT1I(ulonglong, schar,     0)
+static NCX_PUT1I(ulonglong, short,     0)
+static NCX_PUT1I(ulonglong, int,       0)
+static NCX_PUT1I(ulonglong, longlong,  0)
+static NCX_PUT1I(ulonglong, uchar,     1)
+static NCX_PUT1I(ulonglong, ushort,    1)
+static NCX_PUT1I(ulonglong, uint,      1)
+static NCX_PUT1I(ulonglong, ulonglong, 1)
+static NCX_PUT1F(ulonglong, float)
+static NCX_PUT1F(ulonglong, double)
+ 
 
 /* x_size_t */
 
@@ -2077,7 +1886,7 @@
 		/* No negative offsets stored in netcdf */
 	if (*lp < 0) {
 	  /* Assume this is an overflow of a 32-bit int... */
-	  return ERANGE;
+	  return NC_ERANGE;
 	}
 	  
 	assert(sizeof_off_t == 4 || sizeof_off_t == 8);
@@ -2140,7 +1949,7 @@
  * on this system.  Set an error code and return.
  */
 		if (*lp != 0) {
-		  return ERANGE;
+		  return NC_ERANGE;
 		}
 
 		*lp  = ((off_t)(*cp++) << 24);
@@ -2154,7 +1963,7 @@
 		   * than 2^32 which is not allowed, but is not caught
 		   * by the previous check
 		   */
-		  return ERANGE;
+		  return NC_ERANGE;
 		}
 #else
 		*lp =  ((off_t)(*cp++) << 56);
@@ -2171,28 +1980,111 @@
 	return ENOERR;
 }
 
+/*----< ncx_get_int32() >--------------------------------------------------*/
+int
+ncx_get_int32(const void **xpp,
+              int         *ip)
+{
+    const uchar *cp = (const uchar *) *xpp;
+
+    /* cannot call swap4b(), as lp is 8-byte */
+    *ip  = (*cp++ << 24);
+    *ip |= (*cp++ << 16);
+    *ip |= (*cp++ <<  8);
+    *ip |=  *cp;
+
+    /* advance *xpp 4 bytes */
+    *xpp = (void *)((const char *)(*xpp) + 4);
+
+    return NC_NOERR;
+}
+
+/*----< ncx_get_int64() >-------------------------------------------------*/
+int
+ncx_get_int64(const void **xpp,
+              long long   *llp)
+{
+    const uchar *cp = (const uchar *) *xpp;
+
+    /* below is the same as calling swap8b(llp, *xpp) */
+    *llp  = ((long long)(*cp++) << 56);
+    *llp |= ((long long)(*cp++) << 48);
+    *llp |= ((long long)(*cp++) << 40);
+    *llp |= ((long long)(*cp++) << 32);
+    *llp |= ((long long)(*cp++) << 24);
+    *llp |= ((long long)(*cp++) << 16);
+    *llp |= ((long long)(*cp++) <<  8);
+    *llp |=  (long long)*cp;
+
+    /* advance *xpp 8 bytes */
+    *xpp = (void *)((const char *)(*xpp) + 8);
+
+    return NC_NOERR;
+}
+
+/*---< ncx_put_int32() >-----------------------------------------------------*/
+/* copy the contents of lp (a signed 32-bit integer) to xpp in Big Endian
+ * form and advance *xpp 4 bytes
+ */
+int
+ncx_put_int32(void      **xpp,
+              const int   ip)
+{
+#ifdef WORDS_BIGENDIAN
+    int *ptr = (int*) (*xpp); /* typecast to 4-byte integer */
+    *ptr = ip;
+#else
+    /* bitwise shifts below are to produce an integer in Big Endian */
+    /* cannot call swap4b(), as lp is 8-byte */
+    uchar *cp = (uchar *) *xpp;
+    *cp++ = (uchar)((ip & 0xff000000) >> 24);
+    *cp++ = (uchar)((ip & 0x00ff0000) >> 16);
+    *cp++ = (uchar)((ip & 0x0000ff00) >>  8);
+    *cp   = (uchar)( ip & 0x000000ff);
+#endif
+    /* advance *xpp 4 bytes */
+    *xpp  = (void *)((char *)(*xpp) + 4);
+
+    return NC_NOERR;
+}
+
+/*---< ncx_put_int64() >-----------------------------------------------------*/
+/* copy the contents of lp (a signed 64-bit integer) to xpp in Big Endian
+ * form and advance *xpp 8 bytes
+ */
+int
+ncx_put_int64(void             **xpp,
+              const long long    ip)
+{
+#ifdef WORDS_BIGENDIAN
+    long long *ptr = (long long*) (*xpp); /* typecast to 8-byte integer */
+    *ptr = ip;
+#else
+    uchar *cp = (uchar *) *xpp;
+    /* below is the same as calling swap8b(*xpp, &ip) */
+    *cp++ = (uchar)((ip & 0xff00000000000000ULL) >> 56);
+    *cp++ = (uchar)((ip & 0x00ff000000000000ULL) >> 48);
+    *cp++ = (uchar)((ip & 0x0000ff0000000000ULL) >> 40);
+    *cp++ = (uchar)((ip & 0x000000ff00000000ULL) >> 32);
+    *cp++ = (uchar)((ip & 0x00000000ff000000ULL) >> 24);
+    *cp++ = (uchar)((ip & 0x0000000000ff0000ULL) >> 16);
+    *cp++ = (uchar)((ip & 0x000000000000ff00ULL) >>  8);
+    *cp   = (uchar)( ip & 0x00000000000000ffULL);
+#endif
+    /* advance *xpp 8 bytes */
+    *xpp  = (void *)((char *)(*xpp) + 8);
+
+    return NC_NOERR;
+}
+
 
 /*
  * Aggregate numeric conversion functions.
  */
-dnl dnl dnl
-dnl
-dnl Upcase(str)
 dnl
-define(`Upcase',dnl
-`dnl
-translit($1, abcdefghijklmnopqrstuvwxyz, ABCDEFGHIJKLMNOPQRSTUVWXYZ)')dnl
-dnl
-dnl dnl dnl
-dnl
-dnl  sjl: some macros used for putn/getn:
-define(`Isizeof', ``SIZEOF_'Upcase($1)')dnl
-define(`Xsizeof', ``X_SIZEOF_'Upcase($1)')dnl
-define(`Imax', `Upcase($1)`_MAX'')dnl
-define(`Imin', `Upcase($1)`_MIN'')dnl
-define(`Xmax', ``X_'Upcase($1)`_MAX'')dnl
-define(`Xmin', ``X_'Upcase($1)`_MIN'')dnl
-define(`ImaxExp', `Upcase($1)`_MAX_EXP'')dnl
+define(`GETN_CheckBND', `ifelse(index(`$1',`u'), 0, , `ifelse(index(`$2',`u'), 0, `|| xp[i] < 0', `|| xp[i] < Imin($2)')')')dnl
+define(`PUTN_CheckBND', `ifelse(index(`$2',`u'), 0, , `ifelse(index(`$1',`u'), 0, `|| tp[i] < 0', `|| tp[i] < Xmin($1)')')')dnl
+
 dnl
 dnl dnl dnl
 dnl
@@ -2222,46 +2114,50 @@
 ')dnl
 dnl dnl dnl
 dnl
-dnl NCX_GETN_SCHAR(Type)
+dnl NCX_GETN_CHAR(Type)
 dnl
-define(`NCX_GETN_SCHAR',dnl
+define(`NCX_GETN_CHAR',dnl
 `dnl
 int
-ncx_getn_schar_$1(const void **xpp, size_t nelems, $1 *tp)
+ncx_getn_$1_$2(const void **xpp, size_t nelems, $2 *tp)
 {
-	schar *xp = (schar *)(*xpp);
+	int status = ENOERR;
+	$1 *xp = ($1 *)(*xpp);
 
 	while(nelems-- != 0)
 	{
+ifelse(index(`$1',`u'), 0, , `ifelse(index(`$2',`u'), 0, `		if (*xp < 0) status = NC_ERANGE;')')
 		*tp++ = *xp++;
 	}
 
 	*xpp = (const void *)xp;
-	return ENOERR;
+	return status;
 }
 ')dnl
 dnl dnl dnl
 dnl
-dnl NCX_PAD_GETN_SCHAR(Type)
+dnl NCX_PAD_GETN_CHAR(Type)
 dnl
-define(`NCX_PAD_GETN_SCHAR',dnl
+define(`NCX_PAD_GETN_CHAR',dnl
 `dnl
 int
-ncx_pad_getn_schar_$1(const void **xpp, size_t nelems, $1 *tp)
+ncx_pad_getn_$1_$2(const void **xpp, size_t nelems, $2 *tp)
 {
+	int status = ENOERR;
 	size_t rndup = nelems % X_ALIGN;
-	schar *xp = (schar *) *xpp;
+	$1 *xp = ($1 *) *xpp;
 
 	if(rndup)
 		rndup = X_ALIGN - rndup;
 
 	while(nelems-- != 0)
 	{
+ifelse(index(`$1',`u'), 0, , `ifelse(index(`$2',`u'), 0, `		if (*xp < 0) status = NC_ERANGE;')')
 		*tp++ = *xp++;
 	}
 
 	*xpp = (void *)(xp + rndup);
-	return ENOERR;
+	return status;
 }
 ')dnl
 dnl dnl dnl
@@ -2291,7 +2187,7 @@
 ')dnl
 dnl dnl dnl
 dnl
-dnl NCX_GETN(XType, Type)
+dnl NCX_GETN(XType, Type, condition)
 dnl
 define(`NCX_GETN',dnl
 `dnl
@@ -2333,7 +2229,9 @@
     for (i=0; i<ni; i++) {
       tp[i] = ($2) Max( Imin($2), Min(Imax($2), ($2) xp[i]));
      /* test for range errors (not always needed but do it anyway) */
-      nrange += xp[i] < Imin($2) || xp[i] > Imax($2);
+     /* if xpp is unsigned, we need not check if xp[i] < Imin */
+     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
+      nrange += xp[i] > Imax($2) GETN_CheckBND($1, $2);
     }
    /* update xpp and tp */
     if (realign) xp = ($1 *) *xpp;
@@ -2361,27 +2259,27 @@
 ')dnl
 dnl dnl dnl
 dnl
-dnl NCX_PAD_GETN_SHORT( Type)
+dnl NCX_PAD_GETN_SHORT(xtype ttype)
 dnl
 define(`NCX_PAD_GETN_SHORT',dnl
 `dnl
 int
-ncx_pad_getn_short_$1(const void **xpp, size_t nelems, $1 *tp)
+ncx_pad_getn_$1_$2(const void **xpp, size_t nelems, $2 *tp)
 {
 	const size_t rndup = nelems % 2;
 
 	const char *xp = (const char *) *xpp;
 	int status = ENOERR;
 
-	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
+	for( ; nelems != 0; nelems--, xp += Xsizeof($1), tp++)
 	{
-		const int lstatus = ncx_get_short_$1(xp, tp);
+		const int lstatus = ncx_get_$1_$2(xp, tp);
 		if(lstatus != ENOERR)
 			status = lstatus;
 	}
 
 	if(rndup != 0)
-		xp += X_SIZEOF_SHORT;
+		xp += Xsizeof($1);
 		
 	*xpp = (void *)xp;
 	return status;
@@ -2422,21 +2320,21 @@
 ')dnl
 dnl dnl dnl
 dnl
-dnl NCX_PUTN_SCHAR(Type)
+dnl NCX_PUTN_CHAR(Type)
 dnl
-define(`NCX_PUTN_SCHAR',dnl
+define(`NCX_PUTN_CHAR',dnl
 `dnl
 int
-ncx_putn_schar_$1(void **xpp, size_t nelems, const $1 *tp)
+ncx_putn_$1_$2(void **xpp, size_t nelems, const $2 *tp)
 {
 	int status = ENOERR;
-	schar *xp = (schar *) *xpp;
+	$1 *xp = ($1 *) *xpp;
 
 	while(nelems-- != 0)
 	{
-		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
+		if(*tp > Xmax($1) ifelse(index(`$2',`u'), 0, , `ifelse(index(`$1',`u'), 0, `|| *tp < 0',`|| *tp < Xmin(schar)')'))
 			status = NC_ERANGE;
-		*xp++ = (schar) *tp++;
+		*xp++ = ($1) *tp++;
 	}
 
 	*xpp = (void *)xp;
@@ -2445,26 +2343,25 @@
 ')dnl
 dnl dnl dnl
 dnl
-dnl NCX_PAD_PUTN_SCHAR(Type)
+dnl NCX_PAD_PUTN_CHAR(xtype, ttype)
 dnl
-define(`NCX_PAD_PUTN_SCHAR',dnl
+define(`NCX_PAD_PUTN_CHAR',dnl
 `dnl
 int
-ncx_pad_putn_schar_$1(void **xpp, size_t nelems, const $1 *tp)
+ncx_pad_putn_$1_$2(void **xpp, size_t nelems, const $2 *tp)
 {
 	int status = ENOERR;
 	size_t rndup = nelems % X_ALIGN;
-	schar *xp = (schar *) *xpp;
+	$1 *xp = ($1 *) *xpp;
 
 	if(rndup)
 		rndup = X_ALIGN - rndup;
 
 	while(nelems-- != 0)
 	{
-		/* N.B. schar as signed */
-		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
+		if(*tp > Xmax($1) ifelse(index(`$2',`u'), 0, , `ifelse(index(`$1',`u'), 0, `|| *tp < 0',`|| *tp < Xmin(schar)')'))
 			status = NC_ERANGE;
-		*xp++ = (schar) *tp++;
+		*xp++ = ($1) *tp++;
 	}
 
 
@@ -2507,7 +2404,7 @@
 ')dnl
 dnl dnl dnl
 dnl
-dnl NCX_PUTN(XType, Type)
+dnl NCX_PUTN(XType, Type, condition)
 dnl
 define(`NCX_PUTN',dnl
 `dnl
@@ -2555,13 +2452,15 @@
       /* for some reason int to float, for putn, requires a special case */ 
       d = tp[i];
       xp[i] = ($1) Max( Xmin($1), Min(Xmax($1), ($1) d));
-      nrange += d < Xmin($1) || d > Xmax($1);
+      nrange += tp[i] > Xmax($1) PUTN_CheckBND($1, $2);
 ',dnl
 `dnl
       /* the normal case: */
       xp[i] = ($1) Max( Xmin($1), Min(Xmax($1), ($1) tp[i]));
      /* test for range errors (not always needed but do it anyway) */
-      nrange += tp[i] < Xmin($1) || tp[i] > Xmax($1);
+     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
+     /* if tp is unsigned, we need not check if tp[i] < Xmin */
+      nrange += tp[i] > Xmax($1) PUTN_CheckBND($1, $2);
 ')dnl
     }
    /* copy workspace back if necessary */ 
@@ -2595,29 +2494,29 @@
 ')dnl
 dnl dnl dnl
 dnl
-dnl NCX_PAD_PUTN_SHORT(Type)
+dnl NCX_PAD_PUTN_SHORT(xtype, ttype)
 dnl
 define(`NCX_PAD_PUTN_SHORT',dnl
 `dnl
 int
-ncx_pad_putn_short_$1(void **xpp, size_t nelems, const $1 *tp)
+ncx_pad_putn_$1_$2(void **xpp, size_t nelems, const $2 *tp)
 {
 	const size_t rndup = nelems % 2;
 
 	char *xp = (char *) *xpp;
 	int status = ENOERR;
 
-	for( ; nelems != 0; nelems--, xp += Xsizeof(short), tp++)
+	for( ; nelems != 0; nelems--, xp += Xsizeof($1), tp++)
 	{
-		int lstatus = ncx_put_short_$1(xp, tp);
+		int lstatus = ncx_put_$1_$2(xp, tp);
 		if(lstatus != ENOERR)
 			status = lstatus;
 	}
 
 	if(rndup != 0)
 	{
-		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
-		xp += X_SIZEOF_SHORT;	
+		(void) memcpy(xp, nada, Xsizeof($1));
+		xp += Xsizeof($1);	
 	}
 		
 	*xpp = (void *)xp;
@@ -2632,93 +2530,181 @@
 dnl
 dnl dnl dnl
 
-/* schar */
+/* schar ---------------------------------------------------------------------*/
 
-dnl NCX_GETN_SCHAR(schar)
+dnl NCX_GETN_CHAR(schar, schar)
 int
 ncx_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
 {
 	NCX_GETN_Byte_Body
 }
-dnl NCX_GETN_SCHAR(uchar)
+dnl NCX_GETN_CHAR(schar, uchar)
 int
 ncx_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
 {
 	NCX_GETN_Byte_Body
 }
-NCX_GETN_SCHAR(short)
-NCX_GETN_SCHAR(int)
-NCX_GETN_SCHAR(float)
-NCX_GETN_SCHAR(double)
-NCX_GETN_SCHAR(uint)
-NCX_GETN_SCHAR(longlong)
-NCX_GETN_SCHAR(ulonglong)
+NCX_GETN_CHAR(schar, short)
+NCX_GETN_CHAR(schar, int)
+NCX_GETN_CHAR(schar, float)
+NCX_GETN_CHAR(schar, double)
+NCX_GETN_CHAR(schar, longlong)
+NCX_GETN_CHAR(schar, ushort)
+NCX_GETN_CHAR(schar, uint)
+NCX_GETN_CHAR(schar, ulonglong)
 
-dnl NCX_PAD_GETN_SCHAR(schar)
+dnl NCX_PAD_GETN_CHAR(schar, schar)
 int
 ncx_pad_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
 {
 	NCX_PAD_GETN_Byte_Body
 }
-dnl NCX_PAD_GETN_SCHAR(uchar)
+dnl NCX_PAD_GETN_CHAR(schar, uchar)
 int
 ncx_pad_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
 {
 	NCX_PAD_GETN_Byte_Body
 }
-NCX_PAD_GETN_SCHAR(short)
-NCX_PAD_GETN_SCHAR(int)
-NCX_PAD_GETN_SCHAR(float)
-NCX_PAD_GETN_SCHAR(double)
-NCX_PAD_GETN_SCHAR(uint)
-NCX_PAD_GETN_SCHAR(longlong)
-NCX_PAD_GETN_SCHAR(ulonglong)
+NCX_PAD_GETN_CHAR(schar, short)
+NCX_PAD_GETN_CHAR(schar, int)
+NCX_PAD_GETN_CHAR(schar, float)
+NCX_PAD_GETN_CHAR(schar, double)
+NCX_PAD_GETN_CHAR(schar, longlong)
+NCX_PAD_GETN_CHAR(schar, ushort)
+NCX_PAD_GETN_CHAR(schar, uint)
+NCX_PAD_GETN_CHAR(schar, ulonglong)
 
-dnl NCX_PUTN_SCHAR(schar)
+dnl NCX_PUTN_CHAR(schar, schar)
 int
 ncx_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
 {
 	NCX_PUTN_Byte_Body
 }
-dnl NCX_PUTN_SCHAR(uchar)
+dnl NCX_PUTN_CHAR(schar, uchar)
 int
 ncx_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
 {
 	NCX_PUTN_Byte_Body
 }
-NCX_PUTN_SCHAR(short)
-NCX_PUTN_SCHAR(int)
-NCX_PUTN_SCHAR(float)
-NCX_PUTN_SCHAR(double)
-NCX_PUTN_SCHAR(uint)
-NCX_PUTN_SCHAR(longlong)
-NCX_PUTN_SCHAR(ulonglong)
+NCX_PUTN_CHAR(schar, short)
+NCX_PUTN_CHAR(schar, int)
+NCX_PUTN_CHAR(schar, float)
+NCX_PUTN_CHAR(schar, double)
+NCX_PUTN_CHAR(schar, longlong)
+NCX_PUTN_CHAR(schar, ushort)
+NCX_PUTN_CHAR(schar, uint)
+NCX_PUTN_CHAR(schar, ulonglong)
 
-dnl NCX_PAD_PUTN_SCHAR(schar)
+dnl NCX_PAD_PUTN_CHAR(schar, schar)
 int
 ncx_pad_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
 {
 	NCX_PAD_PUTN_Byte_Body
 }
-dnl NCX_PAD_PUTN_SCHAR(uchar)
+dnl NCX_PAD_PUTN_CHAR(schar, uchar)
 int
 ncx_pad_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
 {
 	NCX_PAD_PUTN_Byte_Body
 }
-NCX_PAD_PUTN_SCHAR(short)
-NCX_PAD_PUTN_SCHAR(int)
-NCX_PAD_PUTN_SCHAR(float)
-NCX_PAD_PUTN_SCHAR(double)
-NCX_PAD_PUTN_SCHAR(uint)
-NCX_PAD_PUTN_SCHAR(longlong)
-NCX_PAD_PUTN_SCHAR(ulonglong)
+NCX_PAD_PUTN_CHAR(schar, short)
+NCX_PAD_PUTN_CHAR(schar, int)
+NCX_PAD_PUTN_CHAR(schar, float)
+NCX_PAD_PUTN_CHAR(schar, double)
+NCX_PAD_PUTN_CHAR(schar, longlong)
+NCX_PAD_PUTN_CHAR(schar, ushort)
+NCX_PAD_PUTN_CHAR(schar, uint)
+NCX_PAD_PUTN_CHAR(schar, ulonglong)
 
 
-/* short */
+/* uchar ---------------------------------------------------------------------*/
+dnl
+dnl NCX_GETN_CHAR(uchar, schar)
+int
+ncx_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
+{
+	NCX_GETN_Byte_Body
+}
+dnl NCX_GETN_CHAR(uchar, uchar)
+int
+ncx_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
+{
+	NCX_GETN_Byte_Body
+}
+NCX_GETN_CHAR(uchar, short)
+NCX_GETN_CHAR(uchar, int)
+NCX_GETN_CHAR(uchar, float)
+NCX_GETN_CHAR(uchar, double)
+NCX_GETN_CHAR(uchar, longlong)
+NCX_GETN_CHAR(uchar, ushort)
+NCX_GETN_CHAR(uchar, uint)
+NCX_GETN_CHAR(uchar, ulonglong)
+
+dnl NCX_PAD_GETN_CHAR(uchar, schar)
+int
+ncx_pad_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
+{
+	NCX_PAD_GETN_Byte_Body
+}
+dnl NCX_PAD_GETN_CHAR(uchar, uchar)
+int
+ncx_pad_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
+{
+	NCX_PAD_GETN_Byte_Body
+}
+NCX_PAD_GETN_CHAR(uchar, short)
+NCX_PAD_GETN_CHAR(uchar, int)
+NCX_PAD_GETN_CHAR(uchar, float)
+NCX_PAD_GETN_CHAR(uchar, double)
+NCX_PAD_GETN_CHAR(uchar, longlong)
+NCX_PAD_GETN_CHAR(uchar, ushort)
+NCX_PAD_GETN_CHAR(uchar, uint)
+NCX_PAD_GETN_CHAR(uchar, ulonglong)
+
+dnl NCX_PUTN_CHAR(uchar, schar)
+int
+ncx_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp)
+{
+	NCX_PUTN_Byte_Body
+}
+dnl NCX_PUTN_CHAR(uchar, uchar)
+int
+ncx_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp)
+{
+	NCX_PUTN_Byte_Body
+}
+NCX_PUTN_CHAR(uchar, short)
+NCX_PUTN_CHAR(uchar, int)
+NCX_PUTN_CHAR(uchar, float)
+NCX_PUTN_CHAR(uchar, double)
+NCX_PUTN_CHAR(uchar, longlong)
+NCX_PUTN_CHAR(uchar, ushort)
+NCX_PUTN_CHAR(uchar, uint)
+NCX_PUTN_CHAR(uchar, ulonglong)
+
+dnl NCX_PAD_PUTN_UCHAR(uchar, schar)
+int
+ncx_pad_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp)
+{
+	NCX_PAD_PUTN_Byte_Body
+}
+dnl NCX_PAD_PUTN_UCHAR(uchar, uchar)
+int
+ncx_pad_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp)
+{
+	NCX_PAD_PUTN_Byte_Body
+}
+NCX_PAD_PUTN_CHAR(uchar, short)
+NCX_PAD_PUTN_CHAR(uchar, int)
+NCX_PAD_PUTN_CHAR(uchar, float)
+NCX_PAD_PUTN_CHAR(uchar, double)
+NCX_PAD_PUTN_CHAR(uchar, longlong)
+NCX_PAD_PUTN_CHAR(uchar, ushort)
+NCX_PAD_PUTN_CHAR(uchar, uint)
+NCX_PAD_PUTN_CHAR(uchar, ulonglong)
+
+/* short ---------------------------------------------------------------------*/
 
-NCX_GETN(short, schar)
-NCX_GETN(short, uchar)
 #if X_SIZEOF_SHORT == SIZEOF_SHORT
 /* optimized version */
 int
@@ -2735,25 +2721,27 @@
 #else
 NCX_GETN(short, short)
 #endif
+NCX_GETN(short, schar)
 NCX_GETN(short, int)
 NCX_GETN(short, float)
 NCX_GETN(short, double)
-NCX_GETN(short,uint)
 NCX_GETN(short,longlong)
+NCX_GETN(short, uchar)
+NCX_GETN(short, ushort)
+NCX_GETN(short, uint)
 NCX_GETN(short,ulonglong)
 
-NCX_PAD_GETN_SHORT(schar)
-NCX_PAD_GETN_SHORT(uchar)
-NCX_PAD_GETN_SHORT(short)
-NCX_PAD_GETN_SHORT(int)
-NCX_PAD_GETN_SHORT(float)
-NCX_PAD_GETN_SHORT(double)
-NCX_PAD_GETN_SHORT(uint)
-NCX_PAD_GETN_SHORT(longlong)
-NCX_PAD_GETN_SHORT(ulonglong)
+NCX_PAD_GETN_SHORT(short, schar)
+NCX_PAD_GETN_SHORT(short, uchar)
+NCX_PAD_GETN_SHORT(short, short)
+NCX_PAD_GETN_SHORT(short, int)
+NCX_PAD_GETN_SHORT(short, float)
+NCX_PAD_GETN_SHORT(short, double)
+NCX_PAD_GETN_SHORT(short, uint)
+NCX_PAD_GETN_SHORT(short, longlong)
+NCX_PAD_GETN_SHORT(short, ulonglong)
+NCX_PAD_GETN_SHORT(short, ushort)
 
-NCX_PUTN(short, schar)
-NCX_PUTN(short, uchar)
 #if X_SIZEOF_SHORT == SIZEOF_SHORT
 /* optimized version */
 int
@@ -2770,44 +2758,111 @@
 #else
 NCX_PUTN(short, short)
 #endif
+NCX_PUTN(short, schar)
 NCX_PUTN(short, int)
 NCX_PUTN(short, float)
 NCX_PUTN(short, double)
-NCX_PUTN(short, uint)
 NCX_PUTN(short, longlong)
+NCX_PUTN(short, uchar)
+NCX_PUTN(short, uint)
 NCX_PUTN(short, ulonglong)
+NCX_PUTN(short, ushort)
 
-NCX_PAD_PUTN_SHORT(schar)
-NCX_PAD_PUTN_SHORT(uchar)
-NCX_PAD_PUTN_SHORT(short)
-NCX_PAD_PUTN_SHORT(int)
-NCX_PAD_PUTN_SHORT(float)
-NCX_PAD_PUTN_SHORT(double)
-NCX_PAD_PUTN_SHORT(uint)
-NCX_PAD_PUTN_SHORT(longlong)
-NCX_PAD_PUTN_SHORT(ulonglong)
+NCX_PAD_PUTN_SHORT(short, schar)
+NCX_PAD_PUTN_SHORT(short, uchar)
+NCX_PAD_PUTN_SHORT(short, short)
+NCX_PAD_PUTN_SHORT(short, int)
+NCX_PAD_PUTN_SHORT(short, float)
+NCX_PAD_PUTN_SHORT(short, double)
+NCX_PAD_PUTN_SHORT(short, uint)
+NCX_PAD_PUTN_SHORT(short, longlong)
+NCX_PAD_PUTN_SHORT(short, ulonglong)
+NCX_PAD_PUTN_SHORT(short, ushort)
 
 
-/* int */
+/* ushort --------------------------------------------------------------------*/
 
-NCX_GETN(int, schar)
-NCX_GETN(int, uchar)
-NCX_GETN(int, short)
-#if X_SIZEOF_INT == SIZEOF_INT
+#if X_SIZEOF_USHORT == SIZEOF_USHORT
 /* optimized version */
 int
-ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
+ncx_getn_ushort_ushort(const void **xpp, size_t nelems, unsigned short *tp)
 {
 #ifdef WORDS_BIGENDIAN
-	(void) memcpy(tp, *xpp, nelems * sizeof(int));
+	(void) memcpy(tp, *xpp, nelems * sizeof(unsigned short));
 # else
-	swapn4b(tp, *xpp, nelems);
+	swapn2b(tp, *xpp, nelems);
 # endif
-	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT);
+	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_USHORT);
 	return ENOERR;
 }
+#else
+NCX_GETN(ushort, ushort)
+#endif
+NCX_GETN(ushort, schar)
+NCX_GETN(ushort, short)
+NCX_GETN(ushort, int)
+NCX_GETN(ushort, float)
+NCX_GETN(ushort, double)
+NCX_GETN(ushort, longlong)
+NCX_GETN(ushort, uchar)
+NCX_GETN(ushort, uint)
+NCX_GETN(ushort, ulonglong)
+
+NCX_PAD_GETN_SHORT(ushort, schar)
+NCX_PAD_GETN_SHORT(ushort, uchar)
+NCX_PAD_GETN_SHORT(ushort, short)
+NCX_PAD_GETN_SHORT(ushort, ushort)
+NCX_PAD_GETN_SHORT(ushort, int)
+NCX_PAD_GETN_SHORT(ushort, uint)
+NCX_PAD_GETN_SHORT(ushort, float)
+NCX_PAD_GETN_SHORT(ushort, double)
+NCX_PAD_GETN_SHORT(ushort, longlong)
+NCX_PAD_GETN_SHORT(ushort, ulonglong)
+
+#if X_SIZEOF_USHORT == SIZEOF_USHORT
+/* optimized version */
 int
-ncx_getn_int_uint(const void **xpp, size_t nelems, unsigned int *tp)
+ncx_putn_ushort_ushort(void **xpp, size_t nelems, const unsigned short *tp)
+{
+#ifdef WORDS_BIGENDIAN
+	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_USHORT);
+# else
+	swapn2b(*xpp, tp, nelems);
+# endif
+	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_USHORT);
+	return ENOERR;
+}
+#else
+NCX_PUTN(ushort, ushort)
+#endif
+NCX_PUTN(ushort, schar)
+NCX_PUTN(ushort, short)
+NCX_PUTN(ushort, int)
+NCX_PUTN(ushort, float)
+NCX_PUTN(ushort, double)
+NCX_PUTN(ushort, longlong)
+NCX_PUTN(ushort, uchar)
+NCX_PUTN(ushort, uint)
+NCX_PUTN(ushort, ulonglong)
+
+NCX_PAD_PUTN_SHORT(ushort, schar)
+NCX_PAD_PUTN_SHORT(ushort, uchar)
+NCX_PAD_PUTN_SHORT(ushort, short)
+NCX_PAD_PUTN_SHORT(ushort, int)
+NCX_PAD_PUTN_SHORT(ushort, float)
+NCX_PAD_PUTN_SHORT(ushort, double)
+NCX_PAD_PUTN_SHORT(ushort, uint)
+NCX_PAD_PUTN_SHORT(ushort, longlong)
+NCX_PAD_PUTN_SHORT(ushort, ulonglong)
+NCX_PAD_PUTN_SHORT(ushort, ushort)
+
+
+/* int -----------------------------------------------------------------------*/
+
+#if X_SIZEOF_INT == SIZEOF_INT
+/* optimized version */
+int
+ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
 {
 #ifdef WORDS_BIGENDIAN
 	(void) memcpy(tp, *xpp, nelems * sizeof(int));
@@ -2819,18 +2874,17 @@
 }
 #else
 NCX_GETN(int, int)
-NCX_GETN(int, uint)
 #endif
-
-NCX_GETN(int, longlong)
-NCX_GETN(int, ulonglong)
-
+NCX_GETN(int, schar)
+NCX_GETN(int, short)
 NCX_GETN(int, float)
 NCX_GETN(int, double)
+NCX_GETN(int, longlong)
+NCX_GETN(int, uchar)
+NCX_GETN(int, ushort)
+NCX_GETN(int, uint)
+NCX_GETN(int, ulonglong)
 
-NCX_PUTN(int, schar)
-NCX_PUTN(int, uchar)
-NCX_PUTN(int, short)
 #if X_SIZEOF_INT == SIZEOF_INT
 /* optimized version */
 int
@@ -2844,34 +2898,76 @@
 	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
 	return ENOERR;
 }
+#else
+NCX_PUTN(int, int)
+#endif
+NCX_PUTN(int, schar)
+NCX_PUTN(int, short)
+NCX_PUTN(int, float)
+NCX_PUTN(int, double)
+NCX_PUTN(int, longlong)
+NCX_PUTN(int, uchar)
+NCX_PUTN(int, ushort)
+NCX_PUTN(int, uint)
+NCX_PUTN(int, ulonglong)
+
+/* uint ----------------------------------------------------------------------*/
+
+#if X_SIZEOF_UINT == SIZEOF_UINT
+/* optimized version */
 int
-ncx_putn_int_uint(void **xpp, size_t nelems, const unsigned int *tp)
+ncx_getn_uint_uint(const void **xpp, size_t nelems, unsigned int *tp)
 {
 #ifdef WORDS_BIGENDIAN
-	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_INT);
+	(void) memcpy(tp, *xpp, nelems * sizeof(uint));
 # else
-	swapn4b(*xpp, tp, nelems);
+	swapn4b(tp, *xpp, nelems);
 # endif
-	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
+	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_UINT);
 	return ENOERR;
 }
 #else
-NCX_PUTN(int, int)
-NCX_PUTN(int, uint)
+NCX_GETN(uint, uint)
 #endif
+NCX_GETN(uint, schar)
+NCX_GETN(uint, short)
+NCX_GETN(uint, int)
+NCX_GETN(uint, float)
+NCX_GETN(uint, double)
+NCX_GETN(uint, longlong)
+NCX_GETN(uint, uchar)
+NCX_GETN(uint, ushort)
+NCX_GETN(uint, ulonglong)
 
-NCX_PUTN(int, longlong)
-NCX_PUTN(int, ulonglong)
-NCX_PUTN(int, float)
-NCX_PUTN(int, double)
+#if X_SIZEOF_UINT == SIZEOF_UINT
+/* optimized version */
+int
+ncx_putn_uint_uint(void **xpp, size_t nelems, const unsigned int *tp)
+{
+#ifdef WORDS_BIGENDIAN
+	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_UINT);
+# else
+	swapn4b(*xpp, tp, nelems);
+# endif
+	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_UINT);
+	return ENOERR;
+}
+#else
+NCX_PUTN(uint, uint)
+#endif
+NCX_PUTN(uint, schar)
+NCX_PUTN(uint, short)
+NCX_PUTN(uint, int)
+NCX_PUTN(uint, float)
+NCX_PUTN(uint, double)
+NCX_PUTN(uint, longlong)
+NCX_PUTN(uint, uchar)
+NCX_PUTN(uint, ushort)
+NCX_PUTN(uint, ulonglong)
 
 
-/* float */
+/* float ---------------------------------------------------------------------*/
 
-NCX_GETN(float, schar)
-NCX_GETN(float, uchar)
-NCX_GETN(float, short)
-NCX_GETN(float, int)
 #if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
 /* optimized version */
 int
@@ -2919,15 +3015,16 @@
 }
 
 #endif
+NCX_GETN(float, schar)
+NCX_GETN(float, short)
+NCX_GETN(float, int)
 NCX_GETN(float, double)
-NCX_GETN(float, uint)
 NCX_GETN(float, longlong)
+NCX_GETN(float, ushort)
+NCX_GETN(float, uchar)
+NCX_GETN(float, uint)
 NCX_GETN(float, ulonglong)
 
-NCX_PUTN(float, schar)
-NCX_PUTN(float, uchar)
-NCX_PUTN(float, short)
-NCX_PUTN(float, int)
 #if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
 /* optimized version */
 int
@@ -2973,24 +3070,19 @@
 	*xpp = (void *)xp;
 	return status;
 }
-
 #endif
+NCX_PUTN(float, schar)
+NCX_PUTN(float, short)
+NCX_PUTN(float, int)
 NCX_PUTN(float, double)
-NCX_PUTN(float, uint)
 NCX_PUTN(float, longlong)
+NCX_PUTN(float, uchar)
+NCX_PUTN(float, ushort)
+NCX_PUTN(float, uint)
 NCX_PUTN(float, ulonglong)
 
-/* double */
+/* double --------------------------------------------------------------------*/
 
-NCX_GETN(double, schar)
-NCX_GETN(double, uchar)
-NCX_GETN(double, short)
-NCX_GETN(double, int)
-NCX_GETN(double, float)
-dnl NCX_GETN(double, double)
-NCX_GETN(double, uint)
-NCX_GETN(double, longlong)
-NCX_GETN(double, ulonglong)
 #if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
 /* optimized version */
 int
@@ -3036,18 +3128,17 @@
 	*xpp = (const void *)xp;
 	return status;
 }
-
 #endif
+NCX_GETN(double, schar)
+NCX_GETN(double, short)
+NCX_GETN(double, int)
+NCX_GETN(double, float)
+NCX_GETN(double, longlong)
+NCX_GETN(double, uchar)
+NCX_GETN(double, ushort)
+NCX_GETN(double, uint)
+NCX_GETN(double, ulonglong)
 
-NCX_PUTN(double, schar)
-NCX_PUTN(double, uchar)
-NCX_PUTN(double, short)
-NCX_PUTN(double, int)
-NCX_PUTN(double, float)
-dnl NCX_PUTN(double, double)
-NCX_PUTN(double, uint)
-NCX_PUTN(double, longlong)
-NCX_PUTN(double, ulonglong)
 #if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
 /* optimized version */
 int
@@ -3093,8 +3184,125 @@
 	*xpp = (void *)xp;
 	return status;
 }
+#endif
+NCX_PUTN(double, schar)
+NCX_PUTN(double, short)
+NCX_PUTN(double, int)
+NCX_PUTN(double, float)
+NCX_PUTN(double, longlong)
+NCX_PUTN(double, uchar)
+NCX_PUTN(double, ushort)
+NCX_PUTN(double, uint)
+NCX_PUTN(double, ulonglong)
+
+
+/* longlong -----------------------------------------------------------------------*/
+
+#if X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
+/* optimized version */
+int
+ncx_getn_longlong_longlong(const void **xpp, size_t nelems, long long *tp)
+{
+#ifdef WORDS_BIGENDIAN
+	(void) memcpy(tp, *xpp, nelems * sizeof(long long));
+# else
+	swapn8b(tp, *xpp, nelems);
+# endif
+	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_LONGLONG);
+	return ENOERR;
+}
+#else
+NCX_GETN(longlong, longlong)
+#endif
+NCX_GETN(longlong, schar)
+NCX_GETN(longlong, short)
+NCX_GETN(longlong, int)
+NCX_GETN(longlong, float)
+NCX_GETN(longlong, double)
+NCX_GETN(longlong, uchar)
+NCX_GETN(longlong, ushort)
+NCX_GETN(longlong, uint)
+NCX_GETN(longlong, ulonglong)
+
+#if X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
+/* optimized version */
+int
+ncx_putn_longlong_longlong(void **xpp, size_t nelems, const long long *tp)
+{
+#ifdef WORDS_BIGENDIAN
+	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_LONGLONG);
+# else
+	swapn8b(*xpp, tp, nelems);
+# endif
+	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_LONGLONG);
+	return ENOERR;
+}
+#else
+NCX_PUTN(longlong, longlong)
+#endif
+NCX_PUTN(longlong, schar)
+NCX_PUTN(longlong, short)
+NCX_PUTN(longlong, int)
+NCX_PUTN(longlong, float)
+NCX_PUTN(longlong, double)
+NCX_PUTN(longlong, uchar)
+NCX_PUTN(longlong, ushort)
+NCX_PUTN(longlong, uint)
+NCX_PUTN(longlong, ulonglong)
+
+/* ulonglong ----------------------------------------------------------------------*/
+
+#if X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
+/* optimized version */
+int
+ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, unsigned long long *tp)
+{
+#ifdef WORDS_BIGENDIAN
+	(void) memcpy(tp, *xpp, nelems * sizeof(unsigned long long));
+# else
+	swapn8b(tp, *xpp, nelems);
+# endif
+	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_ULONGLONG);
+	return ENOERR;
+}
+#else
+NCX_GETN(ulonglong, ulonglong)
+#endif
+NCX_GETN(ulonglong, schar)
+NCX_GETN(ulonglong, short)
+NCX_GETN(ulonglong, int)
+NCX_GETN(ulonglong, float)
+NCX_GETN(ulonglong, double)
+NCX_GETN(ulonglong, longlong)
+NCX_GETN(ulonglong, uchar)
+NCX_GETN(ulonglong, ushort)
+NCX_GETN(ulonglong, uint)
 
+#if X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
+/* optimized version */
+int
+ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const unsigned long long *tp)
+{
+#ifdef WORDS_BIGENDIAN
+	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_ULONGLONG);
+# else
+	swapn8b(*xpp, tp, nelems);
+# endif
+	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_ULONGLONG);
+	return ENOERR;
+}
+#else
+NCX_PUTN(ulonglong, ulonglong)
 #endif
+NCX_PUTN(ulonglong, schar)
+NCX_PUTN(ulonglong, short)
+NCX_PUTN(ulonglong, int)
+NCX_PUTN(ulonglong, float)
+NCX_PUTN(ulonglong, double)
+NCX_PUTN(ulonglong, longlong)
+NCX_PUTN(ulonglong, uchar)
+NCX_PUTN(ulonglong, ushort)
+NCX_PUTN(ulonglong, uint)
 
 
 /*
diff netcdf-c/libsrc/putget.m4 cdf5/libsrc/putget.m4
--- netcdf-c/libsrc/putget.m4	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/libsrc/putget.m4	2014-11-14 14:54:46.005956200 -0700
@@ -12,7 +12,7 @@
  *	Copyright 1996, University Corporation for Atmospheric Research
  *      See netcdf/COPYRIGHT file for copying and redistribution conditions.
  */
-/* $Id: putget.m4,v 2.79 2010/05/29 22:25:01 russ Exp $ */
+/* $Id: putget.m4 2783 2014-10-26 05:19:35Z wkliao $ */
 
 #include "config.h"
 #include <string.h>
@@ -126,6 +126,11 @@
 NCFILL(float, float, X_SIZEOF_FLOAT, NC_FILL_FLOAT)
 NCFILL(double, double, X_SIZEOF_DOUBLE, NC_FILL_DOUBLE)
 
+NCFILL(uchar,     uchar,     X_SIZEOF_UBYTE,     NC_FILL_UBYTE)
+NCFILL(ushort,    ushort,    X_SIZEOF_USHORT,    NC_FILL_USHORT)
+NCFILL(uint,      uint,      X_SIZEOF_UINT,      NC_FILL_UINT)
+NCFILL(longlong,  longlong,  X_SIZEOF_LONGLONG,  NC_FILL_INT64)
+NCFILL(ulonglong, ulonglong, X_SIZEOF_ULONGLONG, NC_FILL_UINT64)
 
 
 
@@ -205,6 +210,21 @@
 		case NC_DOUBLE : 
 			status = NC_fill_double(&xp, nelems);
 			break;
+                case NC_UBYTE :
+                        status = NC_fill_uchar(&xp, nelems);
+                        break;
+                case NC_USHORT :
+                        status = NC_fill_ushort(&xp, nelems);
+                        break;
+                case NC_UINT :
+                        status = NC_fill_uint(&xp, nelems);
+                        break;
+                case NC_INT64 :
+                        status = NC_fill_longlong(&xp, nelems);
+                        break;
+                case NC_UINT64 :
+                        status = NC_fill_ulonglong(&xp, nelems);
+                        break;
 		default :
 			assert("fill_NC_var invalid type" == 0);
 			status = NC_EBADTYPE;
@@ -707,6 +727,9 @@
 PUTNCVX(schar, float)
 PUTNCVX(schar, double)
 PUTNCVX(schar, longlong)
+PUTNCVX(schar, ushort)
+PUTNCVX(schar, uint)
+PUTNCVX(schar, ulonglong)
 
 PUTNCVX(short, schar)
 PUTNCVX(short, uchar)
@@ -715,6 +738,9 @@
 PUTNCVX(short, float)
 PUTNCVX(short, double)
 PUTNCVX(short, longlong)
+PUTNCVX(short, ushort)
+PUTNCVX(short, uint)
+PUTNCVX(short, ulonglong)
 
 PUTNCVX(int, schar)
 PUTNCVX(int, uchar)
@@ -723,6 +749,9 @@
 PUTNCVX(int, float)
 PUTNCVX(int, double)
 PUTNCVX(int, longlong)
+PUTNCVX(int, ushort)
+PUTNCVX(int, uint)
+PUTNCVX(int, ulonglong)
 
 PUTNCVX(float, schar)
 PUTNCVX(float, uchar)
@@ -731,6 +760,9 @@
 PUTNCVX(float, float)
 PUTNCVX(float, double)
 PUTNCVX(float, longlong)
+PUTNCVX(float, ushort)
+PUTNCVX(float, uint)
+PUTNCVX(float, ulonglong)
 
 PUTNCVX(double, schar)
 PUTNCVX(double, uchar)
@@ -739,20 +771,64 @@
 PUTNCVX(double, float)
 PUTNCVX(double, double)
 PUTNCVX(double, longlong)
-
-dnl Following are not currently used
-#ifdef NOTUSED
-PUTNCVX(schar, uint)
-PUTNCVX(schar, ulonglong)
-PUTNCVX(short, uint)
-PUTNCVX(short, ulonglong)
-PUTNCVX(int, uint)
-PUTNCVX(int, ulonglong)
-PUTNCVX(float, uint)
-PUTNCVX(float, ulonglong)
+PUTNCVX(double, ushort)
 PUTNCVX(double, uint)
 PUTNCVX(double, ulonglong)
-#endif /*NOTUSED*/
+
+PUTNCVX(uchar, schar)
+PUTNCVX(uchar, uchar)
+PUTNCVX(uchar, short)
+PUTNCVX(uchar, int)
+PUTNCVX(uchar, float)
+PUTNCVX(uchar, double)
+PUTNCVX(uchar, longlong)
+PUTNCVX(uchar, ushort)
+PUTNCVX(uchar, uint)
+PUTNCVX(uchar, ulonglong)
+
+PUTNCVX(ushort, schar)
+PUTNCVX(ushort, uchar)
+PUTNCVX(ushort, short)
+PUTNCVX(ushort, int)
+PUTNCVX(ushort, float)
+PUTNCVX(ushort, double)
+PUTNCVX(ushort, longlong)
+PUTNCVX(ushort, ushort)
+PUTNCVX(ushort, uint)
+PUTNCVX(ushort, ulonglong)
+
+PUTNCVX(uint, schar)
+PUTNCVX(uint, uchar)
+PUTNCVX(uint, short)
+PUTNCVX(uint, int)
+PUTNCVX(uint, float)
+PUTNCVX(uint, double)
+PUTNCVX(uint, longlong)
+PUTNCVX(uint, ushort)
+PUTNCVX(uint, uint)
+PUTNCVX(uint, ulonglong)
+
+PUTNCVX(longlong, schar)
+PUTNCVX(longlong, uchar)
+PUTNCVX(longlong, short)
+PUTNCVX(longlong, int)
+PUTNCVX(longlong, float)
+PUTNCVX(longlong, double)
+PUTNCVX(longlong, longlong)
+PUTNCVX(longlong, ushort)
+PUTNCVX(longlong, uint)
+PUTNCVX(longlong, ulonglong)
+
+PUTNCVX(ulonglong, schar)
+PUTNCVX(ulonglong, uchar)
+PUTNCVX(ulonglong, short)
+PUTNCVX(ulonglong, int)
+PUTNCVX(ulonglong, float)
+PUTNCVX(ulonglong, double)
+PUTNCVX(ulonglong, longlong)
+PUTNCVX(ulonglong, ushort)
+PUTNCVX(ulonglong, uint)
+PUTNCVX(ulonglong, ulonglong)
 
 dnl
 dnl GETNCVX(XType, Type)
@@ -810,6 +886,8 @@
 GETNCVX(schar, longlong)
 GETNCVX(schar, uint)
 GETNCVX(schar, ulonglong)
+GETNCVX(schar, uchar)
+GETNCVX(schar, ushort)
 
 GETNCVX(short, schar)
 GETNCVX(short, uchar)
@@ -820,6 +898,7 @@
 GETNCVX(short, longlong)
 GETNCVX(short, uint)
 GETNCVX(short, ulonglong)
+GETNCVX(short, ushort)
 
 GETNCVX(int, schar)
 GETNCVX(int, uchar)
@@ -830,6 +909,7 @@
 GETNCVX(int, longlong)
 GETNCVX(int, uint)
 GETNCVX(int, ulonglong)
+GETNCVX(int, ushort)
 
 GETNCVX(float, schar)
 GETNCVX(float, uchar)
@@ -840,6 +920,7 @@
 GETNCVX(float, longlong)
 GETNCVX(float, uint)
 GETNCVX(float, ulonglong)
+GETNCVX(float, ushort)
 
 GETNCVX(double, schar)
 GETNCVX(double, uchar)
@@ -850,6 +931,62 @@
 GETNCVX(double, longlong)
 GETNCVX(double, uint)
 GETNCVX(double, ulonglong)
+GETNCVX(double, ushort)
+
+GETNCVX(uchar, schar)
+GETNCVX(uchar, uchar)
+GETNCVX(uchar, short)
+GETNCVX(uchar, int)
+GETNCVX(uchar, float)
+GETNCVX(uchar, double)
+GETNCVX(uchar, longlong)
+GETNCVX(uchar, uint)
+GETNCVX(uchar, ulonglong)
+GETNCVX(uchar, ushort)
+
+GETNCVX(ushort, schar)
+GETNCVX(ushort, uchar)
+GETNCVX(ushort, short)
+GETNCVX(ushort, int)
+GETNCVX(ushort, float)
+GETNCVX(ushort, double)
+GETNCVX(ushort, longlong)
+GETNCVX(ushort, uint)
+GETNCVX(ushort, ulonglong)
+GETNCVX(ushort, ushort)
+
+GETNCVX(uint, schar)
+GETNCVX(uint, uchar)
+GETNCVX(uint, short)
+GETNCVX(uint, int)
+GETNCVX(uint, float)
+GETNCVX(uint, double)
+GETNCVX(uint, longlong)
+GETNCVX(uint, uint)
+GETNCVX(uint, ulonglong)
+GETNCVX(uint, ushort)
+
+GETNCVX(longlong, schar)
+GETNCVX(longlong, uchar)
+GETNCVX(longlong, short)
+GETNCVX(longlong, int)
+GETNCVX(longlong, float)
+GETNCVX(longlong, double)
+GETNCVX(longlong, longlong)
+GETNCVX(longlong, uint)
+GETNCVX(longlong, ulonglong)
+GETNCVX(longlong, ushort)
+
+GETNCVX(ulonglong, schar)
+GETNCVX(ulonglong, uchar)
+GETNCVX(ulonglong, short)
+GETNCVX(ulonglong, int)
+GETNCVX(ulonglong, float)
+GETNCVX(ulonglong, double)
+GETNCVX(ulonglong, longlong)
+GETNCVX(ulonglong, uint)
+GETNCVX(ulonglong, ulonglong)
+GETNCVX(ulonglong, ushort)
 
 dnl Following are not currently uses
 #ifdef NOTUSED
@@ -1025,151 +1162,220 @@
 {
     int status = NC_NOERR;
     switch (CASE(varp->type,memtype)) {
+
     case CASE(NC_CHAR,NC_CHAR):
     case CASE(NC_CHAR,NC_UBYTE):
-        status = getNCvx_char_char(ncp,varp,start,nelems,(char*)value);
-        break;
+        return getNCvx_char_char(ncp,varp,start,nelems,(char*)value);
 
     case CASE(NC_BYTE,NC_BYTE):
+        return getNCvx_schar_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_BYTE,NC_UBYTE):
-        status = getNCvx_schar_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return getNCvx_schar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_BYTE,NC_SHORT):
-        status = getNCvx_schar_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return getNCvx_schar_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_BYTE,NC_INT):
-        status = getNCvx_schar_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return getNCvx_schar_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_BYTE,NC_FLOAT):
-        status = getNCvx_schar_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return getNCvx_schar_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_BYTE,NC_DOUBLE):
-        status = getNCvx_schar_double(ncp,varp,start,nelems,(double *)value);
-        break;
+        return getNCvx_schar_double(ncp,varp,start,nelems,(double *)value);
     case CASE(NC_BYTE,NC_INT64):
-        status = getNCvx_schar_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return getNCvx_schar_longlong(ncp,varp,start,nelems,(long long*)value);
     case CASE(NC_BYTE,NC_UINT):
-        status = getNCvx_schar_uint(ncp,varp,start,nelems,(unsigned int*)value);
-        break;
+        return getNCvx_schar_uint(ncp,varp,start,nelems,(unsigned int*)value);
     case CASE(NC_BYTE,NC_UINT64):
-        status = getNCvx_schar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
-        break;
+        return getNCvx_schar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_BYTE,NC_USHORT):
+        return getNCvx_schar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     case CASE(NC_SHORT,NC_BYTE):
-        status = getNCvx_short_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return getNCvx_short_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_SHORT,NC_UBYTE):
-        status = getNCvx_short_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return getNCvx_short_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_SHORT,NC_SHORT):
-        status = getNCvx_short_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return getNCvx_short_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_SHORT,NC_INT):
-        status = getNCvx_short_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return getNCvx_short_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_SHORT,NC_FLOAT):
-        status = getNCvx_short_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return getNCvx_short_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_SHORT,NC_DOUBLE):
-        status = getNCvx_short_double(ncp,varp,start,nelems,(double*)value);
-        break;
+        return getNCvx_short_double(ncp,varp,start,nelems,(double*)value);
     case CASE(NC_SHORT,NC_INT64):
-        status = getNCvx_short_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return getNCvx_short_longlong(ncp,varp,start,nelems,(long long*)value);
     case CASE(NC_SHORT,NC_UINT):
-        status = getNCvx_short_uint(ncp,varp,start,nelems,(unsigned int*)value);
-        break;
+        return getNCvx_short_uint(ncp,varp,start,nelems,(unsigned int*)value);
     case CASE(NC_SHORT,NC_UINT64):
-        status = getNCvx_short_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
-        break;
-
+        return getNCvx_short_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_SHORT,NC_USHORT):
+        return getNCvx_short_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     case CASE(NC_INT,NC_BYTE):
-        status = getNCvx_int_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return getNCvx_int_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_INT,NC_UBYTE):
-        status = getNCvx_int_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return getNCvx_int_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_INT,NC_SHORT):
-        status = getNCvx_int_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return getNCvx_int_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_INT,NC_INT):
-        status = getNCvx_int_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return getNCvx_int_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_INT,NC_FLOAT):
-        status = getNCvx_int_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return getNCvx_int_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_INT,NC_DOUBLE):
-        status = getNCvx_int_double(ncp,varp,start,nelems,(double*)value);
-        break;
+        return getNCvx_int_double(ncp,varp,start,nelems,(double*)value);
     case CASE(NC_INT,NC_INT64):
-        status = getNCvx_int_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return getNCvx_int_longlong(ncp,varp,start,nelems,(long long*)value);
     case CASE(NC_INT,NC_UINT):
-        status = getNCvx_int_uint(ncp,varp,start,nelems,(unsigned int*)value);
-        break;
+        return getNCvx_int_uint(ncp,varp,start,nelems,(unsigned int*)value);
     case CASE(NC_INT,NC_UINT64):
-        status = getNCvx_int_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
-        break;
-
+        return getNCvx_int_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_INT,NC_USHORT):
+        return getNCvx_int_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     case CASE(NC_FLOAT,NC_BYTE):
-        status = getNCvx_float_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return getNCvx_float_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_FLOAT,NC_UBYTE):
-        status = getNCvx_float_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return getNCvx_float_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_FLOAT,NC_SHORT):
-        status = getNCvx_float_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return getNCvx_float_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_FLOAT,NC_INT):
-        status = getNCvx_float_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return getNCvx_float_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_FLOAT,NC_FLOAT):
-        status = getNCvx_float_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return getNCvx_float_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_FLOAT,NC_DOUBLE):
-        status = getNCvx_float_double(ncp,varp,start,nelems,(double*)value);
-        break;
+        return getNCvx_float_double(ncp,varp,start,nelems,(double*)value);
     case CASE(NC_FLOAT,NC_INT64):
-        status = getNCvx_float_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return getNCvx_float_longlong(ncp,varp,start,nelems,(long long*)value);
     case CASE(NC_FLOAT,NC_UINT):
-        status = getNCvx_float_uint(ncp,varp,start,nelems,(unsigned int*)value);
-        break;
+        return getNCvx_float_uint(ncp,varp,start,nelems,(unsigned int*)value);
     case CASE(NC_FLOAT,NC_UINT64):
-        status = getNCvx_float_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
-        break;
-
+        return getNCvx_float_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_FLOAT,NC_USHORT):
+        return getNCvx_float_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     case CASE(NC_DOUBLE,NC_BYTE):
-        status = getNCvx_double_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return getNCvx_double_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_DOUBLE,NC_UBYTE):
-        status = getNCvx_double_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return getNCvx_double_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_DOUBLE,NC_SHORT):
-        status = getNCvx_double_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return getNCvx_double_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_DOUBLE,NC_INT):
-        status = getNCvx_double_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return getNCvx_double_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_DOUBLE,NC_FLOAT):
-        status = getNCvx_double_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return getNCvx_double_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_DOUBLE,NC_DOUBLE):
-        status = getNCvx_double_double(ncp,varp,start,nelems,(double*)value);
-        break;
+        return getNCvx_double_double(ncp,varp,start,nelems,(double*)value);
     case CASE(NC_DOUBLE,NC_INT64):
-        status = getNCvx_double_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return getNCvx_double_longlong(ncp,varp,start,nelems,(long long*)value);
     case CASE(NC_DOUBLE,NC_UINT):
-        status = getNCvx_double_uint(ncp,varp,start,nelems,(unsigned int*)value);
-        break;
+        return getNCvx_double_uint(ncp,varp,start,nelems,(unsigned int*)value);
     case CASE(NC_DOUBLE,NC_UINT64):
-        status = getNCvx_double_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
-        break;
+        return getNCvx_double_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_DOUBLE,NC_USHORT):
+        return getNCvx_double_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_UBYTE,NC_UBYTE):
+        return getNCvx_uchar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_UBYTE,NC_BYTE):
+        return getNCvx_uchar_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_UBYTE,NC_SHORT):
+        return getNCvx_uchar_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_UBYTE,NC_INT):
+        return getNCvx_uchar_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_UBYTE,NC_FLOAT):
+        return getNCvx_uchar_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_UBYTE,NC_DOUBLE):
+        return getNCvx_uchar_double(ncp,varp,start,nelems,(double *)value);
+    case CASE(NC_UBYTE,NC_INT64):
+        return getNCvx_uchar_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_UBYTE,NC_UINT):
+        return getNCvx_uchar_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_UBYTE,NC_UINT64):
+        return getNCvx_uchar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_UBYTE,NC_USHORT):
+        return getNCvx_uchar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_USHORT,NC_BYTE):
+        return getNCvx_ushort_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_USHORT,NC_UBYTE):
+        return getNCvx_ushort_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_USHORT,NC_SHORT):
+        return getNCvx_ushort_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_USHORT,NC_INT):
+        return getNCvx_ushort_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_USHORT,NC_FLOAT):
+        return getNCvx_ushort_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_USHORT,NC_DOUBLE):
+        return getNCvx_ushort_double(ncp,varp,start,nelems,(double*)value);
+    case CASE(NC_USHORT,NC_INT64):
+        return getNCvx_ushort_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_USHORT,NC_UINT):
+        return getNCvx_ushort_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_USHORT,NC_UINT64):
+        return getNCvx_ushort_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_USHORT,NC_USHORT):
+        return getNCvx_ushort_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_UINT,NC_BYTE):
+        return getNCvx_uint_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_UINT,NC_UBYTE):
+        return getNCvx_uint_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_UINT,NC_SHORT):
+        return getNCvx_uint_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_UINT,NC_INT):
+        return getNCvx_uint_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_UINT,NC_FLOAT):
+        return getNCvx_uint_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_UINT,NC_DOUBLE):
+        return getNCvx_uint_double(ncp,varp,start,nelems,(double*)value);
+    case CASE(NC_UINT,NC_INT64):
+        return getNCvx_uint_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_UINT,NC_UINT):
+        return getNCvx_uint_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_UINT,NC_UINT64):
+        return getNCvx_uint_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_UINT,NC_USHORT):
+        return getNCvx_uint_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_INT64,NC_BYTE):
+        return getNCvx_longlong_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_INT64,NC_UBYTE):
+        return getNCvx_longlong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_INT64,NC_SHORT):
+        return getNCvx_longlong_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_INT64,NC_INT):
+        return getNCvx_longlong_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_INT64,NC_FLOAT):
+        return getNCvx_longlong_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_INT64,NC_DOUBLE):
+        return getNCvx_longlong_double(ncp,varp,start,nelems,(double*)value);
+    case CASE(NC_INT64,NC_INT64):
+        return getNCvx_longlong_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_INT64,NC_UINT):
+        return getNCvx_longlong_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_INT64,NC_UINT64):
+        return getNCvx_longlong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_INT64,NC_USHORT):
+        return getNCvx_longlong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_UINT64,NC_BYTE):
+        return getNCvx_ulonglong_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_UINT64,NC_UBYTE):
+        return getNCvx_ulonglong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_UINT64,NC_SHORT):
+        return getNCvx_ulonglong_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_UINT64,NC_INT):
+        return getNCvx_ulonglong_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_UINT64,NC_FLOAT):
+        return getNCvx_ulonglong_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_UINT64,NC_DOUBLE):
+        return getNCvx_ulonglong_double(ncp,varp,start,nelems,(double*)value);
+    case CASE(NC_UINT64,NC_INT64):
+        return getNCvx_ulonglong_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_UINT64,NC_UINT):
+        return getNCvx_ulonglong_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_UINT64,NC_UINT64):
+        return getNCvx_ulonglong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_UINT64,NC_USHORT):
+        return getNCvx_ulonglong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     default:
 	return NC_EBADTYPE;
@@ -1184,120 +1390,220 @@
 {
     int status = NC_NOERR;
     switch (CASE(varp->type,memtype)) {
+
     case CASE(NC_CHAR,NC_CHAR):
     case CASE(NC_CHAR,NC_UBYTE):
-        status = putNCvx_char_char(ncp,varp,start,nelems,(char*)value);
-        break;
+        return putNCvx_char_char(ncp,varp,start,nelems,(char*)value);
 
     case CASE(NC_BYTE,NC_BYTE):
-        status = putNCvx_schar_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return putNCvx_schar_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_BYTE,NC_UBYTE):
-        status = putNCvx_schar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return putNCvx_schar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_BYTE,NC_SHORT):
-        status = putNCvx_schar_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return putNCvx_schar_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_BYTE,NC_INT):
-        status = putNCvx_schar_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return putNCvx_schar_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_BYTE,NC_FLOAT):
-        status = putNCvx_schar_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return putNCvx_schar_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_BYTE,NC_DOUBLE):
-        status = putNCvx_schar_double(ncp,varp,start,nelems,(double *)value);
-        break;
+        return putNCvx_schar_double(ncp,varp,start,nelems,(double *)value);
     case CASE(NC_BYTE,NC_INT64):
-        status = putNCvx_schar_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return putNCvx_schar_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_BYTE,NC_UINT):
+        return putNCvx_schar_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_BYTE,NC_UINT64):
+        return putNCvx_schar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_BYTE,NC_USHORT):
+        return putNCvx_schar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     case CASE(NC_SHORT,NC_BYTE):
-        status = putNCvx_short_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return putNCvx_short_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_SHORT,NC_UBYTE):
-        status = putNCvx_short_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return putNCvx_short_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_SHORT,NC_SHORT):
-        status = putNCvx_short_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return putNCvx_short_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_SHORT,NC_INT):
-        status = putNCvx_short_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return putNCvx_short_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_SHORT,NC_FLOAT):
-        status = putNCvx_short_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return putNCvx_short_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_SHORT,NC_DOUBLE):
-        status = putNCvx_short_double(ncp,varp,start,nelems,(double*)value);
-        break;
+        return putNCvx_short_double(ncp,varp,start,nelems,(double*)value);
     case CASE(NC_SHORT,NC_INT64):
-        status = putNCvx_short_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return putNCvx_short_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_SHORT,NC_UINT):
+        return putNCvx_short_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_SHORT,NC_UINT64):
+        return putNCvx_short_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_SHORT,NC_USHORT):
+        return putNCvx_short_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     case CASE(NC_INT,NC_BYTE):
-        status = putNCvx_int_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return putNCvx_int_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_INT,NC_UBYTE):
-        status = putNCvx_int_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return putNCvx_int_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_INT,NC_SHORT):
-        status = putNCvx_int_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return putNCvx_int_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_INT,NC_INT):
-        status = putNCvx_int_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return putNCvx_int_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_INT,NC_FLOAT):
-        status = putNCvx_int_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return putNCvx_int_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_INT,NC_DOUBLE):
-        status = putNCvx_int_double(ncp,varp,start,nelems,(double*)value);
-        break;
+        return putNCvx_int_double(ncp,varp,start,nelems,(double*)value);
     case CASE(NC_INT,NC_INT64):
-        status = putNCvx_int_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return putNCvx_int_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_INT,NC_UINT):
+        return putNCvx_int_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_INT,NC_UINT64):
+        return putNCvx_int_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_INT,NC_USHORT):
+        return putNCvx_int_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     case CASE(NC_FLOAT,NC_BYTE):
-        status = putNCvx_float_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return putNCvx_float_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_FLOAT,NC_UBYTE):
-        status = putNCvx_float_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return putNCvx_float_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_FLOAT,NC_SHORT):
-        status = putNCvx_float_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return putNCvx_float_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_FLOAT,NC_INT):
-        status = putNCvx_float_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return putNCvx_float_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_FLOAT,NC_FLOAT):
-        status = putNCvx_float_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return putNCvx_float_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_FLOAT,NC_DOUBLE):
-        status = putNCvx_float_double(ncp,varp,start,nelems,(double*)value);
-        break;
+        return putNCvx_float_double(ncp,varp,start,nelems,(double*)value);
     case CASE(NC_FLOAT,NC_INT64):
-        status = putNCvx_float_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return putNCvx_float_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_FLOAT,NC_UINT):
+        return putNCvx_float_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_FLOAT,NC_UINT64):
+        return putNCvx_float_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_FLOAT,NC_USHORT):
+        return putNCvx_float_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     case CASE(NC_DOUBLE,NC_BYTE):
-        status = putNCvx_double_schar(ncp,varp,start,nelems,(signed char*)value);
-        break;
+        return putNCvx_double_schar(ncp,varp,start,nelems,(signed char*)value);
     case CASE(NC_DOUBLE,NC_UBYTE):
-        status = putNCvx_double_uchar(ncp,varp,start,nelems,(unsigned char*)value);
-        break;
+        return putNCvx_double_uchar(ncp,varp,start,nelems,(unsigned char*)value);
     case CASE(NC_DOUBLE,NC_SHORT):
-        status = putNCvx_double_short(ncp,varp,start,nelems,(short*)value);
-        break;
+        return putNCvx_double_short(ncp,varp,start,nelems,(short*)value);
     case CASE(NC_DOUBLE,NC_INT):
-        status = putNCvx_double_int(ncp,varp,start,nelems,(int*)value);
-        break;
+        return putNCvx_double_int(ncp,varp,start,nelems,(int*)value);
     case CASE(NC_DOUBLE,NC_FLOAT):
-        status = putNCvx_double_float(ncp,varp,start,nelems,(float*)value);
-        break;
+        return putNCvx_double_float(ncp,varp,start,nelems,(float*)value);
     case CASE(NC_DOUBLE,NC_DOUBLE):
-        status = putNCvx_double_double(ncp,varp,start,nelems,(double*)value);
-        break;
+        return putNCvx_double_double(ncp,varp,start,nelems,(double*)value);
     case CASE(NC_DOUBLE,NC_INT64):
-        status = putNCvx_double_longlong(ncp,varp,start,nelems,(long long*)value);
-        break;
+        return putNCvx_double_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_DOUBLE,NC_UINT):
+        return putNCvx_double_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_DOUBLE,NC_UINT64):
+        return putNCvx_double_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_DOUBLE,NC_USHORT):
+        return putNCvx_double_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_UBYTE,NC_UBYTE):
+        return putNCvx_uchar_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_UBYTE,NC_BYTE):
+        return putNCvx_uchar_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_UBYTE,NC_SHORT):
+        return putNCvx_uchar_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_UBYTE,NC_INT):
+        return putNCvx_uchar_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_UBYTE,NC_FLOAT):
+        return putNCvx_uchar_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_UBYTE,NC_DOUBLE):
+        return putNCvx_uchar_double(ncp,varp,start,nelems,(double *)value);
+    case CASE(NC_UBYTE,NC_INT64):
+        return putNCvx_uchar_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_UBYTE,NC_UINT):
+        return putNCvx_uchar_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_UBYTE,NC_UINT64):
+        return putNCvx_uchar_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_UBYTE,NC_USHORT):
+        return putNCvx_uchar_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_USHORT,NC_BYTE):
+        return putNCvx_ushort_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_USHORT,NC_UBYTE):
+        return putNCvx_ushort_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_USHORT,NC_SHORT):
+        return putNCvx_ushort_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_USHORT,NC_INT):
+        return putNCvx_ushort_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_USHORT,NC_FLOAT):
+        return putNCvx_ushort_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_USHORT,NC_DOUBLE):
+        return putNCvx_ushort_double(ncp,varp,start,nelems,(double*)value);
+    case CASE(NC_USHORT,NC_INT64):
+        return putNCvx_ushort_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_USHORT,NC_UINT):
+        return putNCvx_ushort_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_USHORT,NC_UINT64):
+        return putNCvx_ushort_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_USHORT,NC_USHORT):
+        return putNCvx_ushort_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_UINT,NC_BYTE):
+        return putNCvx_uint_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_UINT,NC_UBYTE):
+        return putNCvx_uint_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_UINT,NC_SHORT):
+        return putNCvx_uint_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_UINT,NC_INT):
+        return putNCvx_uint_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_UINT,NC_FLOAT):
+        return putNCvx_uint_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_UINT,NC_DOUBLE):
+        return putNCvx_uint_double(ncp,varp,start,nelems,(double*)value);
+    case CASE(NC_UINT,NC_INT64):
+        return putNCvx_uint_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_UINT,NC_UINT):
+        return putNCvx_uint_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_UINT,NC_UINT64):
+        return putNCvx_uint_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_UINT,NC_USHORT):
+        return putNCvx_uint_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_INT64,NC_BYTE):
+        return putNCvx_longlong_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_INT64,NC_UBYTE):
+        return putNCvx_longlong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_INT64,NC_SHORT):
+        return putNCvx_longlong_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_INT64,NC_INT):
+        return putNCvx_longlong_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_INT64,NC_FLOAT):
+        return putNCvx_longlong_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_INT64,NC_DOUBLE):
+        return putNCvx_longlong_double(ncp,varp,start,nelems,(double*)value);
+    case CASE(NC_INT64,NC_INT64):
+        return putNCvx_longlong_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_INT64,NC_UINT):
+        return putNCvx_longlong_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_INT64,NC_UINT64):
+        return putNCvx_longlong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_INT64,NC_USHORT):
+        return putNCvx_longlong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
+
+    case CASE(NC_UINT64,NC_BYTE):
+        return putNCvx_ulonglong_schar(ncp,varp,start,nelems,(signed char*)value);
+    case CASE(NC_UINT64,NC_UBYTE):
+        return putNCvx_ulonglong_uchar(ncp,varp,start,nelems,(unsigned char*)value);
+    case CASE(NC_UINT64,NC_SHORT):
+        return putNCvx_ulonglong_short(ncp,varp,start,nelems,(short*)value);
+    case CASE(NC_UINT64,NC_INT):
+        return putNCvx_ulonglong_int(ncp,varp,start,nelems,(int*)value);
+    case CASE(NC_UINT64,NC_FLOAT):
+        return putNCvx_ulonglong_float(ncp,varp,start,nelems,(float*)value);
+    case CASE(NC_UINT64,NC_DOUBLE):
+        return putNCvx_ulonglong_double(ncp,varp,start,nelems,(double*)value);
+    case CASE(NC_UINT64,NC_INT64):
+        return putNCvx_ulonglong_longlong(ncp,varp,start,nelems,(long long*)value);
+    case CASE(NC_UINT64,NC_UINT):
+        return putNCvx_ulonglong_uint(ncp,varp,start,nelems,(unsigned int*)value);
+    case CASE(NC_UINT64,NC_UINT64):
+        return putNCvx_ulonglong_ulonglong(ncp,varp,start,nelems,(unsigned long long*)value);
+    case CASE(NC_UINT64,NC_USHORT):
+        return putNCvx_ulonglong_ushort(ncp,varp,start,nelems,(unsigned short*)value);
 
     default:
 	return NC_EBADTYPE;
diff netcdf-c/libsrc/v1hpg.c cdf5/libsrc/v1hpg.c
--- netcdf-c/libsrc/v1hpg.c	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/libsrc/v1hpg.c	2014-11-14 14:54:46.006932700 -0700
@@ -2,7 +2,7 @@
  *	Copyright 1996, University Corporation for Atmospheric Research
  *      See netcdf/COPYRIGHT file for copying and redistribution conditions.
  */
-/* $Id: v1hpg.c,v 1.70 2010/05/26 21:43:34 dmh Exp $ */
+/* $Id: v1hpg.c 2796 2014-10-28 03:40:29Z wkliao $ */
 
 #include "config.h"
 #include "nc3internal.h"
@@ -34,6 +34,7 @@
  */
 static const schar ncmagic[] = {'C', 'D', 'F', 0x02};
 static const schar ncmagic1[] = {'C', 'D', 'F', 0x01};
+static const schar ncmagic5[] = {'C', 'D', 'F', 0x05};
 
 
 /*
@@ -50,7 +51,7 @@
 	off_t offset;	/* argument to nciop->get() */
 	size_t extent;	/* argument to nciop->get() */
 	int flags;	/* set to RGN_WRITE for write */
-        int version;    /* format variant: NC_FORMAT_CLASSIC or NC_FORMAT_64BIT */
+        int version;    /* format variant: NC_FORMAT_CLASSIC, NC_FORMAT_CDF2 or NC_FORMAT_CDF5 */
 	void *base;	/* beginning of current buffer */
 	void *pos;	/* current position in buffer */
 	void *end;	/* end of current buffer = base + extent */
@@ -133,9 +134,16 @@
 static int
 v1h_put_size_t(v1hs *psp, const size_t *sp)
 {
-	int status = check_v1hs(psp, X_SIZEOF_SIZE_T);
+	int status;
+	if (psp->version == 5) /* all integers in CDF-5 are 64 bits */
+		status = check_v1hs(psp, X_SIZEOF_INT64);
+	else
+		status = check_v1hs(psp, X_SIZEOF_INT);
 	if(status != ENOERR)
 		return status;
+        if (psp->version == 5)
+		return ncx_put_int64(&psp->pos, *sp);
+        else
 	return ncx_put_size_t(&psp->pos, sp);
 }
 
@@ -144,9 +152,20 @@
 static int
 v1h_get_size_t(v1hs *gsp, size_t *sp)
 {
-	int status = check_v1hs(gsp, X_SIZEOF_SIZE_T);
+	int status;
+	if (gsp->version == 5) /* all integers in CDF-5 are 64 bits */
+		status = check_v1hs(gsp, X_SIZEOF_INT64);
+	else
+		status = check_v1hs(gsp, X_SIZEOF_INT);
 	if(status != ENOERR)
 		return status;
+        if (gsp->version == 5) {
+		long long tmp=0;
+		status = ncx_get_int64((const void **)(&gsp->pos), &tmp);
+		*sp = (size_t)tmp;
+		return status;
+        }
+        else
 	return ncx_get_size_t((const void **)(&gsp->pos), sp);
 }
 
@@ -187,7 +206,13 @@
 		|| type == NC_SHORT
 		|| type == NC_INT
 		|| type == NC_FLOAT
-		|| type == NC_DOUBLE);
+		|| type == NC_DOUBLE
+		|| type == NC_UBYTE
+		|| type == NC_USHORT
+		|| type == NC_UINT
+		|| type == NC_INT64
+		|| type == NC_UINT64
+		|| type == NC_STRING);
 
 	/* else */
 	*typep = (nc_type) type;
@@ -200,7 +225,7 @@
 
 #define X_SIZEOF_NCTYPE X_SIZEOF_INT
 
-/* Write a NCtype to the header */
+/* Write a NCtype (32-bite integer) to the header */
 static int
 v1h_put_NCtype(v1hs *psp, NCtype type)
 {
@@ -213,7 +238,7 @@
 	return status;
 }
 
-/* Read a NCtype from the header */
+/* Read a NCtype (32-bite integer) from the header */
 static int
 v1h_get_NCtype(v1hs *gsp, NCtype *typep)
 {
@@ -239,9 +264,9 @@
 NC_xlen_string(cdfstr)
  */
 static size_t
-ncx_len_NC_string(const NC_string *ncstrp)
+ncx_len_NC_string(const NC_string *ncstrp, int version)
 {
-	size_t sz = X_SIZEOF_SIZE_T; /* nchars */
+	size_t sz = (version == 5) ? X_SIZEOF_INT64 : X_SIZEOF_INT; /* nchars */
 
 	assert(ncstrp != NULL);
 
@@ -336,14 +361,14 @@
 NC_xlen_dim(dpp)
  */
 static size_t
-ncx_len_NC_dim(const NC_dim *dimp)
+ncx_len_NC_dim(const NC_dim *dimp, int version)
 {
 	size_t sz;
 
 	assert(dimp != NULL);
 
-	sz = ncx_len_NC_string(dimp->name);
-	sz += X_SIZEOF_SIZE_T;
+	sz = ncx_len_NC_string(dimp->name, version);
+	sz += (version == 5) ? X_SIZEOF_INT64 : X_SIZEOF_INT;
 
 	return(sz);
 }
@@ -404,10 +429,10 @@
 
 /* How much space in the header is required for this NC_dimarray? */
 static size_t
-ncx_len_NC_dimarray(const NC_dimarray *ncap)
+ncx_len_NC_dimarray(const NC_dimarray *ncap, int version)
 {
 	size_t xlen = X_SIZEOF_NCTYPE;	/* type */
-	xlen += X_SIZEOF_SIZE_T;	/* count */
+	xlen += (version == 5) ? X_SIZEOF_INT64 : X_SIZEOF_INT; /* count */
 	if(ncap == NULL)
 		return xlen;
 	/* else */
@@ -416,7 +441,7 @@
 		const NC_dim *const *const end = &dpp[ncap->nelems];
 		for(  /*NADA*/; dpp < end; dpp++)
 		{
-			xlen += ncx_len_NC_dim(*dpp);
+			xlen += ncx_len_NC_dim(*dpp, version);
 		}
 	}
 	return xlen;
@@ -537,15 +562,15 @@
 NC_xlen_attr(app)
  */
 static size_t
-ncx_len_NC_attr(const NC_attr *attrp)
+ncx_len_NC_attr(const NC_attr *attrp, int version)
 {
 	size_t sz;
 
 	assert(attrp != NULL);
 
-	sz = ncx_len_NC_string(attrp->name);
+	sz = ncx_len_NC_string(attrp->name, version);
 	sz += X_SIZEOF_NC_TYPE; /* type */
-	sz += X_SIZEOF_SIZE_T; /* nelems */
+	sz += (version == 5) ? X_SIZEOF_INT64 : X_SIZEOF_INT; /* nelems */
 	sz += attrp->xsz;
 
 	return(sz);
@@ -696,10 +721,10 @@
 
 /* How much space in the header is required for this NC_attrarray? */
 static size_t
-ncx_len_NC_attrarray(const NC_attrarray *ncap)
+ncx_len_NC_attrarray(const NC_attrarray *ncap, int version)
 {
 	size_t xlen = X_SIZEOF_NCTYPE;	/* type */
-	xlen += X_SIZEOF_SIZE_T;	/* count */
+	xlen += (version == 5) ? X_SIZEOF_INT64 : X_SIZEOF_INT; /* count */
 	if(ncap == NULL)
 		return xlen;
 	/* else */
@@ -708,7 +733,7 @@
 		const NC_attr *const *const end = &app[ncap->nelems];
 		for( /*NADA*/; app < end; app++)
 		{
-			xlen += ncx_len_NC_attr(*app);
+			xlen += ncx_len_NC_attr(*app, version);
 		}
 	}
 	return xlen;
@@ -826,19 +851,25 @@
 NC_xlen_var(vpp)
  */
 static size_t
-ncx_len_NC_var(const NC_var *varp, size_t sizeof_off_t)
+ncx_len_NC_var(const NC_var *varp, size_t sizeof_off_t, int version)
 {
 	size_t sz;
 
 	assert(varp != NULL);
 	assert(sizeof_off_t != 0);
 
-	sz = ncx_len_NC_string(varp->name);
-	sz += X_SIZEOF_SIZE_T; /* ndims */
+	sz = ncx_len_NC_string(varp->name, version);
+        if (version == 5) {
+	    sz += X_SIZEOF_INT64; /* ndims */
+	    sz += ncx_len_int64(varp->ndims); /* dimids */
+        }
+        else {
+	    sz += X_SIZEOF_INT; /* ndims */
 	sz += ncx_len_int(varp->ndims); /* dimids */
-	sz += ncx_len_NC_attrarray(&varp->attrs);
-	sz += X_SIZEOF_NC_TYPE; /* type */
-	sz += X_SIZEOF_SIZE_T; /* len */
+        }
+	sz += ncx_len_NC_attrarray(&varp->attrs, version);
+	sz += X_SIZEOF_NC_TYPE; /* nc_type */
+	sz += (version == 5) ? X_SIZEOF_INT64 : X_SIZEOF_INT; /* vsize */
 	sz += sizeof_off_t; /* begin */
 
 	return(sz);
@@ -859,6 +890,16 @@
 	if(status != ENOERR)
 		return status;
 
+	if (psp->version == 5) {
+		status = check_v1hs(psp, ncx_len_int64(varp->ndims));
+		if(status != ENOERR)
+			return status;
+		status = ncx_putn_longlong_int(&psp->pos,
+				varp->ndims, varp->dimids);
+		if(status != ENOERR)
+			return status;
+	}
+	else {
 	status = check_v1hs(psp, ncx_len_int(varp->ndims));
 	if(status != ENOERR)
 		return status;
@@ -866,20 +907,21 @@
 			varp->ndims, varp->dimids);
 	if(status != ENOERR)
 		return status;
+	}
 
 	status = v1h_put_NC_attrarray(psp, &varp->attrs);
 	if(status != ENOERR)
 		return status;
 
-	status = v1h_put_nc_type(psp, &varp->type);
+	status = v1h_put_nc_type(psp, &varp->type); /* nc_type */
 	if(status != ENOERR)
 		return status;
 
-	status = v1h_put_size_t(psp, &varp->len);
+	status = v1h_put_size_t(psp, &varp->len); /* vsize */
 	if(status != ENOERR)
 		return status;
 
-	status = check_v1hs(psp, psp->version == 1 ? 4 : 8);
+	status = check_v1hs(psp, psp->version == 1 ? 4 : 8); /* begin */
 	if(status != ENOERR)
 		 return status;
 	status = ncx_put_off_t(&psp->pos, &varp->begin, psp->version == 1 ? 4 : 8);
@@ -914,6 +956,16 @@
 		goto unwind_name;
 	}
 
+	if (gsp->version == 5) {
+		status = check_v1hs(gsp, ncx_len_int64(ndims));
+		if(status != ENOERR)
+			goto unwind_alloc;
+		status = ncx_getn_longlong_int((const void **)(&gsp->pos),
+				ndims, varp->dimids);
+		if(status != ENOERR)
+			goto unwind_alloc;
+	}
+	else {
 	status = check_v1hs(gsp, ncx_len_int(ndims));
 	if(status != ENOERR)
 		goto unwind_alloc;
@@ -921,6 +973,7 @@
 			ndims, varp->dimids);
 	if(status != ENOERR)
 		goto unwind_alloc;
+	}
 
 	status = v1h_get_NC_attrarray(gsp, &varp->attrs);
 	if(status != ENOERR)
@@ -957,10 +1010,10 @@
 
 /* How much space in the header is required for this NC_vararray? */
 static size_t
-ncx_len_NC_vararray(const NC_vararray *ncap, size_t sizeof_off_t)
+ncx_len_NC_vararray(const NC_vararray *ncap, size_t sizeof_off_t, int version)
 {
 	size_t xlen = X_SIZEOF_NCTYPE;	/* type */
-	xlen += X_SIZEOF_SIZE_T;	/* count */
+	xlen += (version == 5) ? X_SIZEOF_INT64 : X_SIZEOF_INT; /* count */
 	if(ncap == NULL)
 		return xlen;
 	/* else */
@@ -969,7 +1022,7 @@
 		const NC_var *const *const end = &vpp[ncap->nelems];
 		for( /*NADA*/; vpp < end; vpp++)
 		{
-			xlen += ncx_len_NC_var(*vpp, sizeof_off_t);
+			xlen += ncx_len_NC_var(*vpp, sizeof_off_t, version);
 		}
 	}
 	return xlen;
@@ -1117,7 +1170,9 @@
 		{
 	  		if(first_rec == NULL)	
 				first_rec = *vpp;
-			if((*vpp)->len == UINT32_MAX) /* Flag for large last record */
+			if((*vpp)->len == UINT32_MAX &&
+                           fIsSet(ncp->flags, NC_64BIT_OFFSET))
+                            /* CDF-2: Flag for large last record */
                             ncp->recsize += (*vpp)->dsizes[0] * (*vpp)->xsz;
 			else
 			    ncp->recsize += (*vpp)->len;
@@ -1168,14 +1223,20 @@
 size_t
 ncx_len_NC(const NC3_INFO* ncp, size_t sizeof_off_t)
 {
+	int version=1;
 	size_t xlen = sizeof(ncmagic);
 
 	assert(ncp != NULL);
 	
-	xlen += X_SIZEOF_SIZE_T; /* numrecs */
-	xlen += ncx_len_NC_dimarray(&ncp->dims);
-	xlen += ncx_len_NC_attrarray(&ncp->attrs);
-	xlen += ncx_len_NC_vararray(&ncp->vars, sizeof_off_t);
+	if (fIsSet(ncp->flags, NC_64BIT_DATA)) /* CDF-5 */
+		version = 5;
+    	else if (fIsSet(ncp->flags, NC_64BIT_OFFSET)) /* CDF-2 */
+		version = 2;
+
+	xlen += (version == 5) ? X_SIZEOF_INT64 : X_SIZEOF_INT; /* numrecs */
+	xlen += ncx_len_NC_dimarray(&ncp->dims, version);
+	xlen += ncx_len_NC_attrarray(&ncp->attrs, version);
+	xlen += ncx_len_NC_vararray(&ncp->vars, sizeof_off_t, version);
 
 	return xlen;
 }
@@ -1195,7 +1256,9 @@
 	ps.nciop = ncp->nciop;
 	ps.flags = RGN_WRITE;
 
-	if (ncp->flags & NC_64BIT_OFFSET)
+	if (ncp->flags & NC_64BIT_DATA)
+	  ps.version = 5;
+	else if (ncp->flags & NC_64BIT_OFFSET)
 	  ps.version = 2;
 	else 
 	  ps.version = 1;
@@ -1206,7 +1269,7 @@
 		 * Come up with a reasonable stream read size.
 		 */
 		extent = ncp->xsz;
-		if(extent <= MIN_NC_XSZ)
+		if(extent <= ((ps.version==5)?MIN_NC5_XSZ:MIN_NC_XSZ))
 		{
 			/* first time read */
 			extent = ncp->chunk;
@@ -1236,7 +1299,9 @@
 		ps.end = (char *)ps.base + ps.extent;
 	}
 
-	if (ps.version == 2)
+	if (ps.version == 5)
+	  status = ncx_putn_schar_schar(&ps.pos, sizeof(ncmagic5), ncmagic5);
+	else if (ps.version == 2)
 	  status = ncx_putn_schar_schar(&ps.pos, sizeof(ncmagic), ncmagic);
 	else
 	  status = ncx_putn_schar_schar(&ps.pos, sizeof(ncmagic1), ncmagic1);
@@ -1245,6 +1310,9 @@
 
 	{
 	const size_t nrecs = NC_get_numrecs(ncp);
+        	if (ps.version == 5)
+			status = ncx_put_int64(&ps.pos, nrecs);
+        	else
 	status = ncx_put_size_t(&ps.pos, &nrecs);
 	if(status != ENOERR)
 		goto release;
@@ -1295,10 +1363,9 @@
 		 * Come up with a reasonable stream read size.
 		 */
 	        off_t filesize;
-		size_t extent = MIN_NC_XSZ;
+		size_t extent = ncp->xsz;
 		
-		extent = ncp->xsz;
-		if(extent <= MIN_NC_XSZ)
+		if(extent <= ((fIsSet(ncp->flags, NC_64BIT_DATA))?MIN_NC5_XSZ:MIN_NC_XSZ))
 		{
 		        status = ncio_filesize(ncp->nciop, &filesize);
 			if(status)
@@ -1362,6 +1429,9 @@
 		    fprintf(stderr, "NETCDF WARNING: Version 2 file on 32-bit system.\n");
 		  }
 #endif
+		} else if (magic[sizeof(ncmagic)-1] == 0x5) {
+		  gs.version = 5;
+		  fSet(ncp->flags, NC_64BIT_DATA);
 		} else {
 			status = NC_ENOTNC;
 			goto unwind_get;
@@ -1370,6 +1440,12 @@
 	
 	{
 	size_t nrecs = 0;
+        	if (gs.version == 5) {
+			long long tmp = 0;
+			status = ncx_get_int64((const void **)(&gs.pos), &tmp);
+			nrecs = (size_t)tmp;
+        	}
+        	else
 	status = ncx_get_size_t((const void **)(&gs.pos), &nrecs);
 	if(status != ENOERR)
 		goto unwind_get;
diff netcdf-c/libsrc/var.c cdf5/libsrc/var.c
--- netcdf-c/libsrc/var.c	2014-11-14 15:15:16.659820900 -0700
+++ cdf5/libsrc/var.c	2014-11-14 14:54:46.007909200 -0700
@@ -81,7 +81,6 @@
 #else /*!MALLOCHACK*/
 	  varp->dimids = (int*)malloc(o1);
 	  varp->shape = (size_t*)malloc(o2);
-      if(varp->shape) { memset(varp->shape,0,o2); }
 	  varp->dsizes = (off_t*)malloc(o3);
 #endif /*!MALLOCHACK*/
 	} else {
@@ -377,6 +376,7 @@
 	switch(type){
 	case NC_BYTE:
 	case NC_CHAR:
+	case NC_UBYTE:
 		return(1);
 	case NC_SHORT :
 		return(2);
@@ -386,6 +386,14 @@
 		return X_SIZEOF_FLOAT;
 	case NC_DOUBLE :
 		return X_SIZEOF_DOUBLE;
+	case NC_USHORT : 
+		return X_SIZEOF_USHORT;
+	case NC_UINT : 
+		return X_SIZEOF_UINT;
+	case NC_INT64 : 
+		return X_SIZEOF_INT64;
+	case NC_UINT64 : 
+		return X_SIZEOF_UINT64;
 	default:
 	        assert("ncx_szof invalid type" == 0);
 	        return 0;
@@ -439,12 +447,11 @@
  			shp >= varp->shape;
 			shp--, dsp--)
 	{
-      /*if(!(shp == varp->shape && IS_RECVAR(varp)))*/
-      if( shp != NULL && (shp != varp->shape || !IS_RECVAR(varp)))
+		if(!(shp == varp->shape && IS_RECVAR(varp)))
 		{
 		    if( (off_t)(*shp) <= OFF_T_MAX / product )
 			{
-              product *= (*shp > 0 ? *shp : 1);
+				product *= *shp;
 			} else
 			{
 				product = OFF_T_MAX ;
@@ -462,6 +469,8 @@
 		case NC_BYTE :
 		case NC_CHAR :
 		case NC_SHORT :
+		case NC_UBYTE :
+		case NC_USHORT :
 		        if( varp->len%4 != 0 )
 			{
 			        varp->len += 4 - varp->len%4; /* round up */
@@ -564,7 +573,7 @@
 	if(status != NC_NOERR)
 		return status;
 
-	status = nc_cktype(type);
+	status = nc_cktype(nc->mode, type);
 	if(status != NC_NOERR)
 		return status;
 
diff netcdf-c/libsrc4/nc4file.c cdf5/libsrc4/nc4file.c
--- netcdf-c/libsrc4/nc4file.c	2015-03-09 13:48:02.748335200 -0600
+++ cdf5/libsrc4/nc4file.c	2014-11-14 14:54:46.024509700 -0700
@@ -471,7 +471,7 @@
    }
 
    /* Check the cmode for validity. */
-   if (cmode & ~(NC_NOCLOBBER | NC_64BIT_OFFSET
+   if (cmode & ~(NC_NOCLOBBER | NC_64BIT_OFFSET | NC_64BIT_DATA
                  | NC_NETCDF4 | NC_CLASSIC_MODEL
                  | NC_SHARE | NC_MPIIO | NC_MPIPOSIX | NC_LOCK | NC_PNETCDF
 		 | NC_DISKLESS
@@ -479,6 +479,7 @@
                  )
        || (cmode & NC_MPIIO && cmode & NC_MPIPOSIX)
        || (cmode & NC_64BIT_OFFSET && cmode & NC_NETCDF4)
+       || (cmode & NC_64BIT_DATA && cmode & NC_NETCDF4)
        || (cmode & (NC_MPIIO | NC_MPIPOSIX) && cmode & NC_DISKLESS)
       )
       return NC_EINVAL;
@@ -497,7 +498,9 @@
    cmode |= NC_NETCDF4;
 
    /* Apply default create format. */
-   if (nc_get_default_format() == NC_FORMAT_64BIT)
+   if (nc_get_default_format() == NC_FORMAT_CDF5)
+      cmode |= NC_64BIT_DATA;
+   else if (nc_get_default_format() == NC_FORMAT_CDF2)
       cmode |= NC_64BIT_OFFSET;
    else if (nc_get_default_format() == NC_FORMAT_NETCDF4_CLASSIC)
       cmode |= NC_CLASSIC_MODEL;
diff netcdf-c/libsrc4/nc4hdf.c cdf5/libsrc4/nc4hdf.c
--- netcdf-c/libsrc4/nc4hdf.c	2015-03-09 13:48:02.748335200 -0600
+++ cdf5/libsrc4/nc4hdf.c	2014-11-14 13:32:33.651886400 -0700
@@ -3599,17 +3599,11 @@
                       return NC_ENOMEM;
                     }
                   if ((dataset_ndims = H5Sget_simple_extent_dims(spaceid, h5dimlen,
-                                                                 h5dimlenmax)) < 0) {
-                    free(h5dimlenmax);
-                    free(h5dimlen);
+							      h5dimlenmax)) < 0)
                     return NC_EHDFERR;
-                  }
-                  if (dataset_ndims != var->ndims) {
-                    free(h5dimlenmax);
-                    free(h5dimlen);
+	       if (dataset_ndims != var->ndims)
                     return NC_EHDFERR;
                   }
-                }
               else
                 {
                   /* Make sure it's scalar. */
@@ -3618,11 +3612,8 @@
                 }
 
               /* Release the space object. */
-              if (H5Sclose(spaceid) < 0) {
-                free(h5dimlen);
-                free(h5dimlenmax);
+	    if (H5Sclose(spaceid) < 0)
                 return NC_EHDFERR;
-              }
 #ifdef EXTRA_TESTS
               num_spaces--;
 #endif
@@ -3645,19 +3636,13 @@
                       char phony_dim_name[NC_MAX_NAME + 1];
 
                       LOG((3, "%s: creating phony dim for var %s", __func__, var->name));
-                      if ((retval = nc4_dim_list_add(&grp->dim, &dim))) {
-                        free(h5dimlenmax);
-                        free(h5dimlen);
+		  if ((retval = nc4_dim_list_add(&grp->dim, &dim)))
                         return retval;
-                      }
                       grp->ndims++;
                       dim->dimid = grp->nc4_info->next_dimid++;
                       sprintf(phony_dim_name, "phony_dim_%d", dim->dimid);
-                      if (!(dim->name = strdup(phony_dim_name))) {
-                        free(h5dimlenmax);
-                        free(h5dimlen);
+		  if (!(dim->name = strdup(phony_dim_name)))
                         return NC_ENOMEM;
-                      }
                       dim->len = h5dimlen[d];
                       if (h5dimlenmax[d] == H5S_UNLIMITED)
                         dim->unlimited = NC_TRUE;
diff netcdf-c/libsrc5/nc5dispatch.c cdf5/libsrc5/nc5dispatch.c
--- netcdf-c/libsrc5/nc5dispatch.c	2015-02-19 15:13:49.827790300 -0700
+++ cdf5/libsrc5/nc5dispatch.c	2014-11-14 14:54:46.037204200 -0700
@@ -1,4 +1,5 @@
-/********************************************************************* *   Copyright 1993, UCAR/Unidata
+/*********************************************************************
+ *   Copyright 1993, UCAR/Unidata
  *   See netcdf/COPYRIGHT file for copying and redistribution conditions.
  *   $Header: /upc/share/CVS/netcdf-3/libsrc4/NC5dispatch.c,v 1.5 2010/05/27 02:19:37 dmh Exp $
  *********************************************************************/
@@ -29,9 +30,10 @@
 #define NC5_DATA(nc) ((NC5_INFO*)(nc)->dispatchdata)
 #define NC5_DATA_SET(nc,data) ((nc)->dispatchdata = (void*)(data))
 
-#define LEGAL_CREATE_FLAGS (NC_NOCLOBBER | NC_64BIT_OFFSET | NC_CLASSIC_MODEL | NC_SHARE | NC_MPIIO | NC_MPIPOSIX | NC_LOCK | NC_PNETCDF)
+/* Cannot have NC_MPIPOSIX flag, ignore NC_MPIIO as PnetCDF use MPIIO */
+#define LEGAL_CREATE_FLAGS (NC_NOCLOBBER | NC_64BIT_OFFSET | NC_CLASSIC_MODEL | NC_SHARE | NC_MPIIO | NC_LOCK | NC_PNETCDF | NC_64BIT_DATA)
 
-#define LEGAL_OPEN_FLAGS (NC_WRITE | NC_NOCLOBBER | NC_SHARE | NC_MPIIO | NC_MPIPOSIX | NC_LOCK | NC_PNETCDF | NC_CLASSIC_MODEL | NC_64BIT_OFFSET)
+#define LEGAL_OPEN_FLAGS (NC_WRITE | NC_NOCLOBBER | NC_SHARE | NC_MPIIO | NC_LOCK | NC_PNETCDF | NC_CLASSIC_MODEL | NC_64BIT_OFFSET | NC_64BIT_DATA)
 
 
 /**************************************************/
@@ -42,7 +44,7 @@
 	  int use_parallel, void* mpidata,
 	  struct NC_Dispatch* table, NC* nc)
 {
-    int res;
+    int res, default_format;
     NC5_INFO* nc5;
     MPI_Comm comm = MPI_COMM_WORLD;
     MPI_Info info = MPI_INFO_NULL;
@@ -51,13 +53,23 @@
     if(cmode & ~LEGAL_CREATE_FLAGS)
 	return NC_EINVAL;
 
-    /* Cannot have both MPIO flags */
-    if((cmode & (NC_MPIIO|NC_MPIPOSIX)) == (NC_MPIIO|NC_MPIPOSIX))
+    /* Cannot have both NC_64BIT_OFFSET & NC_64BIT_DATA */
+    if((cmode & (NC_64BIT_OFFSET|NC_64BIT_DATA)) == (NC_64BIT_OFFSET|NC_64BIT_DATA))
 	return NC_EINVAL;
 
-    /* Appears that this comment is wrong; allow 64 bit offset*/
-    /* Cannot have 64 bit offset flag */
-    /*if(cmode & (NC_64BIT_OFFSET)) return NC_EINVAL;*/
+    default_format = nc_get_default_format();
+    /* if (default_format == NC_FORMAT_CLASSIC) then we respect the format set in cmode */
+    if (default_format == NC_FORMAT_CDF2) {
+        if (! (cmode & NC_64BIT_OFFSET)) /* check if cmode has NC_64BIT_OFFSET already */
+            cmode |= NC_64BIT_OFFSET;
+    }
+    else if (default_format == NC_FORMAT_CDF5) {
+        if (! (cmode & NC_64BIT_DATA)) /* check if cmode has NC_64BIT_DATA already */
+            cmode |= NC_64BIT_DATA;
+    }
+
+    /* No MPI environment initialized */
+    if (mpidata == NULL) return NC_ENOPAR;
 
     comm = ((NC_MPI_INFO *)mpidata)->comm;
     info = ((NC_MPI_INFO *)mpidata)->info;
@@ -69,25 +81,10 @@
     /* Link nc5 and nc */
     NC5_DATA_SET(nc,nc5);
 
-    /* Fix up the cmode by keeping only essential flags;
-       these are the flags that are the same in netcf.h and pnetcdf.h
-    */
-#if 0
-    cmode &= (NC_WRITE | NC_NOCLOBBER | NC_LOCK | NC_SHARE | NC_64BIT_OFFSET);
-#else
-    cmode &= (NC_WRITE | NC_NOCLOBBER | NC_LOCK | NC_SHARE );
-#endif
-
-    /* It turns out that pnetcdf.h defines a flag called
-       NC_64BIT_DATA (not to be confused with NC_64BIT_OFFSET).
-       This flag is essential to getting ncmpi_create to create
-       a proper pnetcdf format file.
-       It just happens that the value of NC_64BIT_DATA is the same
-       as the netcdf NC_NETCDF4 flag value. This is probably no accident.
+    /* PnetCDF recognizes the flags below for create and ignores NC_LOCK and
+     * NC_SHARE */
+    cmode &= (NC_WRITE | NC_NOCLOBBER | NC_SHARE | NC_64BIT_OFFSET | NC_64BIT_DATA);
 
-       In any case, this flag must be set.
-    */
-    cmode |= (NC_NETCDF4);
     res = ncmpi_create(comm, path, cmode, info, &(nc->int_ncid));
 
     if(res && nc5 != NULL) free(nc5); /* reclaim allocated space */
@@ -109,14 +106,6 @@
     if(cmode & ~LEGAL_OPEN_FLAGS)
 	return NC_EINVAL;
 
-    /* Cannot have both MPIO flags */
-    if((cmode & (NC_MPIIO|NC_MPIPOSIX)) == (NC_MPIIO|NC_MPIPOSIX))
-	return NC_EINVAL;
-
-    /* Appears that this comment is wrong; allow 64 bit offset*/
-    /* Cannot have 64 bit offset flag */
-    /* if(cmode & (NC_64BIT_OFFSET)) return NC_EINVAL; */
-
     if(mpidata != NULL) {
         comm = ((NC_MPI_INFO *)mpidata)->comm;
         info = ((NC_MPI_INFO *)mpidata)->info;
@@ -125,12 +114,13 @@
 	info = MPI_INFO_NULL;
     }
 
-    /* Fix up the cmode by keeping only essential flags;
-       these are the flags that are the same in netcf.h and pnetcdf.h
+    /* PnetCDF recognizes the flags NC_WRITE and NC_NOCLOBBER for file open
+     * and ignores NC_LOCK, NC_SHARE, NC_64BIT_OFFSET, and NC_64BIT_DATA.
+     * Ignoring the NC_64BIT_OFFSET and NC_64BIT_DATA flags is because the
+     * file is already in one of the CDF-formats, and setting these 2 flags
+     * will not change the format of that file.
     */
-    cmode &= (NC_WRITE | NC_NOCLOBBER | NC_LOCK | NC_SHARE | NC_64BIT_OFFSET);
-
-    cmode |= (NC_NETCDF4); /* see comment in NC5_create */
+    cmode &= (NC_WRITE | NC_NOCLOBBER);
 
     /* Create our specific NC5_INFO instance */
     nc5 = (NC5_INFO*)calloc(1,sizeof(NC5_INFO));
@@ -159,6 +149,7 @@
     return ncmpi_redef(nc->int_ncid);
 }
 
+/* no need any more
 static int
 NC5_enddef(int ncid)
 {
@@ -180,11 +171,33 @@
     }
     return status;
 }
+*/
 
 static int
 NC5__enddef(int ncid, size_t h_minfree, size_t v_align, size_t v_minfree, size_t r_align)
 {
-    return NC5_enddef(ncid);
+    int status;
+    NC* nc;
+    NC5_INFO* nc5;
+    MPI_Offset mpi_h_minfree = h_minfree;
+    MPI_Offset mpi_v_align   = v_align;
+    MPI_Offset mpi_v_minfree = v_minfree;
+    MPI_Offset mpi_r_align   = r_align;
+
+    status = NC_check_id(ncid, &nc);
+    if(status != NC_NOERR)
+	return status;
+
+    nc5 = NC5_DATA(nc);
+    assert(nc5);
+
+    status = ncmpi__enddef(nc->int_ncid, mpi_h_minfree, mpi_v_align,
+                           mpi_v_minfree, mpi_r_align);
+    if(!status) {
+	if (nc5->pnetcdf_access_mode == NC_INDEPENDENT)
+	    status = ncmpi_begin_indep_data(nc->int_ncid);
+    }
+    return status;
 }
 
 static int
@@ -257,7 +270,15 @@
     NC* nc;
     int status = NC_check_id(ncid, &nc);
     if(status != NC_NOERR) return status;
-    return ncmpi_inq_format(nc->int_ncid,formatp);
+    status = ncmpi_inq_format(nc->int_ncid,formatp);
+
+/* NC_FORMAT_PNETCDF is now NC_FORMAT_CDF5
+    if(status == NC_NOERR) {
+        if (*formatp == NC_FORMAT_CDF5)
+            *formatp = NC_FORMAT_PNETCDF;
+    }
+*/
+    return status;
 }
 
 static int
@@ -284,20 +305,47 @@
     return ncmpi_inq(nc->int_ncid,ndimsp,nvarsp,nattsp,unlimp);
 }
 
-static int
-atomic_size[6] = {
-1, 1, 2, 4, 4, 8
-};
+/* The sizes of types may vary from platform to platform, but within
+ * netCDF files, type sizes are fixed. */
+#define NC_CHAR_LEN sizeof(char)
+#define NC_STRING_LEN sizeof(char *)
+#define NC_BYTE_LEN 1
+#define NC_SHORT_LEN 2
+#define NC_INT_LEN 4
+#define NC_FLOAT_LEN 4
+#define NC_DOUBLE_LEN 8
+#define NC_INT64_LEN 8
+
+static int atomic_size[12] = {NC_BYTE_LEN,  NC_CHAR_LEN,  NC_SHORT_LEN,
+                              NC_INT_LEN,   NC_FLOAT_LEN, NC_DOUBLE_LEN,
+                              NC_BYTE_LEN,  NC_SHORT_LEN, NC_INT_LEN,
+                              NC_INT64_LEN, NC_INT64_LEN, NC_STRING_LEN};
+
 static char
-atomic_name[6][NC_MAX_NAME + 1] = {
-"byte", "char", "short","int", "float", "double"
-};
+atomic_name[12][NC_MAX_NAME + 1] = {"byte", "char", "short",
+                                    "int", "float", "double",
+                                    "ubyte", "ushort","uint",
+                                    "int64", "uint64", "string"};
 
 static int
 NC5_inq_type(int ncid, nc_type typeid, char* name, size_t* size)
 {
+    NC* nc;
+    int format, status;
+
+    status = NC_check_id(ncid, &nc);
+    if (status != NC_NOERR) return status;
+    status = ncmpi_inq_format(nc->int_ncid, &format);
+    if (status != NC_NOERR) return status;
+
+    if (format == NC_FORMAT_CDF5) {
+        if (typeid < NC_BYTE || typeid > NC_STRING)
+           return NC_EBADTYPE;
+    }
+    else { /* CDF-1 and CDF-2 */
    if(typeid < NC_BYTE || typeid > NC_DOUBLE)
       return NC_EBADTYPE;
+    }
 
    /* Give the user the values they want. Subtract one because types
     * are numbered starting at 1, not 0. */
@@ -372,6 +420,7 @@
     NC* nc;
     MPI_Offset mpilen;
     int status = NC_check_id(ncid, &nc);
+    if(status != NC_NOERR) return status;
     status = ncmpi_inq_att(nc->int_ncid,varid,name,xtypep,&mpilen);
     if(status != NC_NOERR) return status;
     if(lenp) *lenp = mpilen;
@@ -448,10 +497,16 @@
         return ncmpi_get_att_float(nc->int_ncid, varid, name, (float*)ip);
     case NC_DOUBLE:
         return ncmpi_get_att_double(nc->int_ncid, varid, name, (double*)ip);
-    case NC_INT64: /* synthetic */
-        return ncmpi_get_att_long(nc->int_ncid, varid, name, (long*)ip);
-    case NC_UBYTE: /* Synthetic */
+    case NC_UBYTE:
         return ncmpi_get_att_uchar(nc->int_ncid, varid, name, (unsigned char*)ip);
+    case NC_USHORT:
+        return ncmpi_get_att_ushort(nc->int_ncid, varid, name, (unsigned short*)ip);
+    case NC_UINT:
+        return ncmpi_get_att_uint(nc->int_ncid, varid, name, (unsigned int*)ip);
+    case NC_INT64:
+        return ncmpi_get_att_longlong(nc->int_ncid, varid, name, (long long*)ip);
+    case NC_UINT64:
+        return ncmpi_get_att_ulonglong(nc->int_ncid, varid, name, (unsigned long long*)ip);
     default:
 	break;
     }
@@ -498,10 +553,16 @@
         return ncmpi_put_att_float(nc->int_ncid, varid, name, xtype, mpilen, (float*)ip);
     case NC_DOUBLE:
         return ncmpi_put_att_double(nc->int_ncid, varid, name, xtype, mpilen, (double*)ip);
-    case NC_INT64: /* synthetic */
-        return ncmpi_put_att_long(nc->int_ncid, varid, name, xtype, mpilen, (long*)ip);
-    case NC_UBYTE: /* Synthetic */
+    case NC_UBYTE:
         return ncmpi_put_att_uchar(nc->int_ncid, varid, name, xtype, mpilen, (unsigned char*)ip);
+    case NC_USHORT:
+        return ncmpi_put_att_ushort(nc->int_ncid, varid, name, xtype, mpilen, (unsigned short*)ip);
+    case NC_UINT:
+        return ncmpi_put_att_uint(nc->int_ncid, varid, name, xtype, mpilen, (unsigned int*)ip);
+    case NC_INT64:
+        return ncmpi_put_att_longlong(nc->int_ncid, varid, name, xtype, mpilen, (long long*)ip);
+    case NC_UINT64:
+        return ncmpi_put_att_ulonglong(nc->int_ncid, varid, name, xtype, mpilen, (unsigned long long*)ip);
     default:
 	break;
     }
@@ -564,20 +625,21 @@
     nc5 = NC5_DATA(nc);
     assert(nc5);
 
-    /* No NC_LONG for parallel-netcdf library! */
-    if(memtype == NC_INT64)
-	 return NC_EINVAL;
-
     /* get variable's rank */
     status= ncmpi_inq_varndims(nc->int_ncid, varid, &rank);
     if(status) return status;
 
-    /* We must convert the start, count, and stride arrays to MPI_Offset type. */
+    /* We must convert the start and count arrays to MPI_Offset type. */
     for (d = 0; d < rank; d++) {
 	 mpi_start[d] = startp[d];
 	 mpi_count[d] = countp[d];
     }
 
+    if (memtype == NC_NAT) {
+        status = ncmpi_inq_vartype(nc->int_ncid, varid, &memtype);
+        if (status) return status;
+    }
+
     if(nc5->pnetcdf_access_mode == NC_INDEPENDENT) {
 	switch(memtype) {
 	case NC_BYTE:
@@ -592,10 +654,16 @@
 	    status=ncmpi_get_vara_float(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	case NC_DOUBLE:
 	    status=ncmpi_get_vara_double(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
-	case NC_UBYTE: /* synthetic */
+	case NC_UBYTE:
 	    status=ncmpi_get_vara_uchar(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
-	case NC_INT64: /* synthetic */
-	    status=ncmpi_get_vara_long(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_USHORT:
+	    status=ncmpi_get_vara_ushort(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_UINT:
+	    status=ncmpi_get_vara_uint(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_INT64:
+	    status=ncmpi_get_vara_longlong(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_UINT64:
+	    status=ncmpi_get_vara_ulonglong(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	default:
 	    status = NC_EBADTYPE;
 	}
@@ -615,8 +683,14 @@
 	    status=ncmpi_get_vara_double_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	case NC_UBYTE:
 	    status=ncmpi_get_vara_uchar_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_USHORT:
+	    status=ncmpi_get_vara_ushort_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_UINT:
+	    status=ncmpi_get_vara_uint_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	case NC_INT64:
-	    status=ncmpi_get_vara_long_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	    status=ncmpi_get_vara_longlong_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_UINT64:
+	    status=ncmpi_get_vara_ulonglong_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	default:
 	    status = NC_EBADTYPE;
 	}
@@ -645,20 +719,21 @@
     nc5 = NC5_DATA(nc);
     assert(nc5);
 
-    /* No NC_LONG for parallel-netcdf library! */
-    if(memtype == NC_INT64)
-	 return NC_EINVAL;
-
     /* get variable's rank */
     status = ncmpi_inq_varndims(nc->int_ncid, varid, &rank);
     if(status) return status;
 
-    /* We must convert the start, count, and stride arrays to MPI_Offset type. */
+    /* We must convert the start and count arrays to MPI_Offset type. */
     for (d = 0; d < rank; d++) {
 	 mpi_start[d] = startp[d];
 	 mpi_count[d] = countp[d];
     }
 
+    if (memtype == NC_NAT) {
+        status = ncmpi_inq_vartype(nc->int_ncid, varid, &memtype);
+        if (status) return status;
+    }
+
     if(nc5->pnetcdf_access_mode == NC_INDEPENDENT) {
 	switch(memtype) {
 	case NC_BYTE:
@@ -675,8 +750,14 @@
 	    status = ncmpi_put_vara_double(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	case NC_UBYTE:
 	    status = ncmpi_put_vara_uchar(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_USHORT:
+	    status = ncmpi_put_vara_ushort(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_UINT:
+	    status = ncmpi_put_vara_uint(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	case NC_INT64:
-	    status = ncmpi_put_vara_long(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	    status = ncmpi_put_vara_longlong(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_UINT64:
+	    status = ncmpi_put_vara_ulonglong(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	default:
 	    status = NC_EBADTYPE;
 	}
@@ -696,8 +777,402 @@
 	    status = ncmpi_put_vara_double_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	case NC_UBYTE:
 	    status = ncmpi_put_vara_uchar_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_USHORT:
+	    status = ncmpi_put_vara_ushort_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_UINT:
+	    status = ncmpi_put_vara_uint_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
 	case NC_INT64:
-	    status = ncmpi_put_vara_long_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	    status = ncmpi_put_vara_longlong_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	case NC_UINT64:
+	    status = ncmpi_put_vara_ulonglong_all(nc->int_ncid, varid, mpi_start, mpi_count, ip); break;
+	default:
+	    status = NC_EBADTYPE;
+	}
+    }
+    return status;
+}
+
+static int
+NC5_get_vars(int ncid,
+		int varid,
+		const size_t* startp,
+		const size_t* countp,
+		const ptrdiff_t* stridep,
+		void* ip,
+		nc_type memtype)
+{
+    NC* nc;
+    NC5_INFO* nc5;
+    int status;
+    MPI_Offset mpi_start[NC_MAX_VAR_DIMS], mpi_count[NC_MAX_VAR_DIMS], mpi_stride[NC_MAX_VAR_DIMS];
+    int d;
+    int rank = 0;
+
+    status = NC_check_id(ncid, &nc);
+    if(status != NC_NOERR) return status;
+
+    nc5 = NC5_DATA(nc);
+    assert(nc5);
+
+    /* get variable's rank */
+    status= ncmpi_inq_varndims(nc->int_ncid, varid, &rank);
+    if(status) return status;
+
+    /* We must convert the start, count, and stride arrays to MPI_Offset type. */
+    for (d = 0; d < rank; d++) {
+	 mpi_start[d] = startp[d];
+	 mpi_count[d] = countp[d];
+	 mpi_stride[d] = stridep[d];
+    }
+
+    if (memtype == NC_NAT) {
+        status = ncmpi_inq_vartype(nc->int_ncid, varid, &memtype);
+        if (status) return status;
+    }
+
+    if(nc5->pnetcdf_access_mode == NC_INDEPENDENT) {
+	switch(memtype) {
+	case NC_BYTE:
+	    status=ncmpi_get_vars_schar(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_CHAR:
+	    status=ncmpi_get_vars_text(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_SHORT:
+	    status=ncmpi_get_vars_short(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_INT:
+	    status=ncmpi_get_vars_int(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_FLOAT:
+	    status=ncmpi_get_vars_float(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_DOUBLE:
+	    status=ncmpi_get_vars_double(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UBYTE:
+	    status=ncmpi_get_vars_uchar(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_USHORT:
+	    status=ncmpi_get_vars_ushort(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UINT:
+	    status=ncmpi_get_vars_uint(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_INT64:
+	    status=ncmpi_get_vars_longlong(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UINT64:
+	    status=ncmpi_get_vars_ulonglong(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	default:
+	    status = NC_EBADTYPE;
+	}
+      } else {
+	switch(memtype) {
+	case NC_BYTE:
+	    status=ncmpi_get_vars_schar_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_CHAR:
+	    status=ncmpi_get_vars_text_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_SHORT:
+	    status=ncmpi_get_vars_short_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_INT:
+	    status=ncmpi_get_vars_int_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_FLOAT:
+	    status=ncmpi_get_vars_float_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_DOUBLE:
+	    status=ncmpi_get_vars_double_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UBYTE:
+	    status=ncmpi_get_vars_uchar_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_USHORT:
+	    status=ncmpi_get_vars_ushort_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UINT:
+	    status=ncmpi_get_vars_uint_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_INT64:
+	    status=ncmpi_get_vars_longlong_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UINT64:
+	    status=ncmpi_get_vars_ulonglong_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	default:
+	    status = NC_EBADTYPE;
+	}
+    }
+    return status;
+}
+
+static int
+NC5_put_vars(int ncid,
+	int varid,
+	const size_t* startp,
+	const size_t* countp,
+	const ptrdiff_t* stridep,
+	const void*ip,
+	nc_type memtype)
+{
+    NC* nc;
+    NC5_INFO* nc5;
+    int status;
+    MPI_Offset mpi_start[NC_MAX_VAR_DIMS], mpi_count[NC_MAX_VAR_DIMS], mpi_stride[NC_MAX_VAR_DIMS];
+    int d;
+    int rank;
+
+    status = NC_check_id(ncid, &nc);
+    if(status != NC_NOERR) return status;
+
+    nc5 = NC5_DATA(nc);
+    assert(nc5);
+
+    /* get variable's rank */
+    status = ncmpi_inq_varndims(nc->int_ncid, varid, &rank);
+    if(status) return status;
+
+    /* We must convert the start, count, and stride arrays to MPI_Offset type. */
+    for (d = 0; d < rank; d++) {
+	 mpi_start[d] = startp[d];
+	 mpi_count[d] = countp[d];
+	 mpi_stride[d] = stridep[d];
+    }
+
+    if (memtype == NC_NAT) {
+        status = ncmpi_inq_vartype(nc->int_ncid, varid, &memtype);
+        if (status) return status;
+    }
+
+    if(nc5->pnetcdf_access_mode == NC_INDEPENDENT) {
+	switch(memtype) {
+	case NC_BYTE:
+	    status = ncmpi_put_vars_schar(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_CHAR:
+	    status = ncmpi_put_vars_text(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_SHORT:
+	    status = ncmpi_put_vars_short(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_INT:
+	    status = ncmpi_put_vars_int(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_FLOAT:
+	    status = ncmpi_put_vars_float(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_DOUBLE:
+	    status = ncmpi_put_vars_double(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UBYTE:
+	    status = ncmpi_put_vars_uchar(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_USHORT:
+	    status = ncmpi_put_vars_ushort(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UINT:
+	    status = ncmpi_put_vars_uint(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_INT64:
+	    status = ncmpi_put_vars_longlong(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UINT64:
+	    status = ncmpi_put_vars_ulonglong(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	default:
+	    status = NC_EBADTYPE;
+	}
+      } else {
+	switch(memtype) {
+	case NC_BYTE:
+	    status = ncmpi_put_vars_schar_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_CHAR:
+	    status = ncmpi_put_vars_text_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_SHORT:
+	    status = ncmpi_put_vars_short_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_INT:
+	    status = ncmpi_put_vars_int_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_FLOAT:
+	    status = ncmpi_put_vars_float_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_DOUBLE:
+	    status = ncmpi_put_vars_double_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UBYTE:
+	    status = ncmpi_put_vars_uchar_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_USHORT:
+	    status = ncmpi_put_vars_ushort_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UINT:
+	    status = ncmpi_put_vars_uint_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_INT64:
+	    status = ncmpi_put_vars_longlong_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	case NC_UINT64:
+	    status = ncmpi_put_vars_ulonglong_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, ip); break;
+	default:
+	    status = NC_EBADTYPE;
+	}
+    }
+    return status;
+}
+
+static int
+NC5_get_varm(int ncid,
+		int varid,
+		const size_t* startp,
+		const size_t* countp,
+		const ptrdiff_t* stridep,
+		const ptrdiff_t* imapp,
+		void* ip,
+		nc_type memtype)
+{
+    NC* nc;
+    NC5_INFO* nc5;
+    int status;
+    MPI_Offset mpi_start[NC_MAX_VAR_DIMS], mpi_count[NC_MAX_VAR_DIMS], mpi_stride[NC_MAX_VAR_DIMS], mpi_imap[NC_MAX_VAR_DIMS];
+    int d;
+    int rank = 0;
+
+    status = NC_check_id(ncid, &nc);
+    if(status != NC_NOERR) return status;
+
+    nc5 = NC5_DATA(nc);
+    assert(nc5);
+
+    /* get variable's rank */
+    status= ncmpi_inq_varndims(nc->int_ncid, varid, &rank);
+    if(status) return status;
+
+    /* We must convert the start, count, stride, and imap arrays to MPI_Offset type. */
+    for (d = 0; d < rank; d++) {
+	 mpi_start[d] = startp[d];
+	 mpi_count[d] = countp[d];
+	 mpi_stride[d] = stridep[d];
+	 mpi_imap[d] = imapp[d];
+    }
+
+    if (memtype == NC_NAT) {
+        status = ncmpi_inq_vartype(nc->int_ncid, varid, &memtype);
+        if (status) return status;
+    }
+
+    if(nc5->pnetcdf_access_mode == NC_INDEPENDENT) {
+	switch(memtype) {
+	case NC_BYTE:
+	    status=ncmpi_get_varm_schar(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_CHAR:
+	    status=ncmpi_get_varm_text(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_SHORT:
+	    status=ncmpi_get_varm_short(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_INT:
+	    status=ncmpi_get_varm_int(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_FLOAT:
+	    status=ncmpi_get_varm_float(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_DOUBLE:
+	    status=ncmpi_get_varm_double(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UBYTE:
+	    status=ncmpi_get_varm_uchar(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_USHORT:
+	    status=ncmpi_get_varm_ushort(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UINT:
+	    status=ncmpi_get_varm_uint(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_INT64:
+	    status=ncmpi_get_varm_longlong(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UINT64:
+	    status=ncmpi_get_varm_ulonglong(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	default:
+	    status = NC_EBADTYPE;
+	}
+      } else {
+	switch(memtype) {
+	case NC_BYTE:
+	    status=ncmpi_get_varm_schar_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_CHAR:
+	    status=ncmpi_get_varm_text_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_SHORT:
+	    status=ncmpi_get_varm_short_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_INT:
+	    status=ncmpi_get_varm_int_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_FLOAT:
+	    status=ncmpi_get_varm_float_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_DOUBLE:
+	    status=ncmpi_get_varm_double_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UBYTE:
+	    status=ncmpi_get_varm_uchar_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_USHORT:
+	    status=ncmpi_get_varm_ushort_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UINT:
+	    status=ncmpi_get_varm_uint_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_INT64:
+	    status=ncmpi_get_varm_longlong_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UINT64:
+	    status=ncmpi_get_varm_ulonglong_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	default:
+	    status = NC_EBADTYPE;
+	}
+    }
+    return status;
+}
+
+static int
+NC5_put_varm(int ncid,
+	int varid,
+	const size_t* startp,
+	const size_t* countp,
+	const ptrdiff_t* stridep,
+	const ptrdiff_t* imapp,
+	const void*ip,
+	nc_type memtype)
+{
+    NC* nc;
+    NC5_INFO* nc5;
+    int status;
+    MPI_Offset mpi_start[NC_MAX_VAR_DIMS], mpi_count[NC_MAX_VAR_DIMS], mpi_stride[NC_MAX_VAR_DIMS], mpi_imap[NC_MAX_VAR_DIMS];
+    int d;
+    int rank;
+
+    status = NC_check_id(ncid, &nc);
+    if(status != NC_NOERR) return status;
+
+    nc5 = NC5_DATA(nc);
+    assert(nc5);
+
+    /* get variable's rank */
+    status = ncmpi_inq_varndims(nc->int_ncid, varid, &rank);
+    if(status) return status;
+
+    /* We must convert the start, count, stride, and imap arrays to MPI_Offset type. */
+    for (d = 0; d < rank; d++) {
+	 mpi_start[d] = startp[d];
+	 mpi_count[d] = countp[d];
+	 mpi_stride[d] = stridep[d];
+	 mpi_imap[d] = imapp[d];
+    }
+
+    if (memtype == NC_NAT) {
+        status = ncmpi_inq_vartype(nc->int_ncid, varid, &memtype);
+        if (status) return status;
+    }
+
+    if(nc5->pnetcdf_access_mode == NC_INDEPENDENT) {
+	switch(memtype) {
+	case NC_BYTE:
+	    status = ncmpi_put_varm_schar(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_CHAR:
+	    status = ncmpi_put_varm_text(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_SHORT:
+	    status = ncmpi_put_varm_short(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_INT:
+	    status = ncmpi_put_varm_int(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_FLOAT:
+	    status = ncmpi_put_varm_float(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_DOUBLE:
+	    status = ncmpi_put_varm_double(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UBYTE:
+	    status = ncmpi_put_varm_uchar(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_USHORT:
+	    status = ncmpi_put_varm_ushort(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UINT:
+	    status = ncmpi_put_varm_uint(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_INT64:
+	    status = ncmpi_put_varm_longlong(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UINT64:
+	    status = ncmpi_put_varm_ulonglong(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	default:
+	    status = NC_EBADTYPE;
+	}
+      } else {
+	switch(memtype) {
+	case NC_BYTE:
+	    status = ncmpi_put_varm_schar_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_CHAR:
+	    status = ncmpi_put_varm_text_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_SHORT:
+	    status = ncmpi_put_varm_short_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_INT:
+	    status = ncmpi_put_varm_int_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_FLOAT:
+	    status = ncmpi_put_varm_float_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_DOUBLE:
+	    status = ncmpi_put_varm_double_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UBYTE:
+	    status = ncmpi_put_varm_uchar_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_USHORT:
+	    status = ncmpi_put_varm_ushort_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UINT:
+	    status = ncmpi_put_varm_uint_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_INT64:
+	    status = ncmpi_put_varm_longlong_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
+	case NC_UINT64:
+	    status = ncmpi_put_varm_ulonglong_all(nc->int_ncid, varid, mpi_start, mpi_count, mpi_stride, mpi_imap, ip); break;
 	default:
 	    status = NC_EBADTYPE;
 	}
@@ -1101,10 +1576,10 @@
 NC5_rename_var,
 NC5_get_vara,
 NC5_put_vara,
-NCDEFAULT_get_vars,
-NCDEFAULT_put_vars,
-NCDEFAULT_get_varm,
-NCDEFAULT_put_varm,
+NC5_get_vars,
+NC5_put_vars,
+NC5_get_varm,
+NC5_put_varm,
 
 NC5_inq_var_all,
 
diff netcdf-c/nc_test/Makefile.am cdf5/nc_test/Makefile.am
--- netcdf-c/nc_test/Makefile.am	2015-03-09 13:48:02.748335200 -0600
+++ cdf5/nc_test/Makefile.am	2014-11-14 14:54:46.038180700 -0700
@@ -12,7 +12,7 @@
 tst_*.nc t_nc.nc large_files.nc quick_large_files.nc \
 tst_diskless.nc tst_diskless2.nc \
 tst_diskless3.nc tst_diskless3_file.cdl tst_diskless3_memory.cdl \
-tst_diskless4.cdl tst_diskless4.nc tst_formatx.nc
+tst_diskless4.cdl tst_diskless4.nc tst_formatx.nc nc_test_cdf5.nc
 
 # These are the tests which are always run.
 TESTPROGRAMS = t_nc tst_small nc_test tst_misc tst_norm tst_names	\
diff netcdf-c/nc_test/nc_test.c cdf5/nc_test/nc_test.c
--- netcdf-c/nc_test/nc_test.c	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/nc_test/nc_test.c	2014-11-14 14:54:46.039157200 -0700
@@ -1,9 +1,13 @@
 /*********************************************************************
  *   Copyright 1996-2005, UCAR/Unidata
  *   See COPYRIGHT file for copying and redistribution conditions.
- *   $Id: nc_test.c,v 1.44 2008/10/20 01:48:08 ed Exp $
+ *   $Id: nc_test.c 2796 2014-10-28 03:40:29Z wkliao $
  *********************************************************************/
 
+int numGatts;  /* number of global attributes */
+int numVars;   /* number of variables */
+int numTypes;  /* number of netCDF data types to test */
+
 #include "tests.h"
 
 /*
@@ -75,11 +79,7 @@
 
 /* Test everything for classic and 64-bit offsetfiles. If netcdf-4 is
  * included, that means another whole round of testing. */
-#ifdef USE_NETCDF4
-#define NUM_FORMATS (3)
-#else
-#define NUM_FORMATS (2)
-#endif
+#define NUM_FORMATS (5)
 
 int
 main(int argc, char *argv[])
@@ -87,6 +87,9 @@
     int i;
     int  nfailsTotal = 0;        /* total number of failures */
 
+#ifdef TEST_PNETCDF
+    MPI_Init(&argc, &argv);
+#endif
     /* Both CRAY MPP and OSF/1 Alpha systems need this.  Some of the
      * extreme test assignments in this program trigger floating point
      * exceptions on CRAY T90
@@ -96,9 +99,6 @@
     verbose = 0;
     max_nmpt = 8;
 
-    /* Initialize global variables defining test file */
-    init_gvars();
-
     /* If you uncomment the nc_set_log_level line, you will get a lot
      * of debugging info. If you set the number higher, you'll get
      * more. 6 is max, 0 shows only errors. 3 is a good place to
@@ -114,6 +114,10 @@
      * output of this program. */
     for (i = 1; i <= NUM_FORMATS; i++)
     {
+       numGatts = 6;
+       numVars  = 136;
+       numTypes = 6;
+
        switch (i) 
        {
 	  case NC_FORMAT_CLASSIC:
@@ -121,23 +125,37 @@
 	     fprintf(stderr, "\n\nSwitching to netCDF classic format.\n");
 	     strcpy(testfile, "nc_test_classic.nc");
 	     break;
-	  case NC_FORMAT_64BIT:
-	     nc_set_default_format(NC_FORMAT_64BIT, NULL);
+	  case NC_FORMAT_CDF2:
+	     nc_set_default_format(NC_FORMAT_CDF2, NULL);
 	     fprintf(stderr, "\n\nSwitching to 64-bit offset format.\n");
 	     strcpy(testfile, "nc_test_64bit.nc");
 	     break;
-#ifdef USE_NETCDF4
+	  case NC_FORMAT_CDF5:
+	     nc_set_default_format(NC_FORMAT_CDF5, NULL);
+	     fprintf(stderr, "\n\nSwitching to 64-bit data format.\n");
+	     strcpy(testfile, "nc_test_cdf5.nc");
+             numGatts = NGATTS;
+             numVars  = NVARS;
+             numTypes = NTYPES;
+	     break;
+	  case NC_FORMAT_NETCDF4_CLASSIC:
 	  case NC_FORMAT_NETCDF4: /* actually it's _CLASSIC. */
+#ifdef USE_NETCDF4
 	     nc_set_default_format(NC_FORMAT_NETCDF4_CLASSIC, NULL);
 	     strcpy(testfile, "nc_test_netcdf4.nc");
 	     fprintf(stderr, "\n\nSwitching to netCDF-4 format (with NC_CLASSIC_MODEL).\n");
 	     break;
+#else
+	     continue; /* loop i */
 #endif
 	  default:
 	     fprintf(stderr, "Unexpected format!\n");
 	     return 2;
        }
 
+       /* Initialize global variables defining test file */
+       init_gvars();
+
 	/* Write the test file, needed for the read-only tests below. */
        write_file(testfile);
 
@@ -172,6 +190,10 @@
 	NC_TEST(nc_get_var_long);
 	NC_TEST(nc_get_var_float);
 	NC_TEST(nc_get_var_double);
+	NC_TEST(nc_get_var_ushort);
+	NC_TEST(nc_get_var_uint);
+	NC_TEST(nc_get_var_longlong);
+	NC_TEST(nc_get_var_ulonglong);
 	NC_TEST(nc_get_var1_text);
 	NC_TEST(nc_get_var1_uchar);
 	NC_TEST(nc_get_var1_schar);
@@ -180,6 +202,10 @@
 	NC_TEST(nc_get_var1_long);
 	NC_TEST(nc_get_var1_float);
 	NC_TEST(nc_get_var1_double);
+	NC_TEST(nc_get_var1_ushort);
+	NC_TEST(nc_get_var1_uint);
+	NC_TEST(nc_get_var1_longlong);
+	NC_TEST(nc_get_var1_ulonglong);
 	NC_TEST(nc_get_var1);
 	NC_TEST(nc_get_vara_text);
 	NC_TEST(nc_get_vara_uchar);
@@ -189,6 +215,10 @@
 	NC_TEST(nc_get_vara_long);
 	NC_TEST(nc_get_vara_float);
 	NC_TEST(nc_get_vara_double);
+	NC_TEST(nc_get_vara_ushort);
+	NC_TEST(nc_get_vara_uint);
+	NC_TEST(nc_get_vara_longlong);
+	NC_TEST(nc_get_vara_ulonglong);
 	NC_TEST(nc_get_vara);
 	NC_TEST(nc_get_vars_text);
 	NC_TEST(nc_get_vars_uchar);
@@ -198,6 +228,10 @@
 	NC_TEST(nc_get_vars_long);
 	NC_TEST(nc_get_vars_float);
 	NC_TEST(nc_get_vars_double);
+	NC_TEST(nc_get_vars_ushort);
+	NC_TEST(nc_get_vars_uint);
+	NC_TEST(nc_get_vars_longlong);
+	NC_TEST(nc_get_vars_ulonglong);
 	NC_TEST(nc_get_vars);
 	NC_TEST(nc_get_varm_text);
 	NC_TEST(nc_get_varm_uchar);
@@ -207,6 +241,10 @@
 	NC_TEST(nc_get_varm_long);
 	NC_TEST(nc_get_varm_float);
 	NC_TEST(nc_get_varm_double);
+	NC_TEST(nc_get_varm_ushort);
+	NC_TEST(nc_get_varm_uint);
+	NC_TEST(nc_get_varm_longlong);
+	NC_TEST(nc_get_varm_ulonglong);
 	NC_TEST(nc_get_varm);
 	NC_TEST(nc_get_att_text);
 	NC_TEST(nc_get_att_uchar);
@@ -216,6 +254,10 @@
 	NC_TEST(nc_get_att_long);
 	NC_TEST(nc_get_att_float);
 	NC_TEST(nc_get_att_double);
+	NC_TEST(nc_get_att_ushort);
+	NC_TEST(nc_get_att_uint);
+	NC_TEST(nc_get_att_longlong);
+	NC_TEST(nc_get_att_ulonglong);
 	NC_TEST(nc_get_att);
 	NC_TEST(nc_inq_att);
 	NC_TEST(nc_inq_attname);
@@ -240,6 +282,10 @@
 	NC_TEST(nc_put_var_long);
 	NC_TEST(nc_put_var_float);
 	NC_TEST(nc_put_var_double);
+	NC_TEST(nc_put_var_ushort);
+	NC_TEST(nc_put_var_uint);
+	NC_TEST(nc_put_var_longlong);
+	NC_TEST(nc_put_var_ulonglong);
 	NC_TEST(nc_put_var1_text);
 	NC_TEST(nc_put_var1_uchar);
 	NC_TEST(nc_put_var1_schar);
@@ -248,6 +294,10 @@
 	NC_TEST(nc_put_var1_long);
 	NC_TEST(nc_put_var1_float);
 	NC_TEST(nc_put_var1_double);
+	NC_TEST(nc_put_var1_ushort);
+	NC_TEST(nc_put_var1_uint);
+	NC_TEST(nc_put_var1_longlong);
+	NC_TEST(nc_put_var1_ulonglong);
 	NC_TEST(nc_put_var1);
 	NC_TEST(nc_put_vara_text);
 	NC_TEST(nc_put_vara_uchar);
@@ -257,6 +307,10 @@
 	NC_TEST(nc_put_vara_long);
 	NC_TEST(nc_put_vara_float);
 	NC_TEST(nc_put_vara_double);
+	NC_TEST(nc_put_vara_ushort);
+	NC_TEST(nc_put_vara_uint);
+	NC_TEST(nc_put_vara_longlong);
+	NC_TEST(nc_put_vara_ulonglong);
 	NC_TEST(nc_put_vara);
 	NC_TEST(nc_put_vars_text);
 	NC_TEST(nc_put_vars_uchar);
@@ -266,6 +320,10 @@
 	NC_TEST(nc_put_vars_long);
 	NC_TEST(nc_put_vars_float);
 	NC_TEST(nc_put_vars_double);
+	NC_TEST(nc_put_vars_ushort);
+	NC_TEST(nc_put_vars_uint);
+	NC_TEST(nc_put_vars_longlong);
+	NC_TEST(nc_put_vars_ulonglong);
 	NC_TEST(nc_put_vars);
 	NC_TEST(nc_put_varm_text);
 	NC_TEST(nc_put_varm_uchar);
@@ -275,6 +333,10 @@
 	NC_TEST(nc_put_varm_long);
 	NC_TEST(nc_put_varm_float);
 	NC_TEST(nc_put_varm_double);
+	NC_TEST(nc_put_varm_ushort);
+	NC_TEST(nc_put_varm_uint);
+	NC_TEST(nc_put_varm_longlong);
+	NC_TEST(nc_put_varm_ulonglong);
 	NC_TEST(nc_put_varm);
 	NC_TEST(nc_rename_var);
 	NC_TEST(nc_put_att_text);
@@ -284,7 +346,11 @@
 	NC_TEST(nc_put_att_int);
 	NC_TEST(nc_put_att_long);
 	NC_TEST(nc_put_att_float);
-	NC_TEST(nc_put_att_double);
+	NC_TEST(nc_put_att_ulonglong);
+	NC_TEST(nc_put_att_ushort);
+	NC_TEST(nc_put_att_uint);
+	NC_TEST(nc_put_att_longlong);
+	NC_TEST(nc_put_att_ulonglong);
 	NC_TEST(nc_put_att);
 	NC_TEST(nc_copy_att);
 	NC_TEST(nc_rename_att);
@@ -302,6 +368,9 @@
     else
        fprintf(stderr, "*** nc_test SUCCESS!!!\n");
 
+#ifdef TEST_PNETCDF
+    MPI_Finalize();
+#endif
     exit(0);
     return 0;
 }
diff netcdf-c/nc_test/t_nc.c cdf5/nc_test/t_nc.c
--- netcdf-c/nc_test/t_nc.c	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/nc_test/t_nc.c	2014-11-14 14:54:46.040133700 -0700
@@ -9,7 +9,7 @@
    Based on a program to test the nasa look-alike program, so not the
    most appropropriate test. See ../nctest for a complete spec test.
  
-   $Id: t_nc.c,v 1.94 2010/05/27 21:34:13 dmh Exp $ */
+   $Id: t_nc.c 2792 2014-10-27 06:02:59Z wkliao $ */
 
 #define REDEF
 /* #define SYNCDEBUG */
@@ -22,7 +22,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
+#include <mpi.h>
 #include <netcdf.h>
+#include <netcdf_par.h>
 
 #define MAXSHORT	32767
 #define MAXINT		2147483647
@@ -314,7 +316,7 @@
 	return;
 }
 
-static const size_t	indices[][3] = {
+static size_t	indices[][3] = {
 	{0, 1, 3},
 	{0, 3, 0},
 	{1, 2, 3},
@@ -329,19 +331,19 @@
 static const size_t s_edges[] = {NUM_RECS, SIZE_1 - 1};
 static char sentence[NUM_RECS* SIZE_1 -1] =
 	"The red death had long devastated the country.";
-static const short shs[] = {97, 99};
-static const int birthday = 82555;
+static short shs[] = {97, 99};
+static int birthday = 82555;
 #define M_E	2.7182818284590452354
-static const float e = (float) M_E;
-static const double pinot = 3.25;
-static const double zed = 0.0;
+static float e = (float) M_E;
+static double pinot = 3.25;
+static double zed = 0.0;
 
 
 /*ARGSUSED*/
 int
-main(int ac, char *av[])
+main(int argc, char *argv[])
 {
-	int ret;
+	int cmode=NC_CLOBBER, omode, ret;
 	int	 id;
 	char buf[256];
 #ifdef SYNCDEBUG
@@ -355,13 +357,23 @@
 	size_t chunksz = 8192;
 	size_t align = 8192/32;
 
-	ret = nc__create(fname,NC_NOCLOBBER, initialsz, &chunksz, &id);
+#ifdef TEST_PNETCDF
+	MPI_Init(&argc, &argv);
+
+        // cmode |= NC_PNETCDF |NC_64BIT_OFFSET;
+        cmode != NC_PNETCDF |NC_64BIT_DATA;
+	ret = nc_create_par(fname,cmode, MPI_COMM_WORLD, MPI_INFO_NULL, &id);
+#else
+	ret = nc__create(fname,cmode, initialsz, &chunksz, &id);
 	if(ret != NC_NOERR) {
  		/* (void) fprintf(stderr, "trying again\n"); */
-		ret = nc__create(fname,NC_CLOBBER, initialsz, &chunksz, &id);
+		ret = nc__create(fname,cmode, initialsz, &chunksz, &id);
+#endif
 	}
-	if(ret != NC_NOERR) 
+	if(ret != NC_NOERR)  {
+		fprintf(stderr,"Error %s in file %s at line %d\n",nc_strerror(ret),__FILE__,__LINE__);
 		exit(ret);
+        }
 	
 	assert( nc_put_att_text(id, NC_GLOBAL,
 		"TITLE", 12, "another name") == NC_NOERR);
@@ -459,7 +471,13 @@
 /*
  *	read it
  */
-	ret = nc__open(fname,NC_NOWRITE, &chunksz, &id);
+        omode = NC_NOWRITE;
+#ifdef TEST_PNETCDF
+        omode = NC_NOWRITE | NC_PNETCDF;
+#else
+	ret = nc_open_par(fname,omode, MPI_COMM_WORLD, MPI_INFO_NULL, &id);
+	ret = nc__open(fname,omode, &chunksz, &id);
+#endif
 	if(ret != NC_NOERR)
 	{
    	    (void) printf("Could not open %s: %s\n", fname,
@@ -652,5 +670,8 @@
 	ret = nc_close(id);
 	/* (void) printf("re nc_close ret = %d\n", ret); */
 
+#ifdef TEST_PNETCDF
+	MPI_Finalize();
+#endif
 	return 0;
 }
diff netcdf-c/nc_test/test_get.m4 cdf5/nc_test/test_get.m4
--- netcdf-c/nc_test/test_get.m4	2015-03-09 13:48:02.763960300 -0600
+++ cdf5/nc_test/test_get.m4	2014-11-14 14:54:46.051851700 -0700
@@ -7,9 +7,12 @@
 /*********************************************************************
  *   Copyright 1996, UCAR/Unidata
  *   See netcdf/COPYRIGHT file for copying and redistribution conditions.
- *   $Id: test_get.m4,v 1.16 2005/03/08 03:04:19 ed Exp $
+ *   $Id: test_get.m4 2785 2014-10-26 05:21:20Z wkliao $
  *********************************************************************/
 
+// #define TEST_PNETCDF
+#include <mpi.h>
+
 undefine(`index')dnl
 dnl dnl dnl
 dnl
@@ -48,10 +51,14 @@
     int canConvert;     /* Both text or both numeric */
     $1 value;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
 	for (j = 0; j < var_rank[i]; j++)
 	    index[j] = 0;
@@ -122,6 +129,10 @@
 TEST_NC_GET_VAR1(long)
 TEST_NC_GET_VAR1(float)
 TEST_NC_GET_VAR1(double)
+TEST_NC_GET_VAR1(ushort)
+TEST_NC_GET_VAR1(uint)
+TEST_NC_GET_VAR1(longlong)
+TEST_NC_GET_VAR1(ulonglong)
 
 
 dnl TEST_NC_GET_VAR(TYPE)
@@ -144,10 +155,14 @@
     $1 value[MAX_NELS];
     double expect[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
@@ -227,6 +242,10 @@
 TEST_NC_GET_VAR(long)
 TEST_NC_GET_VAR(float)
 TEST_NC_GET_VAR(double)
+TEST_NC_GET_VAR(ushort)
+TEST_NC_GET_VAR(uint)
+TEST_NC_GET_VAR(longlong)
+TEST_NC_GET_VAR(ulonglong)
 
 
 dnl TEST_NC_GET_VARA(TYPE)
@@ -255,10 +274,14 @@
     $1 value[MAX_NELS];
     double expect[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
@@ -407,6 +430,10 @@
 TEST_NC_GET_VARA(long)
 TEST_NC_GET_VARA(float)
 TEST_NC_GET_VARA(double)
+TEST_NC_GET_VARA(ushort)
+TEST_NC_GET_VARA(uint)
+TEST_NC_GET_VARA(longlong)
+TEST_NC_GET_VARA(ulonglong)
 
 
 dnl TEST_NC_GET_VARS(TYPE)
@@ -441,10 +468,14 @@
     $1 value[MAX_NELS];
     double expect[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
@@ -597,6 +628,10 @@
 TEST_NC_GET_VARS(long)
 TEST_NC_GET_VARS(float)
 TEST_NC_GET_VARS(double)
+TEST_NC_GET_VARS(ushort)
+TEST_NC_GET_VARS(uint)
+TEST_NC_GET_VARS(longlong)
+TEST_NC_GET_VARS(ulonglong)
 
 
 dnl TEST_NC_GET_VARM(TYPE)
@@ -632,10 +667,14 @@
     $1 value[MAX_NELS];
     double expect[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
@@ -795,6 +834,10 @@
 TEST_NC_GET_VARM(long)
 TEST_NC_GET_VARM(float)
 TEST_NC_GET_VARM(double)
+TEST_NC_GET_VARM(ushort)
+TEST_NC_GET_VARM(uint)
+TEST_NC_GET_VARM(longlong)
+TEST_NC_GET_VARM(ulonglong)
 
 
 dnl TEST_NC_GET_ATT(TYPE)
@@ -816,11 +859,15 @@
     double expect[MAX_NELS];
     int nok = 0;      /* count of valid comparisons */
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err) 
 	error("nc_open: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         for (j = 0; j < NATTS(i); j++) {
 	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
 	    err = nc_get_att_$1(BAD_ID, i, ATT_NAME(i,j), value);
@@ -897,4 +944,8 @@
 TEST_NC_GET_ATT(long)
 TEST_NC_GET_ATT(float)
 TEST_NC_GET_ATT(double)
+TEST_NC_GET_ATT(ushort)
+TEST_NC_GET_ATT(uint)
+TEST_NC_GET_ATT(longlong)
+TEST_NC_GET_ATT(ulonglong)
 
diff netcdf-c/nc_test/test_put.m4 cdf5/nc_test/test_put.m4
--- netcdf-c/nc_test/test_put.m4	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/nc_test/test_put.m4	2014-11-14 14:54:46.052828200 -0700
@@ -7,9 +7,12 @@
 /*********************************************************************
  *   Copyright 1996, UCAR/Unidata
  *   See netcdf/COPYRIGHT file for copying and redistribution conditions.
- *   $Id: test_put.m4,v 1.25 2005/03/08 03:04:19 ed Exp $
+ *   $Id: test_put.m4 2785 2014-10-26 05:21:20Z wkliao $
  *********************************************************************/
 
+// #define TEST_PNETCDF
+#include <mpi.h>
+
 undefine(`index')dnl
 dnl dnl dnl
 dnl
@@ -61,6 +64,10 @@
 HASH(long)
 HASH(float)
 HASH(double)
+HASH(ushort)
+HASH(uint)
+HASH(longlong)
+HASH(ulonglong)
 
 
 dnl CHECK_VARS(TYPE)
@@ -90,11 +97,15 @@
     int canConvert;     /* Both text or both numeric */
     int nok = 0;      /* count of valid comparisons */
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(filename, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(filename, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
 	if (canConvert) {
 	    err = nc_inq_var(ncid, i, name, &datatype, &ndims, dimids, NULL);
@@ -160,6 +171,10 @@
 CHECK_VARS(long)
 CHECK_VARS(float)
 CHECK_VARS(double)
+CHECK_VARS(ushort)
+CHECK_VARS(uint)
+CHECK_VARS(longlong)
+CHECK_VARS(ulonglong)
 
 
 dnl CHECK_ATTS(TYPE)         numeric only
@@ -187,7 +202,7 @@
     int canConvert;     /* Both text or both numeric */
     int nok = 0;      /* count of valid comparisons */
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         for (j = 0; j < NATTS(i); j++) {
 	    canConvert = (ATT_TYPE(i,j) == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
 	    if (canConvert) {
@@ -250,6 +265,10 @@
 CHECK_ATTS(long)
 CHECK_ATTS(float)
 CHECK_ATTS(double)
+CHECK_ATTS(ushort)
+CHECK_ATTS(uint)
+CHECK_ATTS(longlong)
+CHECK_ATTS(ulonglong)
 
 
 dnl TEST_NC_PUT_VAR1(TYPE)
@@ -267,7 +286,11 @@
     int canConvert;	/* Both text or both numeric */
     $1 value = 5;	/* any value would do - only for error cases */
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -278,7 +301,7 @@
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
         for (j = 0; j < var_rank[i]; j++)
             index[j] = 0;
@@ -345,6 +368,10 @@
 TEST_NC_PUT_VAR1(long)
 TEST_NC_PUT_VAR1(float)
 TEST_NC_PUT_VAR1(double)
+TEST_NC_PUT_VAR1(ushort)
+TEST_NC_PUT_VAR1(uint)
+TEST_NC_PUT_VAR1(longlong)
+TEST_NC_PUT_VAR1(ulonglong)
 
 
 dnl TEST_NC_PUT_VAR(TYPE)
@@ -365,7 +392,11 @@
     int allInExtRange;	/* all values within external range? */
     $1 value[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -376,7 +407,7 @@
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
@@ -427,7 +458,7 @@
     IF (err)
         error("nc_put_var1_text: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         if (var_dimid[i][0] == RECDIM) {  /* only test record variables here */
 	    canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
 	    assert(var_rank[i] <= MAX_RANK);
@@ -483,6 +514,10 @@
 TEST_NC_PUT_VAR(long)
 TEST_NC_PUT_VAR(float)
 TEST_NC_PUT_VAR(double)
+TEST_NC_PUT_VAR(ushort)
+TEST_NC_PUT_VAR(uint)
+TEST_NC_PUT_VAR(longlong)
+TEST_NC_PUT_VAR(ulonglong)
 
 
 dnl TEST_NC_PUT_VARA(TYPE)
@@ -508,7 +543,11 @@
     int allInExtRange;	/* all values within external range? */
     $1 value[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -520,7 +559,7 @@
         error("nc_enddef: %s", nc_strerror(err));
 
     value[0] = 0;
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
@@ -567,6 +606,11 @@
 		start[j] = 0;
 	    }
         }
+
+/* wkliao: this test below of put_vara is redundant and incorrectly uses the
+           value[] set from the previously iteration. There is no such test
+           in put_vars and put_varm.
+
 	err = nc_put_vara_$1(ncid, i, start, edge, value);
 	if (canConvert) {
 	    IF (err) 
@@ -575,6 +619,7 @@
 	    IF (err != NC_ECHAR)
 		error("wrong type: status = %d", err);
         }
+*/
         for (j = 0; j < var_rank[i]; j++) {
             edge[j] = 1;
 	}
@@ -648,6 +693,10 @@
 TEST_NC_PUT_VARA(long)
 TEST_NC_PUT_VARA(float)
 TEST_NC_PUT_VARA(double)
+TEST_NC_PUT_VARA(ushort)
+TEST_NC_PUT_VARA(uint)
+TEST_NC_PUT_VARA(longlong)
+TEST_NC_PUT_VARA(ulonglong)
 
 
 dnl TEST_NC_PUT_VARS(TYPE)
@@ -679,7 +728,11 @@
     int allInExtRange;	/* all values within external range? */
     $1 value[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
 	error("nc_create: %s", nc_strerror(err));
 	return;
@@ -690,7 +743,7 @@
     IF (err)
 	error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
 	assert(var_rank[i] <= MAX_RANK);
 	assert(var_nels[i] <= MAX_NELS);
@@ -821,6 +874,10 @@
 TEST_NC_PUT_VARS(long)
 TEST_NC_PUT_VARS(float)
 TEST_NC_PUT_VARS(double)
+TEST_NC_PUT_VARS(ushort)
+TEST_NC_PUT_VARS(uint)
+TEST_NC_PUT_VARS(longlong)
+TEST_NC_PUT_VARS(ulonglong)
 
 
 dnl TEST_NC_PUT_VARM(TYPE)
@@ -853,7 +910,11 @@
     int allInExtRange;	/* all values within external range? */
     $1 value[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
 	error("nc_create: %s", nc_strerror(err));
 	return;
@@ -864,7 +925,7 @@
     IF (err)
 	error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	canConvert = (var_type[i] == NC_CHAR) == (NCT_ITYPE($1) == NCT_TEXT);
 	assert(var_rank[i] <= MAX_RANK);
 	assert(var_nels[i] <= MAX_NELS);
@@ -1002,6 +1063,10 @@
 TEST_NC_PUT_VARM(long)
 TEST_NC_PUT_VARM(float)
 TEST_NC_PUT_VARM(double)
+TEST_NC_PUT_VARM(ushort)
+TEST_NC_PUT_VARM(uint)
+TEST_NC_PUT_VARM(longlong)
+TEST_NC_PUT_VARM(ulonglong)
 
 
 void
@@ -1014,7 +1079,11 @@
     int err;
     text value[MAX_NELS];
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1030,7 +1099,7 @@
 	IF (err != NC_EBADNAME)
 	   error("should be NC_EBADNAME: status = %d", err);
     }
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         for (j = 0; j < NATTS(i); j++) {
             if (ATT_TYPE(i,j) == NC_CHAR) {
 		assert(ATT_LEN(i,j) <= MAX_NELS);
@@ -1080,7 +1149,11 @@
     $1 value[MAX_NELS];
     int allInExtRange;  /* all values within external range? */
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1088,7 +1161,7 @@
     def_dims(ncid);
     def_vars(ncid);
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         for (j = 0; j < NATTS(i); j++) {
             if (!(ATT_TYPE(i,j) == NC_CHAR)) {
 		assert(ATT_LEN(i,j) <= MAX_NELS);
@@ -1140,4 +1213,8 @@
 TEST_NC_PUT_ATT(long)
 TEST_NC_PUT_ATT(float)
 TEST_NC_PUT_ATT(double)
+TEST_NC_PUT_ATT(ushort)
+TEST_NC_PUT_ATT(uint)
+TEST_NC_PUT_ATT(longlong)
+TEST_NC_PUT_ATT(ulonglong)
 
diff netcdf-c/nc_test/test_read.c cdf5/nc_test/test_read.c
--- netcdf-c/nc_test/test_read.c	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/nc_test/test_read.c	2014-11-14 14:54:46.053804700 -0700
@@ -1,7 +1,7 @@
 /*********************************************************************
  *   Copyright 1996, UCAR/Unidata
  *   See netcdf/COPYRIGHT file for copying and redistribution conditions.
- *   $Id: test_read.c,v 1.32 2008/04/04 20:23:51 dmh Exp $
+ *   $Id: test_read.c 2792 2014-10-27 06:02:59Z wkliao $
  *********************************************************************/
 
 #include "tests.h"
@@ -58,14 +58,14 @@
     /* Try on a bad error status */
     /* Dmh: allow trailing extra info */
     message = nc_strerror(-666);/* should fail */
-    IF (strcmp(message, "Unknown Error") != 0)
+    IF (strncmp(message, "Unknown Error", strlen("Unknown Error")) != 0)
 	error("nc_strerror on bad error status returned: %s", message);
 
     /* Try on each legitimate error status */
     /* Dmh: allow trailing extra info */
     for (i=0; i<LEN_OF(ncerrs); i++) {
 	const char *message = nc_strerror(ncerrs[i].status);
-	IF (strcmp(message, ncerrs[i].msg) != 0)
+	IF (strncmp(message, ncerrs[i].msg, strlen(ncerrs[i].msg)) != 0)
 	    error("nc_strerror(%d) should return `%s', not `%s'",
 		  ncerrs[i].status, ncerrs[i].msg, message);
     }
@@ -92,7 +92,11 @@
     int ncid2;
     
     /* Try to open a nonexistent file */
+#ifdef TEST_PNETCDF
+    err = nc_open_par("tooth-fairy.nc", NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open("tooth-fairy.nc", NC_NOWRITE, &ncid);/* should fail */
+#endif
     IF (err == NC_NOERR)
 	error("nc_open of nonexistent file should have failed");
 #ifndef USE_PARALLEL
@@ -107,14 +111,22 @@
     /* 	error("nc_open of non-netCDF file: status = %d", err); */
 
     /* Open a netCDF file in read-only mode, check that write fails */
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     err = nc_redef(ncid);	/* should fail */
     IF (err != NC_EPERM)
 	error("nc_redef of read-only file should fail");
     /* Opened OK, see if can open again and get a different netCDF ID */
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid2);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid2);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     else {
@@ -123,12 +135,20 @@
     IF (ncid2 == ncid)
 	error("netCDF IDs for first and second nc_open calls should differ");
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid2);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid2);
+#endif
     IF (err) 
        error("nc_create: %s", nc_strerror(err));
     else 
        (void) nc_close(ncid2);
+#ifdef TEST_PNETCDF
+    err = nc_open_par(scratch, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid2);
+#else
     err = nc_open(scratch, NC_WRITE, &ncid2);
+#endif
     IF (err) 
        error("nc_open: %s", nc_strerror(err));
     else 
@@ -152,8 +172,12 @@
 void
 test_nc_close(void)
 {
-    int ncid;
-    int err = nc_open(testfile, NC_NOWRITE, &ncid);
+    int ncid, err;
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
+    err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
 
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
@@ -172,14 +196,22 @@
 	error("nc_close with bad netCDF ID returned wrong error (%d)", err);
 
     /* Close in data mode */
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     err = nc_close(ncid);
     IF (err)
 	error("nc_close in data mode failed: %s", nc_strerror(err));
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) 
        error("nc_create: %s", nc_strerror(err));
     err = nc_close(ncid);
@@ -208,7 +240,12 @@
     int nvars;			/* number of variables */
     int ngatts;			/* number of global attributes */
     int recdim;			/* id of unlimited dimension */
-    int err = nc_open(testfile, NC_NOWRITE, &ncid);
+    int err;
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
+    err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
 
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
@@ -223,9 +260,9 @@
 	error("nc_inq: %s", nc_strerror(err));
     else IF (ndims != NDIMS)
 	error("nc_inq: wrong number of dimensions returned, %d", ndims);
-    else IF (nvars != NVARS)
+    else IF (nvars != numVars)
 	error("nc_inq: wrong number of variables returned, %d", nvars);
-    else IF (ngatts != NGATTS)
+    else IF (ngatts != numGatts)
 	error("nc_inq: wrong number of global atts returned, %d", ngatts);
     else IF (recdim != RECDIM)
 	error("nc_inq: wrong record dimension ID returned, %d", recdim);
@@ -236,26 +273,30 @@
 	error("nc_inq for no info failed: %s", nc_strerror(err));
 
     /* Inguire for subsets of info */
-    ngatts = NGATTS - 1;	/* wipe out previous correct value */
+    ngatts = numGatts - 1;	/* wipe out previous correct value */
     err = nc_inq(ncid, 0, 0, &ngatts, 0);
     IF (err)
 	error("nc_inq for one item failed: %s", nc_strerror(err));
-    else IF (ngatts != NGATTS)
+    else IF (ngatts != numGatts)
 	error("nc_inq subset: wrong number of global atts returned, %d", ngatts);
     ndims = NDIMS - 1;
-    nvars = NVARS - 1;
+    nvars = numVars - 1;
     err = nc_inq(ncid, &ndims, &nvars, 0, 0);
     IF (err)
 	error("nc_inq for two items failed: %s", nc_strerror(err));
     else IF (ndims != NDIMS)
 	error("nc_inq subset: wrong number of dimensions returned, %d", ndims);
-    else IF (nvars != NVARS)
+    else IF (nvars != numVars)
 	error("nc_inq subset: wrong number of variables returned, %d", nvars);
 
     {		/* tests using netCDF scratch file */
 	int ncid2;		/* for scratch netCDF dataset */
 
+#ifdef TEST_PNETCDF
+        err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid2);
+#else
         err = nc_create(scratch, NC_NOCLOBBER, &ncid2);
+#endif
         IF (err) {
             error("nc_create: %s", nc_strerror(err));
 	} else {		/* add dim, var, gatt, check inq */
@@ -347,13 +388,17 @@
     err = nc_inq_natts(BAD_ID, &ngatts);
     IF (err != NC_EBADID)
 	error("bad ncid: status = %d", err);
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     err = nc_inq_natts(ncid, &ngatts);
     IF (err)
 	error("nc_inq_natts: %s", nc_strerror(err));
-    else IF (ngatts != NGATTS)
+    else IF (ngatts != numGatts)
 	error("nc_inq_natts: wrong number of global atts returned, %d", ngatts);
     err = nc_close(ncid);
     IF (err)
@@ -371,7 +416,11 @@
     err = nc_inq_ndims(BAD_ID, &ndims);
     IF (err != NC_EBADID)
 	error("bad ncid: status = %d", err);
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     err = nc_inq_ndims(ncid, &ndims);
@@ -395,13 +444,17 @@
     err = nc_inq_nvars(BAD_ID, &nvars);
     IF (err != NC_EBADID)
 	error("bad ncid: status = %d", err);
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     err = nc_inq_nvars(ncid, &nvars);
     IF (err)
 	error("nc_inq_nvars: %s", nc_strerror(err));
-    else IF (nvars != NVARS)
+    else IF (nvars != numVars)
 	error("nc_inq_nvars: wrong number returned, %d", nvars);
     err = nc_close(ncid);
     IF (err)
@@ -419,7 +472,11 @@
     err = nc_inq_unlimdim(BAD_ID, &unlimdim);
     IF (err != NC_EBADID)
 	error("bad ncid: status = %d", err);
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     err = nc_inq_unlimdim(ncid, &unlimdim);
@@ -441,7 +498,11 @@
     int i;
     int err;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     err = nc_inq_dimid(ncid, "noSuch", &dimid);
@@ -472,7 +533,11 @@
     char name[NC_MAX_NAME];
     size_t length;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     for (i = 0; i < NDIMS; i++) {
@@ -517,7 +582,11 @@
     int err;
     size_t length;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     for (i = 0; i < NDIMS; i++) {
@@ -547,7 +616,11 @@
     int err;
     char name[NC_MAX_NAME];
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
     for (i = 0; i < NDIMS; i++) {
@@ -577,7 +650,11 @@
     int i;
     int err;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
 
@@ -585,7 +662,7 @@
     IF (err != NC_ENOTVAR)
 	error("bad ncid: status = %d", err);
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	err = nc_inq_varid(BAD_ID, var_name[i], &varid);
         IF (err != NC_EBADID)
 	    error("bad ncid: status = %d", err);
@@ -614,10 +691,14 @@
     int dimids[MAX_RANK];
     int natts;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	err = nc_inq_var(BAD_ID, i, name, &datatype, &ndims, dimids, &natts);
         IF (err != NC_EBADID)
 	    error("bad ncid: status = %d", err);
@@ -680,10 +761,14 @@
     int err;
     int dimids[MAX_RANK];
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	err = nc_inq_vardimid(BAD_ID, i, dimids);
         IF (err != NC_EBADID)
 	    error("bad ncid: status = %d", err);
@@ -710,10 +795,14 @@
     int err;
     char name[NC_MAX_NAME];
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	err = nc_inq_varname(BAD_ID, i, name);
         IF (err != NC_EBADID)
 	    error("bad ncid: status = %d", err);
@@ -740,10 +829,14 @@
     int err;
     int natts;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	err = nc_inq_varnatts(BAD_ID, i, &natts);
         IF (err != NC_EBADID)
 	    error("bad ncid: status = %d", err);
@@ -770,10 +863,14 @@
     int err;
     int ndims;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	err = nc_inq_varndims(BAD_ID, i, &ndims);
         IF (err != NC_EBADID)
 	    error("bad ncid: status = %d", err);
@@ -800,10 +897,14 @@
     int err;
     nc_type datatype;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	err = nc_inq_vartype(BAD_ID, i, &datatype);
         IF (err != NC_EBADID)
 	    error("bad ncid: status = %d", err);
@@ -838,10 +939,14 @@
     double buf[1];		/* (void *) buffer */
     double value;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	for (j = 0; j < var_rank[i]; j++)
 	    index[j] = 0;
         err = nc_get_var1(BAD_ID, i, index, buf);
@@ -913,10 +1018,14 @@
     double expect;
     double got;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
         for (j = 0; j < var_rank[i]; j++) {
@@ -1040,10 +1149,14 @@
     double expect;
     double got;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
         for (j = 0; j < var_rank[i]; j++) {
@@ -1207,10 +1320,14 @@
     double expect;
     double got;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
 	error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
         for (j = 0; j < var_rank[i]; j++) {
@@ -1220,7 +1337,8 @@
         }
         if (var_rank[i] > 0) {
             j = var_rank[i] - 1;
-            imap[j] = nctypelen(var_type[i]);
+            // imap[j] = nctypelen(var_type[i]); /* in bytes */
+            imap[j] = 1; /* in numbers of elements */
             for (; j > 0; j--)
                 imap[j-1] = imap[j] * var_shape[i][j];
         }
@@ -1346,11 +1464,15 @@
     double got;
     int nok = 0;      /* count of valid comparisons */
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err) 
 	error("nc_open: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         for (j = 0; j < NATTS(i); j++) {
 	    err = nc_get_att(BAD_ID, i, ATT_NAME(i,j), buf);
 	    IF (err != NC_EBADID) 
@@ -1411,11 +1533,15 @@
     nc_type t;
     size_t n;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err) 
 	error("nc_open: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         for (j = 0; j < NATTS(i); j++) {
 	    err = nc_inq_att(BAD_ID, i, ATT_NAME(i,j), &t, &n);
 	    IF (err != NC_EBADID) 
@@ -1453,11 +1579,15 @@
     int err;
     size_t len;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	err = nc_inq_attlen(ncid, i, "noSuch", &len);
 	IF (err != NC_ENOTATT)
 	    error("Bad attribute name: status = %d", err);
@@ -1493,11 +1623,15 @@
     int err;
     nc_type datatype;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	err = nc_inq_atttype(ncid, i, "noSuch", &datatype);
 	IF (err != NC_ENOTATT)
 	    error("Bad attribute name: status = %d", err);
@@ -1533,11 +1667,15 @@
     int err;
     char name[NC_MAX_NAME];
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	err = nc_inq_attname(ncid, i, BAD_ATTNUM, name);
 	IF (err != NC_ENOTATT)
 	    error("Bad attribute number: status = %d", err);
@@ -1576,11 +1714,15 @@
     int err;
     int attnum;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	err = nc_inq_attid(ncid, i, "noSuch", &attnum);
 	IF (err != NC_ENOTATT)
 	    error("Bad attribute name: status = %d", err);
diff netcdf-c/nc_test/test_write.c cdf5/nc_test/test_write.c
--- netcdf-c/nc_test/test_write.c	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/nc_test/test_write.c	2014-11-14 14:54:46.054781200 -0700
@@ -1,7 +1,7 @@
 /*********************************************************************
  *   Copyright 1996, UCAR/Unidata
  *   See netcdf/COPYRIGHT file for copying and redistribution conditions.
- *   $Id: test_write.c,v 1.33 2006/10/31 16:23:13 ed Exp $
+ *   $Id: test_write.c 2796 2014-10-28 03:40:29Z wkliao $
  *********************************************************************/
 
 #include "tests.h"
@@ -28,13 +28,22 @@
     int recdim;                 /* id of unlimited dimension */
 
     for (clobber = 0; clobber < 2; clobber++) {
-	err = nc_create(scratch, clobber ? NC_CLOBBER : NC_NOCLOBBER, &ncid);
+        int cmode = clobber ? NC_CLOBBER : NC_NOCLOBBER;
+#ifdef TEST_PNETCDF
+        err = nc_create_par(scratch, cmode|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
+	err = nc_create(scratch, cmode, &ncid);
+#endif
 	IF (err)
 	    error("nc_create: %s", nc_strerror(err));
 	err = nc_close(ncid);
 	IF (err)
 	    error("nc_close: %s", nc_strerror(err));
+#ifdef TEST_PNETCDF
+        err = nc_open_par(scratch, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
 	err = nc_open(scratch, NC_NOWRITE, &ncid);
+#endif
 	IF (err)
 	    error("nc_open: %s", nc_strerror(err));
 	err = nc_inq(ncid, &ndims, &nvars, &ngatts, &recdim);
@@ -53,7 +62,11 @@
 	    error("nc_close: %s", nc_strerror(err));
     }
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err != NC_EEXIST)
 	error("attempt to overwrite file: status = %d", err);
     err = remove(scratch);
@@ -106,7 +119,11 @@
 	error("bad ncid: status = %d", err);
 
 	/* read-only tests */
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
     err = nc_redef(ncid);
@@ -120,7 +137,11 @@
 	error("nc_close: %s", nc_strerror(err));
 
 	/* tests using scratch file */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc__create(scratch, NC_NOCLOBBER, 0, &sizehint, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -195,7 +216,11 @@
     /* check scratch file written as expected */
     check_file(scratch);  /* checks all except "abc" stuff added above */
 
+#ifdef TEST_PNETCDF
+    IF ((err = nc_open_par(scratch, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)))
+#else
     IF ((err = nc_open(scratch, NC_NOWRITE, &ncid)))
+#endif
         error("nc_open: %s", nc_strerror(err));
     IF ((err = nc_inq_dim(ncid, dimid, name, &length))) 
 	error("nc_inq_dim: %s", nc_strerror(err));
@@ -211,7 +236,11 @@
         error("nc_close: %s", nc_strerror(err));
 
     /* open scratch file for writing, add another dim, var, att, then check */
+#ifdef TEST_PNETCDF
+    IF ((err = nc_open_par(scratch, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)))
+#else
     IF ((err = nc_open(scratch, NC_WRITE, &ncid)))
+#endif
         error("nc_open: %s", nc_strerror(err));
     IF ((err = nc_redef(ncid)))
         error("nc_redef: %s", nc_strerror(err));
@@ -234,7 +263,11 @@
     /* check scratch file written as expected */
     check_file(scratch);
 
+#ifdef TEST_PNETCDF
+        err = nc_open_par(scratch, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(scratch, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
     err = nc_inq_dim(ncid, dimid, name, &length);
@@ -294,7 +327,11 @@
         error("bad ncid: status = %d", err);
 
         /* create scratch file & try nc_sync in define mode */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncidw);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncidw);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
 	return;
@@ -316,7 +353,11 @@
         error("nc_sync of ncidw failed: %s", nc_strerror(err));
 
         /* open another handle, nc_sync, read (check) */
+#ifdef TEST_PNETCDF
+        err = nc_open_par(scratch, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncidr);
+#else
     err = nc_open(scratch, NC_NOWRITE, &ncidr);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
     err = nc_sync(ncidr);
@@ -362,7 +403,11 @@
         error("bad ncid: status = %d", err);
 
         /* create scratch file & try nc_abort in define mode */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -386,7 +431,11 @@
 	 * define new dims, vars, atts
 	 * try nc_abort: should restore previous state (no dims, vars, atts)
 	 */ 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -406,7 +455,11 @@
     err = nc_close(ncid);	/* should already be closed */
     IF (err != NC_EBADID)
         error("bad ncid: status = %d", err);
+#ifdef TEST_PNETCDF
+        err = nc_open_par(scratch, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(scratch, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
     err = nc_inq (ncid, &ndims, &nvars, &ngatts, NULL);
@@ -423,7 +476,11 @@
         error("nc_close: %s", nc_strerror(err));
 
         /* try nc_abort in data mode - should just close */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -473,7 +530,11 @@
         error("bad ncid: status = %d", err);
 
         /* data mode test */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -567,7 +628,11 @@
         error("bad ncid: status = %d", err);
 
         /* main tests */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -629,7 +694,11 @@
         error("bad ncid: status = %d", err);
 
         /* scalar tests */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -672,13 +741,17 @@
         error("remove of %s failed", scratch);
 
         /* general tests using global vars */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
     }
     def_dims(ncid);
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         err = nc_def_var(ncid, var_name[i], var_type[i], var_rank[i],
             var_dimid[i], &varid);
         IF (err) 
@@ -716,7 +789,11 @@
     double value;
     double buf[1];		/* (void *) buffer */
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -727,7 +804,7 @@
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         for (j = 0; j < var_rank[i]; j++)
             index[j] = 0;
         err = nc_put_var1(BAD_ID, i, index, buf);
@@ -801,7 +878,11 @@
     char *p;			/* (void *) pointer */
     double value;
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -812,7 +893,7 @@
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
         for (j = 0; j < var_rank[i]; j++) {
@@ -928,7 +1009,11 @@
     char *p;			/* (void *) pointer */
     double value;
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -939,7 +1024,7 @@
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
         for (j = 0; j < var_rank[i]; j++) {
@@ -1083,7 +1168,11 @@
     char *p;			/* (void *) pointer */
     double value;
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1094,7 +1183,7 @@
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         assert(var_rank[i] <= MAX_RANK);
         assert(var_nels[i] <= MAX_NELS);
         for (j = 0; j < var_rank[i]; j++) {
@@ -1104,7 +1193,8 @@
         }
 	if (var_rank[i] > 0) {
 	    j = var_rank[i] - 1; 
-	    imap[j] = nctypelen(var_type[i]);
+            // imap[j] = nctypelen(var_type[i]); /* in bytes */
+            imap[j] = 1; /* in numbers of elements */
 	    for (; j > 0; j--)
 		imap[j-1] = imap[j] * var_shape[i][j];
 	}
@@ -1228,7 +1318,11 @@
     int i;
     char name[NC_MAX_NAME];
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1240,11 +1334,11 @@
     def_vars(ncid);
 
 	/* Prefix "new_" to each name */
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         err = nc_rename_var(BAD_ID, i, "newName");
         IF (err != NC_EBADID)
             error("bad ncid: status = %d", err);
-        err = nc_rename_var(ncid, i, var_name[NVARS-1]);
+        err = nc_rename_var(ncid, i, var_name[numVars-1]);
         IF (err != NC_ENAMEINUSE)
             error("duplicate name: status = %d", err);
 	(void) strcpy(name, "new_");
@@ -1264,7 +1358,7 @@
     err = nc_enddef(ncid);
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	(void) strcpy(name, "even_longer_");
 	(void) strcat(name, var_name[i]);
         err = nc_rename_var(ncid, i, name);
@@ -1309,7 +1403,11 @@
     size_t length;		/* of att */
     double value;
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1317,7 +1415,7 @@
     def_dims(ncid);
     def_vars(ncid);
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	varid = VARID(i);
         for (j = 0; j < NATTS(i); j++) {
 	    name = ATT_NAME(i,j);
@@ -1389,10 +1487,18 @@
     size_t length;              /* of att */
     char  value;
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid_in);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid_in);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid_out);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid_out);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1400,7 +1506,7 @@
     def_dims(ncid_out);
     def_vars(ncid_out);
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         varid = VARID(i);
         for (j = 0; j < NATTS(i); j++) {
             name = ATT_NAME(i,j);
@@ -1436,7 +1542,11 @@
     err = nc_close(ncid_out);
     IF (err)
         error("nc_close: %s", nc_strerror(err));
+#ifdef TEST_PNETCDF
+    err = nc_open_par(scratch, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid_out);
+#else
     err = nc_open(scratch, NC_WRITE, &ncid_out);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
     check_atts(ncid_out);
@@ -1463,7 +1573,7 @@
     err = nc_enddef(ncid_out);
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	if (NATTS(i) > 0 && ATT_LEN(i,j) > 0) {
 	    err = nc_rename_att(ncid_out, i, att_name[i][0], "a");
 	    IF (err)
@@ -1478,10 +1588,14 @@
         error("nc_close: %s", nc_strerror(err));
 
 	/* Reopen & check */
+#ifdef TEST_PNETCDF
+    err = nc_open_par(scratch, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid_out);
+#else
     err = nc_open(scratch, NC_WRITE, &ncid_out);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	if (NATTS(i) > 0 && ATT_LEN(i,j) > 0) {
 	    err = nc_inq_att(ncid_out, i, "a", &datatype, &length);
 	    IF (err)
@@ -1539,7 +1653,11 @@
     double value[MAX_NELS];
     double expect;
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1551,7 +1669,7 @@
     def_vars(ncid);
     put_atts(ncid);
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         varid = VARID(i);
         for (j = 0; j < NATTS(i); j++) {
 	    attname = ATT_NAME(i,j);
@@ -1578,11 +1696,15 @@
     err = nc_close(ncid);
     IF (err)
         error("nc_close: %s", nc_strerror(err));
+#ifdef TEST_PNETCDF
+    err = nc_open_par(scratch, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(scratch, NC_WRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         varid = VARID(i);
         for (j = 0; j < NATTS(i); j++) {
 	    attname = ATT_NAME(i,j);
@@ -1636,7 +1758,7 @@
 	/* Now in data mode */
 	/* Try making names even longer. Then restore original names */
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
         varid = VARID(i);
         for (j = 0; j < NATTS(i); j++) {
 	    attname = ATT_NAME(i,j);
@@ -1689,7 +1811,11 @@
     int varid;
     char *name;                 /* of att */
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1701,7 +1827,7 @@
     def_vars(ncid);
     put_atts(ncid);
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	varid = VARID(i);
 	numatts = NATTS(i);
         for (j = 0; j < numatts; j++) {
@@ -1737,7 +1863,11 @@
     err = nc_close(ncid);
     IF (err)
         error("nc_close: %s", nc_strerror(err));
+#ifdef TEST_PNETCDF
+    err = nc_open_par(scratch, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(scratch, NC_WRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
     err = nc_inq_natts(ncid, &natts);
@@ -1745,7 +1875,7 @@
 	error("nc_inq_natts: %s", nc_strerror(err));
     IF (natts != 0)
 	error("natts: expected %d, got %d", 0, natts);
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	varid = VARID(i);
 	err = nc_inq_varnatts(ncid, varid, &natts);
 	IF (err)
@@ -1763,7 +1893,7 @@
     IF (err)
         error("nc_enddef: %s", nc_strerror(err));
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	varid = VARID(i);
 	numatts = NATTS(i);
         for (j = 0; j < numatts; j++) {
@@ -1814,7 +1944,11 @@
 	error("bad ncid: status = %d", err);
 
 	/* try in read-only mode */
+#ifdef TEST_PNETCDF
+    err = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(testfile, NC_NOWRITE, &ncid);
+#endif
     IF (err)
         error("nc_open: %s", nc_strerror(err));
     err = nc_set_fill(ncid, NC_NOFILL, &old_fillmode);
@@ -1825,7 +1959,11 @@
         error("nc_close: %s", nc_strerror(err));
 
 	/* create scratch */
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_NOCLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_NOCLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1873,7 +2011,7 @@
         error("nc_put_var1_text: %s", nc_strerror(err));
 
 	/* get all variables & check all values equal default fill */
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	switch (var_type[i]) {
 	    case NC_CHAR:   fill = NC_FILL_CHAR; break;
 	    case NC_BYTE:   fill = NC_FILL_BYTE; break;
@@ -1909,7 +2047,11 @@
     err = nc_close(ncid);
     IF (err)
         error("nc_close: %s", nc_strerror(err));
+#ifdef TEST_PNETCDF
+    err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(scratch, NC_CLOBBER, &ncid);
+#endif
     IF (err) {
         error("nc_create: %s", nc_strerror(err));
         return;
@@ -1919,7 +2061,7 @@
 
 	/* set _FillValue = 42 for all vars */
     text = fill = 42;
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	if (var_type[i] == NC_CHAR) {
 	    err = nc_put_att_text(ncid, i, "_FillValue", 1, &text);
 	    IF (err)
@@ -1941,7 +2083,7 @@
         error("nc_put_var1_text: %s", nc_strerror(err));
 
 	/* get all variables & check all values equal 42 */
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	for (j = 0; j < var_nels[i]; j++) {
             err = toMixedBase(j, var_rank[i], var_shape[i], index);
             IF (err)
@@ -1973,7 +2115,8 @@
 }
 
 /* This function gets the version of a netCDF file, 1 is for netCDF
-   classic, 2 for 64-bit offset format, (someday) 3 for HDF5 format.
+   classic, 2 for 64-bit offset format, (someday) 3 for HDF5 format,
+   5 for 64-bit data format (CDF-5).
 */
 #define MAGIC_NUM_LEN 4
 static
@@ -1997,7 +2140,8 @@
    if (strncmp(magic, "CDF", MAGIC_NUM_LEN-1)==0)
    {
       if (magic[MAGIC_NUM_LEN-1] == NC_FORMAT_CLASSIC || 
-	  magic[MAGIC_NUM_LEN-1] == NC_FORMAT_64BIT)
+	  magic[MAGIC_NUM_LEN-1] == NC_FORMAT_CDF2 ||
+	  magic[MAGIC_NUM_LEN-1] == NC_FORMAT_CDF5)
 	 *version = magic[MAGIC_NUM_LEN-1];
       else
 	 return NC_ENOTNC;
@@ -2033,16 +2177,22 @@
 	error("bad default format: status = %d", err);
 
     /* NULL old_formatp */
-    err = nc_set_default_format(NC_FORMAT_64BIT, NULL);
+    err = nc_set_default_format(NC_FORMAT_CDF2, NULL);
     IF (err)
 	error("null old_fortmatp: status = %d", err);
 
     /* Cycle through available formats. */
-    for(i=1; i<3; i++)
+    for(i=1; i<5; i++)
     {
+       if (i == 3 || i == 4) continue; /* test classic formats only */
+
        if ((err = nc_set_default_format(i, NULL)))
 	  error("setting classic format: status = %d", err);
+#ifdef TEST_PNETCDF
+       if ((err = nc_create_par(scratch, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)))
+#else
        if ((err=nc_create(scratch, NC_CLOBBER, &ncid)))
+#endif
 	  error("bad nc_create: status = %d", err);
        if ((err=nc_put_att_text(ncid, NC_GLOBAL, "testatt", 
 				sizeof("blah"), "blah")))
@@ -2050,9 +2200,16 @@
        if ((err=nc_close(ncid)))
 	  error("bad close: status = %d", err);
        if ((err = nc_get_file_version(scratch, &version)))
-	  error("bad file version = %d", err);
-       if (version != i)
-	  error("bad file version = %d", err);
+	  error("bad file version = %d", version);
+       if (version != i) {
+          if (i == 4) {
+              if (version == 3) continue;
+	      printf("expect version 3 but got %d (file=%s)",version,scratch);
+              continue;
+          }
+	  printf("expect version %d but got %d (file=%s)",i,version,scratch);
+	  error("bad file version = %d", version);
+	}
     }
 
     /* Remove the left-over file. */
diff netcdf-c/nc_test/tests.h cdf5/nc_test/tests.h
--- netcdf-c/nc_test/tests.h	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/nc_test/tests.h	2014-11-14 14:54:46.055757700 -0700
@@ -1,7 +1,7 @@
 /*********************************************************************
  *   Copyright 1996, UCAR/Unidata
  *   See netcdf/COPYRIGHT file for copying and redistribution conditions.
- *   $Id: tests.h,v 1.39 2008/09/21 13:11:23 ed Exp $
+ *   $Id: tests.h 2785 2014-10-26 05:21:20Z wkliao $
  *********************************************************************/
 
 #include <config.h>
@@ -13,7 +13,9 @@
 #include <float.h>
 #define NO_NETCDF_2 1
 #include "netcdf.h"
+#include "netcdf_par.h"
 #include "error.h"
+#include <mpi.h>
 
 #if defined(_CRAY) && !defined(_CRAYIEEE) && !defined(__crayx1)
 #define CRAYFLOAT 1 /* CRAY Floating point */
@@ -51,6 +53,40 @@
 #endif
 #define X_DOUBLE_MIN	(-X_DOUBLE_MAX)
 
+#define X_SCHAR_MAX     X_CHAR_MAX
+#define X_SCHAR_MIN     X_CHAR_MIN
+#define X_UCHAR_MAX     UCHAR_MAX
+#define X_UCHAR_MIN     0
+#define X_UBYTE_MAX     X_UCHAR_MAX
+#define X_UBYTE_MIN     X_UCHAR_MIN
+#define X_USHORT_MAX    USHRT_MAX
+#define X_USHORT_MIN    0
+#define X_UINT_MAX      UINT_MAX
+#define X_UINT_MIN      0
+
+#ifndef LLONG_MAX
+#define LLONG_MAX  0x7fffffffffffffffLL
+#endif
+#ifndef LLONG_MIN
+#define LLONG_MIN (-0x7fffffffffffffffLL-1)
+#endif
+#ifndef ULLONG_MAX
+#define ULLONG_MAX  0xffffffffffffffffULL
+#endif
+
+#ifndef X_INT64_MAX
+#define X_INT64_MAX    LLONG_MAX
+#endif
+#ifndef X_INT64_MIN
+#define X_INT64_MIN    LLONG_MIN
+#endif
+#ifndef X_UINT64_MAX
+#define X_UINT64_MAX  ULLONG_MAX
+#endif
+#ifndef X_UINT64_MIN
+#define X_UINT64_MIN  ULLONG_MIN
+#endif
+
 
 #if _SX /* NEC SUPER UX */
 #if _INT64
@@ -86,9 +122,9 @@
 
     /* Parameters of test data */
 
-#define NTYPES 6
+#define NTYPES 11
 #define NDIMS 5
-#define NVARS 136
+#define NVARS 166
 #define NRECS 2
 #define NGATTS NTYPES
 #define RECDIM 0
@@ -97,6 +133,10 @@
 #define MAX_DIM_LEN 4
 #define MAX_NATTS 3
 
+extern int numGatts;  /* number of global attributes */
+extern int numVars;   /* number of variables */
+extern int numTypes;  /* number of netCDF data types to test */
+
 
     /* Limits of internal types */
 
@@ -108,6 +148,13 @@
 #define long_min LONG_MIN
 #define float_min (-FLT_MAX)
 #define double_min (-DBL_MAX)
+#define ushort_min 0
+#define uint_min 0
+#define ulong_min 0
+#define int64_min LLONG_MIN
+#define longlong_min int64_min
+#define uint64_min 0
+#define ulonglong_min uint64_min
 
 #define text_max CHAR_MAX
 #define uchar_max UCHAR_MAX
@@ -117,6 +164,13 @@
 #define long_max LONG_MAX
 #define float_max FLT_MAX
 #define double_max DBL_MAX
+#define ushort_max USHRT_MAX
+#define uint_max UINT_MAX
+#define ulong_max ULONG_MAX
+#define int64_max LLONG_MAX
+#define longlong_max int64_max
+#define uint64_max ULLONG_MAX
+#define ulonglong_max uint64_max
 
 
 
@@ -140,9 +194,29 @@
 
     /* Non-standard internal types */
 
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+
 typedef char text;
 typedef signed char schar;
 
+#ifndef HAVE_USHORT
+typedef unsigned short int  ushort;
+#endif
+
+#ifndef HAVE_UINT
+typedef unsigned       int  uint;
+#endif
+
+#ifndef HAVE_INT64
+typedef          long long  int64;
+#endif
+
+#ifndef HAVE_UINT64
+typedef unsigned long long  uint64;
+#endif
+
 
     /* Global variables - filenames */
 
@@ -179,7 +253,7 @@
     /* varid is -1 for NC_GLOBAL so can do global atts in same loop */
 
 #define VARID(varid)      (varid < 0 ? NC_GLOBAL : varid)
-#define NATTS(varid)      (varid < 0 ? NGATTS : var_natts[varid])
+#define NATTS(varid)      (varid < 0 ? numGatts : var_natts[varid])
 #define ATT_NAME(varid,j) (varid < 0 ? gatt_name[j] : att_name[varid][j])
 #define ATT_TYPE(varid,j) (varid < 0 ? gatt_type[j] : att_type[varid][j])
 #define ATT_LEN(varid,j)  (varid < 0 ? gatt_len[j] : att_len[varid][j])
@@ -218,6 +292,10 @@
 extern void test_nc_get_var_text(void);
 extern void test_nc_get_var_uchar(void);
 extern void test_nc_get_var(void);
+extern void test_nc_get_var_ushort(void);
+extern void test_nc_get_var_uint(void);
+extern void test_nc_get_var_longlong(void);
+extern void test_nc_get_var_ulonglong(void);
 
 extern void test_nc_get_var1_double(void);
 extern void test_nc_get_var1_float(void);
@@ -228,6 +306,10 @@
 extern void test_nc_get_var1_text(void);
 extern void test_nc_get_var1_uchar(void);
 extern void test_nc_get_var1(void);
+extern void test_nc_get_var1_ushort(void);
+extern void test_nc_get_var1_uint(void);
+extern void test_nc_get_var1_longlong(void);
+extern void test_nc_get_var1_ulonglong(void);
 
 extern void test_nc_get_vara_double(void);
 extern void test_nc_get_vara_float(void);
@@ -238,6 +320,10 @@
 extern void test_nc_get_vara_text(void);
 extern void test_nc_get_vara_uchar(void);
 extern void test_nc_get_vara(void);
+extern void test_nc_get_vara_ushort(void);
+extern void test_nc_get_vara_uint(void);
+extern void test_nc_get_vara_longlong(void);
+extern void test_nc_get_vara_ulonglong(void);
 
 extern void test_nc_get_vars(void);
 extern void test_nc_get_vars_double(void);
@@ -249,6 +335,10 @@
 extern void test_nc_get_vars_text(void);
 extern void test_nc_get_vars_uchar(void);
 extern void test_nc_get_vars(void);
+extern void test_nc_get_vars_ushort(void);
+extern void test_nc_get_vars_uint(void);
+extern void test_nc_get_vars_longlong(void);
+extern void test_nc_get_vars_ulonglong(void);
 
 extern void test_nc_get_varm(void);
 extern void test_nc_get_varm_double(void);
@@ -260,6 +350,10 @@
 extern void test_nc_get_varm_text(void);
 extern void test_nc_get_varm_uchar(void);
 extern void test_nc_get_varm(void);
+extern void test_nc_get_varm_ushort(void);
+extern void test_nc_get_varm_uint(void);
+extern void test_nc_get_varm_longlong(void);
+extern void test_nc_get_varm_ulonglong(void);
 
 extern void test_nc_get_att(void);
 extern void test_nc_get_att_double(void);
@@ -270,6 +364,10 @@
 extern void test_nc_get_att_short(void);
 extern void test_nc_get_att_text(void);
 extern void test_nc_get_att_uchar(void);
+extern void test_nc_get_att_ushort(void);
+extern void test_nc_get_att_uint(void);
+extern void test_nc_get_att_longlong(void);
+extern void test_nc_get_att_ulonglong(void);
 
 extern void test_nc_put_att(void);
 extern void test_nc_put_var_double(void);
@@ -281,6 +379,10 @@
 extern void test_nc_put_var_text(void);
 extern void test_nc_put_var_uchar(void);
 extern void test_nc_put_var(void);
+extern void test_nc_put_var_ushort(void);
+extern void test_nc_put_var_uint(void);
+extern void test_nc_put_var_longlong(void);
+extern void test_nc_put_var_ulonglong(void);
 
 extern void test_nc_put_var1_double(void);
 extern void test_nc_put_var1_float(void);
@@ -291,6 +393,10 @@
 extern void test_nc_put_var1_text(void);
 extern void test_nc_put_var1_uchar(void);
 extern void test_nc_put_var1(void);
+extern void test_nc_put_var1_ushort(void);
+extern void test_nc_put_var1_uint(void);
+extern void test_nc_put_var1_longlong(void);
+extern void test_nc_put_var1_ulonglong(void);
 
 extern void test_nc_put_vara_double(void);
 extern void test_nc_put_vara_float(void);
@@ -301,6 +407,10 @@
 extern void test_nc_put_vara_text(void);
 extern void test_nc_put_vara_uchar(void);
 extern void test_nc_put_vara(void);
+extern void test_nc_put_vara_ushort(void);
+extern void test_nc_put_vara_uint(void);
+extern void test_nc_put_vara_longlong(void);
+extern void test_nc_put_vara_ulonglong(void);
 
 extern void test_nc_put_vars_double(void);
 extern void test_nc_put_vars_float(void);
@@ -311,6 +421,10 @@
 extern void test_nc_put_vars_text(void);
 extern void test_nc_put_vars_uchar(void);
 extern void test_nc_put_vars(void);
+extern void test_nc_put_vars_ushort(void);
+extern void test_nc_put_vars_uint(void);
+extern void test_nc_put_vars_longlong(void);
+extern void test_nc_put_vars_ulonglong(void);
 
 extern void test_nc_put_varm_double(void);
 extern void test_nc_put_varm_float(void);
@@ -321,6 +435,10 @@
 extern void test_nc_put_varm_text(void);
 extern void test_nc_put_varm_uchar(void);
 extern void test_nc_put_varm(void);
+extern void test_nc_put_varm_ushort(void);
+extern void test_nc_put_varm_uint(void);
+extern void test_nc_put_varm_longlong(void);
+extern void test_nc_put_varm_ulonglong(void);
 
 extern void test_nc_put_att_double(void);
 extern void test_nc_put_att_float(void);
@@ -330,6 +448,10 @@
 extern void test_nc_put_att_short(void);
 extern void test_nc_put_att_text(void);
 extern void test_nc_put_att_uchar(void);
+extern void test_nc_put_att_ushort(void);
+extern void test_nc_put_att_uint(void);
+extern void test_nc_put_att_longlong(void);
+extern void test_nc_put_att_ulonglong(void);
 
 extern void test_nc_create(void);
 extern void test_nc_redef(void);
@@ -370,7 +492,13 @@
 	NCT_INT =	20,	/* int */
 	NCT_LONG =	22,	/* long */
 	NCT_FLOAT =	36,	/* float */
-	NCT_DOUBLE =	40	/* double */
+	NCT_DOUBLE =	40,	/* double */
+        NCT_USHORT =    41,
+        NCT_UINT =      42,
+        NCT_INT64 =     43,
+#define NCT_LONGLONG NCT_INT64
+        NCT_UINT64 =    44
+#define NCT_ULONGLONG NCT_UINT64
 } nct_itype;
 
 int inRange3(const double value, const nc_type datatype, const nct_itype itype);
diff netcdf-c/nc_test/tst_atts.c cdf5/nc_test/tst_atts.c
--- netcdf-c/nc_test/tst_atts.c	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/nc_test/tst_atts.c	2014-11-14 14:54:46.056734200 -0700
@@ -6,7 +6,7 @@
    Unicode names encoded with UTF-8. It is the NETCDF3 equivalent
    of tst_unicode.c
 
-   $Id$
+   $Id: tst_atts.c 2792 2014-10-27 06:02:59Z wkliao $
 */
 
 #include <nc_tests.h>
@@ -454,7 +454,11 @@
     int i444_dims[RANK_i444];
 
     /* enter define mode */
+#ifdef TEST_PNETCDF
+    stat = nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     stat = nc_create(FILE_NAME, NC_CLOBBER, &ncid);
+#endif
     check_err(stat,__LINE__,__FILE__);
 
     /* define dimensions */
@@ -2342,6 +2346,9 @@
 int
 main(int argc, char **argv)
 {
+#ifdef TEST_PNETCDF
+   MPI_Init(&argc, &argv);
+#endif
    printf("\n*** Testing netCDF attributes.\n");
    printf("*** testing attribute renaming for memory leak, like nc_test...");
    {
@@ -2354,7 +2361,11 @@
       char char_data = 'a';
 
       /* Create a file with a var with two atts. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_NETCDF4|NC_CLASSIC_MODEL|NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_def_var(ncid, VAR_NAME, NC_INT, 0, NULL, &varid)) ERR;
       if (nc_put_att(ncid, varid, A1_NAME, NC_CHAR, 1, &char_data)) ERR;
       if (nc_put_att(ncid, varid, B1_NAME, NC_CHAR, 1, &char_data)) ERR;
@@ -2390,7 +2401,11 @@
       if (nc_close(ncid)) ERR;
 
       /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_inq_nvars(ncid, &nvars)) ERR;
       if (nvars != 1) ERR_RET;
       for (v = 0; v < nvars; v++)
@@ -2418,7 +2433,11 @@
       if (create_file()) ERR;
 
       /* Open the file. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_redef(ncid)) ERR;
 
       /* Add a global attribute A_NAME. */
@@ -2443,7 +2462,11 @@
       if (nc_close(ncid)) ERR;
 
       /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_inq_nvars(ncid, &nvars)) ERR;
       if (nvars != NVARS) ERR_RET;
       for (v = 0; v < nvars; v++)
@@ -2459,5 +2482,8 @@
 
    }
    SUMMARIZE_ERR;
+#ifdef TEST_PNETCDF
+   MPI_Finalize();
+#endif
    FINAL_RESULTS;
 }
diff netcdf-c/nc_test/tst_atts3.c cdf5/nc_test/tst_atts3.c
--- netcdf-c/nc_test/tst_atts3.c	2014-11-14 15:14:32.036534500 -0700
+++ cdf5/nc_test/tst_atts3.c	2014-11-14 14:54:46.057710700 -0700
@@ -4,11 +4,12 @@
 
    Test attributes. 
 
-   $Id: tst_atts1.c 2190 2012-05-21 11:20:44Z russ $
+   $Id: tst_atts3.c 2796 2014-10-28 03:40:29Z wkliao $
 */
 
 #include <nc_tests.h>
 #include "netcdf.h"
+#include "netcdf_par.h"
 #include <signal.h>
 
 #define FILE_NAME "tst_atts_3.nc"
@@ -93,7 +94,11 @@
    int j;
 
    /* Create a file with some global atts. */
+#ifdef TEST_PNETCDF
+   if (nc_create_par(FILE_NAME, cmode|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
    if (nc_create(FILE_NAME, cmode, &ncid)) ERR;
+#endif
    if (nc_put_att_text(ncid, NC_GLOBAL, name[0], len[0], NULL)) ERR;      
    if (nc_put_att_schar(ncid, NC_GLOBAL, name[1], NC_BYTE, len[1], b)) ERR;      
    if (nc_put_att_short(ncid, NC_GLOBAL, name[2], NC_SHORT, len[2], s)) ERR;      
@@ -105,7 +110,11 @@
    if (nc_close(ncid)) ERR;
       
    /* Reopen the file and check the order. */
+#ifdef TEST_PNETCDF
+   if (nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_open(FILE_NAME, 0, &ncid)) ERR;
+#endif
    for (j = 0; j < NUM_ATTS; j++)
    {
       if (nc_inq_attname(ncid, NC_GLOBAL, j, name_in)) ERR;
@@ -136,6 +145,9 @@
     unsigned long long ulonglong_out[ATT_LEN] = {0LL, 128LL, 3123456789LL};
 #endif
 
+#ifdef TEST_PNETCDF
+   MPI_Init(&argc, &argv);
+#endif
     (void) signal(SIGFPE, SIG_IGN);
 
    printf("\n*** Testing netcdf-3 attribute functions.\n");
@@ -149,13 +161,21 @@
       int j;
 
       /* Create a file with some global atts. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       for (j = 0; j < NUM_SIMPLE_ATTS; j++)
 	 if (nc_put_att_int(ncid, NC_GLOBAL, name[j], NC_INT, 0, NULL)) ERR;      
       if (nc_close(ncid)) ERR;
       
       /* Reopen the file and check the order. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, 0, &ncid)) ERR;
+#endif
       for (j = 0; j < NUM_SIMPLE_ATTS; j++)
       {
 	 if (nc_inq_attname(ncid, NC_GLOBAL, j, name_in)) ERR;
@@ -176,7 +196,11 @@
       char *speech_in;
 
       /* This won't work, because classic files can't create these types. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_put_att_int(ncid, NC_GLOBAL, ATT_INT_NAME, NC_INT, ATT_LEN, 
 			    int_out)) ERR;      
       /* It is also OK to read classic types converted into
@@ -193,7 +217,11 @@
       if (nc_close(ncid)) ERR;
 
       /* Create a file with a global attribute of each type. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_put_att_text(ncid, NC_GLOBAL, ATT_TEXT_NAME, strlen(speech)+1, speech)) ERR;      
       if (nc_put_att_schar(ncid, NC_GLOBAL, ATT_SCHAR_NAME, NC_BYTE, ATT_LEN, schar_out)) ERR;      
       if (nc_put_att_short(ncid, NC_GLOBAL, ATT_SHORT_NAME, NC_SHORT, ATT_LEN, short_out)) ERR;      
@@ -203,7 +231,11 @@
       if (nc_close(ncid)) ERR;
 
       /* Open the file and check attributes. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, 0, &ncid)) ERR;
+#endif
       /* Check text. */
       if (nc_inq_att(ncid, NC_GLOBAL, ATT_TEXT_NAME, &att_type, &att_len))
 	 ERR;
@@ -238,7 +270,11 @@
       int i;
 
       /* Reopen the file and try different type conversions. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, 0, &ncid)) ERR;
+#endif
 
       /* No text conversions are allowed, and people who try them should
        * be locked up, away from decent folk! */
@@ -379,7 +415,11 @@
       /*int int_in[ATT_LEN], int_out[ATT_LEN] = {NC_MIN_INT, 128, NC_MAX_INT};*/
 
       /* Create a file with a global attribute of each type of zero length. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_put_att_text(ncid, NC_GLOBAL, ATT_TEXT_NAME, 0, NULL)) ERR;
       if (nc_put_att_schar(ncid, NC_GLOBAL, ATT_SCHAR_NAME, NC_BYTE, 0, NULL)) ERR;
       if (nc_put_att_short(ncid, NC_GLOBAL, ATT_SHORT_NAME, NC_SHORT, 0, NULL)) ERR;
@@ -401,7 +441,11 @@
       size_t len;
       nc_type xtype;
 
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, 0, &ncid)) ERR;
+#endif
       if (nc_get_att_text(ncid, NC_GLOBAL, ATT_TEXT_NAME, NULL)) ERR;
       if (nc_inq_att(ncid, NC_GLOBAL, ATT_TEXT_NAME, &xtype, &len)) ERR;
       if (len || xtype != NC_CHAR) ERR;
@@ -440,7 +484,11 @@
 
 
       /* Create a file with a global attribute of each type of zero length. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_enddef(ncid)) ERR;
       if (nc_redef(ncid)) ERR;
       if (nc_put_att_text(ncid, NC_GLOBAL, ATT_TEXT_NAME, 0, NULL)) ERR;
@@ -453,7 +501,11 @@
 
       /* Make sure we can read all these zero-length atts added during a
        * redef. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, 0, &ncid)) ERR;
+#endif
       if (nc_get_att_text(ncid, NC_GLOBAL, ATT_TEXT_NAME, NULL)) ERR;
       if (nc_get_att_schar(ncid, NC_GLOBAL, ATT_SCHAR_NAME, schar_in)) ERR;
       if (nc_get_att_short(ncid, NC_GLOBAL, ATT_SHORT_NAME, short_in)) ERR;
@@ -480,13 +532,21 @@
       int int_out[ATT_LEN] = {-100000, 128, 100000};
 
       /* Create a file with a global attribute. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_put_att_text(ncid, NC_GLOBAL, ATT_TEXT_NAME, strlen(speech)+1, 
 			  speech)) ERR;      
       if (nc_close(ncid)) ERR;
       
       /* Rename it. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_inq_attid(ncid, NC_GLOBAL, ATT_TEXT_NAME, &attid_in)) ERR;
       if (attid_in != 0) ERR;
       if (nc_inq_attname(ncid, NC_GLOBAL, attid_in, name_in)) ERR;
@@ -497,7 +557,11 @@
       if (strcmp(name_in, ATT_TEXT_NAME2)) ERR;
       if (nc_close(ncid)) ERR;
 
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_inq_att(ncid, NC_GLOBAL, ATT_TEXT_NAME2, &att_type, &att_len)) ERR;
       if (att_type != NC_CHAR || att_len != strlen(speech) + 1) ERR;
       if (!(speech_in = malloc(att_len + 1))) ERR;
@@ -508,13 +572,21 @@
       if (nc_close(ncid)) ERR;
 
       /* Now delete the att. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_redef(ncid)) ERR;
       if (nc_del_att(ncid, NC_GLOBAL, ATT_TEXT_NAME2)) ERR;
       if (nc_close(ncid)) ERR;
 
       /* Now create a file with a variable, which has an att. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_put_att_text(ncid, NC_GLOBAL, ATT_TEXT_NAME, strlen(speech)+1, speech)) ERR;      
       if (nc_def_dim(ncid, DIM1_NAME, DIM1_LEN, &dimids[0])) ERR;
       if (nc_def_dim(ncid, DIM2_NAME, DIM2_LEN, &dimids[1])) ERR;
@@ -523,14 +595,22 @@
       if (nc_close(ncid)) ERR;
       
       /* Reopen the file and delete it. Make sure it's gone. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_redef(ncid)) ERR;
       if (nc_del_att(ncid, 0, ATT_INT_NAME)) ERR;
       if (nc_close(ncid)) ERR;
 
       /* Reopen the file and readd the attribute. Enddef and redef,
        * and delete it, then check to make sure it's gone. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_redef(ncid)) ERR;
       if (nc_put_att_int(ncid, varid, ATT_INT_NAME, NC_INT, 3, int_out)) ERR;      
       if (nc_enddef(ncid)) ERR;
@@ -552,13 +632,21 @@
       const int number = 42;
 
       /* Create a file with several global attributes. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_put_att_int(ncid, NC_GLOBAL, ATT0, NC_INT, 1, &number)) ERR;
       if (nc_put_att_int(ncid, NC_GLOBAL, ATT1, NC_INT, 1, &number)) ERR;
       if (nc_close(ncid)) ERR;
       
       /* Open it and check the order. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_inq_attid(ncid, NC_GLOBAL, ATT0, &attid_in)) ERR;
       if (attid_in != 0) ERR;
       if (nc_inq_attid(ncid, NC_GLOBAL, ATT1, &attid_in)) ERR;
@@ -566,7 +654,11 @@
       if (nc_close(ncid)) ERR;
 
       /* Now create a file with a variable, which has two atts. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_def_dim(ncid, DIM1_NAME, DIM1_LEN, &dimids[0])) ERR;
       if (nc_def_dim(ncid, DIM2_NAME, DIM2_LEN, &dimids[1])) ERR;
       if (nc_def_var(ncid, VAR1_NAME, NC_INT, 2, dimids, &varid)) ERR;
@@ -575,7 +667,11 @@
       if (nc_close(ncid)) ERR;
       
       /* Reopen the file and check the order of the attributes on the var. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, NC_WRITE, &ncid)) ERR;
+#endif
       if (nc_inq_attid(ncid, 0, ATT0, &attid_in)) ERR;
       if (attid_in != 0) ERR;
       if (nc_inq_attid(ncid, 0, ATT1, &attid_in)) ERR;
@@ -600,7 +696,11 @@
       char name_in[NC_MAX_NAME + 1];
 
       /* Create a file with one var, and attach three atts to it. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_def_var(ncid, VAR_NAME, NC_INT, 0, NULL, &varid)) ERR;
       if (nc_put_att_double(ncid, varid, A1_NAME, NC_INT, A1_LEN, dvalue)) ERR;      
       if (nc_put_att_double(ncid, varid, A2_NAME, NC_INT, A2_LEN, dvalue)) ERR;      
@@ -608,7 +708,11 @@
       if (nc_close(ncid)) ERR;
       
       /* Reopen the file and check. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, 0, &ncid)) ERR;
+#endif
       if (nc_inq_nvars(ncid, &nvars)) ERR;
       if (nvars != 1) ERR;
       if (nc_inq_varnatts(ncid, 0, &natts)) ERR;
@@ -640,7 +744,11 @@
    {
       int ncid, att = 1;
 
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_enddef(ncid)) ERR;
       if (nc_redef(ncid)) ERR;
       if (nc_put_att(ncid, NC_GLOBAL, ATT_1, NC_INT, 1, &att)) ERR;
@@ -649,7 +757,11 @@
 
       if (nc_close(ncid)) ERR;
 
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME, 0, &ncid)) ERR;
+#endif
       if (nc_close(ncid)) ERR;
    }
 
@@ -669,7 +781,11 @@
       double double_in[ATT_LEN], double_out[ATT_LEN] = {0.25, .5, 0.125};
 
       /* Create a file with a global attribute of each type. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)) ERR;
+#else
       if (nc_create(FILE_NAME, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_put_att_text(ncid, NC_GLOBAL, ATT_TEXT_NAME, strlen(speech)+1, speech)) ERR;      
       if (nc_put_att_schar(ncid, NC_GLOBAL, ATT_SCHAR_NAME, NC_BYTE, ATT_LEN, schar_out)) ERR;      
       if (nc_put_att_short(ncid, NC_GLOBAL, ATT_SHORT_NAME, NC_SHORT, ATT_LEN, short_out)) ERR;      
@@ -678,7 +794,11 @@
       if (nc_put_att_double(ncid, NC_GLOBAL, ATT_DOUBLE_NAME, NC_DOUBLE, ATT_LEN, double_out)) ERR;      
 
       /* Create another file and copy all the attributes. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(FILE_NAME2, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid2)) ERR;
+#else
       if (nc_create(FILE_NAME2, NC_CLOBBER, &ncid2)) ERR;      
+#endif
       if (nc_copy_att(ncid, NC_GLOBAL, ATT_TEXT_NAME, ncid2, NC_GLOBAL)) ERR;
       if (nc_copy_att(ncid, NC_GLOBAL, ATT_SCHAR_NAME, ncid2, NC_GLOBAL)) ERR;
       if (nc_copy_att(ncid, NC_GLOBAL, ATT_SHORT_NAME, ncid2, NC_GLOBAL)) ERR;
@@ -691,7 +811,11 @@
       if (nc_close(ncid2)) ERR;
 
       /* Open the file and check attributes. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(FILE_NAME2, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(FILE_NAME2, 0, &ncid)) ERR;
+#endif
       /* Check text. */
       if (nc_inq_att(ncid, NC_GLOBAL, ATT_TEXT_NAME, &att_type, &att_len)) ERR;
       if (att_type != NC_CHAR || att_len != strlen(speech) + 1) ERR;
@@ -718,6 +842,9 @@
       if (nc_close(ncid)) ERR;
    }
    SUMMARIZE_ERR;
+#ifdef TEST_PNETCDF
+   MPI_Finalize();
+#endif
    FINAL_RESULTS;
 }
 
diff netcdf-c/nc_test/tst_meta.c cdf5/nc_test/tst_meta.c
--- netcdf-c/nc_test/tst_meta.c	2015-03-09 13:48:02.763960300 -0600
+++ cdf5/nc_test/tst_meta.c	2014-11-14 14:54:46.058687200 -0700
@@ -9,6 +9,7 @@
 
 */
 
+#include <stdio.h> /* printf() */
 #include <config.h>
 #include <netcdf.h>
 #include <netcdf_meta.h>
diff netcdf-c/nc_test/tst_misc.c cdf5/nc_test/tst_misc.c
--- netcdf-c/nc_test/tst_misc.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test/tst_misc.c	2014-11-14 14:54:46.059663700 -0700
@@ -14,12 +14,16 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <netcdf.h>
+#include <netcdf_par.h>
 
 #define FILE_NAME "tst_misc.nc"
 
 int
 main(int argc, char **argv) 
 {
+#ifdef TEST_PNETCDF
+   MPI_Init(&argc, &argv);
+#endif
    printf("\n*** Testing some extra stuff.\n");
    printf("*** Trying to open non-netCDF files of tiny length...");
    {
@@ -41,7 +45,11 @@
 	 if (fclose(file)) ERR;
 	 
 	 /* Make sure that netCDF rejects this file politely. */
+#ifdef TEST_PNETCDF
+        openstat = nc_open_par(FILE_NAME, NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
 	 openstat = nc_open(FILE_NAME, 0, &ncid);
+#endif
 	 /* Some platforms (OSX, buddy) return stat = 2 (file not found)
 	    for index i == 2.  Not sure why, but this is a work around. */
 	 if(openstat != NC_ENOTNC && openstat != 2) ERR;
@@ -50,5 +58,8 @@
    }
 
    SUMMARIZE_ERR;
+#ifdef TEST_PNETCDF
+   MPI_Finalize();
+#endif
    FINAL_RESULTS;
 }
diff netcdf-c/nc_test/tst_names.c cdf5/nc_test/tst_names.c
--- netcdf-c/nc_test/tst_names.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test/tst_names.c	2014-11-14 14:54:46.060640200 -0700
@@ -6,13 +6,14 @@
    netCDF data objects, including names with "/" character, trailing spaces, 
    leading special characters, and invalid UTF-8 strings.
 
-   $Id: tst_names.c,v 1.9 2008/08/07 14:23:36 russ Exp $
+   $Id: tst_names.c 2792 2014-10-27 06:02:59Z wkliao $
 */
 #include <config.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <netcdf.h>
+#include <netcdf_par.h>
 #include <nc_tests.h>
 
 /* The data file we will create. */
@@ -20,6 +21,9 @@
 #define NDIMS 1
 #define DIMLEN 1
 
+#define ERROR {printf("Error at line %d: %s\n",__LINE__,nc_strerror(res)); continue;}
+#define ERRORI {printf("Error at line %d (loop=%d): %s\n",__LINE__,i,nc_strerror(res)); continue;}
+
 int
 main(int argc, char **argv)
 {
@@ -214,6 +218,8 @@
        NC_FORMAT_CLASSIC
        ,
        NC_FORMAT_64BIT
+       ,
+       NC_FORMAT_CDF5
 #ifdef USE_NETCDF4
        ,
        NC_FORMAT_NETCDF4
@@ -223,35 +229,44 @@
    };
    int num_formats = (sizeof formats) / (sizeof formats[0]);
    char *format_names[] = {
-       "classic", "64-bit offset", "netCDF-4/HDF5", "netCDF-4 classic model"
+       "classic", "64-bit offset", "64-bit data", "netCDF-4/HDF5", "netCDF-4 classic model"
    };
 
+#ifdef TEST_PNETCDF
+   MPI_Init(&argc, &argv);
+#endif
+
    printf("\n*** testing names with file %s...\n", testfile);
    for (j = 0; j < num_formats; j++)
    {
        printf("*** switching to netCDF %s format...", format_names[j]);
        nc_set_default_format(formats[j], NULL);
+#ifdef TEST_PNETCDF
+       if((res = nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)))
+#else
        if((res = nc_create(testfile, NC_CLOBBER, &ncid)))
-	   ERR;
+#endif
+	   ERROR
        
        /* Define dimensions, variables, and attributes with various
 	* acceptable names */
        for (i = 0; i < NUM_GOOD; i++) {
 	   if ((res = nc_def_dim(ncid, valid[i], DIMLEN, &dimid)))
-	       ERR;
+	       ERRORI
+
 	   dimids[i] = dimid;
 	   /* Define variable with same name */
 	   if ((res = nc_def_var(ncid, valid[i], NC_FLOAT, NDIMS, &dimids[i], 
 				 &varid)))
-	       ERR;
+	       ERRORI
 	   varids[i] = varid;
 	   /* Define variable and global attributes with same name and value */
 	   if ((res = nc_put_att_text(ncid, varid, valid[i], 
 				      strlen(valid[i]), valid[i])))
-	       ERR;
+	       ERRORI
 	   if ((res = nc_put_att_double(ncid, NC_GLOBAL, valid[i], NC_DOUBLE, 
 					NATTVALS, attvals)))
-	       ERR;
+	       ERRORI
 #if 0
 	   attnums[i] = i;
 #endif
@@ -261,47 +276,52 @@
 	* bad names and make sure these are rejected */
        for (i = 0; i < NUM_BAD; i++) {
 	   if ((res = nc_def_dim(ncid, notvalid[i], DIMLEN, &dimid)) 
-	       != NC_EBADNAME) ERR;
+	       != NC_EBADNAME) ERRORI
 	   if ((res = nc_def_var(ncid, notvalid[i], NC_FLOAT, NDIMS, dimids, 
 				 &varid))
-	       != NC_EBADNAME) ERR;
+	       != NC_EBADNAME) ERRORI
 	   if ((res = nc_put_att_text(ncid, varid, notvalid[i], 
 				      strlen(attstring), attstring))
-	       != NC_EBADNAME) ERR;
+	       != NC_EBADNAME) ERRORI
 	   if ((res = nc_put_att_double(ncid, NC_GLOBAL, notvalid[i], NC_DOUBLE, 
 					NATTVALS, attvals))
-	       != NC_EBADNAME) ERR;
+	       != NC_EBADNAME) ERRORI
        }
        if ((res = nc_enddef(ncid)))
-	   ERR;
+	   ERROR
        if ((res = nc_close(ncid)))
-	   ERR;
+	   ERROR
        
        /* Check it out, make sure all objects with good names were defined OK */
+#ifdef TEST_PNETCDF
+       if ((res = nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)))
+#else
        if ((res = nc_open(testfile, NC_NOWRITE, &ncid)))
-	   ERR;
+#endif
+	   ERROR
        for (i = 0; i < NUM_GOOD; i++) {
 	   size_t attlen;
 	   if ((res = nc_inq_dimid(ncid, valid[i], &dimid)) || 
 	       dimid != dimids[i])
-	       ERR;
+	       ERRORI
 	   if ((res = nc_inq_varid(ncid, valid[i], &varid)) || 
 	       varid != varids[i])
-	       ERR;
+	       ERRORI
 	   res = nc_inq_attlen(ncid, varid, valid[i], &attlen);
 	   if ((res = nc_get_att_text(ncid, varid, valid[i], attstr_in))) 
-	       ERR;
+	       ERRORI
 	   attstr_in[attlen] = '\0';
 	   if (strcmp(valid[i], attstr_in) != 0) 
-	       ERR;
+	       ERRORI
 	   if ((res = nc_get_att_double(ncid, NC_GLOBAL, valid[i], 
 					attvals_in)) 
 	       || attvals[0] != attvals_in[0]) 
-	       ERR;
+	       ERRORI
        }
        if ((res = nc_close(ncid)))
-	   ERR;
+	   ERROR
 /*        (void) remove(testfile); */
+
        SUMMARIZE_ERR;
    }
    FINAL_RESULTS;
@@ -306,5 +326,8 @@
    }
    FINAL_RESULTS;
 
+#ifdef TEST_PNETCDF
+   MPI_Finalize();
+#endif
    return 0;
 }
diff netcdf-c/nc_test/tst_nofill.c cdf5/nc_test/tst_nofill.c
--- netcdf-c/nc_test/tst_nofill.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test/tst_nofill.c	2014-11-14 14:54:46.066499200 -0700
@@ -9,7 +9,7 @@
   when invoked with the blksize argument between 2091953 and 2150032,
   inclusive, and succeeds for other blksizes.
 
-  $Id$
+  $Id: tst_nofill.c 2792 2014-10-27 06:02:59Z wkliao $
 */
 
 #include <config.h>
@@ -107,9 +107,14 @@
     * the same effect by providing the desired value as sizehint to
     * nc__create() instead of calling nc_create() and getting the
     * block size reported by fstat */
+#ifdef TEST_PNETCDF
+   stat = nc_create_par(file_name, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+   /* PnetCDF does not support fill mode */
+#else
    stat = nc__create(file_name, NC_CLOBBER, default_initialsize, sizehintp, &ncid);
    check_err(stat,__LINE__,__FILE__);
    stat = nc_set_fill(ncid, fill_mode, &old_fill_mode);
+#endif
    check_err(stat,__LINE__,__FILE__);
 
    /* define dimensions */
@@ -357,6 +362,9 @@
 				 * value between 2091953 and 2150032
 				 * triggers bug, whereas all other
 				 * values work fine. */
+#ifdef TEST_PNETCDF
+    MPI_Init(&argc, &argv);
+#endif
 
     if (argc > 1) {
 	char *endptr, *str = argv[1];
@@ -393,8 +401,13 @@
        printf("*** Compare values in nofill mode and fill mode files...");
        /* compare data in two files created with nofill mode and fill
 	* mode, which should be identical if all the data were written */
+#ifdef TEST_PNETCDF
+       if (nc_open_par(FILE_NAME1, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid1)) ERR;
+       if (nc_open_par(FILE_NAME2, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid2)) ERR;
+#else
        if (nc_open(FILE_NAME1, NC_NOWRITE, &ncid1)) ERR;
        if (nc_open(FILE_NAME2, NC_NOWRITE, &ncid2)) ERR;
+#endif
        if (nc_inq_nvars(ncid1, &nvars1)) ERR;
        if (nc_inq_nvars(ncid2, &nvars2)) ERR;
        if (nvars1 != nvars2) ERR;
@@ -473,4 +486,7 @@
        SUMMARIZE_ERR;
    }
    FINAL_RESULTS;
+#ifdef TEST_PNETCDF
+   MPI_Finalize();
+#endif
 }
diff netcdf-c/nc_test/tst_norm.c cdf5/nc_test/tst_norm.c
--- netcdf-c/nc_test/tst_norm.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test/tst_norm.c	2014-11-14 14:54:46.067475700 -0700
@@ -5,13 +5,14 @@
    This is a very simple example which tests NFC normalization of
    Unicode names encoded with UTF-8.
 
-   $Id: tst_norm.c,v 1.8 2008/10/20 01:48:08 ed Exp $
+   $Id: tst_norm.c 2792 2014-10-27 06:02:59Z wkliao $
 */
 #include <config.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <netcdf.h>
+#include <netcdf_par.h>
 #include <nc_tests.h>
 
 /* The data file we will create. */
@@ -99,8 +100,15 @@
    int attvals[] = {42};
 #define ATTNUM ((sizeof attvals)/(sizeof attvals[0]))
 
+#ifdef TEST_PNETCDF
+MPI_Init(&argc, &argv);
+#endif
    printf("\n*** testing UTF-8 normalization...");
+#ifdef TEST_PNETCDF
+   if((res = nc_create_par(FILE7_NAME, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL,&ncid)))
+#else
    if((res = nc_create(FILE7_NAME, NC_CLOBBER, &ncid)))
+#endif
        ERR;
 
    /* Define dimension with unnormalized Unicode UTF-8 encoded name */
@@ -124,10 +132,11 @@
     * version of same name.  These should fail, as unnormalized name
     * should have been normalized in library, so these are attempts to
     * create duplicate netCDF objects. */
-   if ((res = nc_def_dim(ncid, NNAME, NX, &dimid))
-       != NC_ENAMEINUSE) ERR;
-   if ((res = nc_def_var(ncid, NNAME, NC_CHAR, NDIMS, dimids, &varid))
-       != NC_ENAMEINUSE) ERR;
+   if ((res = nc_def_dim(ncid, NNAME, NX, &dimid)) != NC_ENAMEINUSE)
+       ERR;
+
+   if ((res = nc_def_var(ncid, NNAME, NC_CHAR, NDIMS, dimids, &varid)) != NC_ENAMEINUSE)
+       ERR;
    if ((res = nc_enddef(ncid)))
        ERR;
 
@@ -138,7 +147,11 @@
        ERR;
 
    /* Check it out. */
+#ifdef TEST_PNETCDF
+   if ((res = nc_open_par(FILE7_NAME, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD,MPI_INFO_NULL, &ncid)))
+#else
    if ((res = nc_open(FILE7_NAME, NC_NOWRITE, &ncid)))
+#endif
        ERR;
    if ((res = nc_inq_varid(ncid, UNAME, &varid)))
        ERR;
@@ -169,6 +182,9 @@
        ERR;
 
    SUMMARIZE_ERR;
+#ifdef TEST_PNETCDF
+   MPI_Finalize();
+#endif
    FINAL_RESULTS;
    return 0;
 }
diff netcdf-c/nc_test/tst_small.c cdf5/nc_test/tst_small.c
--- netcdf-c/nc_test/tst_small.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test/tst_small.c	2014-11-14 14:54:46.068452200 -0700
@@ -4,19 +4,17 @@
 
    Test small files.
 
-   $Id: tst_small.c,v 1.15 2008/10/20 01:48:08 ed Exp $
+   $Id: tst_small.c 2796 2014-10-28 03:40:29Z wkliao $
 */
 
+#include <mpi.h>
 #include <nc_tests.h>
 #include <netcdf.h>
+#include <netcdf_par.h>
 
-/* Test everything for classic and 64-bit offsetfiles. If netcdf-4 is
+/* Test everything for classic, 64-bit offset, 64-bit data files. If netcdf-4 is
  * included, that means another whole round of testing. */
-#ifdef USE_NETCDF4
-#define NUM_FORMATS (4)
-#else
-#define NUM_FORMATS (2)
-#endif
+#define NUM_FORMATS (5)
 
 #define ATT_NAME "Atom"
 #define MAX_LEN 7   
@@ -41,13 +39,21 @@
 	 strncpy(att, source, t);
 	 
 	 /* Create a file with one attribute. */
+#ifdef TEST_PNETCDF
+         if (nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
 	 if (nc_create(testfile, NC_CLOBBER, &ncid)) ERR;
+#endif
 	 if (nc_put_att_text(ncid, NC_GLOBAL, ATT_NAME, t + 1, att)) ERR;
 	 if (f && nc_set_fill(ncid, NC_NOFILL, NULL)) ERR;
 	 if (nc_close(ncid)) ERR;
 	 
 	 /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+         if (nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
 	 if (nc_open(testfile, NC_NOWRITE, &ncid)) ERR;
+#endif
 	 if (nc_inq(ncid, &ndims, &nvars, &natts, &unlimdimid)) ERR;
 	 if (ndims != 0 && nvars != 0 && natts != 1 && unlimdimid != -1) ERR;
 	 if (nc_inq_attlen(ncid, NC_GLOBAL, ATT_NAME, &len_in)) ERR;
@@ -89,7 +95,11 @@
    
    /* Create a file with two dimensions, one unlimited, and one
     * var, and a global att. */
+#ifdef TEST_PNETCDF
+   if (nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_create(testfile, NC_CLOBBER, &ncid)) ERR;
+#endif
    if (nc_def_dim(ncid, DIM1_NAME, NC_UNLIMITED, dimids)) ERR;
    if (nc_def_dim(ncid, DIM2_NAME, STR_LEN, &dimids[1])) ERR;
    if (nc_def_var(ncid, VAR_NAME, NC_CHAR, 2, dimids, &varid)) ERR;
@@ -107,7 +117,11 @@
    if (nc_close(ncid)) ERR;
    
    /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+   if (nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_open(testfile, NC_NOWRITE, &ncid)) ERR;
+#endif
    if (nc_inq(ncid, &ndims, &nvars, &natts, &unlimdimid)) ERR;
    if (ndims != 2 && nvars != 1 && natts != 0 && unlimdimid != 0) ERR;
    if (nc_get_var_text(ncid, varid, (char *)data_in)) ERR;
@@ -134,7 +148,11 @@
    
    /* Create a file with two dimensions, one unlimited, and one
     * var, and a global att. */
+#ifdef TEST_PNETCDF
+   if (nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_create(testfile, NC_CLOBBER, &ncid)) ERR;
+#endif
    if (nc_def_dim(ncid, DIM1_NAME, NUM_VALS, dimids)) ERR;
    if (nc_def_dim(ncid, DIM2_NAME, STR_LEN, &dimids[1])) ERR;
    if (nc_def_var(ncid, VAR_NAME, NC_CHAR, NDIMS, dimids, &varid)) ERR;
@@ -152,7 +170,11 @@
    if (nc_close(ncid)) ERR;
    
    /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+   if (nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_open(testfile, NC_NOWRITE, &ncid)) ERR;
+#endif
    if (nc_inq(ncid, &ndims, &nvars, &natts, &unlimdimid)) ERR;
    if (ndims != 2 && nvars != 1 && natts != 0 && unlimdimid != -1) ERR;
    if (nc_get_var_text(ncid, varid, (char *)data_in)) ERR;
@@ -172,7 +194,11 @@
    size_t start[NDIMS], count[NDIMS];
 
    /* Create a file with one ulimited dimensions, and one var. */
+#ifdef TEST_PNETCDF
+   if (nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_create(testfile, NC_CLOBBER, &ncid)) ERR;
+#endif
    if (nc_def_dim(ncid, DIM1_NAME, NC_UNLIMITED, &dimid)) ERR;
    if (nc_def_var(ncid, VAR_NAME, NC_CHAR, 1, &dimid, &varid)) ERR;
    if (nc_enddef(ncid)) ERR;
@@ -186,7 +212,11 @@
    if (nc_close(ncid)) ERR;
    
    /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+   if (nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_open(testfile, NC_NOWRITE, &ncid)) ERR;
+#endif
    if (nc_inq(ncid, &ndims, &nvars, &natts, &unlimdimid)) ERR;
    if (ndims != 1 && nvars != 1 && natts != 0 && unlimdimid != 0) ERR;
    if (nc_get_var_text(ncid, varid, &data_in)) ERR;
@@ -215,7 +245,11 @@
    for (f = 0; f < 2; f++)
    {
       /* Create a file with one ulimited dimensions, and one var. */
+#ifdef TEST_PNETCDF
+      if (nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_create(testfile, NC_CLOBBER, &ncid)) ERR;
+#endif
       if (nc_def_dim(ncid, DIM1_NAME, NC_UNLIMITED, &dimid)) ERR;
       if (nc_def_var(ncid, VAR_NAME, NC_CHAR, 1, &dimid, &varid)) ERR;
       if (nc_close(ncid)) ERR;
@@ -225,7 +259,11 @@
       for (r = 0; r < MAX_RECS; r++)
       {
 	 /* Write one record of var data, a single character. */
+#ifdef TEST_PNETCDF
+	 if (nc_open_par(testfile, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
 	 if (nc_open(testfile, NC_WRITE, &ncid)) ERR;
+#endif
 	 if (f && nc_set_fill(ncid, NC_NOFILL, NULL)) ERR;
 	 count[0] = 1;
 	 start[0] = r;
@@ -233,7 +271,11 @@
 	 if (nc_close(ncid)) ERR;
       
 	 /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+         if (nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
 	 if (nc_open(testfile, NC_NOWRITE, &ncid)) ERR;
+#endif
 	 if (nc_inq_dimlen(ncid, 0, &len_in)) ERR;
 	 if (len_in != r + 1) ERR;
 	 index[0] = r;
@@ -260,7 +302,11 @@
    int r;
 
    /* Create a file with one ulimited dimensions, and one var. */
+#ifdef TEST_PNETCDF
+   if (nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_create(testfile, NC_CLOBBER, &ncid)) ERR;
+#endif
    if (nc_def_dim(ncid, DIM1_NAME, NC_UNLIMITED, &dimid)) ERR;
    if (nc_def_var(ncid, VAR_NAME, NC_CHAR, 1, &dimid, &varid)) ERR;
    if (nc_close(ncid)) ERR;
@@ -275,7 +321,11 @@
    for (r = 0; r < MAX_RECS; r++)
    {
       /* Write one record of var data, a single character. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(testfile, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(testfile, NC_WRITE, &ncid)) ERR;
+#endif
       count[0] = 1;
       start[0] = r;
       if (nc_put_vara_text(ncid, varid, start, count, &data[r])) ERR;
@@ -285,7 +335,11 @@
       if (nc_close(ncid)) ERR;
       
       /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(testfile, NC_NOWRITE, &ncid)) ERR;
+#endif
       if (nc_inq_dimlen(ncid, 0, &len_in)) ERR;
       if (len_in != r + 1) ERR;
       index[0] = r;
@@ -313,7 +367,11 @@
    int v, r;
 
    /* Create a file with one ulimited dimensions, and one var. */
+#ifdef TEST_PNETCDF
+   if (nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_create(testfile, NC_CLOBBER, &ncid)) ERR;
+#endif
    if (nc_def_dim(ncid, DIM1_NAME, NC_UNLIMITED, &dimid)) ERR;
    if (nc_def_var(ncid, VAR_NAME, NC_CHAR, 1, &dimid, &varid[0])) ERR;
    if (nc_def_var(ncid, VAR_NAME2, NC_CHAR, 1, &dimid, &varid[1])) ERR;
@@ -329,7 +387,11 @@
    for (r = 0; r < MAX_RECS; r++)
    {
       /* Write one record of var data, a single character. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(testfile, NC_WRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(testfile, NC_WRITE, &ncid)) ERR;
+#endif
       count[0] = 1;
       start[0] = r;
       sprintf(att_name, "a_%d", data[r]);
@@ -343,7 +405,11 @@
       if (nc_close(ncid)) ERR;
       
       /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+      if (nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
       if (nc_open(testfile, NC_NOWRITE, &ncid)) ERR;
+#endif
       if (nc_inq_dimlen(ncid, 0, &len_in)) ERR;
       if (len_in != r + 1) ERR;
       index[0] = r;
@@ -367,7 +433,11 @@
    size_t start[NDIMS], count[NDIMS];
 
    /* Create a file with one ulimited dimensions, and one var. */
+#ifdef TEST_PNETCDF
+   if (nc_create_par(testfile, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_create(testfile, NC_CLOBBER, &ncid)) ERR;
+#endif
    if (nc_def_dim(ncid, DIM1_NAME, NC_UNLIMITED, &dimid)) ERR;
    if (nc_def_var(ncid, VAR_NAME, NC_CHAR, 1, &dimid, &varid)) ERR;
    if (nc_put_att_text(ncid, NC_GLOBAL, ATT_NAME, 1, &data)) ERR;
@@ -382,7 +452,11 @@
    if (nc_close(ncid)) ERR;
    
    /* Reopen the file and check it. */
+#ifdef TEST_PNETCDF
+   if (nc_open_par(testfile, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid)) ERR;
+#else
    if (nc_open(testfile, NC_NOWRITE, &ncid)) ERR;
+#endif
    if (nc_inq(ncid, &ndims, &nvars, &natts, &unlimdimid)) ERR;
    if (ndims != 1 && nvars != 1 && natts != 0 && unlimdimid != 0) ERR;
    if (nc_get_var_text(ncid, varid, &data_in)) ERR;
@@ -399,6 +473,10 @@
    int i;
    char testfile[NC_MAX_NAME + 1];
 
+#ifdef TEST_PNETCDF
+   MPI_Init(&argc, &argv);
+#endif
+
    printf("\n*** Testing small files.\n");
    /*nc_set_log_level(3);*/
 
@@ -413,11 +491,16 @@
 	    printf("Switching to netCDF classic format.\n");
 	    strcpy(testfile, "tst_small_classic.nc");
 	    break;
-	 case NC_FORMAT_64BIT:
-	    nc_set_default_format(NC_FORMAT_64BIT, NULL);
+	 case NC_FORMAT_CDF2:
+	    nc_set_default_format(NC_FORMAT_CDF2, NULL);
 	    printf("Switching to 64-bit offset format.\n");
 	    strcpy(testfile, "tst_small_64bit.nc");
 	    break;
+	 case NC_FORMAT_CDF5:
+	    nc_set_default_format(NC_FORMAT_CDF5, NULL);
+	    printf("Switching to 64-bit data format.\n");
+	    strcpy(testfile, "tst_small_cdf5.nc");
+	    break;
 #ifdef USE_NETCDF4
 	 case NC_FORMAT_NETCDF4_CLASSIC:
 	    nc_set_default_format(NC_FORMAT_NETCDF4_CLASSIC, NULL);
@@ -429,6 +512,10 @@
 	    strcpy(testfile, "tst_small_netcdf4.nc");
 	    printf("Switching to netCDF-4 format.\n");
 	    break;
+#else
+	 case NC_FORMAT_NETCDF4_CLASSIC:
+	 case NC_FORMAT_NETCDF4:
+	    continue; /* loop i */
 #endif
 	 default:
 	    printf("Unexpected format!\n");
@@ -470,6 +557,9 @@
       SUMMARIZE_ERR;
    }
 
+#ifdef TEST_PNETCDF
+   MPI_Finalize();
+#endif
    FINAL_RESULTS;
 }
 
diff netcdf-c/nc_test/util.c cdf5/nc_test/util.c
--- netcdf-c/nc_test/util.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test/util.c	2014-11-14 14:54:46.069428700 -0700
@@ -1,7 +1,7 @@
 /*********************************************************************
  *   Copyright 1996, UCAR/Unidata
  *   See netcdf/COPYRIGHT file for copying and redistribution conditions.
- *   $Id: util.c,v 1.27 2006/12/10 13:59:56 ed Exp $
+ *   $Id: util.c 2792 2014-10-27 06:02:59Z wkliao $
  *********************************************************************/
 
 #include "tests.h"
@@ -23,12 +23,17 @@
     double min, max;
 
     switch (datatype) {
-	case NC_CHAR:   min = X_CHAR_MIN;   max = X_CHAR_MAX; break;
-	case NC_BYTE:   min = X_BYTE_MIN;   max = X_BYTE_MAX; break;
-	case NC_SHORT:  min = X_SHORT_MIN;  max = X_SHORT_MAX; break;
-	case NC_INT:   min = X_INT_MIN;   max = X_INT_MAX; break;
-	case NC_FLOAT:  min = X_FLOAT_MIN;  max = X_FLOAT_MAX; break;
-	case NC_DOUBLE: min = X_DOUBLE_MIN; max = X_DOUBLE_MAX; break;
+        case NC_CHAR:   return value >= X_CHAR_MIN   && value <= X_CHAR_MAX;
+        case NC_BYTE:   return value >= X_BYTE_MIN   && value <= X_BYTE_MAX;
+        case NC_SHORT:  return value >= X_SHORT_MIN  && value <= X_SHORT_MAX;
+        case NC_INT:    return value >= X_INT_MIN    && value <= X_INT_MAX;
+        case NC_FLOAT:  return value >= X_FLOAT_MIN  && value <= X_FLOAT_MAX;
+        case NC_DOUBLE: return value >= X_DOUBLE_MIN && value <= X_DOUBLE_MAX;
+        case NC_UBYTE:  return value >= 0            && value <= X_UCHAR_MAX;
+        case NC_USHORT: return value >= 0            && value <= X_USHORT_MAX;
+        case NC_UINT:   return value >= 0            && value <= X_UINT_MAX;
+        case NC_INT64:  return value >= X_INT64_MIN  && value <= X_INT64_MAX;
+        case NC_UINT64: return value >= 0            && value <= X_UINT64_MAX;
 	default:  assert(0);
     }
     return value >= min && value <= max;
@@ -45,6 +50,22 @@
 }
 
 static int
+inRange_schar(const double value, const nc_type datatype)
+{
+    /* check value of type datatype if within schar range */
+
+    if (datatype == NC_UBYTE) {
+        /* netCDF specification make a special case for type conversion between
+         * uchar and scahr: do not check for range error. See
+         * http://www.unidata.ucar.edu/software/netcdf/docs_rc/data_type.html#type_conversion
+         */
+        return(value >= X_CHAR_MIN && value <= X_CHAR_MAX);
+    }
+    /* else */
+    return inRange(value, datatype);
+}
+
+static int
 inRange_float(const double value, const nc_type datatype)
 {
     double min, max;
@@ -72,6 +93,11 @@
 			max = X_DOUBLE_MAX;
 		}
 		break;
+        case NC_UBYTE:  min = 0;            max = X_UCHAR_MAX;  break;
+        case NC_USHORT: min = 0;            max = X_USHORT_MAX; break;
+        case NC_UINT:   min = 0;            max = X_UINT_MAX;   break;
+        case NC_INT64:  min = X_INT64_MIN;  max = X_INT64_MAX;  break;
+        case NC_UINT64: min = 0;            max = X_UINT64_MAX; break;
 	default:  assert(0);
     }
     if(!( value >= min && value <= max)) {
@@ -104,6 +130,9 @@
     const nct_itype itype)
 {
     switch (itype) {
+        case NCT_SCHAR:
+        case NCT_CHAR:
+            return inRange_schar(value, datatype);
     case NCT_UCHAR:
 	return inRange_uchar(value, datatype);
     case NCT_FLOAT:
@@ -239,13 +268,22 @@
         case NC_SHORT: *result = *((short *) p); break;
         case NC_INT:
 #if INT_MAX >= X_INT_MAX
-		*result = *((int *) p);
+		*result = *((int *) p); break;
 #else
-		*result = *((long *) p);
+		*result = *((long *) p); break;
 #endif
-		break;
         case NC_FLOAT: *result = *((float *) p); break;
         case NC_DOUBLE: *result = *((double *) p); break;
+        case NC_UBYTE:  *result = *((unsigned char *)  p); break;
+        case NC_USHORT: *result = *((unsigned short *) p); break;
+        case NC_UINT:
+#if UINT_MAX >= X_UINT_MAX
+            *result = *((unsigned int *) p); break;
+#else
+            *result = *((unsigned long *) p); break;
+#endif
+        case NC_INT64:  *result = *((long long *)          p); break;
+        case NC_UINT64: *result = *((unsigned long long *) p); break;
         default: return 1;
     }
     return 0;
@@ -290,6 +328,35 @@
             case NC_DOUBLE:
                 *((double *) p) = d;
                 break;
+        case NC_UBYTE:
+            r = floor(0.5+d);
+            if ( r < 0.0  ||  r > uchar_max )  return 2;
+            *((unsigned char *) p) = r;
+            break;
+        case NC_USHORT:
+            r = floor(0.5+d);
+            if ( r < 0.0  ||  r > ushort_max )  return 2;
+            *((unsigned short *) p) = r;
+            break;
+        case NC_UINT:
+            r = floor(0.5+d);
+            if ( r < 0.0  ||  r > uint_max )  return 2;
+#if UINT_MAX >= X_UINT_MAX
+            *((unsigned int  *) p) = r;
+#else
+            *((unsigned long *) p) = r;
+#endif
+            break;
+        case NC_INT64:
+            r = floor(0.5+d);
+            if ( r < int64_min  ||  r > int64_max )  return 2;
+            *((long long *) p) = r;
+            break;
+        case NC_UINT64:
+            r = floor(0.5+d);
+            if ( r < 0.0  ||  r > uint64_max )  return 2;
+            *((unsigned long long *) p) = r;
+            break;
             default:
                 return 1;
         }
@@ -322,6 +389,12 @@
 		    case NC_INT:   return X_INT_MIN;
 		    case NC_FLOAT:  return X_FLOAT_MIN;
 		    case NC_DOUBLE: return X_DOUBLE_MIN;
+                    case NC_UBYTE:  return 0;
+                    case NC_USHORT: return 0;
+                    case NC_UINT:   return 0;
+                    case NC_INT64:  return X_INT_MIN - 128.0; /* slight smaller
+                                                                 than INT_MIN */
+                    case NC_UINT64: return 0;
 		    default:  assert(0);
 		}
 	    case 1:
@@ -332,6 +405,13 @@
 		    case NC_INT:   return X_INT_MAX;
 		    case NC_FLOAT:  return X_FLOAT_MAX;
 		    case NC_DOUBLE: return X_DOUBLE_MAX;
+                    case NC_UBYTE:  return X_UCHAR_MAX;
+                    case NC_USHORT: return X_USHORT_MAX;
+                    case NC_UINT:   return X_UINT_MAX;
+                    case NC_INT64:  return X_INT_MAX + 128.0;
+                                    /* slightly bigger than INT_MAX */
+                    case NC_UINT64: return X_UINT_MAX + 128.0;
+                                    /* slightly bigger than UINT_MAX */
 		    default:  assert(0);
 		}
 	    case 2:
@@ -342,6 +422,11 @@
 		    case NC_INT:   return X_INT_MIN-1.0;
 		    case NC_FLOAT:  return X_FLOAT_MIN * (1.0 + FUZZ);
 		    case NC_DOUBLE: return -1.0;
+                    case NC_UBYTE:  return -1.0;
+                    case NC_USHORT: return -1.0;
+                    case NC_UINT:   return -1.0;
+                    case NC_INT64:  return -1.0;  /* skip test */
+                    case NC_UINT64: return -1.0;
 		    default:  assert(0);
 		}
 	    case 3:
@@ -352,6 +437,11 @@
 		    case NC_INT:   return X_INT_MAX+1.0;
 		    case NC_FLOAT:  return X_FLOAT_MAX * (1.0 + FUZZ);
 		    case NC_DOUBLE: return 1.0;
+                    case NC_UBYTE:  return X_UCHAR_MAX +1.0;
+                    case NC_USHORT: return X_USHORT_MAX+1.0;
+                    case NC_UINT:   return X_UINT_MAX  +1.0;
+                    case NC_INT64:  return 1.0;    /* skip test */
+                    case NC_UINT64: return 1.0;    /* skip test */
 		    default:  assert(0);
 		}
 	}
@@ -363,6 +453,13 @@
 	    case NC_INT: base = -20; break;
 	    case NC_FLOAT: base = -9; break;
 	    case NC_DOUBLE: base = -10; break;
+
+            /* not sure what right values are */
+            case NC_UBYTE:   base =   2;  break;
+            case NC_USHORT:  base =   5;  break;
+            case NC_UINT:    base =  20;  break;
+            case NC_INT64:   base = -20;  break;
+            case NC_UINT64:  base =  20;  break;
 	    default:  assert(0);
 	}
 	result = rank < 0 ? base * 7 : base * (rank + 1);
@@ -397,6 +494,12 @@
 		    case NC_INT:   return SANE_INT;
 		    case NC_FLOAT:  return SANE_FLOAT;
 		    case NC_DOUBLE: return SANE_DOUBLE;
+                    case NC_UBYTE:  return 0;
+                    case NC_USHORT: return 0;
+                    case NC_UINT:   return 0;
+                    case NC_INT64:  return X_INT_MIN - 128.0; /* slight smaller
+                                                                 than INT_MIN */
+                    case NC_UINT64: return 0;
 		    default:  assert(0);
 		}
 	    case 1:
@@ -407,6 +510,13 @@
 		    case NC_INT:   return SANE_INT;
 		    case NC_FLOAT:  return SANE_FLOAT;
 		    case NC_DOUBLE: return SANE_DOUBLE;
+                    case NC_UBYTE:  return X_UCHAR_MAX;
+                    case NC_USHORT: return X_USHORT_MAX;
+                    case NC_UINT:   return X_UINT_MAX;
+                    case NC_INT64:  return X_INT_MAX + 128.0;
+                                    /* slightly bigger than INT_MAX */
+                    case NC_UINT64: return X_UINT_MAX + 128.0;
+                                    /* slightly bigger than UINT_MAX */
 		    default:  assert(0);
 		}
 	    case 2:
@@ -417,6 +527,11 @@
 		    case NC_INT:   return SANE_INT-1.0;
 		    case NC_FLOAT:  return SANE_FLOAT * (1.0 + FUZZ);
 		    case NC_DOUBLE: return -1.0;
+                    case NC_UBYTE:  return -1.0;
+                    case NC_USHORT: return -1.0;
+                    case NC_UINT:   return -1.0;
+                    case NC_INT64:  return -1.0;  /* skip test */
+                    case NC_UINT64: return -1.0;
 		    default:  assert(0);
 		}
 	    case 3:
@@ -427,6 +542,11 @@
 		    case NC_INT:   return SANE_INT+1.0;
 		    case NC_FLOAT:  return SANE_FLOAT * (1.0 + FUZZ);
 		    case NC_DOUBLE: return 1.0;
+                    case NC_UBYTE:  return X_UCHAR_MAX +1.0;
+                    case NC_USHORT: return X_USHORT_MAX+1.0;
+                    case NC_UINT:   return X_UINT_MAX  +1.0;
+                    case NC_INT64:  return 1.0;    /* skip test */
+                    case NC_UINT64: return 1.0;    /* skip test */
 		    default:  assert(0);
 		}
 	}
@@ -438,6 +558,13 @@
 	    case NC_INT: base = -20; break;
 	    case NC_FLOAT: base = -9; break;
 	    case NC_DOUBLE: base = -10; break;
+
+            /* not sure what right values are */
+            case NC_UBYTE:   base =   2;  break;
+            case NC_USHORT:  base =   5;  break;
+            case NC_UINT:    base =  20;  break;
+            case NC_INT64:   base = -20;  break;
+            case NC_UINT64:  base =  20;  break;
 	    default:  assert(0);
 	}
 	result = rank < 0 ? base * 7 : base * (rank + 1);
@@ -472,6 +599,11 @@
         case 'i': return NC_INT;
         case 'f': return NC_FLOAT;
         case 'd': return NC_DOUBLE;
+        case 'y': return NC_UBYTE;
+        case 't': return NC_USHORT;
+        case 'u': return NC_UINT;
+        case 'x': return NC_INT64;
+        case 'z': return NC_UINT64;
         default:  assert(0);
     }
     return NC_CHAR;  /* Just to keep compiler happy */
@@ -495,7 +627,7 @@
 init_gatts(const char *type_letter)
 {
 	int attid;
-	for (attid = 0; attid < NGATTS; attid++)
+	for (attid = 0; attid < numGatts; attid++)
 	{
 		gatt_name[attid][0] = 'G';
 		gatt_name[attid][1] = type_letter[attid];
@@ -528,7 +660,10 @@
 		MAX_DIM_LEN,
 		MAX_DIM_LEN
 	};
-	const char type_letter[] = "cbsifd";
+    const char type_letter[] = "cbsifdytuxz";
+    /* c:char, b:byte, s:short, i:int, f:float, d:double, y:ubyte, t:ushort,
+     * u:uint, x:int64, z:uint64
+     */
 	const char digit[] = "r123456789";
 
 	size_t rank;
@@ -540,6 +675,9 @@
 
 	init_dims(digit);
 
+	for (vn=0; vn<numVars; vn++)
+	    memset(var_name[vn], 0, 2+MAX_RANK);
+
 	for (rank = 0, vn = 0, xtype = 0, an = 0;  rank <= MAX_RANK; rank++)
 	{
 			/* number variables of a type and rank */
@@ -549,11 +687,11 @@
 		for (jj = 0; jj < nvars; jj++)
 		{
 				/* number types of this shape */
-			const int ntypes = rank < 2 ? NTYPES : 1;
+			const int ntypes = rank < 2 ? numTypes : 1;
 
 			int tc;
 			for (tc = 0; tc < ntypes;
-			     tc++, vn++, xtype = (xtype + 1) % NTYPES)
+			     tc++, vn++, xtype = (xtype + 1) % numTypes)
 			{
 				size_t tmp[MAX_RANK];
 
@@ -565,10 +703,10 @@
 					int ac;
 					for (ac = 0; ac < var_natts[vn]; ac++, an++)
 					{
-						att_name[vn][ac][0] = type_letter[an % NTYPES];
+						att_name[vn][ac][0] = type_letter[an % numTypes];
 						att_name[vn][ac][1] = '\0';
 						att_len[vn][ac] = an;
-						att_type[vn][ac] = char2type (type_letter[an % NTYPES]);
+						att_type[vn][ac] = char2type (type_letter[an % numTypes]);
 					}
 				} /* ac block */
 #ifndef NDEBUG
@@ -622,7 +760,7 @@
     int  i;
     int var_id;
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	err = nc_def_var(ncid, var_name[i], var_type[i], var_rank[i],
 	    var_dimid[i], &var_id);
 	IF (err) error("nc_def_var: %s", nc_strerror(err));
@@ -642,7 +780,7 @@
     double att[MAX_NELS];
     char catt[MAX_NELS];
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	for (j = 0; j < NATTS(i); j++) {
 	    if (ATT_TYPE(i,j) == NC_CHAR) {
 		for (k = 0; k < ATT_LEN(i,j); k++) {
@@ -686,7 +824,7 @@
 
     for (j = 0; j < MAX_RANK; j++)
 	start[j] = 0;
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
 	for (allInRange = 1, j = 0; j < var_nels[i]; j++) {
 	    err = toMixedBase(j, var_rank[i], var_shape[i], index);
 	    IF (err) error("toMixedBase");
@@ -722,7 +860,11 @@
     int  ncid;			/* netCDF id */
     int  err;		/* status */
 
+#ifdef TEST_PNETCDF
+    err = nc_create_par(filename, NC_CLOBBER|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_create(filename, NC_CLOBBER, &ncid);
+#endif
     IF (err) 
 	error("nc_create: %s", nc_strerror(err));
 
@@ -784,7 +926,7 @@
     size_t length;
     int nok = 0;      /* count of valid comparisons */
 
-    for (i = 0; i < NVARS; i++) {
+    for (i = 0; i < numVars; i++) {
         isChar = var_type[i] == NC_CHAR;
 	err = nc_inq_var(ncid, i, name, &datatype, &ndims, dimids, NULL);
 	IF (err) 
@@ -866,7 +1008,7 @@
     double expect;
     int nok = 0;      /* count of valid comparisons */
 
-    for (i = -1; i < NVARS; i++) {
+    for (i = -1; i < numVars; i++) {
 	for (j = 0; j < NATTS(i); j++) {
             err = nc_inq_attname(ncid, i, j, name);
             IF (err) 
@@ -919,7 +1061,11 @@
     int  ncid;		/* netCDF id */
     int  err;		/* status */
 
+#ifdef TEST_PNETCDF
+    err = nc_open_par(filename, NC_NOWRITE|NC_PNETCDF, MPI_COMM_WORLD, MPI_INFO_NULL, &ncid);
+#else
     err = nc_open(filename, NC_NOWRITE, &ncid);
+#endif
     IF (err) {
         error("nc_open: %s", nc_strerror(err));
     } else {
@@ -937,18 +1083,17 @@
 s_nc_type(nc_type type)
 {
 	switch((int)type){
-	case NC_BYTE:
-		return "NC_BYTE";
-	case NC_CHAR:
-		return "NC_CHAR";
-	case NC_SHORT:
-		return "NC_SHORT";
-	case NC_INT:
-		return "NC_INT";
-	case NC_FLOAT:
-		return "NC_FLOAT";
-	case NC_DOUBLE:
-		return "NC_DOUBLE";
+        case NC_CHAR:   return "NC_CHAR";
+        case NC_BYTE:   return "NC_BYTE";
+        case NC_UBYTE:  return "NC_UBYTE";
+        case NC_SHORT:  return "NC_SHORT";
+        case NC_USHORT: return "NC_USHORT";
+        case NC_INT:    return "NC_INT";
+        case NC_UINT:   return "NC_UINT";
+        case NC_FLOAT:  return "NC_FLOAT";
+        case NC_DOUBLE: return "NC_DOUBLE";
+        case NC_INT64:  return "NC_INT64";
+        case NC_UINT64: return "NC_UINT64";
 	}
 	return "";
 }
diff netcdf-c/nc_test4/bm_file.c cdf5/nc_test4/bm_file.c
--- netcdf-c/nc_test4/bm_file.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test4/bm_file.c	2014-11-14 14:54:46.070405200 -0700
@@ -868,9 +868,12 @@
 	    {
 	       case NC_FORMAT_CLASSIC:
 		  break;
-	       case NC_FORMAT_64BIT:
+	       case NC_FORMAT_CDF2:
 		  cmode = NC_64BIT_OFFSET;
 		  break;
+	       case NC_FORMAT_CDF5:
+		  cmode = NC_64BIT_DATA;
+		  break;
 	       case NC_FORMAT_NETCDF4:
 		  cmode = NC_NETCDF4;
 		  break;
diff netcdf-c/nc_test4/tst_converts.c cdf5/nc_test4/tst_converts.c
--- netcdf-c/nc_test4/tst_converts.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test4/tst_converts.c	2014-11-14 14:54:46.071381700 -0700
@@ -53,8 +53,10 @@
    int ncid, varid, cflags=0, dimids[1];
    int retval;
 
-   if (format == NC_FORMAT_64BIT)
+   if (format == NC_FORMAT_CDF2)
       cflags |= NC_64BIT_OFFSET;
+   else if (format == NC_FORMAT_CDF5)
+      cflags |= NC_64BIT_DATA;
    else if (format == NC_FORMAT_NETCDF4_CLASSIC)
    {
       cflags |= (NC_NETCDF4|NC_CLASSIC_MODEL);
diff netcdf-c/nc_test4/tst_files.c cdf5/nc_test4/tst_files.c
--- netcdf-c/nc_test4/tst_files.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/nc_test4/tst_files.c	2014-11-14 14:54:46.071381700 -0700
@@ -259,7 +259,7 @@
    test_redef(NC_FORMAT_CLASSIC);
    SUMMARIZE_ERR;
    printf("*** testing redef for netCDF 64-bit offset...");
-   test_redef(NC_FORMAT_64BIT);
+   test_redef(NC_FORMAT_CDF2);
    SUMMARIZE_ERR;
    printf("*** testing redef for netCDF-4 ...");
    test_redef(NC_FORMAT_NETCDF4);
@@ -281,7 +281,7 @@
       /* Create a netcdf-3 64-bit offset file. */
       if (nc_create(FILE_NAME, NC_64BIT_OFFSET|NC_CLOBBER, &ncid)) ERR;
       if (nc_inq_format(ncid, &format)) ERR;
-      if (format != NC_FORMAT_64BIT) ERR;
+      if (format != NC_FORMAT_CDF2) ERR;
       if (nc_close(ncid)) ERR;
 
       /* Create a netcdf-4 file. */
@@ -305,7 +305,7 @@
       /* Create a netcdf-3 64-bit offset file. */
       if (nc_create(FILE_NAME, NC_64BIT_OFFSET|NC_CLOBBER|NC_CLASSIC_MODEL, &ncid)) ERR;
       if (nc_inq_format(ncid, &format)) ERR;
-      if (format != NC_FORMAT_64BIT) ERR;
+      if (format != NC_FORMAT_CDF2) ERR;
       if (nc_close(ncid)) ERR;
    }
    SUMMARIZE_ERR;
@@ -395,8 +395,10 @@
    float cache_preemption_in;
    int ret;
 
-   if (format == NC_FORMAT_64BIT)
+   if (format == NC_FORMAT_CDF2)
       cflags |= NC_64BIT_OFFSET;
+   else if (format == NC_FORMAT_CDF5)
+      cflags |= NC_64BIT_DATA;
    else if (format == NC_FORMAT_NETCDF4_CLASSIC)
       cflags |= (NC_NETCDF4|NC_CLASSIC_MODEL);
    else if (format == NC_FORMAT_NETCDF4)
diff netcdf-c/ncdump/nccopy.c cdf5/ncdump/nccopy.c
--- netcdf-c/ncdump/nccopy.c	2015-03-09 13:48:02.810835600 -0600
+++ cdf5/ncdump/nccopy.c	2014-11-14 14:54:46.073334700 -0700
@@ -3,7 +3,7 @@
  *   See netcdf/README file for copying and redistribution conditions.
  *   Thanks to Philippe Poilbarbe and Antonio S. Cofiño for 
  *   compression additions.
- *   $Id: nccopy.c 400 2010-08-27 21:02:52Z russ $
+ *   $Id: nccopy.c 2796 2014-10-28 03:40:29Z wkliao $
  *********************************************************************/
 
 #include "config.h"		/* for USE_NETCDF4 macro */
@@ -1154,7 +1154,8 @@
  * to copy data a record at a time. */
 static int
 nc3_special_case(int ncid, int kind) {
-    if (kind == NC_FORMAT_CLASSIC ||  kind == NC_FORMAT_64BIT) {
+    if (kind == NC_FORMAT_CLASSIC ||  kind == NC_FORMAT_CDF2 ||
+        kind == NC_FORMAT_CDF5) {
 	int recdimid = 0;
 	NC_CHECK(nc_inq_unlimdim(ncid, &recdimid));
 	if (recdimid != -1) {	/* we have a record dimension */
@@ -1364,7 +1365,8 @@
     if (option_kind == SAME_AS_INPUT) {	/* default, kind not specified */
 	outkind = inkind;
 	/* Deduce output kind if netCDF-4 features requested */
-	if (inkind == NC_FORMAT_CLASSIC || inkind == NC_FORMAT_64BIT) { 
+	if (inkind == NC_FORMAT_CLASSIC || inkind == NC_FORMAT_CDF2 ||
+	    inkind == NC_FORMAT_CDF5) { 
 	    if (option_deflate_level > 0 || 
 		option_shuffle_vars == NC_SHUFFLE || 
 		option_chunkspec) 
@@ -1402,9 +1404,12 @@
     case NC_FORMAT_CLASSIC:
 	/* nothing to do */
 	break;
-    case NC_FORMAT_64BIT:
+    case NC_FORMAT_CDF2:
 	create_mode |= NC_64BIT_OFFSET;
 	break;
+    case NC_FORMAT_CDF5:
+	create_mode |= NC_64BIT_DATA;
+	break;
 #ifdef USE_NETCDF4
     case NC_FORMAT_NETCDF4:
 	create_mode |= NC_NETCDF4;
@@ -1510,7 +1515,8 @@
 {
 #define USAGE   "\
   [-k n]    specify kind of netCDF format for output file, default same as input\n\
-	    1 classic, 2 64-bit offset, 3 netCDF-4, 4 netCDF-4 classic model\n\
+	    1 classic, 2 64-bit offset, 3 netCDF-4, 4 netCDF-4 classic model,\n\
+	    5 classic CDF-5\n\
   [-d n]    set deflation compression level, default same as input (0=none 9=max)\n\
   [-s]      add shuffle option to deflation compression\n\
   [-c chunkspec] specify chunking for dimensions, e.g. \"dim1/N1,dim2/N2,...\"\n\
@@ -1523,7 +1529,7 @@
   [-m n]    set size in bytes of copy buffer, default is 5000000 bytes\n\
   [-h n]    set size in bytes of chunk_cache for chunked variables\n\
   [-e n]    set number of elements that chunk_cache can hold\n\
-  [-r]      read whole input file into diskless file on open (classic or 64-bit offset format only)\n\
+  [-r]      read whole input file into diskless file on open (classic or 64-bit offset/data format only)\n\
   infile    name of netCDF input file\n\
   outfile   name for netCDF output file\n"
 
@@ -1550,9 +1556,9 @@
 	{"classic", NC_FORMAT_CLASSIC},
 	
 	/* The 64-bit offset kind (2) */
-	{"2", NC_FORMAT_64BIT},
-	{"64-bit-offset", NC_FORMAT_64BIT},
-	{"64-bit offset", NC_FORMAT_64BIT},
+	{"2", NC_FORMAT_CDF2},
+	{"64-bit-offset", NC_FORMAT_CDF2},
+	{"64-bit offset", NC_FORMAT_CDF2},
 	
 	/* NetCDF-4 HDF5 format */
 	{"3", NC_FORMAT_NETCDF4},
@@ -1568,6 +1574,11 @@
 	{"netCDF4_classic", NC_FORMAT_NETCDF4_CLASSIC},
 	{"enhanced-nc3", NC_FORMAT_NETCDF4_CLASSIC},
 
+	/* The 64-bit data kind (5) */
+	{"5", NC_FORMAT_CDF5},
+	{"64-bit-data", NC_FORMAT_CDF5},
+	{"64-bit data", NC_FORMAT_CDF5},
+	
 	/* null terminate*/
 	{NULL,0}
     };
@@ -1588,12 +1599,15 @@
                      2 (=> classic 64 bit offsets)
                      3 (=> netCDF-4/HDF5)
                      4 (=> classic, but stored in netCDF-4/HDF5 format)
+                     5 (=> classic 64 bit data, CDF-5)
                      Also allow string versions of above
                      "classic"
                      "64-bit-offset"
                      "64-bit offset"
 		     "enhanced" | "hdf5" | "netCDF-4"
                      "enhanced-nc3" | "hdf5-nc3" | "netCDF-4 classic model"
+                     "64-bit-data"
+                     "64-bit data"
 		   */
 	    {
 		struct Kvalues* kvalue;
diff netcdf-c/ncdump/ncdump.c cdf5/ncdump/ncdump.c
--- netcdf-c/ncdump/ncdump.c	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/ncdump/ncdump.c	2014-11-14 14:54:46.081146700 -0700
@@ -162,7 +162,6 @@
 	return "float";
       case NC_DOUBLE:
 	return "double";
-#ifdef USE_NETCDF4
       case NC_UBYTE:
 	return "ubyte";
       case NC_USHORT:
@@ -173,6 +172,7 @@
 	return "int64";
       case NC_UINT64:
 	return "uint64";
+#ifdef USE_NETCDF4
       case NC_STRING:
 	return "string";
       case NC_VLEN:
@@ -226,8 +226,10 @@
     switch (kind) {
     case NC_FORMAT_CLASSIC:
 	return "classic";
-    case NC_FORMAT_64BIT:
+    case NC_FORMAT_CDF2:
 	return "64-bit offset";
+    case NC_FORMAT_CDF5:
+	return "64-bit data";
     case NC_FORMAT_NETCDF4:
 	return "netCDF-4";
     case NC_FORMAT_NETCDF4_CLASSIC:
@@ -246,7 +248,9 @@
     static char text[1024];
     switch (kind) {
     case NC_FORMAT_NC3:
-	if(mode & NC_64BIT_OFFSET)
+	if(mode & NC_64BIT_DATA)
+	    snprintf(text,sizeof(text),"%s mode=%08x", "64-bit data",mode);
+	else if(mode & NC_64BIT_OFFSET)
 	    snprintf(text,sizeof(text),"%s mode=%08x", "64-bit offset",mode);
 	else
 	    snprintf(text,sizeof(text),"%s mode=%08x", "classic",mode);
@@ -320,7 +324,7 @@
 	    break;
 	case '\n':		
 	    /* Only generate linebreaks after embedded newlines for
-	     * classic, 64-bit offset, or classic model files.  For
+	     * classic, 64-bit offset/data, or classic model files.  For
 	     * netCDF-4 files, don't generate linebreaks, because that
 	     * would create an extra string in a list of strings.  */
 	    if (kind != NC_FORMAT_NETCDF4) {
@@ -435,12 +439,12 @@
     char gps[PRIM_LEN];
     float ff;
     double dd;
-#ifdef USE_NETCDF4
     unsigned char uc;
     unsigned short us;
     unsigned int ui;
     int64_t i64;
     uint64_t ui64;
+#ifdef USE_NETCDF4
     char *stringp;
 #endif /* USE_NETCDF4 */
     char *delim = ", ";	/* delimiter between output values */
@@ -505,7 +509,6 @@
 		}
 	    }
 	    break;
-#ifdef USE_NETCDF4
 	case NC_UBYTE:
 	    uc = ((unsigned char *) vals)[iel];
 	    printf ("%uUB%s", uc, delim);
@@ -526,6 +529,7 @@
 	    ui64 = ((uint64_t *) vals)[iel];
 	    printf ("%lluUL%s", ui64, delim);
 	    break;
+#ifdef USE_NETCDF4
 	case NC_STRING:
 	    stringp = ((char **) vals)[iel];
             if(stringp)
@@ -561,11 +565,9 @@
     float ff;
     double dd;
     int ii;
-#ifdef USE_NETCDF4
     unsigned int ui;
     int64_t i64;
     uint64_t ui64;
-#endif /* USE_NETCDF4 */
 
     attvals[0]='\0';
     if (len == 0)
@@ -583,7 +585,6 @@
 	    (void) strlcat(attvals, gps, attvalslen);
 	    (void) strlcat(attvals, iel < len-1 ? " " : "", attvalslen);
 	    break;
-#ifdef USE_NETCDF4
 	case NC_UBYTE:
 	case NC_USHORT:
 	case NC_UINT:
@@ -607,7 +608,6 @@
 	    (void) strlcat(attvals, gps, attvalslen);
 	    (void) strlcat(attvals, iel < len-1 ? " " : "", attvalslen);
 	    break;
-#endif /* USE_NETCDF4 */
 	case NC_FLOAT:
 	    ff = vals[iel];
 	    res = snprintf(gps, PRIM_LEN, float_attx_fmt, ff);
@@ -1107,7 +1107,6 @@
 	case NC_INT:
 	    memval = *(int *)&data;
 	    break;
-#ifdef USE_NETCDF4
 	case NC_UBYTE:
 	    memval = *(unsigned char *)&data;
 	    break;
@@ -1123,7 +1122,6 @@
 	case NC_UINT64:
 	    memval = *(uint64_t *)&data;
 	    break;
-#endif /* USE_NETCDF4 */
 	default:
 	    error("Bad base type for enum!");
 	    break;
@@ -1262,7 +1260,6 @@
 	case NC_DOUBLE:
 	    *(double *)fillvalp = NC_FILL_DOUBLE;
 	    break;
-#ifdef USE_NETCDF4
 	case NC_UBYTE:
 	    /* don't do default fill-values for bytes, too risky */
 	    vp->has_fillval = 0;
@@ -1281,6 +1278,7 @@
 	case NC_UINT64:
 	    *(uint64_t *)fillvalp = NC_FILL_UINT64;
 	    break;
+#ifdef USE_NETCDF4
 	case NC_STRING:
 	    *((char **)fillvalp) = strdup(NC_FILL_STRING);
 	    break;
@@ -1469,7 +1467,7 @@
    /* Because netCDF-4 can have a string attribute with multiple
     * string values, we can't output strings with embedded newlines
     * as what look like multiple strings, as we do for classic and
-    * 64-bit offset files.  So we need to know the output file type
+    * 64-bit offset/data files.  So we need to know the output file type
     * to know how to print strings with embedded newlines. */
    NC_CHECK( nc_inq_format(ncid, &kind) );
        
diff netcdf-c/ncdump/tst_64bit.sh cdf5/ncdump/tst_64bit.sh
--- netcdf-c/ncdump/tst_64bit.sh	2014-04-14 17:59:12.184677500 -0600
+++ cdf5/ncdump/tst_64bit.sh	2014-11-14 14:54:46.089935200 -0700
@@ -6,13 +6,28 @@
 echo "*** Testing ncgen and ncdump with 64-bit offset format."
 set -e
 echo "*** creating test0.nc from test0.cdl..."
-../ncgen/ncgen -b -v2 $srcdir/test0.cdl
+../ncgen/ncgen -b -k2 $srcdir/test0.cdl
 echo "*** creating test1.cdl from test0.nc..."
 ./ncdump -n test1 test0.nc > test1.cdl
 echo "*** creating test1.nc from test1.cdl..."
-../ncgen/ncgen -b -v2 test1.cdl
+../ncgen/ncgen -b -k2 test1.cdl
 echo "*** creating test2.cdl from test1.nc..."
 ./ncdump test1.nc > test2.cdl
 cmp test1.cdl test2.cdl
 echo "*** All ncgen and ncdump with 64-bit offset format tests passed!"
+
+echo ""
+echo "*** Testing ncgen and ncdump with 64-bit data format."
+set -e
+echo "*** creating test0.nc from test0.cdl..."
+../ncgen/ncgen -b -k5 $srcdir/test0.cdl
+echo "*** creating test1.cdl from test0.nc..."
+./ncdump -n test1 test0.nc > test1.cdl
+echo "*** creating test1.nc from test1.cdl..."
+../ncgen/ncgen -b -k5 test1.cdl
+echo "*** creating test2.cdl from test1.nc..."
+./ncdump test1.nc > test2.cdl
+cmp test1.cdl test2.cdl
+echo "*** All ncgen and ncdump with 64-bit data format tests passed!"
+
 exit 0
diff netcdf-c/ncdump/tst_formatx3.sh cdf5/ncdump/tst_formatx3.sh
--- netcdf-c/ncdump/tst_formatx3.sh	2015-03-09 13:48:02.826460700 -0600
+++ cdf5/ncdump/tst_formatx3.sh	2014-11-14 14:54:46.090911700 -0700
@@ -30,6 +30,15 @@
 ECODE=1
 fi
 
+echo "Test extended format output for a 64-bit CDF-5 classic file"
+rm -f tmp
+../ncgen/ncgen -k5 -b -o ./test.nc $srcdir/ref_tst_small.cdl
+./ncdump -K test.nc >tmp
+if ! fgrep '64-bit data mode=00000010' <tmp ; then
+echo "*** Fail: extended format for a 64-bit CDF-5 classic file"
+ECODE=1
+fi
+
 rm -f tmp test.nc
 
 exit $ECODE
diff netcdf-c/ncdump/tst_lengths.sh cdf5/ncdump/tst_lengths.sh
--- netcdf-c/ncdump/tst_lengths.sh	2015-03-09 13:48:02.842085800 -0600
+++ cdf5/ncdump/tst_lengths.sh	2014-11-14 14:54:46.091888200 -0700
@@ -82,6 +82,30 @@
     exit 1
 fi
 
+echo "*** testing length of 64-bit data file"
+../ncgen/ncgen -b -k64-bit-data ${srcdir}/small.cdl
+if test `wc -c < small.nc` != 104; then
+    exit 1
+fi
+
+echo "*** testing length of 64-bit data file written with NOFILL"
+../ncgen/ncgen -b -k64-bit-data -x ${srcdir}/small.cdl
+if test `wc -c < small.nc` != 104; then
+    exit 1
+fi
+
+echo "*** testing length of rewritten 64-bit data file"
+../ncgen/ncgen -b -k64-bit-data ${srcdir}/small.cdl && ./rewrite-scalar small.nc t
+if test `wc -c < small.nc` != 104; then
+    exit 1
+fi
+
+echo "*** testing length of rewritten 64-bit data file written with NOFILL"
+../ncgen/ncgen -b -k64-bit-data -x ${srcdir}/small.cdl && ./rewrite-scalar small.nc t
+if test `wc -c < small.nc` != 104; then
+    exit 1
+fi
+
 # test with only one record variable of type byte or short, which need
 # not be 4-byte aligned
 echo "*** testing length of one-record-variable classic file"
@@ -107,3 +131,16 @@
 if test `wc -c < small2.nc` != 105; then
     exit 1
 fi
+
+echo "*** testing length of one-record-variable 64-bit data file"
+../ncgen/ncgen -b -k64-bit-data ${srcdir}/small2.cdl
+if test `wc -c < small2.nc` != 161; then
+    exit 1
+fi
+
+echo "*** testing length of one-record-variable 64-bit data file written with NOFILL"
+../ncgen/ncgen -b -k64-bit-data -x ${srcdir}/small2.cdl
+if test `wc -c < small2.nc` != 161; then
+    exit 1
+fi
+
diff netcdf-c/ncgen/escapes.c cdf5/ncgen/escapes.c
--- netcdf-c/ncgen/escapes.c	2014-11-14 15:15:16.659820900 -0700
+++ cdf5/ncgen/escapes.c	2014-11-14 13:32:35.095301200 -0700
@@ -461,13 +461,13 @@
 contain utf8 characters to one that is
 acceptable to the Java compiler.
 Basically this means convert the printables
-using ccodify (above) equivalent and then escape
+using codify (above) equivalent and then escape
 all the utf chars.
 */
 static char*
 jcodify (const char *name)
 {
-    return ccodify(name);
+    return codify(name);
 }
 
 /**************************************************/
diff netcdf-c/ncgen/genc.c cdf5/ncgen/genc.c
--- netcdf-c/ncgen/genc.c	2015-02-19 15:13:49.857088300 -0700
+++ cdf5/ncgen/genc.c	2014-11-14 14:54:46.093841200 -0700
@@ -1140,14 +1140,13 @@
 	codedump(stmt);
 	break;
 
-#ifdef USE_NETCDF4
     /* !usingclassic only (except NC_STRING) */
     case NC_UBYTE:
     case NC_USHORT:
     case NC_UINT:
     case NC_INT64:
     case NC_UINT64:
-	if(usingclassic) {
+	if(usingclassic && k_flag <= 2) {
 	    verror("Non-classic type: %s",nctypename(basetype->typ.typecode));
 	    return;
 	}
@@ -1180,7 +1179,6 @@
 		cname(asym));
 	codedump(stmt);
 	break;
-#endif
 
     default: /* User defined type */
 #ifndef USE_NETCDF4
diff netcdf-c/ncgen/genlib.h cdf5/ncgen/genlib.h
--- netcdf-c/ncgen/genlib.h	2014-11-14 15:14:32.052158900 -0700
+++ cdf5/ncgen/genlib.h	2014-11-14 14:54:46.094817700 -0700
@@ -160,7 +160,8 @@
 extern int format_attribute; /* 1 if format came from _FORMAT attribute */
 extern int enhanced_flag; /* 1 => netcdf-4 constructs appear in the parse */
 extern int specials_flag; /* 1 => special attributes are present */
-extern int usingclassic;   /* 1 => k_flag == 1|2 */
+extern int usingclassic;   /* 1 => k_flag == 1|2|5 */
+extern int k_flag;
 
 /* Global data */
 
diff netcdf-c/ncgen/jdata.c cdf5/ncgen/jdata.c
--- netcdf-c/ncgen/jdata.c	2014-11-14 15:15:16.659820900 -0700
+++ cdf5/ncgen/jdata.c	2014-11-14 13:32:35.107020400 -0700
@@ -50,17 +50,9 @@
 	bbprintf(codetmp,"%d",con->value.int32v);
 	break;
     case NC_FLOAT:
-	/* Special case for nan */
-	if(isnan(con->value.floatv))
-	    bbprintf(codetmp,"Float.NaN");
-	else
 	    bbprintf(codetmp,"%f",con->value.floatv);
 	break;
     case NC_DOUBLE:
-	/* Special case for nan */
-	if(isnan(con->value.doublev))
-	    bbprintf(codetmp,"Double.NaN");
-	else
 	    bbprintf(codetmp,"%lf",con->value.doublev);
 	break;
     case NC_UBYTE:
diff netcdf-c/ncgen/main.c cdf5/ncgen/main.c
--- netcdf-c/ncgen/main.c	2015-03-09 13:48:02.857710900 -0600
+++ cdf5/ncgen/main.c	2014-11-14 14:54:46.095794200 -0700
@@ -40,7 +40,7 @@
 int k_flag;    /* > 0  => -k was specified on command line*/
 int format_flag;   /* _Format attribute value (same range as -k flag) */
 int format_attribute; /* 1=>format came from format attribute */
-int enhanced_flag; /* 1 => netcdf-4 constructs appear in the parse */
+int enhanced_flag; /* 1 => netcdf-4/CDF-5 constructs appear in the parse */
 int specials_flag; /* 1=> special attributes are present */
 int usingclassic;
 int cmode_modifier;
@@ -87,6 +87,11 @@
     {"netCDF-4 classic model", 4},
     {"enhanced-nc3", 4},
 
+    /* CDF-5 format */
+    {"5", 5},
+    {"64-bit-data", 5},
+    {"64-bit data", 5},
+
     /* null terminate*/
     {NULL,0}
 };
@@ -286,15 +291,17 @@
         case 'k': /* for specifying variant of netCDF format to be generated
                      Possible values are:
                      1 (=> classic 32 bit)
-                     2 (=> classic 64 bit)
+                     2 (=> classic 64 bit offset, CDF-2)
                      3 (=> enhanced)
                      4 (=> classic, but stored in an enhanced file format)
+                     5 (=> classic 64 bit data, CDF-5)
                      Also provide string versions of above
                      "classic"
                      "64-bit-offset"
                      "64-bit offset"
 		     "enhanced" | "hdf5" | "netCDF-4"
                      "enhanced-nc3" | "hdf5-nc3" | "netCDF-4 classic model"
+                     "64-bit-data" | "64-bit data"
 		   */
 	    {
 		struct Kvalues* kvalue;
@@ -457,7 +464,7 @@
     if(enhanced_flag && k_flag == 0)
 	k_flag = 3;
 
-    if(enhanced_flag && k_flag != 3) {
+    if(enhanced_flag && k_flag != 3 && k_flag != 5) {
 	derror("-k or _Format conflicts with enhanced CDL input");
 	return 0;
     }
@@ -472,7 +479,7 @@
     if(k_flag == 0)
 	k_flag = 1;
 
-    usingclassic = (k_flag <= 2 || k_flag == 4)?1:0;
+    usingclassic = (k_flag <= 2 || k_flag == 4 || k_flag == 5)?1:0;
 
     /* compute cmode_modifier */
     switch (k_flag) {
@@ -480,6 +487,7 @@
     case 2: cmode_modifier = NC_64BIT_OFFSET; break;
     case 3: cmode_modifier = NC_NETCDF4; break;
     case 4: cmode_modifier = NC_NETCDF4 | NC_CLASSIC_MODEL; break;
+    case 5: cmode_modifier = NC_64BIT_DATA; break;
     default: ASSERT(0); /* cannot happen */
     }
 
diff netcdf-c/ncgen/Makefile.am cdf5/ncgen/Makefile.am
--- netcdf-c/ncgen/Makefile.am	2015-03-09 13:48:02.857710900 -0600
+++ cdf5/ncgen/Makefile.am	2014-11-14 14:54:46.092864700 -0700
@@ -22,7 +22,7 @@
 # These files all need to be distributed.
 EXTRA_DIST = ncgen.y ncgenyy.c ncgen.l $(man_MANS) internals.html	\
 run_tests.sh run_nc4_tests.sh c0.cdl c0_4.cdl ref_camrun.cdl \
-ncf199.cdl CMakeLists.txt XGetopt.c
+ncf199.cdl CMakeLists.txt XGetopt.c c5.cdl
 
 # This shell script causes ncgen to build a classic and a 64-bit
 # offset file from a cdl file shipped with the distribution.
@@ -34,7 +34,7 @@
 #endif # !BUILD_DLL
 
 CLEANFILES = c0.nc c0_64.nc c0_4.nc c0_4c.nc ref_camrun.c \
-		ncf199.nc
+		ncf199.nc c5.nc
 
 # These rule are used if someone wants to rebuild ncgenyy.c or ncgentab.c
 # Otherwise never invoked, but records how to do it.
diff netcdf-c/ncgen/ncgen.h cdf5/ncgen/ncgen.h
--- netcdf-c/ncgen/ncgen.h	2015-03-09 13:48:02.857710900 -0600
+++ cdf5/ncgen/ncgen.h	2014-11-14 14:54:46.096770700 -0700
@@ -103,7 +103,7 @@
 int k_flag;
 };
 
-#define NKVALUES 16
+#define NKVALUES 19
 extern struct Kvalues legalkinds[NKVALUES];
 
 /* Note: some non-var specials (i.e. _Format) are not included in this struct*/
diff netcdf-c/ncgen/run_tests.sh cdf5/ncgen/run_tests.sh
--- netcdf-c/ncgen/run_tests.sh	2014-04-14 17:59:18.106552500 -0600
+++ cdf5/ncgen/run_tests.sh	2014-11-14 14:54:46.096770700 -0700
@@ -8,6 +8,8 @@
 ./ncgen -b -o c0.nc $srcdir/c0.cdl
 echo "*** creating 64-bit offset file c0_64.nc from c0.cdl..."
 ./ncgen -k 64-bit-offset -b -o c0_64.nc $srcdir/c0.cdl
+echo "*** creating 64-bit offset file c5.nc from c5.cdl..."
+./ncgen -k 64-bit-data -b -o c5.nc $srcdir/c5.cdl
 
 echo "*** Test successful!"
 exit 0
diff netcdf-c/ncgen/semantics.c cdf5/ncgen/semantics.c
--- netcdf-c/ncgen/semantics.c	2014-11-14 15:15:16.659820900 -0700
+++ cdf5/ncgen/semantics.c	2014-11-14 14:54:46.111418200 -0700
@@ -825,13 +825,6 @@
         /* If we are in classic mode, then restrict the inferred type
            to the classic types */
 	switch (nctype) {
-	case NC_UBYTE:
-	    nctype = NC_SHORT;
-	    break;	
-	case NC_USHORT:
-	case NC_UINT:
-	case NC_INT64:
-	case NC_UINT64:
 	case NC_OPAQUE:
 	case NC_ENUM:
 	    nctype = NC_INT;
diff netcdf-c/nctest/driver.c cdf5/nctest/driver.c
--- netcdf-c/nctest/driver.c	2014-11-14 15:14:32.067783300 -0700
+++ cdf5/nctest/driver.c	2014-11-14 14:54:46.112394700 -0700
@@ -49,8 +49,8 @@
 	     nc_set_default_format(NC_FORMAT_CLASSIC, NULL);
 	     fprintf(stderr, "\n\nSwitching to netCDF classic format.\n");
 	     break;
-	  case NC_FORMAT_64BIT:
-	     nc_set_default_format(NC_FORMAT_64BIT, NULL);
+	  case NC_FORMAT_CDF2:
+	     nc_set_default_format(NC_FORMAT_CDF2, NULL);
 	     fprintf(stderr, "\n\nSwitching to 64-bit offset format.\n");
 	     break;
 #ifdef USE_NETCDF4 
