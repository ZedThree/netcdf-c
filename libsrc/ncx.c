#line 11 "stdin"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 13
/*
 *	Copyright 1996, University Corporation for Atmospheric Research
 *	See netcdf/COPYRIGHT file for copying and redistribution conditions.
 *
 * 	This file contains some routines derived from code
 *	which is copyrighted by Sun Microsystems, Inc.
 *	The "#ifdef vax" versions of
 *		 ncx_put_float_float()
 *		 ncx_get_float_float()
 *		 ncx_put_double_double()
 *		 ncx_get_double_double()
 *		 ncx_putn_float_float()
 *		 ncx_getn_float_float()
 *		 ncx_putn_double_double()
 *		 ncx_getn_double_double()
 * 	are derived from xdr_float() and xdr_double() routines
 *	in the freely available, copyrighted Sun RPCSRC 3.9
 *	distribution, xdr_float.c.
 * 	Our "value added" is that these are always memory to memory,
 *	they handle IEEE subnormals properly, and their "n" versions
 *	operate speedily on arrays.
 */
/* $Id: ncx.m4 2795 2014-10-27 23:12:51Z wkliao $ */

/*
 * An external data representation interface.
 */

#include "ncx.h"
#include "nc3dispatch.h"
#include <string.h>
#include <limits.h>

/* alias poorly named limits.h macros */
#define  SHORT_MAX  SHRT_MAX
#define  SHORT_MIN  SHRT_MIN
#define USHORT_MAX USHRT_MAX
#ifndef LLONG_MAX
#   define LLONG_MAX	9223372036854775807LL
#   define LLONG_MIN	(-LLONG_MAX - 1LL)
#   define ULLONG_MAX	18446744073709551615ULL
#endif
#ifndef LONG_LONG_MAX
#define LONG_LONG_MAX LLONG_MAX
#endif
#ifndef LONGLONG_MAX
#define LONGLONG_MAX LONG_LONG_MAX
#endif
#ifndef LONG_LONG_MIN
#define LONG_LONG_MIN LLONG_MIN
#endif
#ifndef LONGLONG_MIN
#define LONGLONG_MIN LONG_LONG_MIN
#endif
#ifndef ULONG_LONG_MAX
#define ULONG_LONG_MAX ULLONG_MAX
#endif
#ifndef ULONGLONG_MAX
#define ULONGLONG_MAX ULONG_LONG_MAX
#endif
#include <float.h>
#ifndef FLT_MAX /* This POSIX macro missing on some systems */
# ifndef NO_IEEE_FLOAT
# define FLT_MAX 3.40282347e+38f
# else
# error "You will need to define FLT_MAX"
# endif
#endif
/* alias poorly named float.h macros */
#define FLOAT_MAX FLT_MAX
#define FLOAT_MIN (-FLT_MAX)
#define DOUBLE_MAX DBL_MAX
#define DOUBLE_MIN (-DBL_MAX)
#define FLOAT_MAX_EXP FLT_MAX_EXP
#define DOUBLE_MAX_EXP DBL_MAX_EXP
#include <assert.h>
#define UCHAR_MIN 0
#define Min(a,b) ((a) < (b) ? (a) : (b))
#define Max(a,b) ((a) > (b) ? (a) : (b))

#ifndef SIZEOF_USHORT
#define SIZEOF_USHORT SIZEOF_UNSIGNED_SHORT_INT
#endif
#ifndef SIZEOF_UINT
#define SIZEOF_UINT SIZEOF_UNSIGNED_INT
#endif
#ifndef SIZEOF_ULONG_LONG
#define SIZEOF_ULONG_LONG SIZEOF_UNSIGNED_LONG_LONG
#endif

/*
 * If the machine's float domain is "smaller" than the external one
 * use the machine domain
 */
#if defined(FLT_MAX_EXP) && FLT_MAX_EXP < 128 /* 128 is X_FLT_MAX_EXP */
#undef X_FLOAT_MAX
# define X_FLOAT_MAX FLT_MAX
#undef X_FLOAT_MIN
# define X_FLOAT_MIN (-X_FLOAT_MAX)
#endif

#if _SX /* NEC SUPER UX */
#define LOOPCNT 256    /* must be no longer than hardware vector length */
#if _INT64
#undef  INT_MAX /* workaround cpp bug */
#define INT_MAX  X_INT_MAX
#undef  INT_MIN /* workaround cpp bug */
#define INT_MIN  X_INT_MIN
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  X_INT_MAX
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN  X_INT_MIN
#elif _LONG64
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  4294967295L
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN -4294967295L
#endif
#if !_FLOAT0
#error "FLOAT1 and FLOAT2 not supported"
#endif
#endif /* _SX */

static const char nada[X_ALIGN] = {0, 0, 0, 0};

#ifndef WORDS_BIGENDIAN
/* LITTLE_ENDIAN: DEC and intel */
/*
 * Routines to convert to BIGENDIAN.
 * Optimize the swapn?b() and swap?b() routines aggressivly.
 */

#define SWAP2(a) ( (((a) & 0xff) << 8) | \
		(((a) >> 8) & 0xff) )

#define SWAP4(a) ( ((a) << 24) | \
		(((a) <<  8) & 0x00ff0000) | \
		(((a) >>  8) & 0x0000ff00) | \
		(((a) >> 24) & 0x000000ff) )


static void
swapn2b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *
 *	while(nn-- != 0)
 *	{
 *		*op++ = *(++ip);
 *		*op++ = *(ip++ -1);
 *	}
 */
	while(nn > 3)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		nn -= 4;
	}
	while(nn-- != 0)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
	}
}

# ifndef vax
void
swap4b(void *dst, const void *src)
{
    unsigned int *op = dst;
    const char *ip = src;
    unsigned int tempIn;
    unsigned int tempOut;

    tempIn = *(unsigned int *)(ip+0);
    tempOut =
    ( tempIn << 24) |
    ((tempIn & 0x0000ff00) << 8) |
    ((tempIn & 0x00ff0000) >> 8) |
    ( tempIn >> 24);

    *(float *)op = *(float *)(&tempOut);
}
# endif /* !vax */

static void
swapn4b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while(nn-- != 0)
 *	{
 *		op[0] = ip[3];
 *		op[1] = ip[2];
 *		op[2] = ip[1];
 *		op[3] = ip[0];
 *		op += 4;
 *		ip += 4;
 *	}
 */
	while(nn > 3)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op[8] = ip[11];
		op[9] = ip[10];
		op[10] = ip[9];
		op[11] = ip[8];
		op[12] = ip[15];
		op[13] = ip[14];
		op[14] = ip[13];
		op[15] = ip[12];
		op += 16;
		ip += 16;
		nn -= 4;
	}
	while(nn-- != 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op += 4;
		ip += 4;
	}
}

# ifndef vax
static void
swap8b(void *dst, const void *src)
{
	char *op = dst;
	const char *ip = src;
#  ifndef FLOAT_WORDS_BIGENDIAN
	op[0] = ip[7];
	op[1] = ip[6];
	op[2] = ip[5];
	op[3] = ip[4];
	op[4] = ip[3];
	op[5] = ip[2];
	op[6] = ip[1];
	op[7] = ip[0];
#  else
	op[0] = ip[3];
	op[1] = ip[2];
	op[2] = ip[1];
	op[3] = ip[0];
	op[4] = ip[7];
	op[5] = ip[6];
	op[6] = ip[5];
	op[7] = ip[4];
#  endif
}
# endif /* !vax */

# ifndef vax
static void
swapn8b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while(nn-- != 0)
 *	{
 *		op[0] = ip[7];
 *		op[1] = ip[6];
 *		op[2] = ip[5];
 *		op[3] = ip[4];
 *		op[4] = ip[3];
 *		op[5] = ip[2];
 *		op[6] = ip[1];
 *		op[7] = ip[0];
 *		op += 8;
 *		ip += 8;
 *	}
 */
#  ifndef FLOAT_WORDS_BIGENDIAN
	while(nn > 1)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op[8] = ip[15];
		op[9] = ip[14];
		op[10] = ip[13];
		op[11] = ip[12];
		op[12] = ip[11];
		op[13] = ip[10];
		op[14] = ip[9];
		op[15] = ip[8];
		op += 16;
		ip += 16;
		nn -= 2;
	}
	while(nn-- != 0)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op += 8;
		ip += 8;
	}
#  else
	while(nn-- != 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op += 8;
		ip += 8;
	}
#  endif
}
# endif /* !vax */

#endif /* LITTLE_ENDIAN */

#line 386

#line 394

#line 402

#line 409


#line 417


#line 425


#line 433


/*
 * Primitive numeric conversion functions.
 */

#line 455

#line 481

#line 497

#line 522

/* x_schar */
/* x_uchar */

/* We don't implement any x_schar and x_uchar primitives. */


/* x_short -------------------------------------------------------------------*/

#if SHORT_MAX == X_SHORT_MAX
typedef short ix_short;
#define SIZEOF_IX_SHORT SIZEOF_SHORT
#define IX_SHORT_MAX SHORT_MAX
#elif INT_MAX >= X_SHORT_MAX
typedef int ix_short;
#define SIZEOF_IX_SHORT SIZEOF_INT
#define IX_SHORT_MAX INT_MAX
#elif LONG_MAX >= X_SHORT_MAX
typedef long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG
#define IX_SHORT_MAX LONG_MAX
#elif LLONG_MAX >= X_SHORT_MAX
typedef long long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG_LONG
#define IX_SHORT_MAX LLONG_MAX
#else
#error "ix_short implementation"
#endif

static void
get_ix_short(const void *xp, ix_short *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = *cp++ << 8;
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if(*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= *cp;
}

static void
put_ix_short(void *xp, const ix_short *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (*ip) >> 8;
	*cp = (*ip) & 0xff;
}

static int
#line 574
ncx_get_short_schar(const void *xp, schar *ip)
#line 574
{
#line 574
	ix_short xx;
#line 574
	get_ix_short(xp, &xx);
#line 574
	*ip = (schar) xx;
#line 574
#if IX_SHORT_MAX > SCHAR_MAX
#line 574
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 574
#endif
#line 574

#line 574
	return ENOERR;
#line 574
}
#line 574

static int
#line 575
ncx_get_short_short(const void *xp, short *ip)
#line 575
{
#line 575
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 575
	get_ix_short(xp, (ix_short *)ip);
#line 575
	return ENOERR;
#line 575
#else
#line 575
	ix_short xx;
#line 575
	get_ix_short(xp, &xx);
#line 575
	*ip = (short) xx;
#line 575
#if IX_SHORT_MAX > SHORT_MAX
#line 575
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 575
#endif
#line 575

#line 575
#endif
#line 575
	return ENOERR;
#line 575
}
#line 575

static int
#line 576
ncx_get_short_int(const void *xp, int *ip)
#line 576
{
#line 576
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 576
	get_ix_short(xp, (ix_short *)ip);
#line 576
	return ENOERR;
#line 576
#else
#line 576
	ix_short xx;
#line 576
	get_ix_short(xp, &xx);
#line 576
	*ip = (int) xx;
#line 576
#if IX_SHORT_MAX > INT_MAX
#line 576
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 576
#endif
#line 576

#line 576
#endif
#line 576
	return ENOERR;
#line 576
}
#line 576

static int
#line 577
ncx_get_short_longlong(const void *xp, longlong *ip)
#line 577
{
#line 577
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 577
	get_ix_short(xp, (ix_short *)ip);
#line 577
	return ENOERR;
#line 577
#else
#line 577
	ix_short xx;
#line 577
	get_ix_short(xp, &xx);
#line 577
	*ip = (longlong) xx;
#line 577
#if IX_SHORT_MAX > LONGLONG_MAX
#line 577
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 577
#endif
#line 577

#line 577
#endif
#line 577
	return ENOERR;
#line 577
}
#line 577

static int
#line 578
ncx_get_short_ushort(const void *xp, ushort *ip)
#line 578
{
#line 578
	ix_short xx;
#line 578
	get_ix_short(xp, &xx);
#line 578
	*ip = (ushort) xx;
#line 578
#if IX_SHORT_MAX > USHORT_MAX
#line 578
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 578
#endif
#line 578
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 578
	return ENOERR;
#line 578
}
#line 578

static int
#line 579
ncx_get_short_uchar(const void *xp, uchar *ip)
#line 579
{
#line 579
	ix_short xx;
#line 579
	get_ix_short(xp, &xx);
#line 579
	*ip = (uchar) xx;
#line 579
#if IX_SHORT_MAX > UCHAR_MAX
#line 579
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 579
#endif
#line 579
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 579
	return ENOERR;
#line 579
}
#line 579

static int
#line 580
ncx_get_short_uint(const void *xp, uint *ip)
#line 580
{
#line 580
	ix_short xx;
#line 580
	get_ix_short(xp, &xx);
#line 580
	*ip = (uint) xx;
#line 580
#if IX_SHORT_MAX > UINT_MAX
#line 580
	if (xx > UINT_MAX) return NC_ERANGE;
#line 580
#endif
#line 580
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 580
	return ENOERR;
#line 580
}
#line 580

static int
#line 581
ncx_get_short_ulonglong(const void *xp, ulonglong *ip)
#line 581
{
#line 581
	ix_short xx;
#line 581
	get_ix_short(xp, &xx);
#line 581
	*ip = (ulonglong) xx;
#line 581
#if IX_SHORT_MAX > ULONGLONG_MAX
#line 581
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 581
#endif
#line 581
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 581
	return ENOERR;
#line 581
}
#line 581

static int
#line 582
ncx_get_short_float(const void *xp, float *ip)
#line 582
{
#line 582
	ix_short xx;
#line 582
	get_ix_short(xp, &xx);
#line 582
	*ip = (float) xx;
#line 582

#line 582
	return ENOERR;
#line 582
}
#line 582

static int
#line 583
ncx_get_short_double(const void *xp, double *ip)
#line 583
{
#line 583
	ix_short xx;
#line 583
	get_ix_short(xp, &xx);
#line 583
	*ip = (double) xx;
#line 583

#line 583
	return ENOERR;
#line 583
}
#line 583


static int
ncx_put_short_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
	return ENOERR;
}

static int
ncx_put_short_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return ENOERR;
}

static int
#line 606
ncx_put_short_short(void *xp, const short *ip)
#line 606
{
#line 606
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 606
	put_ix_short(xp, (const ix_short *)ip);
#line 606
	return ENOERR;
#line 606
#else
#line 606
	ix_short xx = (ix_short)*ip;
#line 606
	put_ix_short(xp, &xx);
#line 606
#if IX_SHORT_MAX < SHORT_MAX
#line 606
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 606
#endif
#line 606

#line 606
#endif
#line 606
	return ENOERR;
#line 606
}
#line 606

static int
#line 607
ncx_put_short_int(void *xp, const int *ip)
#line 607
{
#line 607
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 607
	put_ix_short(xp, (const ix_short *)ip);
#line 607
	return ENOERR;
#line 607
#else
#line 607
	ix_short xx = (ix_short)*ip;
#line 607
	put_ix_short(xp, &xx);
#line 607
#if IX_SHORT_MAX < INT_MAX
#line 607
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 607
#endif
#line 607

#line 607
#endif
#line 607
	return ENOERR;
#line 607
}
#line 607

static int
#line 608
ncx_put_short_longlong(void *xp, const longlong *ip)
#line 608
{
#line 608
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 608
	put_ix_short(xp, (const ix_short *)ip);
#line 608
	return ENOERR;
#line 608
#else
#line 608
	ix_short xx = (ix_short)*ip;
#line 608
	put_ix_short(xp, &xx);
#line 608
#if IX_SHORT_MAX < LONGLONG_MAX
#line 608
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 608
#endif
#line 608

#line 608
#endif
#line 608
	return ENOERR;
#line 608
}
#line 608

static int
#line 609
ncx_put_short_ushort(void *xp, const ushort *ip)
#line 609
{
#line 609
	ix_short xx = (ix_short)*ip;
#line 609
	put_ix_short(xp, &xx);
#line 609
#if IX_SHORT_MAX < USHORT_MAX
#line 609
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 609
#endif
#line 609

#line 609
	return ENOERR;
#line 609
}
#line 609

static int
#line 610
ncx_put_short_uint(void *xp, const uint *ip)
#line 610
{
#line 610
	ix_short xx = (ix_short)*ip;
#line 610
	put_ix_short(xp, &xx);
#line 610
#if IX_SHORT_MAX < UINT_MAX
#line 610
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 610
#endif
#line 610

#line 610
	return ENOERR;
#line 610
}
#line 610

static int
#line 611
ncx_put_short_ulonglong(void *xp, const ulonglong *ip)
#line 611
{
#line 611
	ix_short xx = (ix_short)*ip;
#line 611
	put_ix_short(xp, &xx);
#line 611
#if IX_SHORT_MAX < ULONGLONG_MAX
#line 611
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 611
#endif
#line 611

#line 611
	return ENOERR;
#line 611
}
#line 611

static int
#line 612
ncx_put_short_float(void *xp, const float *ip)
#line 612
{
#line 612
	ix_short xx = (ix_short)*ip;
#line 612
	put_ix_short(xp, &xx);
#line 612
	if(*ip > (double)X_SHORT_MAX || *ip < (double)X_SHORT_MIN) return NC_ERANGE;
#line 612
	return ENOERR;
#line 612
}
#line 612

static int
#line 613
ncx_put_short_double(void *xp, const double *ip)
#line 613
{
#line 613
	ix_short xx = (ix_short)*ip;
#line 613
	put_ix_short(xp, &xx);
#line 613
	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 613
	return ENOERR;
#line 613
}
#line 613


/* x_ushort ------------------------------------------------------------------*/

#if USHORT_MAX == X_USHORT_MAX
typedef unsigned short ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_USHORT
#define IX_USHORT_MAX USHORT_MAX
#elif UINT_MAX >= X_USHORT_MAX
typedef unsigned int ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_UINT
#define IX_USHORT_MAX UINT_MAX
#elif ULONG_MAX >= X_USHORT_MAX
typedef unsigned long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONG
#define IX_USHORT_MAX ULONG_MAX
#elif ULLONG_MAX >= X_USHORT_MAX
typedef unsigned long long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONG_LONG
#define IX_USHORT_MAX ULLONG_MAX
#else
#error "ix_ushort implementation"
#endif

static void
get_ix_ushort(const void *xp, ix_ushort *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = *cp++ << 8;
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if(*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= *cp; 
}

static void
put_ix_ushort(void *xp, const ix_ushort *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (*ip) >> 8;
	*cp = (*ip) & 0xff;
}

static int
#line 660
ncx_get_ushort_schar(const void *xp, schar *ip)
#line 660
{
#line 660
	ix_ushort xx;
#line 660
	get_ix_ushort(xp, &xx);
#line 660
	*ip = (schar) xx;
#line 660
#if IX_USHORT_MAX > SCHAR_MAX
#line 660
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 660
#endif
#line 660

#line 660
	return ENOERR;
#line 660
}
#line 660

static int
#line 661
ncx_get_ushort_short(const void *xp, short *ip)
#line 661
{
#line 661
	ix_ushort xx;
#line 661
	get_ix_ushort(xp, &xx);
#line 661
	*ip = (short) xx;
#line 661
#if IX_USHORT_MAX > SHORT_MAX
#line 661
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 661
#endif
#line 661

#line 661
	return ENOERR;
#line 661
}
#line 661

static int
#line 662
ncx_get_ushort_int(const void *xp, int *ip)
#line 662
{
#line 662
	ix_ushort xx;
#line 662
	get_ix_ushort(xp, &xx);
#line 662
	*ip = (int) xx;
#line 662
#if IX_USHORT_MAX > INT_MAX
#line 662
	if (xx > INT_MAX) return NC_ERANGE;
#line 662
#endif
#line 662

#line 662
	return ENOERR;
#line 662
}
#line 662

static int
#line 663
ncx_get_ushort_longlong(const void *xp, longlong *ip)
#line 663
{
#line 663
	ix_ushort xx;
#line 663
	get_ix_ushort(xp, &xx);
#line 663
	*ip = (longlong) xx;
#line 663
#if IX_USHORT_MAX > LONGLONG_MAX
#line 663
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 663
#endif
#line 663

#line 663
	return ENOERR;
#line 663
}
#line 663

static int
#line 664
ncx_get_ushort_ushort(const void *xp, ushort *ip)
#line 664
{
#line 664
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 664
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 664
	return ENOERR;
#line 664
#else
#line 664
	ix_ushort xx;
#line 664
	get_ix_ushort(xp, &xx);
#line 664
	*ip = (ushort) xx;
#line 664
#if IX_USHORT_MAX > USHORT_MAX
#line 664
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 664
#endif
#line 664

#line 664
#endif
#line 664
	return ENOERR;
#line 664
}
#line 664

static int
#line 665
ncx_get_ushort_uchar(const void *xp, uchar *ip)
#line 665
{
#line 665
#if SIZEOF_IX_USHORT == SIZEOF_UCHAR && IX_USHORT_MAX == UCHAR_MAX
#line 665
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 665
	return ENOERR;
#line 665
#else
#line 665
	ix_ushort xx;
#line 665
	get_ix_ushort(xp, &xx);
#line 665
	*ip = (uchar) xx;
#line 665
#if IX_USHORT_MAX > UCHAR_MAX
#line 665
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 665
#endif
#line 665

#line 665
#endif
#line 665
	return ENOERR;
#line 665
}
#line 665

static int
#line 666
ncx_get_ushort_uint(const void *xp, uint *ip)
#line 666
{
#line 666
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 666
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 666
	return ENOERR;
#line 666
#else
#line 666
	ix_ushort xx;
#line 666
	get_ix_ushort(xp, &xx);
#line 666
	*ip = (uint) xx;
#line 666
#if IX_USHORT_MAX > UINT_MAX
#line 666
	if (xx > UINT_MAX) return NC_ERANGE;
#line 666
#endif
#line 666

#line 666
#endif
#line 666
	return ENOERR;
#line 666
}
#line 666

static int
#line 667
ncx_get_ushort_ulonglong(const void *xp, ulonglong *ip)
#line 667
{
#line 667
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 667
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 667
	return ENOERR;
#line 667
#else
#line 667
	ix_ushort xx;
#line 667
	get_ix_ushort(xp, &xx);
#line 667
	*ip = (ulonglong) xx;
#line 667
#if IX_USHORT_MAX > ULONGLONG_MAX
#line 667
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 667
#endif
#line 667

#line 667
#endif
#line 667
	return ENOERR;
#line 667
}
#line 667

static int
#line 668
ncx_get_ushort_float(const void *xp, float *ip)
#line 668
{
#line 668
	ix_ushort xx;
#line 668
	get_ix_ushort(xp, &xx);
#line 668
	*ip = (float) xx;
#line 668

#line 668
	return ENOERR;
#line 668
}
#line 668

static int
#line 669
ncx_get_ushort_double(const void *xp, double *ip)
#line 669
{
#line 669
	ix_ushort xx;
#line 669
	get_ix_ushort(xp, &xx);
#line 669
	*ip = (double) xx;
#line 669

#line 669
	return ENOERR;
#line 669
}
#line 669


static int
ncx_put_ushort_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
        if (*ip < 0) return NC_ERANGE;

	return ENOERR;
}

static int
ncx_put_ushort_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return ENOERR;
}

static int
#line 694
ncx_put_ushort_short(void *xp, const short *ip)
#line 694
{
#line 694
	ix_ushort xx = (ix_ushort)*ip;
#line 694
	put_ix_ushort(xp, &xx);
#line 694
#if IX_USHORT_MAX < SHORT_MAX
#line 694
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 694
#endif
#line 694
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 694
	return ENOERR;
#line 694
}
#line 694

static int
#line 695
ncx_put_ushort_int(void *xp, const int *ip)
#line 695
{
#line 695
	ix_ushort xx = (ix_ushort)*ip;
#line 695
	put_ix_ushort(xp, &xx);
#line 695
#if IX_USHORT_MAX < INT_MAX
#line 695
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 695
#endif
#line 695
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 695
	return ENOERR;
#line 695
}
#line 695

static int
#line 696
ncx_put_ushort_longlong(void *xp, const longlong *ip)
#line 696
{
#line 696
	ix_ushort xx = (ix_ushort)*ip;
#line 696
	put_ix_ushort(xp, &xx);
#line 696
#if IX_USHORT_MAX < LONGLONG_MAX
#line 696
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 696
#endif
#line 696
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 696
	return ENOERR;
#line 696
}
#line 696

static int
#line 697
ncx_put_ushort_ushort(void *xp, const ushort *ip)
#line 697
{
#line 697
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 697
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 697
	return ENOERR;
#line 697
#else
#line 697
	ix_ushort xx = (ix_ushort)*ip;
#line 697
	put_ix_ushort(xp, &xx);
#line 697
#if IX_USHORT_MAX < USHORT_MAX
#line 697
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 697
#endif
#line 697

#line 697
#endif
#line 697
	return ENOERR;
#line 697
}
#line 697

static int
#line 698
ncx_put_ushort_uint(void *xp, const uint *ip)
#line 698
{
#line 698
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 698
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 698
	return ENOERR;
#line 698
#else
#line 698
	ix_ushort xx = (ix_ushort)*ip;
#line 698
	put_ix_ushort(xp, &xx);
#line 698
#if IX_USHORT_MAX < UINT_MAX
#line 698
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 698
#endif
#line 698

#line 698
#endif
#line 698
	return ENOERR;
#line 698
}
#line 698

static int
#line 699
ncx_put_ushort_ulonglong(void *xp, const ulonglong *ip)
#line 699
{
#line 699
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 699
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 699
	return ENOERR;
#line 699
#else
#line 699
	ix_ushort xx = (ix_ushort)*ip;
#line 699
	put_ix_ushort(xp, &xx);
#line 699
#if IX_USHORT_MAX < ULONGLONG_MAX
#line 699
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 699
#endif
#line 699

#line 699
#endif
#line 699
	return ENOERR;
#line 699
}
#line 699

static int
#line 700
ncx_put_ushort_float(void *xp, const float *ip)
#line 700
{
#line 700
	ix_ushort xx = (ix_ushort)*ip;
#line 700
	put_ix_ushort(xp, &xx);
#line 700
	if(*ip > (double)X_USHORT_MAX || *ip < 0) return NC_ERANGE;
#line 700
	return ENOERR;
#line 700
}
#line 700

static int
#line 701
ncx_put_ushort_double(void *xp, const double *ip)
#line 701
{
#line 701
	ix_ushort xx = (ix_ushort)*ip;
#line 701
	put_ix_ushort(xp, &xx);
#line 701
	if(*ip > X_USHORT_MAX || *ip < 0) return NC_ERANGE;
#line 701
	return ENOERR;
#line 701
}
#line 701


/* x_int ---------------------------------------------------------------------*/

#if SHORT_MAX == X_INT_MAX
typedef short ix_int;
#define SIZEOF_IX_INT SIZEOF_SHORT
#define IX_INT_MAX SHORT_MAX
#elif INT_MAX  >= X_INT_MAX
typedef int ix_int;
#define SIZEOF_IX_INT SIZEOF_INT
#define IX_INT_MAX INT_MAX
#elif LONG_MAX  >= X_INT_MAX
typedef long ix_int;
#define SIZEOF_IX_INT SIZEOF_LONG
#define IX_INT_MAX LONG_MAX
#else
#error "ix_int implementation"
#endif


static void
get_ix_int(const void *xp, ix_int *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = *cp++ << 24;
#if SIZEOF_IX_INT > X_SIZEOF_INT
	if(*ip & 0x80000000)
	{
		/* extern is negative */
		*ip |= (~(0xffffffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp;
}

static void
put_ix_int(void *xp, const ix_int *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (*ip) >> 24;
	*cp++ = ((*ip) & 0x00ff0000) >> 16;
	*cp++ = ((*ip) & 0x0000ff00) >>  8;
	*cp   = ((*ip) & 0x000000ff);
}

static int
#line 751
ncx_get_int_schar(const void *xp, schar *ip)
#line 751
{
#line 751
	ix_int xx;
#line 751
	get_ix_int(xp, &xx);
#line 751
	*ip = (schar) xx;
#line 751
#if IX_INT_MAX > SCHAR_MAX
#line 751
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 751
#endif
#line 751

#line 751
	return ENOERR;
#line 751
}
#line 751

static int
#line 752
ncx_get_int_short(const void *xp, short *ip)
#line 752
{
#line 752
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 752
	get_ix_int(xp, (ix_int *)ip);
#line 752
	return ENOERR;
#line 752
#else
#line 752
	ix_int xx;
#line 752
	get_ix_int(xp, &xx);
#line 752
	*ip = (short) xx;
#line 752
#if IX_INT_MAX > SHORT_MAX
#line 752
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 752
#endif
#line 752

#line 752
#endif
#line 752
	return ENOERR;
#line 752
}
#line 752

       int
#line 753
ncx_get_int_int(const void *xp, int *ip)
#line 753
{
#line 753
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 753
	get_ix_int(xp, (ix_int *)ip);
#line 753
	return ENOERR;
#line 753
#else
#line 753
	ix_int xx;
#line 753
	get_ix_int(xp, &xx);
#line 753
	*ip = (int) xx;
#line 753
#if IX_INT_MAX > INT_MAX
#line 753
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 753
#endif
#line 753

#line 753
#endif
#line 753
	return ENOERR;
#line 753
}
#line 753

static int
#line 754
ncx_get_int_longlong(const void *xp, longlong *ip)
#line 754
{
#line 754
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 754
	get_ix_int(xp, (ix_int *)ip);
#line 754
	return ENOERR;
#line 754
#else
#line 754
	ix_int xx;
#line 754
	get_ix_int(xp, &xx);
#line 754
	*ip = (longlong) xx;
#line 754
#if IX_INT_MAX > LONGLONG_MAX
#line 754
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 754
#endif
#line 754

#line 754
#endif
#line 754
	return ENOERR;
#line 754
}
#line 754

static int
#line 755
ncx_get_int_ushort(const void *xp, ushort *ip)
#line 755
{
#line 755
	ix_int xx;
#line 755
	get_ix_int(xp, &xx);
#line 755
	*ip = (ushort) xx;
#line 755
#if IX_INT_MAX > USHORT_MAX
#line 755
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 755
#endif
#line 755
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 755
	return ENOERR;
#line 755
}
#line 755

static int
#line 756
ncx_get_int_uchar(const void *xp, uchar *ip)
#line 756
{
#line 756
	ix_int xx;
#line 756
	get_ix_int(xp, &xx);
#line 756
	*ip = (uchar) xx;
#line 756
#if IX_INT_MAX > UCHAR_MAX
#line 756
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 756
#endif
#line 756
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 756
	return ENOERR;
#line 756
}
#line 756

static int
#line 757
ncx_get_int_uint(const void *xp, uint *ip)
#line 757
{
#line 757
	ix_int xx;
#line 757
	get_ix_int(xp, &xx);
#line 757
	*ip = (uint) xx;
#line 757
#if IX_INT_MAX > UINT_MAX
#line 757
	if (xx > UINT_MAX) return NC_ERANGE;
#line 757
#endif
#line 757
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 757
	return ENOERR;
#line 757
}
#line 757

static int
#line 758
ncx_get_int_ulonglong(const void *xp, ulonglong *ip)
#line 758
{
#line 758
	ix_int xx;
#line 758
	get_ix_int(xp, &xx);
#line 758
	*ip = (ulonglong) xx;
#line 758
#if IX_INT_MAX > ULONGLONG_MAX
#line 758
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 758
#endif
#line 758
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 758
	return ENOERR;
#line 758
}
#line 758

static int
#line 759
ncx_get_int_float(const void *xp, float *ip)
#line 759
{
#line 759
	ix_int xx;
#line 759
	get_ix_int(xp, &xx);
#line 759
	*ip = (float) xx;
#line 759

#line 759
	return ENOERR;
#line 759
}
#line 759

static int
#line 760
ncx_get_int_double(const void *xp, double *ip)
#line 760
{
#line 760
	ix_int xx;
#line 760
	get_ix_int(xp, &xx);
#line 760
	*ip = (double) xx;
#line 760

#line 760
	return ENOERR;
#line 760
}
#line 760


static int
ncx_put_int_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
	{
		*cp++ = 0xff;
		*cp++ = 0xff;
		*cp++ = 0xff;
	}
	else
	{
		*cp++ = 0x00;
		*cp++ = 0x00;
		*cp++ = 0x00;
	}
	*cp = (uchar)*ip;
	return ENOERR;
}

static int
ncx_put_int_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return ENOERR;
}

static int
#line 793
ncx_put_int_short(void *xp, const short *ip)
#line 793
{
#line 793
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 793
	put_ix_int(xp, (const ix_int *)ip);
#line 793
	return ENOERR;
#line 793
#else
#line 793
	ix_int xx = (ix_int)*ip;
#line 793
	put_ix_int(xp, &xx);
#line 793
#if IX_INT_MAX < SHORT_MAX
#line 793
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 793
#endif
#line 793

#line 793
#endif
#line 793
	return ENOERR;
#line 793
}
#line 793

       int
#line 794
ncx_put_int_int(void *xp, const int *ip)
#line 794
{
#line 794
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 794
	put_ix_int(xp, (const ix_int *)ip);
#line 794
	return ENOERR;
#line 794
#else
#line 794
	ix_int xx = (ix_int)*ip;
#line 794
	put_ix_int(xp, &xx);
#line 794
#if IX_INT_MAX < INT_MAX
#line 794
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 794
#endif
#line 794

#line 794
#endif
#line 794
	return ENOERR;
#line 794
}
#line 794

static int
#line 795
ncx_put_int_longlong(void *xp, const longlong *ip)
#line 795
{
#line 795
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 795
	put_ix_int(xp, (const ix_int *)ip);
#line 795
	return ENOERR;
#line 795
#else
#line 795
	ix_int xx = (ix_int)*ip;
#line 795
	put_ix_int(xp, &xx);
#line 795
#if IX_INT_MAX < LONGLONG_MAX
#line 795
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 795
#endif
#line 795

#line 795
#endif
#line 795
	return ENOERR;
#line 795
}
#line 795

static int
#line 796
ncx_put_int_ushort(void *xp, const ushort *ip)
#line 796
{
#line 796
	ix_int xx = (ix_int)*ip;
#line 796
	put_ix_int(xp, &xx);
#line 796
#if IX_INT_MAX < USHORT_MAX
#line 796
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 796
#endif
#line 796

#line 796
	return ENOERR;
#line 796
}
#line 796

static int
#line 797
ncx_put_int_uint(void *xp, const uint *ip)
#line 797
{
#line 797
	ix_int xx = (ix_int)*ip;
#line 797
	put_ix_int(xp, &xx);
#line 797
#if IX_INT_MAX < UINT_MAX
#line 797
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 797
#endif
#line 797

#line 797
	return ENOERR;
#line 797
}
#line 797

static int
#line 798
ncx_put_int_ulonglong(void *xp, const ulonglong *ip)
#line 798
{
#line 798
	ix_int xx = (ix_int)*ip;
#line 798
	put_ix_int(xp, &xx);
#line 798
#if IX_INT_MAX < ULONGLONG_MAX
#line 798
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 798
#endif
#line 798

#line 798
	return ENOERR;
#line 798
}
#line 798

static int
#line 799
ncx_put_int_float(void *xp, const float *ip)
#line 799
{
#line 799
	ix_int xx = (ix_int)*ip;
#line 799
	put_ix_int(xp, &xx);
#line 799
	if(*ip > (double)X_INT_MAX || *ip < (double)X_INT_MIN) return NC_ERANGE;
#line 799
	return ENOERR;
#line 799
}
#line 799

static int
#line 800
ncx_put_int_double(void *xp, const double *ip)
#line 800
{
#line 800
	ix_int xx = (ix_int)*ip;
#line 800
	put_ix_int(xp, &xx);
#line 800
	if(*ip > X_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 800
	return ENOERR;
#line 800
}
#line 800



/* x_uint --------------------------------------------------------------------*/

#if USHORT_MAX == X_UINT_MAX
typedef ushort ix_uint;
#define SIZEOF_IX_UINT SIZEOF_USHORT
#define IX_UINT_MAX USHORT_MAX
#elif UINT_MAX  >= X_UINT_MAX
typedef uint ix_uint;
#define SIZEOF_IX_UINT SIZEOF_UINT
#define IX_UINT_MAX UINT_MAX
#elif ULONG_MAX  >= X_UINT_MAX
typedef ulong ix_uint;
#define SIZEOF_IX_UINT SIZEOF_ULONG
#define IX_UINT_MAX ULONG_MAX
#else
#error "ix_uint implementation"
#endif


static void
get_ix_uint(const void *xp, ix_uint *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = *cp++ << 24;
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp; 
}

static void
put_ix_uint(void *xp, const ix_uint *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (*ip) >> 24;
	*cp++ = ((*ip) & 0x00ff0000) >> 16;
	*cp++ = ((*ip) & 0x0000ff00) >>  8;
	*cp   = ((*ip) & 0x000000ff);
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 845
ncx_get_uint_uint(const void *xp, uint *ip)
#line 845
{
#line 845
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 845
	get_ix_uint(xp, (ix_uint *)ip);
#line 845
	return ENOERR;
#line 845
#else
#line 845
	ix_uint xx;
#line 845
	get_ix_uint(xp, &xx);
#line 845
	*ip = (uint) xx;
#line 845
#if IX_UINT_MAX > UINT_MAX
#line 845
	if (xx > UINT_MAX) return NC_ERANGE;
#line 845
#endif
#line 845

#line 845
#endif
#line 845
	return ENOERR;
#line 845
}
#line 845

#endif

static int
#line 848
ncx_get_uint_schar(const void *xp, schar *ip)
#line 848
{
#line 848
	ix_uint xx;
#line 848
	get_ix_uint(xp, &xx);
#line 848
	*ip = (schar) xx;
#line 848
#if IX_UINT_MAX > SCHAR_MAX
#line 848
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 848
#endif
#line 848

#line 848
	return ENOERR;
#line 848
}
#line 848

static int
#line 849
ncx_get_uint_short(const void *xp, short *ip)
#line 849
{
#line 849
	ix_uint xx;
#line 849
	get_ix_uint(xp, &xx);
#line 849
	*ip = (short) xx;
#line 849
#if IX_UINT_MAX > SHORT_MAX
#line 849
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 849
#endif
#line 849

#line 849
	return ENOERR;
#line 849
}
#line 849

static int
#line 850
ncx_get_uint_int(const void *xp, int *ip)
#line 850
{
#line 850
	ix_uint xx;
#line 850
	get_ix_uint(xp, &xx);
#line 850
	*ip = (int) xx;
#line 850
#if IX_UINT_MAX > INT_MAX
#line 850
	if (xx > INT_MAX) return NC_ERANGE;
#line 850
#endif
#line 850

#line 850
	return ENOERR;
#line 850
}
#line 850

static int
#line 851
ncx_get_uint_longlong(const void *xp, longlong *ip)
#line 851
{
#line 851
	ix_uint xx;
#line 851
	get_ix_uint(xp, &xx);
#line 851
	*ip = (longlong) xx;
#line 851
#if IX_UINT_MAX > LONGLONG_MAX
#line 851
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 851
#endif
#line 851

#line 851
	return ENOERR;
#line 851
}
#line 851

static int
#line 852
ncx_get_uint_ushort(const void *xp, ushort *ip)
#line 852
{
#line 852
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 852
	get_ix_uint(xp, (ix_uint *)ip);
#line 852
	return ENOERR;
#line 852
#else
#line 852
	ix_uint xx;
#line 852
	get_ix_uint(xp, &xx);
#line 852
	*ip = (ushort) xx;
#line 852
#if IX_UINT_MAX > USHORT_MAX
#line 852
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 852
#endif
#line 852

#line 852
#endif
#line 852
	return ENOERR;
#line 852
}
#line 852

static int
#line 853
ncx_get_uint_uchar(const void *xp, uchar *ip)
#line 853
{
#line 853
#if SIZEOF_IX_UINT == SIZEOF_UCHAR && IX_UINT_MAX == UCHAR_MAX
#line 853
	get_ix_uint(xp, (ix_uint *)ip);
#line 853
	return ENOERR;
#line 853
#else
#line 853
	ix_uint xx;
#line 853
	get_ix_uint(xp, &xx);
#line 853
	*ip = (uchar) xx;
#line 853
#if IX_UINT_MAX > UCHAR_MAX
#line 853
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 853
#endif
#line 853

#line 853
#endif
#line 853
	return ENOERR;
#line 853
}
#line 853

static int
#line 854
ncx_get_uint_ulonglong(const void *xp, ulonglong *ip)
#line 854
{
#line 854
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 854
	get_ix_uint(xp, (ix_uint *)ip);
#line 854
	return ENOERR;
#line 854
#else
#line 854
	ix_uint xx;
#line 854
	get_ix_uint(xp, &xx);
#line 854
	*ip = (ulonglong) xx;
#line 854
#if IX_UINT_MAX > ULONGLONG_MAX
#line 854
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 854
#endif
#line 854

#line 854
#endif
#line 854
	return ENOERR;
#line 854
}
#line 854

static int
#line 855
ncx_get_uint_float(const void *xp, float *ip)
#line 855
{
#line 855
	ix_uint xx;
#line 855
	get_ix_uint(xp, &xx);
#line 855
	*ip = (float) xx;
#line 855

#line 855
	return ENOERR;
#line 855
}
#line 855

static int
#line 856
ncx_get_uint_double(const void *xp, double *ip)
#line 856
{
#line 856
	ix_uint xx;
#line 856
	get_ix_uint(xp, &xx);
#line 856
	*ip = (double) xx;
#line 856

#line 856
	return ENOERR;
#line 856
}
#line 856


static int
ncx_put_uint_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp = (uchar)*ip;

	if (*ip < 0) return NC_ERANGE;

	return ENOERR;
}

static int
ncx_put_uint_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return ENOERR;
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 884
ncx_put_uint_uint(void *xp, const uint *ip)
#line 884
{
#line 884
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 884
	put_ix_uint(xp, (const ix_uint *)ip);
#line 884
	return ENOERR;
#line 884
#else
#line 884
	ix_uint xx = (ix_uint)*ip;
#line 884
	put_ix_uint(xp, &xx);
#line 884
#if IX_UINT_MAX < UINT_MAX
#line 884
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 884
#endif
#line 884

#line 884
#endif
#line 884
	return ENOERR;
#line 884
}
#line 884

#endif
static int
#line 886
ncx_put_uint_short(void *xp, const short *ip)
#line 886
{
#line 886
	ix_uint xx = (ix_uint)*ip;
#line 886
	put_ix_uint(xp, &xx);
#line 886
#if IX_UINT_MAX < SHORT_MAX
#line 886
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 886
#endif
#line 886
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 886
	return ENOERR;
#line 886
}
#line 886

static int
#line 887
ncx_put_uint_int(void *xp, const int *ip)
#line 887
{
#line 887
	ix_uint xx = (ix_uint)*ip;
#line 887
	put_ix_uint(xp, &xx);
#line 887
#if IX_UINT_MAX < INT_MAX
#line 887
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 887
#endif
#line 887
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 887
	return ENOERR;
#line 887
}
#line 887

static int
#line 888
ncx_put_uint_longlong(void *xp, const longlong *ip)
#line 888
{
#line 888
	ix_uint xx = (ix_uint)*ip;
#line 888
	put_ix_uint(xp, &xx);
#line 888
#if IX_UINT_MAX < LONGLONG_MAX
#line 888
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 888
#endif
#line 888
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 888
	return ENOERR;
#line 888
}
#line 888

static int
#line 889
ncx_put_uint_ushort(void *xp, const ushort *ip)
#line 889
{
#line 889
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 889
	put_ix_uint(xp, (const ix_uint *)ip);
#line 889
	return ENOERR;
#line 889
#else
#line 889
	ix_uint xx = (ix_uint)*ip;
#line 889
	put_ix_uint(xp, &xx);
#line 889
#if IX_UINT_MAX < USHORT_MAX
#line 889
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 889
#endif
#line 889

#line 889
#endif
#line 889
	return ENOERR;
#line 889
}
#line 889

static int
#line 890
ncx_put_uint_ulonglong(void *xp, const ulonglong *ip)
#line 890
{
#line 890
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 890
	put_ix_uint(xp, (const ix_uint *)ip);
#line 890
	return ENOERR;
#line 890
#else
#line 890
	ix_uint xx = (ix_uint)*ip;
#line 890
	put_ix_uint(xp, &xx);
#line 890
#if IX_UINT_MAX < ULONGLONG_MAX
#line 890
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 890
#endif
#line 890

#line 890
#endif
#line 890
	return ENOERR;
#line 890
}
#line 890

static int
#line 891
ncx_put_uint_float(void *xp, const float *ip)
#line 891
{
#line 891
	ix_uint xx = (ix_uint)*ip;
#line 891
	put_ix_uint(xp, &xx);
#line 891
	if(*ip > (double)X_UINT_MAX || *ip < 0) return NC_ERANGE;
#line 891
	return ENOERR;
#line 891
}
#line 891

static int
#line 892
ncx_put_uint_double(void *xp, const double *ip)
#line 892
{
#line 892
	ix_uint xx = (ix_uint)*ip;
#line 892
	put_ix_uint(xp, &xx);
#line 892
	if(*ip > X_UINT_MAX || *ip < 0) return NC_ERANGE;
#line 892
	return ENOERR;
#line 892
}
#line 892

 

/* x_float -------------------------------------------------------------------*/

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)

static void
get_ix_float(const void *xp, float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, sizeof(float));
#else
	swap4b(ip, xp);
#endif
}

static void
put_ix_float(void *xp, const float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_FLOAT);
#else
	swap4b(xp, ip);
#endif
}

#elif vax

/* What IEEE single precision floating point looks like on a Vax */
struct	ieee_single {
	unsigned int	exp_hi       : 7;
	unsigned int	sign         : 1;
	unsigned int 	mant_hi      : 7;
	unsigned int	exp_lo       : 1;
	unsigned int	mant_lo_hi   : 8;
	unsigned int	mant_lo_lo   : 8;
};

/* Vax single precision floating point */
struct	vax_single {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
};

#define VAX_SNG_BIAS	0x81
#define IEEE_SNG_BIAS	0x7f

static struct sgl_limits {
	struct vax_single s;
	struct ieee_single ieee;
} max = {
	{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0x1, 0x0, 0x0 }		/* Max IEEE */
};
static struct sgl_limits min = {
	{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }		/* Min IEEE */
};

#line 1006
static void
get_ix_float(const void *xp, float *ip)
{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 1009
		const struct ieee_single *const isp =
#line 1009
			 (const struct ieee_single *) xp;
#line 1009
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 1009

#line 1009
		switch(exp) {
#line 1009
		case 0 :
#line 1009
			/* ieee subnormal */
#line 1009
			if(isp->mant_hi == min.ieee.mant_hi
#line 1009
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 1009
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 1009
			{
#line 1009
				*vsp = min.s;
#line 1009
			}
#line 1009
			else
#line 1009
			{
#line 1009
				unsigned mantissa = (isp->mant_hi << 16)
#line 1009
					 | isp->mant_lo_hi << 8
#line 1009
					 | isp->mant_lo_lo;
#line 1009
				unsigned tmp = mantissa >> 20;
#line 1009
				if(tmp >= 4) {
#line 1009
					vsp->exp = 2;
#line 1009
				} else if (tmp >= 2) {
#line 1009
					vsp->exp = 1;
#line 1009
				} else {
#line 1009
					*vsp = min.s;
#line 1009
					break;
#line 1009
				} /* else */
#line 1009
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 1009
				tmp <<= 3 - vsp->exp;
#line 1009
				vsp->mantissa2 = tmp;
#line 1009
				vsp->mantissa1 = (tmp >> 16);
#line 1009
			}
#line 1009
			break;
#line 1009
		case 0xfe :
#line 1009
		case 0xff :
#line 1009
			*vsp = max.s;
#line 1009
			break;
#line 1009
		default :
#line 1009
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 1009
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 1009
			vsp->mantissa1 = isp->mant_hi;
#line 1009
		}
#line 1009

#line 1009
		vsp->sign = isp->sign;
#line 1009

}

#line 1063

static void
put_ix_float(void *xp, const float *ip)
{
		const struct vax_single *const vsp =
#line 1067
			 (const struct vax_single *)ip;
#line 1067
		struct ieee_single *const isp = (struct ieee_single *) xp;
#line 1067

#line 1067
		switch(vsp->exp){
#line 1067
		case 0 :
#line 1067
			/* all vax float with zero exponent map to zero */
#line 1067
			*isp = min.ieee;
#line 1067
			break;
#line 1067
		case 2 :
#line 1067
		case 1 :
#line 1067
		{
#line 1067
			/* These will map to subnormals */
#line 1067
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 1067
					 | vsp->mantissa2;
#line 1067
			mantissa >>= 3 - vsp->exp;
#line 1067
			mantissa += (1 << (20 + vsp->exp));
#line 1067
			isp->mant_lo_lo = mantissa;
#line 1067
			isp->mant_lo_hi = mantissa >> 8;
#line 1067
			isp->mant_hi = mantissa >> 16;
#line 1067
			isp->exp_lo = 0;
#line 1067
			isp->exp_hi = 0;
#line 1067
		}
#line 1067
			break;
#line 1067
		case 0xff : /* max.s.exp */
#line 1067
			if( vsp->mantissa2 == max.s.mantissa2
#line 1067
				&& vsp->mantissa1 == max.s.mantissa1)
#line 1067
			{
#line 1067
				/* map largest vax float to ieee infinity */
#line 1067
				*isp = max.ieee;
#line 1067
				break;
#line 1067
			} /* else, fall thru */
#line 1067
		default :
#line 1067
		{
#line 1067
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 1067
			isp->exp_hi = exp >> 1;
#line 1067
			isp->exp_lo = exp;
#line 1067
			isp->mant_lo_lo = vsp->mantissa2;
#line 1067
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 1067
			isp->mant_hi = vsp->mantissa1;
#line 1067
		}
#line 1067
		}
#line 1067

#line 1067
		isp->sign = vsp->sign;
#line 1067

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

/*
 * Return the number of bytes until the next "word" boundary
 * N.B. This is based on the very wierd YMP address structure,
 * which puts the address within a word in the leftmost 3 bits
 * of the address.
 */
static size_t
word_align(const void *vp)
{
	const size_t rem = ((size_t)vp >> (64 - 3)) & 0x7;
	return (rem != 0);
}

struct ieee_single_hi {
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
	unsigned int	pad	:32;
};
typedef struct ieee_single_hi ieee_single_hi;

struct ieee_single_lo {
	unsigned int	pad	:32;
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
};
typedef struct ieee_single_lo ieee_single_lo;

static const int ieee_single_bias = 0x7f;

struct ieee_double {
	unsigned int	sign	: 1;
	unsigned int	 exp	:11;
	unsigned int	mant	:52;
};
typedef struct ieee_double ieee_double;

static const int ieee_double_bias = 0x3ff;

#if defined(NO_IEEE_FLOAT)

struct cray_single {
	unsigned int	sign	: 1;
	unsigned int	 exp	:15;
	unsigned int	mant	:48;
};
typedef struct cray_single cray_single;

static const int cs_ieis_bias = 0x4000 - 0x7f;

static const int cs_id_bias = 0x4000 - 0x3ff;

#line 1202

static void
get_ix_float(const void *xp, float *ip)
{

	if(word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1210

#line 1210
		if(isp->exp == 0)
#line 1210
		{
#line 1210
			/* ieee subnormal */
#line 1210
			*ip = (double)isp->mant;
#line 1210
			if(isp->mant != 0)
#line 1210
			{
#line 1210
				csp->exp -= (ieee_single_bias + 22);
#line 1210
			}
#line 1210
		}
#line 1210
		else
#line 1210
		{
#line 1210
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1210
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1210
			csp->mant |= (1 << (48 - 1));
#line 1210
		}
#line 1210
		csp->sign = isp->sign;
#line 1210

#line 1210

	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1215

#line 1215
		if(isp->exp == 0)
#line 1215
		{
#line 1215
			/* ieee subnormal */
#line 1215
			*ip = (double)isp->mant;
#line 1215
			if(isp->mant != 0)
#line 1215
			{
#line 1215
				csp->exp -= (ieee_single_bias + 22);
#line 1215
			}
#line 1215
		}
#line 1215
		else
#line 1215
		{
#line 1215
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1215
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1215
			csp->mant |= (1 << (48 - 1));
#line 1215
		}
#line 1215
		csp->sign = isp->sign;
#line 1215

#line 1215

	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	if(word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1225
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1225

#line 1225
	isp->sign = csp->sign;
#line 1225

#line 1225
	if(ieee_exp >= 0xff)
#line 1225
	{
#line 1225
		/* NC_ERANGE => ieee Inf */
#line 1225
		isp->exp = 0xff;
#line 1225
		isp->mant = 0x0;
#line 1225
	}
#line 1225
	else if(ieee_exp > 0)
#line 1225
	{
#line 1225
		/* normal ieee representation */
#line 1225
		isp->exp  = ieee_exp;
#line 1225
		/* assumes cray rep is in normal form */
#line 1225
		assert(csp->mant & 0x800000000000);
#line 1225
		isp->mant = (((csp->mant << 1) &
#line 1225
				0xffffffffffff) >> (48 - 23));
#line 1225
	}
#line 1225
	else if(ieee_exp > -23)
#line 1225
	{
#line 1225
		/* ieee subnormal, right shift */
#line 1225
		const int rshift = (48 - 23 - ieee_exp);
#line 1225

#line 1225
		isp->mant = csp->mant >> rshift;
#line 1225

#line 1225
#if 0
#line 1225
		if(csp->mant & (1 << (rshift -1)))
#line 1225
		{
#line 1225
			/* round up */
#line 1225
			isp->mant++;
#line 1225
		}
#line 1225
#endif
#line 1225

#line 1225
		isp->exp  = 0;
#line 1225
	}
#line 1225
	else
#line 1225
	{
#line 1225
		/* smaller than ieee can represent */
#line 1225
		isp->exp = 0;
#line 1225
		isp->mant = 0;
#line 1225
	}
#line 1225

	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1230
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1230

#line 1230
	isp->sign = csp->sign;
#line 1230

#line 1230
	if(ieee_exp >= 0xff)
#line 1230
	{
#line 1230
		/* NC_ERANGE => ieee Inf */
#line 1230
		isp->exp = 0xff;
#line 1230
		isp->mant = 0x0;
#line 1230
	}
#line 1230
	else if(ieee_exp > 0)
#line 1230
	{
#line 1230
		/* normal ieee representation */
#line 1230
		isp->exp  = ieee_exp;
#line 1230
		/* assumes cray rep is in normal form */
#line 1230
		assert(csp->mant & 0x800000000000);
#line 1230
		isp->mant = (((csp->mant << 1) &
#line 1230
				0xffffffffffff) >> (48 - 23));
#line 1230
	}
#line 1230
	else if(ieee_exp > -23)
#line 1230
	{
#line 1230
		/* ieee subnormal, right shift */
#line 1230
		const int rshift = (48 - 23 - ieee_exp);
#line 1230

#line 1230
		isp->mant = csp->mant >> rshift;
#line 1230

#line 1230
#if 0
#line 1230
		if(csp->mant & (1 << (rshift -1)))
#line 1230
		{
#line 1230
			/* round up */
#line 1230
			isp->mant++;
#line 1230
		}
#line 1230
#endif
#line 1230

#line 1230
		isp->exp  = 0;
#line 1230
	}
#line 1230
	else
#line 1230
	{
#line 1230
		/* smaller than ieee can represent */
#line 1230
		isp->exp = 0;
#line 1230
		isp->mant = 0;
#line 1230
	}
#line 1230

	}
}

#else
	/* IEEE Cray with only doubles */
static void
get_ix_float(const void *xp, float *ip)
{

	ieee_double *idp = (ieee_double *) ip;

	if(word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		if(isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		if(isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	const ieee_double *idp = (const ieee_double *) ip;
	if(word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
		if(idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
		if(idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
}
#endif

#else
#error "ix_float implementation"
#endif

#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_get_float_float(const void *xp, float *ip)
{
	/* TODO */
	get_ix_float(xp, ip);
	return ENOERR;
}
#endif

#define ix_float float

static int
#line 1317
ncx_get_float_schar(const void *xp, schar *ip)
#line 1317
{
#line 1317
	ix_float xx;
#line 1317
	get_ix_float(xp, &xx);
#line 1317
	*ip = (schar) xx;
#line 1317
	if(xx > (double)SCHAR_MAX || xx < (double)SCHAR_MIN) return NC_ERANGE;
#line 1317
	return ENOERR;
#line 1317
}
#line 1317

static int
#line 1318
ncx_get_float_short(const void *xp, short *ip)
#line 1318
{
#line 1318
	ix_float xx;
#line 1318
	get_ix_float(xp, &xx);
#line 1318
	*ip = (short) xx;
#line 1318
	if(xx > (double)SHORT_MAX || xx < (double)SHORT_MIN) return NC_ERANGE;
#line 1318
	return ENOERR;
#line 1318
}
#line 1318

static int
#line 1319
ncx_get_float_int(const void *xp, int *ip)
#line 1319
{
#line 1319
	ix_float xx;
#line 1319
	get_ix_float(xp, &xx);
#line 1319
	*ip = (int) xx;
#line 1319
	if(xx > (double)INT_MAX || xx < (double)INT_MIN) return NC_ERANGE;
#line 1319
	return ENOERR;
#line 1319
}
#line 1319

static int
#line 1320
ncx_get_float_double(const void *xp, double *ip)
#line 1320
{
#line 1320
	ix_float xx;
#line 1320
	get_ix_float(xp, &xx);
#line 1320
	*ip = (double) xx;
#line 1320

#line 1320
	return ENOERR;
#line 1320
}
#line 1320

static int
#line 1321
ncx_get_float_longlong(const void *xp, longlong *ip)
#line 1321
{
#line 1321
	ix_float xx;
#line 1321
	get_ix_float(xp, &xx);
#line 1321
	*ip = (longlong) xx;
#line 1321
	if(xx > (double)LONGLONG_MAX || xx < (double)LONGLONG_MIN) return NC_ERANGE;
#line 1321
	return ENOERR;
#line 1321
}
#line 1321

static int
#line 1322
ncx_get_float_uchar(const void *xp, uchar *ip)
#line 1322
{
#line 1322
	ix_float xx;
#line 1322
	get_ix_float(xp, &xx);
#line 1322
	*ip = (uchar) xx;
#line 1322
	if(xx > (double)UCHAR_MAX || xx < 0) return NC_ERANGE;
#line 1322
	return ENOERR;
#line 1322
}
#line 1322

static int
#line 1323
ncx_get_float_ushort(const void *xp, ushort *ip)
#line 1323
{
#line 1323
	ix_float xx;
#line 1323
	get_ix_float(xp, &xx);
#line 1323
	*ip = (ushort) xx;
#line 1323
	if(xx > (double)USHORT_MAX || xx < 0) return NC_ERANGE;
#line 1323
	return ENOERR;
#line 1323
}
#line 1323

static int
#line 1324
ncx_get_float_uint(const void *xp, uint *ip)
#line 1324
{
#line 1324
	ix_float xx;
#line 1324
	get_ix_float(xp, &xx);
#line 1324
	*ip = (uint) xx;
#line 1324
	if(xx > (double)UINT_MAX || xx < 0) return NC_ERANGE;
#line 1324
	return ENOERR;
#line 1324
}
#line 1324

static int
#line 1325
ncx_get_float_ulonglong(const void *xp, ulonglong *ip)
#line 1325
{
#line 1325
	ix_float xx;
#line 1325
	get_ix_float(xp, &xx);
#line 1325
	*ip = (ulonglong) xx;
#line 1325
	if(xx > (double)ULONGLONG_MAX || xx < 0) return NC_ERANGE;
#line 1325
	return ENOERR;
#line 1325
}
#line 1325


#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_put_float_float(void *xp, const float *ip)
{
	put_ix_float(xp, ip);
#ifdef NO_IEEE_FLOAT
	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}
#endif

static int
#line 1340
ncx_put_float_schar(void *xp, const schar *ip)
#line 1340
{
#line 1340
	ix_float xx = (ix_float)*ip;
#line 1340
	put_ix_float(xp, &xx);
#line 1340

#line 1340
	return ENOERR;
#line 1340
}
#line 1340

static int
#line 1341
ncx_put_float_short(void *xp, const short *ip)
#line 1341
{
#line 1341
	ix_float xx = (ix_float)*ip;
#line 1341
	put_ix_float(xp, &xx);
#line 1341

#line 1341
	return ENOERR;
#line 1341
}
#line 1341

static int
#line 1342
ncx_put_float_int(void *xp, const int *ip)
#line 1342
{
#line 1342
	ix_float xx = (ix_float)*ip;
#line 1342
	put_ix_float(xp, &xx);
#line 1342

#line 1342
	return ENOERR;
#line 1342
}
#line 1342

static int
#line 1343
ncx_put_float_double(void *xp, const double *ip)
#line 1343
{
#line 1343
	ix_float xx = (ix_float)*ip;
#line 1343
	put_ix_float(xp, &xx);
#line 1343
	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN) return NC_ERANGE;
#line 1343
	return ENOERR;
#line 1343
}
#line 1343

static int
#line 1344
ncx_put_float_longlong(void *xp, const longlong *ip)
#line 1344
{
#line 1344
	ix_float xx = (ix_float)*ip;
#line 1344
	put_ix_float(xp, &xx);
#line 1344

#line 1344
	return ENOERR;
#line 1344
}
#line 1344

static int
#line 1345
ncx_put_float_uchar(void *xp, const uchar *ip)
#line 1345
{
#line 1345
	ix_float xx = (ix_float)*ip;
#line 1345
	put_ix_float(xp, &xx);
#line 1345

#line 1345
	return ENOERR;
#line 1345
}
#line 1345

static int
#line 1346
ncx_put_float_ushort(void *xp, const ushort *ip)
#line 1346
{
#line 1346
	ix_float xx = (ix_float)*ip;
#line 1346
	put_ix_float(xp, &xx);
#line 1346

#line 1346
	return ENOERR;
#line 1346
}
#line 1346

static int
#line 1347
ncx_put_float_uint(void *xp, const uint *ip)
#line 1347
{
#line 1347
	ix_float xx = (ix_float)*ip;
#line 1347
	put_ix_float(xp, &xx);
#line 1347

#line 1347
	return ENOERR;
#line 1347
}
#line 1347

static int
#line 1348
ncx_put_float_ulonglong(void *xp, const ulonglong *ip)
#line 1348
{
#line 1348
	ix_float xx = (ix_float)*ip;
#line 1348
	put_ix_float(xp, &xx);
#line 1348

#line 1348
	return ENOERR;
#line 1348
}
#line 1348



/* x_double ------------------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE  && !defined(NO_IEEE_FLOAT)

static void
get_ix_double(const void *xp, double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, sizeof(double));
#else
	swap8b(ip, xp);
#endif
}

static void
put_ix_double(void *xp, const double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_DOUBLE);
#else
	swap8b(xp, ip);
#endif
}

#elif vax

/* What IEEE double precision floating point looks like on a Vax */
struct	ieee_double {
	unsigned int	exp_hi   : 7;
	unsigned int	sign     : 1;
	unsigned int 	mant_6   : 4;
	unsigned int	exp_lo   : 4;
	unsigned int	mant_5   : 8;
	unsigned int	mant_4   : 8;

	unsigned int	mant_lo  : 32;
};

/* Vax double precision floating point */
struct  vax_double {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
	unsigned int	mantissa3 : 16;
	unsigned int	mantissa4 : 16;
};

#define VAX_DBL_BIAS	0x81
#define IEEE_DBL_BIAS	0x3ff
#define MASK(nbits)	((1 << nbits) - 1)

static const struct dbl_limits {
	struct	vax_double d;
	struct	ieee_double ieee;
} dbl_limits[2] = {
	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0}}, /* Max IEEE */
	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}, /* Min IEEE */
};


#line 1462
static void
get_ix_double(const void *xp, double *ip)
{
	struct vax_double *const vdp =
#line 1465
			 (struct vax_double *)ip;
#line 1465
	const struct ieee_double *const idp =
#line 1465
			 (const struct ieee_double *) xp;
#line 1465
	{
#line 1465
		const struct dbl_limits *lim;
#line 1465
		int ii;
#line 1465
		for (ii = 0, lim = dbl_limits;
#line 1465
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 1465
			ii++, lim++)
#line 1465
		{
#line 1465
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 1465
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 1465
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 1465
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 1465
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 1465
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 1465
				)
#line 1465
			{
#line 1465
				*vdp = lim->d;
#line 1465
				goto doneit;
#line 1465
			}
#line 1465
		}
#line 1465
	}
#line 1465
	{
#line 1465
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 1465
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 1465
	}
#line 1465
	{
#line 1465
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 1465
				 | (idp->mant_5 << 8)
#line 1465
				 | idp->mant_4);
#line 1465
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 1465
		vdp->mantissa1 = (mant_hi >> 13);
#line 1465
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 1465
				| (mant_lo >> 29);
#line 1465
		vdp->mantissa3 = (mant_lo >> 13);
#line 1465
		vdp->mantissa4 = (mant_lo << 3);
#line 1465
	}
#line 1465
	doneit:
#line 1465
		vdp->sign = idp->sign;
#line 1465

}


#line 1535
static void
put_ix_double(void *xp, const double *ip)
{
	const struct vax_double *const vdp =
#line 1538
			(const struct vax_double *)ip;
#line 1538
	struct ieee_double *const idp =
#line 1538
			 (struct ieee_double *) xp;
#line 1538

#line 1538
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 1538
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 1538
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 1538
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 1538
		(vdp->exp == dbl_limits[0].d.exp))
#line 1538
	{
#line 1538
		*idp = dbl_limits[0].ieee;
#line 1538
		goto shipit;
#line 1538
	}
#line 1538
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 1538
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 1538
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 1538
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 1538
		(vdp->exp == dbl_limits[1].d.exp))
#line 1538
	{
#line 1538
		*idp = dbl_limits[1].ieee;
#line 1538
		goto shipit;
#line 1538
	}
#line 1538

#line 1538
	{
#line 1538
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 1538

#line 1538
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 1538
			(vdp->mantissa3 << 13) |
#line 1538
			((vdp->mantissa4 >> 3) & MASK(13));
#line 1538

#line 1538
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 1538
				 | (vdp->mantissa2 >> 3);
#line 1538

#line 1538
		if((vdp->mantissa4 & 7) > 4)
#line 1538
		{
#line 1538
			/* round up */
#line 1538
			mant_lo++;
#line 1538
			if(mant_lo == 0)
#line 1538
			{
#line 1538
				mant_hi++;
#line 1538
				if(mant_hi > 0xffffff)
#line 1538
				{
#line 1538
					mant_hi = 0;
#line 1538
					exp++;
#line 1538
				}
#line 1538
			}
#line 1538
		}
#line 1538

#line 1538
		idp->mant_lo = SWAP4(mant_lo);
#line 1538
		idp->mant_6 = mant_hi >> 16;
#line 1538
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 1538
		idp->mant_4 = mant_hi;
#line 1538
		idp->exp_hi = exp >> 4;
#line 1538
		idp->exp_lo = exp;
#line 1538
	}
#line 1538

#line 1538
	shipit:
#line 1538
		idp->sign = vdp->sign;
#line 1538

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

static void
get_ix_double(const void *xp, double *ip)
{
	const ieee_double *idp = (const ieee_double *) xp;
	cray_single *csp = (cray_single *) ip;

	if(idp->exp == 0)
	{
		/* ieee subnormal */
		*ip = (double)idp->mant;
		if(idp->mant != 0)
		{
			csp->exp -= (ieee_double_bias + 51);
		}
	}
	else
	{
		csp->exp  = idp->exp + cs_id_bias + 1;
		csp->mant = idp->mant >> (52 - 48 + 1);
		csp->mant |= (1 << (48 - 1));
	}
	csp->sign = idp->sign;
}

static void
put_ix_double(void *xp, const double *ip)
{
	ieee_double *idp = (ieee_double *) xp;
	const cray_single *csp = (const cray_single *) ip;

	int ieee_exp = csp->exp - cs_id_bias -1;

	idp->sign = csp->sign;

	if(ieee_exp >= 0x7ff)
	{
		/* NC_ERANGE => ieee Inf */
		idp->exp = 0x7ff;
		idp->mant = 0x0;
	}
	else if(ieee_exp > 0)
	{
		/* normal ieee representation */
		idp->exp  = ieee_exp;
		/* assumes cray rep is in normal form */
		assert(csp->mant & 0x800000000000);
		idp->mant = (((csp->mant << 1) &
				0xffffffffffff) << (52 - 48));
	}
	else if(ieee_exp >= (-(52 -48)))
	{
		/* ieee subnormal, left shift */
		const int lshift = (52 - 48) + ieee_exp;
		idp->mant = csp->mant << lshift;
		idp->exp  = 0;
	}
	else if(ieee_exp >= -52)
	{
		/* ieee subnormal, right shift */
		const int rshift = (- (52 - 48) - ieee_exp);

		idp->mant = csp->mant >> rshift;

#if 0
		if(csp->mant & (1 << (rshift -1)))
		{
			/* round up */
			idp->mant++;
		}
#endif

		idp->exp  = 0;
	}
	else
	{
		/* smaller than ieee can represent */
		idp->exp = 0;
		idp->mant = 0;
	}
}
#else
#error "ix_double implementation"
#endif

#define ix_double double

static int
#line 1630
ncx_get_double_schar(const void *xp, schar *ip)
#line 1630
{
#line 1630
	ix_double xx;
#line 1630
	get_ix_double(xp, &xx);
#line 1630
	*ip = (schar) xx;
#line 1630
	if(xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 1630
	return ENOERR;
#line 1630
}
#line 1630

static int
#line 1631
ncx_get_double_short(const void *xp, short *ip)
#line 1631
{
#line 1631
	ix_double xx;
#line 1631
	get_ix_double(xp, &xx);
#line 1631
	*ip = (short) xx;
#line 1631
	if(xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 1631
	return ENOERR;
#line 1631
}
#line 1631

static int
#line 1632
ncx_get_double_int(const void *xp, int *ip)
#line 1632
{
#line 1632
	ix_double xx;
#line 1632
	get_ix_double(xp, &xx);
#line 1632
	*ip = (int) xx;
#line 1632
	if(xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 1632
	return ENOERR;
#line 1632
}
#line 1632

static int
#line 1633
ncx_get_double_longlong(const void *xp, longlong *ip)
#line 1633
{
#line 1633
	ix_double xx;
#line 1633
	get_ix_double(xp, &xx);
#line 1633
	*ip = (longlong) xx;
#line 1633
	if(xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 1633
	return ENOERR;
#line 1633
}
#line 1633

static int
#line 1634
ncx_get_double_uchar(const void *xp, uchar *ip)
#line 1634
{
#line 1634
	ix_double xx;
#line 1634
	get_ix_double(xp, &xx);
#line 1634
	*ip = (uchar) xx;
#line 1634
	if(xx > UCHAR_MAX || xx < 0) return NC_ERANGE;
#line 1634
	return ENOERR;
#line 1634
}
#line 1634

static int
#line 1635
ncx_get_double_ushort(const void *xp, ushort *ip)
#line 1635
{
#line 1635
	ix_double xx;
#line 1635
	get_ix_double(xp, &xx);
#line 1635
	*ip = (ushort) xx;
#line 1635
	if(xx > USHORT_MAX || xx < 0) return NC_ERANGE;
#line 1635
	return ENOERR;
#line 1635
}
#line 1635

static int
#line 1636
ncx_get_double_uint(const void *xp, uint *ip)
#line 1636
{
#line 1636
	ix_double xx;
#line 1636
	get_ix_double(xp, &xx);
#line 1636
	*ip = (uint) xx;
#line 1636
	if(xx > UINT_MAX || xx < 0) return NC_ERANGE;
#line 1636
	return ENOERR;
#line 1636
}
#line 1636

static int
#line 1637
ncx_get_double_ulonglong(const void *xp, ulonglong *ip)
#line 1637
{
#line 1637
	ix_double xx;
#line 1637
	get_ix_double(xp, &xx);
#line 1637
	*ip = (ulonglong) xx;
#line 1637
	if(xx > ULONGLONG_MAX || xx < 0) return NC_ERANGE;
#line 1637
	return ENOERR;
#line 1637
}
#line 1637


static int
ncx_get_double_float(const void *xp, float *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	if(xx > FLT_MAX)
	{
		*ip = FLT_MAX;
		return NC_ERANGE;
	}
	if(xx < (-FLT_MAX))
	{
		*ip = (-FLT_MAX);
		return NC_ERANGE;
	}
	*ip = (float) xx;
	return ENOERR;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_get_double_double(const void *xp, double *ip)
{
	/* TODO */
	get_ix_double(xp, ip);
	return ENOERR;
}
#endif

static int
#line 1668
ncx_put_double_schar(void *xp, const schar *ip)
#line 1668
{
#line 1668
	ix_double xx = (ix_double)*ip;
#line 1668
	put_ix_double(xp, &xx);
#line 1668

#line 1668
	return ENOERR;
#line 1668
}
#line 1668

static int
#line 1669
ncx_put_double_uchar(void *xp, const uchar *ip)
#line 1669
{
#line 1669
	ix_double xx = (ix_double)*ip;
#line 1669
	put_ix_double(xp, &xx);
#line 1669

#line 1669
	return ENOERR;
#line 1669
}
#line 1669

static int
#line 1670
ncx_put_double_short(void *xp, const short *ip)
#line 1670
{
#line 1670
	ix_double xx = (ix_double)*ip;
#line 1670
	put_ix_double(xp, &xx);
#line 1670

#line 1670
	return ENOERR;
#line 1670
}
#line 1670

static int
#line 1671
ncx_put_double_ushort(void *xp, const ushort *ip)
#line 1671
{
#line 1671
	ix_double xx = (ix_double)*ip;
#line 1671
	put_ix_double(xp, &xx);
#line 1671

#line 1671
	return ENOERR;
#line 1671
}
#line 1671

static int
#line 1672
ncx_put_double_int(void *xp, const int *ip)
#line 1672
{
#line 1672
	ix_double xx = (ix_double)*ip;
#line 1672
	put_ix_double(xp, &xx);
#line 1672

#line 1672
	return ENOERR;
#line 1672
}
#line 1672

static int
#line 1673
ncx_put_double_uint(void *xp, const uint *ip)
#line 1673
{
#line 1673
	ix_double xx = (ix_double)*ip;
#line 1673
	put_ix_double(xp, &xx);
#line 1673

#line 1673
	return ENOERR;
#line 1673
}
#line 1673

static int
#line 1674
ncx_put_double_longlong(void *xp, const longlong *ip)
#line 1674
{
#line 1674
	ix_double xx = (ix_double)*ip;
#line 1674
	put_ix_double(xp, &xx);
#line 1674

#line 1674
	return ENOERR;
#line 1674
}
#line 1674

static int
#line 1675
ncx_put_double_ulonglong(void *xp, const ulonglong *ip)
#line 1675
{
#line 1675
	ix_double xx = (ix_double)*ip;
#line 1675
	put_ix_double(xp, &xx);
#line 1675

#line 1675
	return ENOERR;
#line 1675
}
#line 1675


static int
ncx_put_double_float(void *xp, const float *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 1	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_put_double_double(void *xp, const double *ip)
{
	put_ix_double(xp, ip);
#ifdef NO_IEEE_FLOAT
	if(*ip > X_DOUBLE_MAX || *ip < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}
#endif


/* x_longlong ---------------------------------------------------------------------*/

#if SHORT_MAX == X_LONGLONG_MAX
typedef short ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_SHORT
#define IX_LONGLONG_MAX SHORT_MAX
#elif LONG_LONG_MAX  >= X_LONGLONG_MAX
typedef longlong ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_LONGLONG
#define IX_LONGLONG_MAX LONG_LONG_MAX
#elif LONG_MAX  >= X_LONGLONG_MAX
typedef long ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_LONG
#define IX_LONGLONG_MAX LONG_MAX
#else
#error "ix_longlong implementation"
#endif


static void
get_ix_longlong(const void *xp, ix_longlong *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((long long)(*cp++) << 56);
    *ip |= ((long long)(*cp++) << 48);
    *ip |= ((long long)(*cp++) << 40);
    *ip |= ((long long)(*cp++) << 32);
    *ip |= ((long long)(*cp++) << 24);
    *ip |= ((long long)(*cp++) << 16);
    *ip |= ((long long)(*cp++) <<  8);
    *ip |=  (long long)*cp;
}

static void
put_ix_longlong(void *xp, const ix_longlong *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (*ip) >> 56;
    *cp++ = ((*ip) & 0x00ff000000000000LL) >> 48;
    *cp++ = ((*ip) & 0x0000ff0000000000LL) >> 40;
    *cp++ = ((*ip) & 0x000000ff00000000LL) >> 32;
    *cp++ = ((*ip) & 0x00000000ff000000LL) >> 24;
    *cp++ = ((*ip) & 0x0000000000ff0000LL) >> 16;
    *cp++ = ((*ip) & 0x000000000000ff00LL) >>  8;
    *cp   = ((*ip) & 0x00000000000000ffLL);
}

static int
#line 1752
ncx_get_longlong_schar(const void *xp, schar *ip)
#line 1752
{
#line 1752
	ix_longlong xx;
#line 1752
	get_ix_longlong(xp, &xx);
#line 1752
	*ip = (schar) xx;
#line 1752
#if IX_LONGLONG_MAX > SCHAR_MAX
#line 1752
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 1752
#endif
#line 1752

#line 1752
	return ENOERR;
#line 1752
}
#line 1752

static int
#line 1753
ncx_get_longlong_short(const void *xp, short *ip)
#line 1753
{
#line 1753
#if SIZEOF_IX_LONGLONG == SIZEOF_SHORT && IX_LONGLONG_MAX == SHORT_MAX
#line 1753
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1753
	return ENOERR;
#line 1753
#else
#line 1753
	ix_longlong xx;
#line 1753
	get_ix_longlong(xp, &xx);
#line 1753
	*ip = (short) xx;
#line 1753
#if IX_LONGLONG_MAX > SHORT_MAX
#line 1753
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 1753
#endif
#line 1753

#line 1753
#endif
#line 1753
	return ENOERR;
#line 1753
}
#line 1753

static int
#line 1754
ncx_get_longlong_int(const void *xp, int *ip)
#line 1754
{
#line 1754
#if SIZEOF_IX_LONGLONG == SIZEOF_INT && IX_LONGLONG_MAX == INT_MAX
#line 1754
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1754
	return ENOERR;
#line 1754
#else
#line 1754
	ix_longlong xx;
#line 1754
	get_ix_longlong(xp, &xx);
#line 1754
	*ip = (int) xx;
#line 1754
#if IX_LONGLONG_MAX > INT_MAX
#line 1754
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 1754
#endif
#line 1754

#line 1754
#endif
#line 1754
	return ENOERR;
#line 1754
}
#line 1754

static int
#line 1755
ncx_get_longlong_longlong(const void *xp, longlong *ip)
#line 1755
{
#line 1755
#if SIZEOF_IX_LONGLONG == SIZEOF_LONGLONG && IX_LONGLONG_MAX == LONGLONG_MAX
#line 1755
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1755
	return ENOERR;
#line 1755
#else
#line 1755
	ix_longlong xx;
#line 1755
	get_ix_longlong(xp, &xx);
#line 1755
	*ip = (longlong) xx;
#line 1755
#if IX_LONGLONG_MAX > LONGLONG_MAX
#line 1755
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 1755
#endif
#line 1755

#line 1755
#endif
#line 1755
	return ENOERR;
#line 1755
}
#line 1755

static int
#line 1756
ncx_get_longlong_ushort(const void *xp, ushort *ip)
#line 1756
{
#line 1756
	ix_longlong xx;
#line 1756
	get_ix_longlong(xp, &xx);
#line 1756
	*ip = (ushort) xx;
#line 1756
#if IX_LONGLONG_MAX > USHORT_MAX
#line 1756
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 1756
#endif
#line 1756
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1756
	return ENOERR;
#line 1756
}
#line 1756

static int
#line 1757
ncx_get_longlong_uchar(const void *xp, uchar *ip)
#line 1757
{
#line 1757
	ix_longlong xx;
#line 1757
	get_ix_longlong(xp, &xx);
#line 1757
	*ip = (uchar) xx;
#line 1757
#if IX_LONGLONG_MAX > UCHAR_MAX
#line 1757
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 1757
#endif
#line 1757
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1757
	return ENOERR;
#line 1757
}
#line 1757

static int
#line 1758
ncx_get_longlong_uint(const void *xp, uint *ip)
#line 1758
{
#line 1758
	ix_longlong xx;
#line 1758
	get_ix_longlong(xp, &xx);
#line 1758
	*ip = (uint) xx;
#line 1758
#if IX_LONGLONG_MAX > UINT_MAX
#line 1758
	if (xx > UINT_MAX) return NC_ERANGE;
#line 1758
#endif
#line 1758
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1758
	return ENOERR;
#line 1758
}
#line 1758

static int
#line 1759
ncx_get_longlong_ulonglong(const void *xp, ulonglong *ip)
#line 1759
{
#line 1759
	ix_longlong xx;
#line 1759
	get_ix_longlong(xp, &xx);
#line 1759
	*ip = (ulonglong) xx;
#line 1759
#if IX_LONGLONG_MAX > ULONGLONG_MAX
#line 1759
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 1759
#endif
#line 1759
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1759
	return ENOERR;
#line 1759
}
#line 1759

static int
#line 1760
ncx_get_longlong_float(const void *xp, float *ip)
#line 1760
{
#line 1760
	ix_longlong xx;
#line 1760
	get_ix_longlong(xp, &xx);
#line 1760
	*ip = (float) xx;
#line 1760

#line 1760
	return ENOERR;
#line 1760
}
#line 1760

static int
#line 1761
ncx_get_longlong_double(const void *xp, double *ip)
#line 1761
{
#line 1761
	ix_longlong xx;
#line 1761
	get_ix_longlong(xp, &xx);
#line 1761
	*ip = (double) xx;
#line 1761

#line 1761
	return ENOERR;
#line 1761
}
#line 1761


static int
#line 1763
ncx_put_longlong_schar(void *xp, const schar *ip)
#line 1763
{
#line 1763
	ix_longlong xx = (ix_longlong)*ip;
#line 1763
	put_ix_longlong(xp, &xx);
#line 1763
#if IX_LONGLONG_MAX < SCHAR_MAX
#line 1763
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1763
#endif
#line 1763

#line 1763
	return ENOERR;
#line 1763
}
#line 1763

static int
#line 1764
ncx_put_longlong_short(void *xp, const short *ip)
#line 1764
{
#line 1764
#if SIZEOF_IX_LONGLONG == SIZEOF_SHORT && IX_LONGLONG_MAX == SHORT_MAX
#line 1764
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1764
	return ENOERR;
#line 1764
#else
#line 1764
	ix_longlong xx = (ix_longlong)*ip;
#line 1764
	put_ix_longlong(xp, &xx);
#line 1764
#if IX_LONGLONG_MAX < SHORT_MAX
#line 1764
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1764
#endif
#line 1764

#line 1764
#endif
#line 1764
	return ENOERR;
#line 1764
}
#line 1764

static int
#line 1765
ncx_put_longlong_int(void *xp, const int *ip)
#line 1765
{
#line 1765
#if SIZEOF_IX_LONGLONG == SIZEOF_INT && IX_LONGLONG_MAX == INT_MAX
#line 1765
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1765
	return ENOERR;
#line 1765
#else
#line 1765
	ix_longlong xx = (ix_longlong)*ip;
#line 1765
	put_ix_longlong(xp, &xx);
#line 1765
#if IX_LONGLONG_MAX < INT_MAX
#line 1765
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1765
#endif
#line 1765

#line 1765
#endif
#line 1765
	return ENOERR;
#line 1765
}
#line 1765

static int
#line 1766
ncx_put_longlong_longlong(void *xp, const longlong *ip)
#line 1766
{
#line 1766
#if SIZEOF_IX_LONGLONG == SIZEOF_LONGLONG && IX_LONGLONG_MAX == LONGLONG_MAX
#line 1766
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1766
	return ENOERR;
#line 1766
#else
#line 1766
	ix_longlong xx = (ix_longlong)*ip;
#line 1766
	put_ix_longlong(xp, &xx);
#line 1766
#if IX_LONGLONG_MAX < LONGLONG_MAX
#line 1766
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1766
#endif
#line 1766

#line 1766
#endif
#line 1766
	return ENOERR;
#line 1766
}
#line 1766

static int
#line 1767
ncx_put_longlong_ushort(void *xp, const ushort *ip)
#line 1767
{
#line 1767
	ix_longlong xx = (ix_longlong)*ip;
#line 1767
	put_ix_longlong(xp, &xx);
#line 1767
#if IX_LONGLONG_MAX < USHORT_MAX
#line 1767
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1767
#endif
#line 1767

#line 1767
	return ENOERR;
#line 1767
}
#line 1767

static int
#line 1768
ncx_put_longlong_uchar(void *xp, const uchar *ip)
#line 1768
{
#line 1768
	ix_longlong xx = (ix_longlong)*ip;
#line 1768
	put_ix_longlong(xp, &xx);
#line 1768
#if IX_LONGLONG_MAX < UCHAR_MAX
#line 1768
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1768
#endif
#line 1768

#line 1768
	return ENOERR;
#line 1768
}
#line 1768

static int
#line 1769
ncx_put_longlong_uint(void *xp, const uint *ip)
#line 1769
{
#line 1769
	ix_longlong xx = (ix_longlong)*ip;
#line 1769
	put_ix_longlong(xp, &xx);
#line 1769
#if IX_LONGLONG_MAX < UINT_MAX
#line 1769
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1769
#endif
#line 1769

#line 1769
	return ENOERR;
#line 1769
}
#line 1769

static int
#line 1770
ncx_put_longlong_ulonglong(void *xp, const ulonglong *ip)
#line 1770
{
#line 1770
	ix_longlong xx = (ix_longlong)*ip;
#line 1770
	put_ix_longlong(xp, &xx);
#line 1770
#if IX_LONGLONG_MAX < ULONGLONG_MAX
#line 1770
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1770
#endif
#line 1770

#line 1770
	return ENOERR;
#line 1770
}
#line 1770

static int
#line 1771
ncx_put_longlong_float(void *xp, const float *ip)
#line 1771
{
#line 1771
	ix_longlong xx = (ix_longlong)*ip;
#line 1771
	put_ix_longlong(xp, &xx);
#line 1771
	if(*ip > (double)X_LONGLONG_MAX || *ip < (double)X_LONGLONG_MIN) return NC_ERANGE;
#line 1771
	return ENOERR;
#line 1771
}
#line 1771

static int
#line 1772
ncx_put_longlong_double(void *xp, const double *ip)
#line 1772
{
#line 1772
	ix_longlong xx = (ix_longlong)*ip;
#line 1772
	put_ix_longlong(xp, &xx);
#line 1772
	if(*ip > X_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1772
	return ENOERR;
#line 1772
}
#line 1772

 

/* x_ulonglong --------------------------------------------------------------------*/

#if USHORT_MAX == X_ULONGLONG_MAX
typedef ushort ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_USHORT
#define IX_ULONGLONG_MAX USHORT_MAX
#elif ULONG_LONG_MAX  >= X_ULONGLONG_MAX
typedef ulonglong ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_ULONGLONG
#define IX_ULONGLONG_MAX ULONG_LONG_MAX
#elif ULONG_MAX  >= X_ULONGLONG_MAX
typedef ulong ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_ULONG
#define IX_ULONGLONG_MAX ULONG_MAX
#else
#error "ix_ulonglong implementation"
#endif


static void
get_ix_ulonglong(const void *xp, ix_ulonglong *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((unsigned long long)(*cp++) << 56);
    *ip |= ((unsigned long long)(*cp++) << 48);
    *ip |= ((unsigned long long)(*cp++) << 40);
    *ip |= ((unsigned long long)(*cp++) << 32);
    *ip |= ((unsigned long long)(*cp++) << 24);
    *ip |= ((unsigned long long)(*cp++) << 16);
    *ip |= ((unsigned long long)(*cp++) <<  8);
    *ip |=  (unsigned long long)*cp;
}

static void
put_ix_ulonglong(void *xp, const ix_ulonglong *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (*ip) >> 56;
    *cp++ = ((*ip) & 0x00ff000000000000ULL) >> 48;
    *cp++ = ((*ip) & 0x0000ff0000000000ULL) >> 40;
    *cp++ = ((*ip) & 0x000000ff00000000ULL) >> 32;
    *cp++ = ((*ip) & 0x00000000ff000000ULL) >> 24;
    *cp++ = ((*ip) & 0x0000000000ff0000ULL) >> 16;
    *cp++ = ((*ip) & 0x000000000000ff00ULL) >>  8;
    *cp   = ((*ip) & 0x00000000000000ffULL);
}

static int
#line 1824
ncx_get_ulonglong_schar(const void *xp, schar *ip)
#line 1824
{
#line 1824
	ix_ulonglong xx;
#line 1824
	get_ix_ulonglong(xp, &xx);
#line 1824
	*ip = (schar) xx;
#line 1824
#if IX_ULONGLONG_MAX > SCHAR_MAX
#line 1824
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 1824
#endif
#line 1824

#line 1824
	return ENOERR;
#line 1824
}
#line 1824

static int
#line 1825
ncx_get_ulonglong_short(const void *xp, short *ip)
#line 1825
{
#line 1825
	ix_ulonglong xx;
#line 1825
	get_ix_ulonglong(xp, &xx);
#line 1825
	*ip = (short) xx;
#line 1825
#if IX_ULONGLONG_MAX > SHORT_MAX
#line 1825
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 1825
#endif
#line 1825

#line 1825
	return ENOERR;
#line 1825
}
#line 1825

static int
#line 1826
ncx_get_ulonglong_int(const void *xp, int *ip)
#line 1826
{
#line 1826
	ix_ulonglong xx;
#line 1826
	get_ix_ulonglong(xp, &xx);
#line 1826
	*ip = (int) xx;
#line 1826
#if IX_ULONGLONG_MAX > INT_MAX
#line 1826
	if (xx > INT_MAX) return NC_ERANGE;
#line 1826
#endif
#line 1826

#line 1826
	return ENOERR;
#line 1826
}
#line 1826

static int
#line 1827
ncx_get_ulonglong_longlong(const void *xp, longlong *ip)
#line 1827
{
#line 1827
	ix_ulonglong xx;
#line 1827
	get_ix_ulonglong(xp, &xx);
#line 1827
	*ip = (longlong) xx;
#line 1827
#if IX_ULONGLONG_MAX > LONGLONG_MAX
#line 1827
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 1827
#endif
#line 1827

#line 1827
	return ENOERR;
#line 1827
}
#line 1827

static int
#line 1828
ncx_get_ulonglong_ushort(const void *xp, ushort *ip)
#line 1828
{
#line 1828
#if SIZEOF_IX_ULONGLONG == SIZEOF_USHORT && IX_ULONGLONG_MAX == USHORT_MAX
#line 1828
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1828
	return ENOERR;
#line 1828
#else
#line 1828
	ix_ulonglong xx;
#line 1828
	get_ix_ulonglong(xp, &xx);
#line 1828
	*ip = (ushort) xx;
#line 1828
#if IX_ULONGLONG_MAX > USHORT_MAX
#line 1828
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 1828
#endif
#line 1828

#line 1828
#endif
#line 1828
	return ENOERR;
#line 1828
}
#line 1828

static int
#line 1829
ncx_get_ulonglong_uchar(const void *xp, uchar *ip)
#line 1829
{
#line 1829
#if SIZEOF_IX_ULONGLONG == SIZEOF_UCHAR && IX_ULONGLONG_MAX == UCHAR_MAX
#line 1829
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1829
	return ENOERR;
#line 1829
#else
#line 1829
	ix_ulonglong xx;
#line 1829
	get_ix_ulonglong(xp, &xx);
#line 1829
	*ip = (uchar) xx;
#line 1829
#if IX_ULONGLONG_MAX > UCHAR_MAX
#line 1829
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 1829
#endif
#line 1829

#line 1829
#endif
#line 1829
	return ENOERR;
#line 1829
}
#line 1829

static int
#line 1830
ncx_get_ulonglong_uint(const void *xp, uint *ip)
#line 1830
{
#line 1830
#if SIZEOF_IX_ULONGLONG == SIZEOF_UINT && IX_ULONGLONG_MAX == UINT_MAX
#line 1830
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1830
	return ENOERR;
#line 1830
#else
#line 1830
	ix_ulonglong xx;
#line 1830
	get_ix_ulonglong(xp, &xx);
#line 1830
	*ip = (uint) xx;
#line 1830
#if IX_ULONGLONG_MAX > UINT_MAX
#line 1830
	if (xx > UINT_MAX) return NC_ERANGE;
#line 1830
#endif
#line 1830

#line 1830
#endif
#line 1830
	return ENOERR;
#line 1830
}
#line 1830

static int
#line 1831
ncx_get_ulonglong_ulonglong(const void *xp, ulonglong *ip)
#line 1831
{
#line 1831
#if SIZEOF_IX_ULONGLONG == SIZEOF_ULONGLONG && IX_ULONGLONG_MAX == ULONGLONG_MAX
#line 1831
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1831
	return ENOERR;
#line 1831
#else
#line 1831
	ix_ulonglong xx;
#line 1831
	get_ix_ulonglong(xp, &xx);
#line 1831
	*ip = (ulonglong) xx;
#line 1831
#if IX_ULONGLONG_MAX > ULONGLONG_MAX
#line 1831
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 1831
#endif
#line 1831

#line 1831
#endif
#line 1831
	return ENOERR;
#line 1831
}
#line 1831

static int
#line 1832
ncx_get_ulonglong_float(const void *xp, float *ip)
#line 1832
{
#line 1832
	ix_ulonglong xx;
#line 1832
	get_ix_ulonglong(xp, &xx);
#line 1832
	*ip = (float) xx;
#line 1832

#line 1832
	return ENOERR;
#line 1832
}
#line 1832

static int
#line 1833
ncx_get_ulonglong_double(const void *xp, double *ip)
#line 1833
{
#line 1833
	ix_ulonglong xx;
#line 1833
	get_ix_ulonglong(xp, &xx);
#line 1833
	*ip = (double) xx;
#line 1833

#line 1833
	return ENOERR;
#line 1833
}
#line 1833


static int
#line 1835
ncx_put_ulonglong_schar(void *xp, const schar *ip)
#line 1835
{
#line 1835
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1835
	put_ix_ulonglong(xp, &xx);
#line 1835
#if IX_ULONGLONG_MAX < SCHAR_MAX
#line 1835
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1835
#endif
#line 1835
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1835
	return ENOERR;
#line 1835
}
#line 1835

static int
#line 1836
ncx_put_ulonglong_short(void *xp, const short *ip)
#line 1836
{
#line 1836
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1836
	put_ix_ulonglong(xp, &xx);
#line 1836
#if IX_ULONGLONG_MAX < SHORT_MAX
#line 1836
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1836
#endif
#line 1836
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1836
	return ENOERR;
#line 1836
}
#line 1836

static int
#line 1837
ncx_put_ulonglong_int(void *xp, const int *ip)
#line 1837
{
#line 1837
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1837
	put_ix_ulonglong(xp, &xx);
#line 1837
#if IX_ULONGLONG_MAX < INT_MAX
#line 1837
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1837
#endif
#line 1837
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1837
	return ENOERR;
#line 1837
}
#line 1837

static int
#line 1838
ncx_put_ulonglong_longlong(void *xp, const longlong *ip)
#line 1838
{
#line 1838
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1838
	put_ix_ulonglong(xp, &xx);
#line 1838
#if IX_ULONGLONG_MAX < LONGLONG_MAX
#line 1838
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1838
#endif
#line 1838
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1838
	return ENOERR;
#line 1838
}
#line 1838

static int
#line 1839
ncx_put_ulonglong_uchar(void *xp, const uchar *ip)
#line 1839
{
#line 1839
#if SIZEOF_IX_ULONGLONG == SIZEOF_UCHAR && IX_ULONGLONG_MAX == UCHAR_MAX
#line 1839
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1839
	return ENOERR;
#line 1839
#else
#line 1839
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1839
	put_ix_ulonglong(xp, &xx);
#line 1839
#if IX_ULONGLONG_MAX < UCHAR_MAX
#line 1839
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1839
#endif
#line 1839

#line 1839
#endif
#line 1839
	return ENOERR;
#line 1839
}
#line 1839

static int
#line 1840
ncx_put_ulonglong_ushort(void *xp, const ushort *ip)
#line 1840
{
#line 1840
#if SIZEOF_IX_ULONGLONG == SIZEOF_USHORT && IX_ULONGLONG_MAX == USHORT_MAX
#line 1840
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1840
	return ENOERR;
#line 1840
#else
#line 1840
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1840
	put_ix_ulonglong(xp, &xx);
#line 1840
#if IX_ULONGLONG_MAX < USHORT_MAX
#line 1840
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1840
#endif
#line 1840

#line 1840
#endif
#line 1840
	return ENOERR;
#line 1840
}
#line 1840

static int
#line 1841
ncx_put_ulonglong_uint(void *xp, const uint *ip)
#line 1841
{
#line 1841
#if SIZEOF_IX_ULONGLONG == SIZEOF_UINT && IX_ULONGLONG_MAX == UINT_MAX
#line 1841
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1841
	return ENOERR;
#line 1841
#else
#line 1841
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1841
	put_ix_ulonglong(xp, &xx);
#line 1841
#if IX_ULONGLONG_MAX < UINT_MAX
#line 1841
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1841
#endif
#line 1841

#line 1841
#endif
#line 1841
	return ENOERR;
#line 1841
}
#line 1841

static int
#line 1842
ncx_put_ulonglong_ulonglong(void *xp, const ulonglong *ip)
#line 1842
{
#line 1842
#if SIZEOF_IX_ULONGLONG == SIZEOF_ULONGLONG && IX_ULONGLONG_MAX == ULONGLONG_MAX
#line 1842
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1842
	return ENOERR;
#line 1842
#else
#line 1842
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1842
	put_ix_ulonglong(xp, &xx);
#line 1842
#if IX_ULONGLONG_MAX < ULONGLONG_MAX
#line 1842
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1842
#endif
#line 1842

#line 1842
#endif
#line 1842
	return ENOERR;
#line 1842
}
#line 1842

static int
#line 1843
ncx_put_ulonglong_float(void *xp, const float *ip)
#line 1843
{
#line 1843
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1843
	put_ix_ulonglong(xp, &xx);
#line 1843
	if(*ip > (double)X_ULONGLONG_MAX || *ip < 0) return NC_ERANGE;
#line 1843
	return ENOERR;
#line 1843
}
#line 1843

static int
#line 1844
ncx_put_ulonglong_double(void *xp, const double *ip)
#line 1844
{
#line 1844
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1844
	put_ix_ulonglong(xp, &xx);
#line 1844
	if(*ip > X_ULONGLONG_MAX || *ip < 0) return NC_ERANGE;
#line 1844
	return ENOERR;
#line 1844
}
#line 1844

 

/* x_size_t */

#if SIZEOF_SIZE_T < X_SIZEOF_SIZE_T
#error "x_size_t implementation"
/* netcdf requires size_t which can hold a values from 0 to 2^32 -1 */
#endif

int
ncx_put_size_t(void **xpp, const size_t *ulp)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
	assert(*ulp <= X_SIZE_MAX);

	*cp++ = (uchar)((*ulp) >> 24);
	*cp++ = (uchar)(((*ulp) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ulp) & 0x0000ff00) >>  8);
	*cp   = (uchar)((*ulp) & 0x000000ff);

	*xpp = (void *)((char *)(*xpp) + X_SIZEOF_SIZE_T);
	return ENOERR;
}

int
ncx_get_size_t(const void **xpp,  size_t *ulp)
{
	/* similar to get_ix_int */
	const uchar *cp = (const uchar *) *xpp;

	*ulp = (unsigned)(*cp++ << 24);
	*ulp |= (*cp++ << 16);
	*ulp |= (*cp++ << 8);
	*ulp |= *cp;

	*xpp = (const void *)((const char *)(*xpp) + X_SIZEOF_SIZE_T);
	return ENOERR;
}

/* x_off_t */

int
ncx_put_off_t(void **xpp, const off_t *lp, size_t sizeof_off_t)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
		/* No negative offsets stored in netcdf */
	if (*lp < 0) {
	  /* Assume this is an overflow of a 32-bit int... */
	  return NC_ERANGE;
	}

	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

	if (sizeof_off_t == 4) {
		*cp++ = (uchar) ((*lp)               >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
	} else {
#if SIZEOF_OFF_T == 4
/* Write a 64-bit offset on a system with only a 32-bit offset */
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;

		*cp++ = (uchar)(((*lp) & 0xff000000) >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
#else
		*cp++ = (uchar) ((*lp)                          >> 56);
		*cp++ = (uchar)(((*lp) & 0x00ff000000000000ULL) >> 48);
		*cp++ = (uchar)(((*lp) & 0x0000ff0000000000ULL) >> 40);
		*cp++ = (uchar)(((*lp) & 0x000000ff00000000ULL) >> 32);
		*cp++ = (uchar)(((*lp) & 0x00000000ff000000ULL) >> 24);
		*cp++ = (uchar)(((*lp) & 0x0000000000ff0000ULL) >> 16);
		*cp++ = (uchar)(((*lp) & 0x000000000000ff00ULL) >>  8);
		*cp   = (uchar)( (*lp) & 0x00000000000000ffULL);
#endif
	}
	*xpp = (void *)((char *)(*xpp) + sizeof_off_t);
	return ENOERR;
}

int
ncx_get_off_t(const void **xpp, off_t *lp, size_t sizeof_off_t)
{
	/* similar to get_ix_int() */
	const uchar *cp = (const uchar *) *xpp;
	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

 	if (sizeof_off_t == 4) {
		*lp =  (off_t)(*cp++ << 24);
		*lp |= (off_t)(*cp++ << 16);
		*lp |= (off_t)(*cp++ <<  8);
		*lp |= (off_t)*cp;
	} else {
#if SIZEOF_OFF_T == 4
/* Read a 64-bit offset on a system with only a 32-bit offset */
/* If the offset overflows, set an error code and return */
		*lp =  ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |= ((off_t)(*cp++));
/*
 * lp now contains the upper 32-bits of the 64-bit offset.  if lp is
 * not zero, then the dataset is larger than can be represented
 * on this system.  Set an error code and return.
 */
		if (*lp != 0) {
		  return NC_ERANGE;
		}

		*lp  = ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;

		if (*lp < 0) {
		  /*
		   * If this fails, then the offset is >2^31, but less
		   * than 2^32 which is not allowed, but is not caught
		   * by the previous check
		   */
		  return NC_ERANGE;
		}
#else
		*lp =  ((off_t)(*cp++) << 56);
		*lp |= ((off_t)(*cp++) << 48);
		*lp |= ((off_t)(*cp++) << 40);
		*lp |= ((off_t)(*cp++) << 32);
		*lp |= ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;
#endif
	}
	*xpp = (const void *)((const char *)(*xpp) + sizeof_off_t);
	return ENOERR;
}

/*----< ncx_get_int32() >--------------------------------------------------*/
int
ncx_get_int32(const void **xpp,
              int         *ip)
{
    const uchar *cp = (const uchar *) *xpp;

    /* cannot call swap4b(), as lp is 8-byte */
    *ip  = (*cp++ << 24);
    *ip |= (*cp++ << 16);
    *ip |= (*cp++ <<  8);
    *ip |=  *cp;

    /* advance *xpp 4 bytes */
    *xpp = (void *)((const char *)(*xpp) + 4);

    return NC_NOERR;
}

/*----< ncx_get_int64() >-------------------------------------------------*/
int
ncx_get_int64(const void **xpp,
              long long   *llp)
{
    const uchar *cp = (const uchar *) *xpp;

    /* below is the same as calling swap8b(llp, *xpp) */
    *llp  = ((long long)(*cp++) << 56);
    *llp |= ((long long)(*cp++) << 48);
    *llp |= ((long long)(*cp++) << 40);
    *llp |= ((long long)(*cp++) << 32);
    *llp |= ((long long)(*cp++) << 24);
    *llp |= ((long long)(*cp++) << 16);
    *llp |= ((long long)(*cp++) <<  8);
    *llp |=  (long long)*cp;

    /* advance *xpp 8 bytes */
    *xpp = (void *)((const char *)(*xpp) + 8);

    return NC_NOERR;
}

/*---< ncx_put_int32() >-----------------------------------------------------*/
/* copy the contents of lp (a signed 32-bit integer) to xpp in Big Endian
 * form and advance *xpp 4 bytes
 */
int
ncx_put_int32(void      **xpp,
              const int   ip)
{
#ifdef WORDS_BIGENDIAN
    int *ptr = (int*) (*xpp); /* typecast to 4-byte integer */
    *ptr = ip;
#else
    /* bitwise shifts below are to produce an integer in Big Endian */
    /* cannot call swap4b(), as lp is 8-byte */
    uchar *cp = (uchar *) *xpp;
    *cp++ = (uchar)((ip & 0xff000000) >> 24);
    *cp++ = (uchar)((ip & 0x00ff0000) >> 16);
    *cp++ = (uchar)((ip & 0x0000ff00) >>  8);
    *cp   = (uchar)( ip & 0x000000ff);
#endif
    /* advance *xpp 4 bytes */
    *xpp  = (void *)((char *)(*xpp) + 4);

    return NC_NOERR;
}

/*---< ncx_put_int64() >-----------------------------------------------------*/
/* copy the contents of lp (a signed 64-bit integer) to xpp in Big Endian
 * form and advance *xpp 8 bytes
 */
int
ncx_put_int64(void             **xpp,
              const long long    ip)
{
#ifdef WORDS_BIGENDIAN
    long long *ptr = (long long*) (*xpp); /* typecast to 8-byte integer */
    *ptr = ip;
#else
    uchar *cp = (uchar *) *xpp;
    /* below is the same as calling swap8b(*xpp, &ip) */
    *cp++ = (uchar)((ip & 0xff00000000000000ULL) >> 56);
    *cp++ = (uchar)((ip & 0x00ff000000000000ULL) >> 48);
    *cp++ = (uchar)((ip & 0x0000ff0000000000ULL) >> 40);
    *cp++ = (uchar)((ip & 0x000000ff00000000ULL) >> 32);
    *cp++ = (uchar)((ip & 0x00000000ff000000ULL) >> 24);
    *cp++ = (uchar)((ip & 0x0000000000ff0000ULL) >> 16);
    *cp++ = (uchar)((ip & 0x000000000000ff00ULL) >>  8);
    *cp   = (uchar)( ip & 0x00000000000000ffULL);
#endif
    /* advance *xpp 8 bytes */
    *xpp  = (void *)((char *)(*xpp) + 8);

    return NC_NOERR;
}

/*----< ncx_get_int32() >--------------------------------------------------*/
int
ncx_get_int32(const void **xpp,
              int         *ip)
{
    const uchar *cp = (const uchar *) *xpp;

    /* cannot call swap4b(), as lp is 8-byte */
    *ip  = (*cp++ << 24);
    *ip |= (*cp++ << 16);
    *ip |= (*cp++ <<  8);
    *ip |=  *cp;

    /* advance *xpp 4 bytes */
    *xpp = (void *)((const char *)(*xpp) + 4);

    return NC_NOERR;
}

/*----< ncx_get_int64() >-------------------------------------------------*/
int
ncx_get_int64(const void **xpp,
              long long   *llp)
{
    const uchar *cp = (const uchar *) *xpp;

    /* below is the same as calling swap8b(llp, *xpp) */
    *llp  = ((long long)(*cp++) << 56);
    *llp |= ((long long)(*cp++) << 48);
    *llp |= ((long long)(*cp++) << 40);
    *llp |= ((long long)(*cp++) << 32);
    *llp |= ((long long)(*cp++) << 24);
    *llp |= ((long long)(*cp++) << 16);
    *llp |= ((long long)(*cp++) <<  8);
    *llp |=  (long long)*cp;

    /* advance *xpp 8 bytes */
    *xpp = (void *)((const char *)(*xpp) + 8);

    return NC_NOERR;
}

/*---< ncx_put_int32() >-----------------------------------------------------*/
/* copy the contents of lp (a signed 32-bit integer) to xpp in Big Endian
 * form and advance *xpp 4 bytes
 */
int
ncx_put_int32(void      **xpp,
              const int   ip)
{
#ifdef WORDS_BIGENDIAN
    int *ptr = (int*) (*xpp); /* typecast to 4-byte integer */
    *ptr = ip;
#else
    /* bitwise shifts below are to produce an integer in Big Endian */
    /* cannot call swap4b(), as lp is 8-byte */
    uchar *cp = (uchar *) *xpp;
    *cp++ = (uchar)((ip & 0xff000000) >> 24);
    *cp++ = (uchar)((ip & 0x00ff0000) >> 16);
    *cp++ = (uchar)((ip & 0x0000ff00) >>  8);
    *cp   = (uchar)( ip & 0x000000ff);
#endif
    /* advance *xpp 4 bytes */
    *xpp  = (void *)((char *)(*xpp) + 4);

    return NC_NOERR;
}

/*---< ncx_put_int64() >-----------------------------------------------------*/
/* copy the contents of lp (a signed 64-bit integer) to xpp in Big Endian
 * form and advance *xpp 8 bytes
 */
int
ncx_put_int64(void             **xpp,
              const long long    ip)
{
#ifdef WORDS_BIGENDIAN
    long long *ptr = (long long*) (*xpp); /* typecast to 8-byte integer */
    *ptr = ip;
#else
    uchar *cp = (uchar *) *xpp;
    /* below is the same as calling swap8b(*xpp, &ip) */
    *cp++ = (uchar)((ip & 0xff00000000000000ULL) >> 56);
    *cp++ = (uchar)((ip & 0x00ff000000000000ULL) >> 48);
    *cp++ = (uchar)((ip & 0x0000ff0000000000ULL) >> 40);
    *cp++ = (uchar)((ip & 0x000000ff00000000ULL) >> 32);
    *cp++ = (uchar)((ip & 0x00000000ff000000ULL) >> 24);
    *cp++ = (uchar)((ip & 0x0000000000ff0000ULL) >> 16);
    *cp++ = (uchar)((ip & 0x000000000000ff00ULL) >>  8);
    *cp   = (uchar)( ip & 0x00000000000000ffULL);
#endif
    /* advance *xpp 8 bytes */
    *xpp  = (void *)((char *)(*xpp) + 8);

    return NC_NOERR;
}


/*
 * Aggregate numeric conversion functions.
 */
#line 2190

#line 2627

#line 2633

/* schar ---------------------------------------------------------------------*/

#line 2637
int
ncx_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2640
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2640
	return ENOERR;
#line 2640

}
#line 2643
int
ncx_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2646
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2646
	return ENOERR;
#line 2646

}
int
#line 2648
ncx_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2648
{
#line 2648
	int status = ENOERR;
#line 2648
	schar *xp = (schar *)(*xpp);
#line 2648

#line 2648
	while(nelems-- != 0)
#line 2648
	{
#line 2648

#line 2648
		*tp++ = *xp++;
#line 2648
	}
#line 2648

#line 2648
	*xpp = (const void *)xp;
#line 2648
	return status;
#line 2648
}
#line 2648

int
#line 2649
ncx_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2649
{
#line 2649
	int status = ENOERR;
#line 2649
	schar *xp = (schar *)(*xpp);
#line 2649

#line 2649
	while(nelems-- != 0)
#line 2649
	{
#line 2649

#line 2649
		*tp++ = *xp++;
#line 2649
	}
#line 2649

#line 2649
	*xpp = (const void *)xp;
#line 2649
	return status;
#line 2649
}
#line 2649

int
#line 2650
ncx_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2650
{
#line 2650
	int status = ENOERR;
#line 2650
	schar *xp = (schar *)(*xpp);
#line 2650

#line 2650
	while(nelems-- != 0)
#line 2650
	{
#line 2650

#line 2650
		*tp++ = *xp++;
#line 2650
	}
#line 2650

#line 2650
	*xpp = (const void *)xp;
#line 2650
	return status;
#line 2650
}
#line 2650

int
#line 2651
ncx_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2651
{
#line 2651
	int status = ENOERR;
#line 2651
	schar *xp = (schar *)(*xpp);
#line 2651

#line 2651
	while(nelems-- != 0)
#line 2651
	{
#line 2651

#line 2651
		*tp++ = *xp++;
#line 2651
	}
#line 2651

#line 2651
	*xpp = (const void *)xp;
#line 2651
	return status;
#line 2651
}
#line 2651

int
#line 2652
ncx_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2652
{
#line 2652
	int status = ENOERR;
#line 2652
	schar *xp = (schar *)(*xpp);
#line 2652

#line 2652
	while(nelems-- != 0)
#line 2652
	{
#line 2652

#line 2652
		*tp++ = *xp++;
#line 2652
	}
#line 2652

#line 2652
	*xpp = (const void *)xp;
#line 2652
	return status;
#line 2652
}
#line 2652

int
#line 2653
ncx_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2653
{
#line 2653
	int status = ENOERR;
#line 2653
	schar *xp = (schar *)(*xpp);
#line 2653

#line 2653
	while(nelems-- != 0)
#line 2653
	{
#line 2653
		if (*xp < 0) status = NC_ERANGE;
#line 2653
		*tp++ = *xp++;
#line 2653
	}
#line 2653

#line 2653
	*xpp = (const void *)xp;
#line 2653
	return status;
#line 2653
}
#line 2653

int
#line 2654
ncx_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2654
{
#line 2654
	int status = ENOERR;
#line 2654
	schar *xp = (schar *)(*xpp);
#line 2654

#line 2654
	while(nelems-- != 0)
#line 2654
	{
#line 2654
		if (*xp < 0) status = NC_ERANGE;
#line 2654
		*tp++ = *xp++;
#line 2654
	}
#line 2654

#line 2654
	*xpp = (const void *)xp;
#line 2654
	return status;
#line 2654
}
#line 2654

int
#line 2655
ncx_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2655
{
#line 2655
	int status = ENOERR;
#line 2655
	schar *xp = (schar *)(*xpp);
#line 2655

#line 2655
	while(nelems-- != 0)
#line 2655
	{
#line 2655
		if (*xp < 0) status = NC_ERANGE;
#line 2655
		*tp++ = *xp++;
#line 2655
	}
#line 2655

#line 2655
	*xpp = (const void *)xp;
#line 2655
	return status;
#line 2655
}
#line 2655


#line 2658
int
ncx_pad_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2661

#line 2661
	if(rndup)
#line 2661
		rndup = X_ALIGN - rndup;
#line 2661

#line 2661
	(void) memcpy(tp, *xpp, nelems);
#line 2661
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2661

#line 2661
	return ENOERR;
#line 2661

}
#line 2664
int
ncx_pad_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2667

#line 2667
	if(rndup)
#line 2667
		rndup = X_ALIGN - rndup;
#line 2667

#line 2667
	(void) memcpy(tp, *xpp, nelems);
#line 2667
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2667

#line 2667
	return ENOERR;
#line 2667

}
int
#line 2669
ncx_pad_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2669
{
#line 2669
	int status = ENOERR;
#line 2669
	size_t rndup = nelems % X_ALIGN;
#line 2669
	schar *xp = (schar *) *xpp;
#line 2669

#line 2669
	if(rndup)
#line 2669
		rndup = X_ALIGN - rndup;
#line 2669

#line 2669
	while(nelems-- != 0)
#line 2669
	{
#line 2669

#line 2669
		*tp++ = *xp++;
#line 2669
	}
#line 2669

#line 2669
	*xpp = (void *)(xp + rndup);
#line 2669
	return status;
#line 2669
}
#line 2669

int
#line 2670
ncx_pad_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2670
{
#line 2670
	int status = ENOERR;
#line 2670
	size_t rndup = nelems % X_ALIGN;
#line 2670
	schar *xp = (schar *) *xpp;
#line 2670

#line 2670
	if(rndup)
#line 2670
		rndup = X_ALIGN - rndup;
#line 2670

#line 2670
	while(nelems-- != 0)
#line 2670
	{
#line 2670

#line 2670
		*tp++ = *xp++;
#line 2670
	}
#line 2670

#line 2670
	*xpp = (void *)(xp + rndup);
#line 2670
	return status;
#line 2670
}
#line 2670

int
#line 2671
ncx_pad_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2671
{
#line 2671
	int status = ENOERR;
#line 2671
	size_t rndup = nelems % X_ALIGN;
#line 2671
	schar *xp = (schar *) *xpp;
#line 2671

#line 2671
	if(rndup)
#line 2671
		rndup = X_ALIGN - rndup;
#line 2671

#line 2671
	while(nelems-- != 0)
#line 2671
	{
#line 2671

#line 2671
		*tp++ = *xp++;
#line 2671
	}
#line 2671

#line 2671
	*xpp = (void *)(xp + rndup);
#line 2671
	return status;
#line 2671
}
#line 2671

int
#line 2672
ncx_pad_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2672
{
#line 2672
	int status = ENOERR;
#line 2672
	size_t rndup = nelems % X_ALIGN;
#line 2672
	schar *xp = (schar *) *xpp;
#line 2672

#line 2672
	if(rndup)
#line 2672
		rndup = X_ALIGN - rndup;
#line 2672

#line 2672
	while(nelems-- != 0)
#line 2672
	{
#line 2672

#line 2672
		*tp++ = *xp++;
#line 2672
	}
#line 2672

#line 2672
	*xpp = (void *)(xp + rndup);
#line 2672
	return status;
#line 2672
}
#line 2672

int
#line 2673
ncx_pad_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2673
{
#line 2673
	int status = ENOERR;
#line 2673
	size_t rndup = nelems % X_ALIGN;
#line 2673
	schar *xp = (schar *) *xpp;
#line 2673

#line 2673
	if(rndup)
#line 2673
		rndup = X_ALIGN - rndup;
#line 2673

#line 2673
	while(nelems-- != 0)
#line 2673
	{
#line 2673

#line 2673
		*tp++ = *xp++;
#line 2673
	}
#line 2673

#line 2673
	*xpp = (void *)(xp + rndup);
#line 2673
	return status;
#line 2673
}
#line 2673

int
#line 2674
ncx_pad_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2674
{
#line 2674
	int status = ENOERR;
#line 2674
	size_t rndup = nelems % X_ALIGN;
#line 2674
	schar *xp = (schar *) *xpp;
#line 2674

#line 2674
	if(rndup)
#line 2674
		rndup = X_ALIGN - rndup;
#line 2674

#line 2674
	while(nelems-- != 0)
#line 2674
	{
#line 2674
		if (*xp < 0) status = NC_ERANGE;
#line 2674
		*tp++ = *xp++;
#line 2674
	}
#line 2674

#line 2674
	*xpp = (void *)(xp + rndup);
#line 2674
	return status;
#line 2674
}
#line 2674

int
#line 2675
ncx_pad_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2675
{
#line 2675
	int status = ENOERR;
#line 2675
	size_t rndup = nelems % X_ALIGN;
#line 2675
	schar *xp = (schar *) *xpp;
#line 2675

#line 2675
	if(rndup)
#line 2675
		rndup = X_ALIGN - rndup;
#line 2675

#line 2675
	while(nelems-- != 0)
#line 2675
	{
#line 2675
		if (*xp < 0) status = NC_ERANGE;
#line 2675
		*tp++ = *xp++;
#line 2675
	}
#line 2675

#line 2675
	*xpp = (void *)(xp + rndup);
#line 2675
	return status;
#line 2675
}
#line 2675

int
#line 2676
ncx_pad_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2676
{
#line 2676
	int status = ENOERR;
#line 2676
	size_t rndup = nelems % X_ALIGN;
#line 2676
	schar *xp = (schar *) *xpp;
#line 2676

#line 2676
	if(rndup)
#line 2676
		rndup = X_ALIGN - rndup;
#line 2676

#line 2676
	while(nelems-- != 0)
#line 2676
	{
#line 2676
		if (*xp < 0) status = NC_ERANGE;
#line 2676
		*tp++ = *xp++;
#line 2676
	}
#line 2676

#line 2676
	*xpp = (void *)(xp + rndup);
#line 2676
	return status;
#line 2676
}
#line 2676


#line 2679
int
ncx_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2682
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2682

#line 2682
	return ENOERR;
#line 2682

}
#line 2685
int
ncx_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2688
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2688

#line 2688
	return ENOERR;
#line 2688

}
int
#line 2690
ncx_putn_schar_short(void **xpp, size_t nelems, const short *tp)
#line 2690
{
#line 2690
	int status = ENOERR;
#line 2690
	schar *xp = (schar *) *xpp;
#line 2690

#line 2690
	while(nelems-- != 0)
#line 2690
	{
#line 2690
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2690
			status = NC_ERANGE;
#line 2690
		*xp++ = (schar) *tp++;
#line 2690
	}
#line 2690

#line 2690
	*xpp = (void *)xp;
#line 2690
	return status;
#line 2690
}
#line 2690

int
#line 2691
ncx_putn_schar_int(void **xpp, size_t nelems, const int *tp)
#line 2691
{
#line 2691
	int status = ENOERR;
#line 2691
	schar *xp = (schar *) *xpp;
#line 2691

#line 2691
	while(nelems-- != 0)
#line 2691
	{
#line 2691
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2691
			status = NC_ERANGE;
#line 2691
		*xp++ = (schar) *tp++;
#line 2691
	}
#line 2691

#line 2691
	*xpp = (void *)xp;
#line 2691
	return status;
#line 2691
}
#line 2691

int
#line 2692
ncx_putn_schar_float(void **xpp, size_t nelems, const float *tp)
#line 2692
{
#line 2692
	int status = ENOERR;
#line 2692
	schar *xp = (schar *) *xpp;
#line 2692

#line 2692
	while(nelems-- != 0)
#line 2692
	{
#line 2692
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2692
			status = NC_ERANGE;
#line 2692
		*xp++ = (schar) *tp++;
#line 2692
	}
#line 2692

#line 2692
	*xpp = (void *)xp;
#line 2692
	return status;
#line 2692
}
#line 2692

int
#line 2693
ncx_putn_schar_double(void **xpp, size_t nelems, const double *tp)
#line 2693
{
#line 2693
	int status = ENOERR;
#line 2693
	schar *xp = (schar *) *xpp;
#line 2693

#line 2693
	while(nelems-- != 0)
#line 2693
	{
#line 2693
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2693
			status = NC_ERANGE;
#line 2693
		*xp++ = (schar) *tp++;
#line 2693
	}
#line 2693

#line 2693
	*xpp = (void *)xp;
#line 2693
	return status;
#line 2693
}
#line 2693

int
#line 2694
ncx_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2694
{
#line 2694
	int status = ENOERR;
#line 2694
	schar *xp = (schar *) *xpp;
#line 2694

#line 2694
	while(nelems-- != 0)
#line 2694
	{
#line 2694
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2694
			status = NC_ERANGE;
#line 2694
		*xp++ = (schar) *tp++;
#line 2694
	}
#line 2694

#line 2694
	*xpp = (void *)xp;
#line 2694
	return status;
#line 2694
}
#line 2694

int
#line 2695
ncx_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2695
{
#line 2695
	int status = ENOERR;
#line 2695
	schar *xp = (schar *) *xpp;
#line 2695

#line 2695
	while(nelems-- != 0)
#line 2695
	{
#line 2695
		if(*tp > X_SCHAR_MAX )
#line 2695
			status = NC_ERANGE;
#line 2695
		*xp++ = (schar) *tp++;
#line 2695
	}
#line 2695

#line 2695
	*xpp = (void *)xp;
#line 2695
	return status;
#line 2695
}
#line 2695

int
#line 2696
ncx_putn_schar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2696
{
#line 2696
	int status = ENOERR;
#line 2696
	schar *xp = (schar *) *xpp;
#line 2696

#line 2696
	while(nelems-- != 0)
#line 2696
	{
#line 2696
		if(*tp > X_SCHAR_MAX )
#line 2696
			status = NC_ERANGE;
#line 2696
		*xp++ = (schar) *tp++;
#line 2696
	}
#line 2696

#line 2696
	*xpp = (void *)xp;
#line 2696
	return status;
#line 2696
}
#line 2696

int
#line 2697
ncx_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2697
{
#line 2697
	int status = ENOERR;
#line 2697
	schar *xp = (schar *) *xpp;
#line 2697

#line 2697
	while(nelems-- != 0)
#line 2697
	{
#line 2697
		if(*tp > X_SCHAR_MAX )
#line 2697
			status = NC_ERANGE;
#line 2697
		*xp++ = (schar) *tp++;
#line 2697
	}
#line 2697

#line 2697
	*xpp = (void *)xp;
#line 2697
	return status;
#line 2697
}
#line 2697


#line 2700
int
ncx_pad_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2703

#line 2703
	if(rndup)
#line 2703
		rndup = X_ALIGN - rndup;
#line 2703

#line 2703
	(void) memcpy(*xpp, tp, nelems);
#line 2703
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2703

#line 2703
	if(rndup)
#line 2703
	{
#line 2703
		(void) memcpy(*xpp, nada, rndup);
#line 2703
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2703
	}
#line 2703

#line 2703
	return ENOERR;
#line 2703

}
#line 2706
int
ncx_pad_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2709

#line 2709
	if(rndup)
#line 2709
		rndup = X_ALIGN - rndup;
#line 2709

#line 2709
	(void) memcpy(*xpp, tp, nelems);
#line 2709
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2709

#line 2709
	if(rndup)
#line 2709
	{
#line 2709
		(void) memcpy(*xpp, nada, rndup);
#line 2709
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2709
	}
#line 2709

#line 2709
	return ENOERR;
#line 2709

}
int
#line 2711
ncx_pad_putn_schar_short(void **xpp, size_t nelems, const short *tp)
#line 2711
{
#line 2711
	int status = ENOERR;
#line 2711
	size_t rndup = nelems % X_ALIGN;
#line 2711
	schar *xp = (schar *) *xpp;
#line 2711

#line 2711
	if(rndup)
#line 2711
		rndup = X_ALIGN - rndup;
#line 2711

#line 2711
	while(nelems-- != 0)
#line 2711
	{
#line 2711
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2711
			status = NC_ERANGE;
#line 2711
		*xp++ = (schar) *tp++;
#line 2711
	}
#line 2711

#line 2711

#line 2711
	if(rndup)
#line 2711
	{
#line 2711
		(void) memcpy(xp, nada, rndup);
#line 2711
		xp += rndup;
#line 2711
	}
#line 2711

#line 2711
	*xpp = (void *)xp;
#line 2711
	return status;
#line 2711
}
#line 2711

int
#line 2712
ncx_pad_putn_schar_int(void **xpp, size_t nelems, const int *tp)
#line 2712
{
#line 2712
	int status = ENOERR;
#line 2712
	size_t rndup = nelems % X_ALIGN;
#line 2712
	schar *xp = (schar *) *xpp;
#line 2712

#line 2712
	if(rndup)
#line 2712
		rndup = X_ALIGN - rndup;
#line 2712

#line 2712
	while(nelems-- != 0)
#line 2712
	{
#line 2712
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2712
			status = NC_ERANGE;
#line 2712
		*xp++ = (schar) *tp++;
#line 2712
	}
#line 2712

#line 2712

#line 2712
	if(rndup)
#line 2712
	{
#line 2712
		(void) memcpy(xp, nada, rndup);
#line 2712
		xp += rndup;
#line 2712
	}
#line 2712

#line 2712
	*xpp = (void *)xp;
#line 2712
	return status;
#line 2712
}
#line 2712

int
#line 2713
ncx_pad_putn_schar_float(void **xpp, size_t nelems, const float *tp)
#line 2713
{
#line 2713
	int status = ENOERR;
#line 2713
	size_t rndup = nelems % X_ALIGN;
#line 2713
	schar *xp = (schar *) *xpp;
#line 2713

#line 2713
	if(rndup)
#line 2713
		rndup = X_ALIGN - rndup;
#line 2713

#line 2713
	while(nelems-- != 0)
#line 2713
	{
#line 2713
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2713
			status = NC_ERANGE;
#line 2713
		*xp++ = (schar) *tp++;
#line 2713
	}
#line 2713

#line 2713

#line 2713
	if(rndup)
#line 2713
	{
#line 2713
		(void) memcpy(xp, nada, rndup);
#line 2713
		xp += rndup;
#line 2713
	}
#line 2713

#line 2713
	*xpp = (void *)xp;
#line 2713
	return status;
#line 2713
}
#line 2713

int
#line 2714
ncx_pad_putn_schar_double(void **xpp, size_t nelems, const double *tp)
#line 2714
{
#line 2714
	int status = ENOERR;
#line 2714
	size_t rndup = nelems % X_ALIGN;
#line 2714
	schar *xp = (schar *) *xpp;
#line 2714

#line 2714
	if(rndup)
#line 2714
		rndup = X_ALIGN - rndup;
#line 2714

#line 2714
	while(nelems-- != 0)
#line 2714
	{
#line 2714
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2714
			status = NC_ERANGE;
#line 2714
		*xp++ = (schar) *tp++;
#line 2714
	}
#line 2714

#line 2714

#line 2714
	if(rndup)
#line 2714
	{
#line 2714
		(void) memcpy(xp, nada, rndup);
#line 2714
		xp += rndup;
#line 2714
	}
#line 2714

#line 2714
	*xpp = (void *)xp;
#line 2714
	return status;
#line 2714
}
#line 2714

int
#line 2715
ncx_pad_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2715
{
#line 2715
	int status = ENOERR;
#line 2715
	size_t rndup = nelems % X_ALIGN;
#line 2715
	schar *xp = (schar *) *xpp;
#line 2715

#line 2715
	if(rndup)
#line 2715
		rndup = X_ALIGN - rndup;
#line 2715

#line 2715
	while(nelems-- != 0)
#line 2715
	{
#line 2715
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2715
			status = NC_ERANGE;
#line 2715
		*xp++ = (schar) *tp++;
#line 2715
	}
#line 2715

#line 2715

#line 2715
	if(rndup)
#line 2715
	{
#line 2715
		(void) memcpy(xp, nada, rndup);
#line 2715
		xp += rndup;
#line 2715
	}
#line 2715

#line 2715
	*xpp = (void *)xp;
#line 2715
	return status;
#line 2715
}
#line 2715

int
#line 2716
ncx_pad_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2716
{
#line 2716
	int status = ENOERR;
#line 2716
	size_t rndup = nelems % X_ALIGN;
#line 2716
	schar *xp = (schar *) *xpp;
#line 2716

#line 2716
	if(rndup)
#line 2716
		rndup = X_ALIGN - rndup;
#line 2716

#line 2716
	while(nelems-- != 0)
#line 2716
	{
#line 2716
		if(*tp > X_SCHAR_MAX )
#line 2716
			status = NC_ERANGE;
#line 2716
		*xp++ = (schar) *tp++;
#line 2716
	}
#line 2716

#line 2716

#line 2716
	if(rndup)
#line 2716
	{
#line 2716
		(void) memcpy(xp, nada, rndup);
#line 2716
		xp += rndup;
#line 2716
	}
#line 2716

#line 2716
	*xpp = (void *)xp;
#line 2716
	return status;
#line 2716
}
#line 2716

int
#line 2717
ncx_pad_putn_schar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2717
{
#line 2717
	int status = ENOERR;
#line 2717
	size_t rndup = nelems % X_ALIGN;
#line 2717
	schar *xp = (schar *) *xpp;
#line 2717

#line 2717
	if(rndup)
#line 2717
		rndup = X_ALIGN - rndup;
#line 2717

#line 2717
	while(nelems-- != 0)
#line 2717
	{
#line 2717
		if(*tp > X_SCHAR_MAX )
#line 2717
			status = NC_ERANGE;
#line 2717
		*xp++ = (schar) *tp++;
#line 2717
	}
#line 2717

#line 2717

#line 2717
	if(rndup)
#line 2717
	{
#line 2717
		(void) memcpy(xp, nada, rndup);
#line 2717
		xp += rndup;
#line 2717
	}
#line 2717

#line 2717
	*xpp = (void *)xp;
#line 2717
	return status;
#line 2717
}
#line 2717

int
#line 2718
ncx_pad_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2718
{
#line 2718
	int status = ENOERR;
#line 2718
	size_t rndup = nelems % X_ALIGN;
#line 2718
	schar *xp = (schar *) *xpp;
#line 2718

#line 2718
	if(rndup)
#line 2718
		rndup = X_ALIGN - rndup;
#line 2718

#line 2718
	while(nelems-- != 0)
#line 2718
	{
#line 2718
		if(*tp > X_SCHAR_MAX )
#line 2718
			status = NC_ERANGE;
#line 2718
		*xp++ = (schar) *tp++;
#line 2718
	}
#line 2718

#line 2718

#line 2718
	if(rndup)
#line 2718
	{
#line 2718
		(void) memcpy(xp, nada, rndup);
#line 2718
		xp += rndup;
#line 2718
	}
#line 2718

#line 2718
	*xpp = (void *)xp;
#line 2718
	return status;
#line 2718
}
#line 2718


/* uchar ---------------------------------------------------------------------*/
#line 2723
int
ncx_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2726
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2726
	return ENOERR;
#line 2726

}
#line 2729
int
ncx_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2732
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2732
	return ENOERR;
#line 2732

}
int
#line 2734
ncx_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2734
{
#line 2734
	int status = ENOERR;
#line 2734
	uchar *xp = (uchar *)(*xpp);
#line 2734

#line 2734
	while(nelems-- != 0)
#line 2734
	{
#line 2734

#line 2734
		*tp++ = *xp++;
#line 2734
	}
#line 2734

#line 2734
	*xpp = (const void *)xp;
#line 2734
	return status;
#line 2734
}
#line 2734

int
#line 2735
ncx_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2735
{
#line 2735
	int status = ENOERR;
#line 2735
	uchar *xp = (uchar *)(*xpp);
#line 2735

#line 2735
	while(nelems-- != 0)
#line 2735
	{
#line 2735

#line 2735
		*tp++ = *xp++;
#line 2735
	}
#line 2735

#line 2735
	*xpp = (const void *)xp;
#line 2735
	return status;
#line 2735
}
#line 2735

int
#line 2736
ncx_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2736
{
#line 2736
	int status = ENOERR;
#line 2736
	uchar *xp = (uchar *)(*xpp);
#line 2736

#line 2736
	while(nelems-- != 0)
#line 2736
	{
#line 2736

#line 2736
		*tp++ = *xp++;
#line 2736
	}
#line 2736

#line 2736
	*xpp = (const void *)xp;
#line 2736
	return status;
#line 2736
}
#line 2736

int
#line 2737
ncx_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2737
{
#line 2737
	int status = ENOERR;
#line 2737
	uchar *xp = (uchar *)(*xpp);
#line 2737

#line 2737
	while(nelems-- != 0)
#line 2737
	{
#line 2737

#line 2737
		*tp++ = *xp++;
#line 2737
	}
#line 2737

#line 2737
	*xpp = (const void *)xp;
#line 2737
	return status;
#line 2737
}
#line 2737

int
#line 2738
ncx_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2738
{
#line 2738
	int status = ENOERR;
#line 2738
	uchar *xp = (uchar *)(*xpp);
#line 2738

#line 2738
	while(nelems-- != 0)
#line 2738
	{
#line 2738

#line 2738
		*tp++ = *xp++;
#line 2738
	}
#line 2738

#line 2738
	*xpp = (const void *)xp;
#line 2738
	return status;
#line 2738
}
#line 2738

int
#line 2739
ncx_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2739
{
#line 2739
	int status = ENOERR;
#line 2739
	uchar *xp = (uchar *)(*xpp);
#line 2739

#line 2739
	while(nelems-- != 0)
#line 2739
	{
#line 2739

#line 2739
		*tp++ = *xp++;
#line 2739
	}
#line 2739

#line 2739
	*xpp = (const void *)xp;
#line 2739
	return status;
#line 2739
}
#line 2739

int
#line 2740
ncx_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2740
{
#line 2740
	int status = ENOERR;
#line 2740
	uchar *xp = (uchar *)(*xpp);
#line 2740

#line 2740
	while(nelems-- != 0)
#line 2740
	{
#line 2740

#line 2740
		*tp++ = *xp++;
#line 2740
	}
#line 2740

#line 2740
	*xpp = (const void *)xp;
#line 2740
	return status;
#line 2740
}
#line 2740

int
#line 2741
ncx_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2741
{
#line 2741
	int status = ENOERR;
#line 2741
	uchar *xp = (uchar *)(*xpp);
#line 2741

#line 2741
	while(nelems-- != 0)
#line 2741
	{
#line 2741

#line 2741
		*tp++ = *xp++;
#line 2741
	}
#line 2741

#line 2741
	*xpp = (const void *)xp;
#line 2741
	return status;
#line 2741
}
#line 2741


/* uchar ---------------------------------------------------------------------*/
#line 2746
int
ncx_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2749
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2749
	return ENOERR;
#line 2749

}
#line 2752
int
ncx_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2755
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2755
	return ENOERR;
#line 2755

}
int
#line 2757
ncx_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2757
{
#line 2757
	int status = ENOERR;
#line 2757
	uchar *xp = (uchar *)(*xpp);
#line 2757

#line 2757
	while(nelems-- != 0)
#line 2757
	{
#line 2757

#line 2757
		*tp++ = *xp++;
#line 2757
	}
#line 2757

#line 2757
	*xpp = (const void *)xp;
#line 2757
	return status;
#line 2757
}
#line 2757

int
#line 2758
ncx_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2758
{
#line 2758
	int status = ENOERR;
#line 2758
	uchar *xp = (uchar *)(*xpp);
#line 2758

#line 2758
	while(nelems-- != 0)
#line 2758
	{
#line 2758

#line 2758
		*tp++ = *xp++;
#line 2758
	}
#line 2758

#line 2758
	*xpp = (const void *)xp;
#line 2758
	return status;
#line 2758
}
#line 2758

int
#line 2759
ncx_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2759
{
#line 2759
	int status = ENOERR;
#line 2759
	uchar *xp = (uchar *)(*xpp);
#line 2759

#line 2759
	while(nelems-- != 0)
#line 2759
	{
#line 2759

#line 2759
		*tp++ = *xp++;
#line 2759
	}
#line 2759

#line 2759
	*xpp = (const void *)xp;
#line 2759
	return status;
#line 2759
}
#line 2759

int
#line 2760
ncx_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2760
{
#line 2760
	int status = ENOERR;
#line 2760
	uchar *xp = (uchar *)(*xpp);
#line 2760

#line 2760
	while(nelems-- != 0)
#line 2760
	{
#line 2760

#line 2760
		*tp++ = *xp++;
#line 2760
	}
#line 2760

#line 2760
	*xpp = (const void *)xp;
#line 2760
	return status;
#line 2760
}
#line 2760

int
#line 2761
ncx_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2761
{
#line 2761
	int status = ENOERR;
#line 2761
	uchar *xp = (uchar *)(*xpp);
#line 2761

#line 2761
	while(nelems-- != 0)
#line 2761
	{
#line 2761

#line 2761
		*tp++ = *xp++;
#line 2761
	}
#line 2761

#line 2761
	*xpp = (const void *)xp;
#line 2761
	return status;
#line 2761
}
#line 2761

int
#line 2762
ncx_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2762
{
#line 2762
	int status = ENOERR;
#line 2762
	uchar *xp = (uchar *)(*xpp);
#line 2762

#line 2762
	while(nelems-- != 0)
#line 2762
	{
#line 2762

#line 2762
		*tp++ = *xp++;
#line 2762
	}
#line 2762

#line 2762
	*xpp = (const void *)xp;
#line 2762
	return status;
#line 2762
}
#line 2762

int
#line 2763
ncx_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2763
{
#line 2763
	int status = ENOERR;
#line 2763
	uchar *xp = (uchar *)(*xpp);
#line 2763

#line 2763
	while(nelems-- != 0)
#line 2763
	{
#line 2763

#line 2763
		*tp++ = *xp++;
#line 2763
	}
#line 2763

#line 2763
	*xpp = (const void *)xp;
#line 2763
	return status;
#line 2763
}
#line 2763

int
#line 2764
ncx_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2764
{
#line 2764
	int status = ENOERR;
#line 2764
	uchar *xp = (uchar *)(*xpp);
#line 2764

#line 2764
	while(nelems-- != 0)
#line 2764
	{
#line 2764

#line 2764
		*tp++ = *xp++;
#line 2764
	}
#line 2764

#line 2764
	*xpp = (const void *)xp;
#line 2764
	return status;
#line 2764
}
#line 2764


#line 2767
int
ncx_pad_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2770

#line 2770
	if(rndup)
#line 2770
		rndup = X_ALIGN - rndup;
#line 2770

#line 2770
	(void) memcpy(tp, *xpp, nelems);
#line 2770
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2770

#line 2770
	return ENOERR;
#line 2770

}
#line 2773
int
ncx_pad_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2776

#line 2776
	if(rndup)
#line 2776
		rndup = X_ALIGN - rndup;
#line 2776

#line 2776
	(void) memcpy(tp, *xpp, nelems);
#line 2776
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2776

#line 2776
	return ENOERR;
#line 2776

}
int
#line 2778
ncx_pad_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2778
{
#line 2778
	int status = ENOERR;
#line 2778
	size_t rndup = nelems % X_ALIGN;
#line 2778
	uchar *xp = (uchar *) *xpp;
#line 2778

#line 2778
	if(rndup)
#line 2778
		rndup = X_ALIGN - rndup;
#line 2778

#line 2778
	while(nelems-- != 0)
#line 2778
	{
#line 2778

#line 2778
		*tp++ = *xp++;
#line 2778
	}
#line 2778

#line 2778
	*xpp = (void *)(xp + rndup);
#line 2778
	return status;
#line 2778
}
#line 2778

int
#line 2779
ncx_pad_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2779
{
#line 2779
	int status = ENOERR;
#line 2779
	size_t rndup = nelems % X_ALIGN;
#line 2779
	uchar *xp = (uchar *) *xpp;
#line 2779

#line 2779
	if(rndup)
#line 2779
		rndup = X_ALIGN - rndup;
#line 2779

#line 2779
	while(nelems-- != 0)
#line 2779
	{
#line 2779

#line 2779
		*tp++ = *xp++;
#line 2779
	}
#line 2779

#line 2779
	*xpp = (void *)(xp + rndup);
#line 2779
	return status;
#line 2779
}
#line 2779

int
#line 2780
ncx_pad_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2780
{
#line 2780
	int status = ENOERR;
#line 2780
	size_t rndup = nelems % X_ALIGN;
#line 2780
	uchar *xp = (uchar *) *xpp;
#line 2780

#line 2780
	if(rndup)
#line 2780
		rndup = X_ALIGN - rndup;
#line 2780

#line 2780
	while(nelems-- != 0)
#line 2780
	{
#line 2780

#line 2780
		*tp++ = *xp++;
#line 2780
	}
#line 2780

#line 2780
	*xpp = (void *)(xp + rndup);
#line 2780
	return status;
#line 2780
}
#line 2780

int
#line 2781
ncx_pad_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2781
{
#line 2781
	int status = ENOERR;
#line 2781
	size_t rndup = nelems % X_ALIGN;
#line 2781
	uchar *xp = (uchar *) *xpp;
#line 2781

#line 2781
	if(rndup)
#line 2781
		rndup = X_ALIGN - rndup;
#line 2781

#line 2781
	while(nelems-- != 0)
#line 2781
	{
#line 2781

#line 2781
		*tp++ = *xp++;
#line 2781
	}
#line 2781

#line 2781
	*xpp = (void *)(xp + rndup);
#line 2781
	return status;
#line 2781
}
#line 2781

int
#line 2782
ncx_pad_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2782
{
#line 2782
	int status = ENOERR;
#line 2782
	size_t rndup = nelems % X_ALIGN;
#line 2782
	uchar *xp = (uchar *) *xpp;
#line 2782

#line 2782
	if(rndup)
#line 2782
		rndup = X_ALIGN - rndup;
#line 2782

#line 2782
	while(nelems-- != 0)
#line 2782
	{
#line 2782

#line 2782
		*tp++ = *xp++;
#line 2782
	}
#line 2782

#line 2782
	*xpp = (void *)(xp + rndup);
#line 2782
	return status;
#line 2782
}
#line 2782

int
#line 2783
ncx_pad_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2783
{
#line 2783
	int status = ENOERR;
#line 2783
	size_t rndup = nelems % X_ALIGN;
#line 2783
	uchar *xp = (uchar *) *xpp;
#line 2783

#line 2783
	if(rndup)
#line 2783
		rndup = X_ALIGN - rndup;
#line 2783

#line 2783
	while(nelems-- != 0)
#line 2783
	{
#line 2783

#line 2783
		*tp++ = *xp++;
#line 2783
	}
#line 2783

#line 2783
	*xpp = (void *)(xp + rndup);
#line 2783
	return status;
#line 2783
}
#line 2783

int
#line 2784
ncx_pad_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2784
{
#line 2784
	int status = ENOERR;
#line 2784
	size_t rndup = nelems % X_ALIGN;
#line 2784
	uchar *xp = (uchar *) *xpp;
#line 2784

#line 2784
	if(rndup)
#line 2784
		rndup = X_ALIGN - rndup;
#line 2784

#line 2784
	while(nelems-- != 0)
#line 2784
	{
#line 2784

#line 2784
		*tp++ = *xp++;
#line 2784
	}
#line 2784

#line 2784
	*xpp = (void *)(xp + rndup);
#line 2784
	return status;
#line 2784
}
#line 2784

int
#line 2785
ncx_pad_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2785
{
#line 2785
	int status = ENOERR;
#line 2785
	size_t rndup = nelems % X_ALIGN;
#line 2785
	uchar *xp = (uchar *) *xpp;
#line 2785

#line 2785
	if(rndup)
#line 2785
		rndup = X_ALIGN - rndup;
#line 2785

#line 2785
	while(nelems-- != 0)
#line 2785
	{
#line 2785

#line 2785
		*tp++ = *xp++;
#line 2785
	}
#line 2785

#line 2785
	*xpp = (void *)(xp + rndup);
#line 2785
	return status;
#line 2785
}
#line 2785


#line 2788
int
ncx_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2791
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2791

#line 2791
	return ENOERR;
#line 2791

}
#line 2794
int
ncx_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2797
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2797

#line 2797
	return ENOERR;
#line 2797

}
int
#line 2799
ncx_putn_uchar_short(void **xpp, size_t nelems, const short *tp)
#line 2799
{
#line 2799
	int status = ENOERR;
#line 2799
	uchar *xp = (uchar *) *xpp;
#line 2799

#line 2799
	while(nelems-- != 0)
#line 2799
	{
#line 2799
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2799
			status = NC_ERANGE;
#line 2799
		*xp++ = (uchar) *tp++;
#line 2799
	}
#line 2799

#line 2799
	*xpp = (void *)xp;
#line 2799
	return status;
#line 2799
}
#line 2799

int
#line 2800
ncx_putn_uchar_int(void **xpp, size_t nelems, const int *tp)
#line 2800
{
#line 2800
	int status = ENOERR;
#line 2800
	uchar *xp = (uchar *) *xpp;
#line 2800

#line 2800
	while(nelems-- != 0)
#line 2800
	{
#line 2800
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2800
			status = NC_ERANGE;
#line 2800
		*xp++ = (uchar) *tp++;
#line 2800
	}
#line 2800

#line 2800
	*xpp = (void *)xp;
#line 2800
	return status;
#line 2800
}
#line 2800

int
#line 2801
ncx_putn_uchar_float(void **xpp, size_t nelems, const float *tp)
#line 2801
{
#line 2801
	int status = ENOERR;
#line 2801
	uchar *xp = (uchar *) *xpp;
#line 2801

#line 2801
	while(nelems-- != 0)
#line 2801
	{
#line 2801
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2801
			status = NC_ERANGE;
#line 2801
		*xp++ = (uchar) *tp++;
#line 2801
	}
#line 2801

#line 2801
	*xpp = (void *)xp;
#line 2801
	return status;
#line 2801
}
#line 2801

int
#line 2802
ncx_putn_uchar_double(void **xpp, size_t nelems, const double *tp)
#line 2802
{
#line 2802
	int status = ENOERR;
#line 2802
	uchar *xp = (uchar *) *xpp;
#line 2802

#line 2802
	while(nelems-- != 0)
#line 2802
	{
#line 2802
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2802
			status = NC_ERANGE;
#line 2802
		*xp++ = (uchar) *tp++;
#line 2802
	}
#line 2802

#line 2802
	*xpp = (void *)xp;
#line 2802
	return status;
#line 2802
}
#line 2802

int
#line 2803
ncx_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2803
{
#line 2803
	int status = ENOERR;
#line 2803
	uchar *xp = (uchar *) *xpp;
#line 2803

#line 2803
	while(nelems-- != 0)
#line 2803
	{
#line 2803
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2803
			status = NC_ERANGE;
#line 2803
		*xp++ = (uchar) *tp++;
#line 2803
	}
#line 2803

#line 2803
	*xpp = (void *)xp;
#line 2803
	return status;
#line 2803
}
#line 2803

int
#line 2804
ncx_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2804
{
#line 2804
	int status = ENOERR;
#line 2804
	uchar *xp = (uchar *) *xpp;
#line 2804

#line 2804
	while(nelems-- != 0)
#line 2804
	{
#line 2804
		if(*tp > X_UCHAR_MAX )
#line 2804
			status = NC_ERANGE;
#line 2804
		*xp++ = (uchar) *tp++;
#line 2804
	}
#line 2804

#line 2804
	*xpp = (void *)xp;
#line 2804
	return status;
#line 2804
}
#line 2804

int
#line 2805
ncx_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2805
{
#line 2805
	int status = ENOERR;
#line 2805
	uchar *xp = (uchar *) *xpp;
#line 2805

#line 2805
	while(nelems-- != 0)
#line 2805
	{
#line 2805
		if(*tp > X_UCHAR_MAX )
#line 2805
			status = NC_ERANGE;
#line 2805
		*xp++ = (uchar) *tp++;
#line 2805
	}
#line 2805

#line 2805
	*xpp = (void *)xp;
#line 2805
	return status;
#line 2805
}
#line 2805

int
#line 2806
ncx_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2806
{
#line 2806
	int status = ENOERR;
#line 2806
	uchar *xp = (uchar *) *xpp;
#line 2806

#line 2806
	while(nelems-- != 0)
#line 2806
	{
#line 2806
		if(*tp > X_UCHAR_MAX )
#line 2806
			status = NC_ERANGE;
#line 2806
		*xp++ = (uchar) *tp++;
#line 2806
	}
#line 2806

#line 2806
	*xpp = (void *)xp;
#line 2806
	return status;
#line 2806
}
#line 2806


#line 2809
int
ncx_pad_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2812

#line 2812
	if(rndup)
#line 2812
		rndup = X_ALIGN - rndup;
#line 2812

#line 2812
	(void) memcpy(*xpp, tp, nelems);
#line 2812
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2812

#line 2812
	if(rndup)
#line 2812
	{
#line 2812
		(void) memcpy(*xpp, nada, rndup);
#line 2812
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2812
	}
#line 2812

#line 2812
	return ENOERR;
#line 2812

}
#line 2815
int
ncx_pad_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2818

#line 2818
	if(rndup)
#line 2818
		rndup = X_ALIGN - rndup;
#line 2818

#line 2818
	(void) memcpy(*xpp, tp, nelems);
#line 2818
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2818

#line 2818
	if(rndup)
#line 2818
	{
#line 2818
		(void) memcpy(*xpp, nada, rndup);
#line 2818
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2818
	}
#line 2818

#line 2818
	return ENOERR;
#line 2818

}
int
#line 2820
ncx_pad_putn_uchar_short(void **xpp, size_t nelems, const short *tp)
#line 2820
{
#line 2820
	int status = ENOERR;
#line 2820
	size_t rndup = nelems % X_ALIGN;
#line 2820
	uchar *xp = (uchar *) *xpp;
#line 2820

#line 2820
	if(rndup)
#line 2820
		rndup = X_ALIGN - rndup;
#line 2820

#line 2820
	while(nelems-- != 0)
#line 2820
	{
#line 2820
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2820
			status = NC_ERANGE;
#line 2820
		*xp++ = (uchar) *tp++;
#line 2820
	}
#line 2820

#line 2820

#line 2820
	if(rndup)
#line 2820
	{
#line 2820
		(void) memcpy(xp, nada, rndup);
#line 2820
		xp += rndup;
#line 2820
	}
#line 2820

#line 2820
	*xpp = (void *)xp;
#line 2820
	return status;
#line 2820
}
#line 2820

int
#line 2821
ncx_pad_putn_uchar_int(void **xpp, size_t nelems, const int *tp)
#line 2821
{
#line 2821
	int status = ENOERR;
#line 2821
	size_t rndup = nelems % X_ALIGN;
#line 2821
	uchar *xp = (uchar *) *xpp;
#line 2821

#line 2821
	if(rndup)
#line 2821
		rndup = X_ALIGN - rndup;
#line 2821

#line 2821
	while(nelems-- != 0)
#line 2821
	{
#line 2821
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2821
			status = NC_ERANGE;
#line 2821
		*xp++ = (uchar) *tp++;
#line 2821
	}
#line 2821

#line 2821

#line 2821
	if(rndup)
#line 2821
	{
#line 2821
		(void) memcpy(xp, nada, rndup);
#line 2821
		xp += rndup;
#line 2821
	}
#line 2821

#line 2821
	*xpp = (void *)xp;
#line 2821
	return status;
#line 2821
}
#line 2821

int
#line 2822
ncx_pad_putn_uchar_float(void **xpp, size_t nelems, const float *tp)
#line 2822
{
#line 2822
	int status = ENOERR;
#line 2822
	size_t rndup = nelems % X_ALIGN;
#line 2822
	uchar *xp = (uchar *) *xpp;
#line 2822

#line 2822
	if(rndup)
#line 2822
		rndup = X_ALIGN - rndup;
#line 2822

#line 2822
	while(nelems-- != 0)
#line 2822
	{
#line 2822
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2822
			status = NC_ERANGE;
#line 2822
		*xp++ = (uchar) *tp++;
#line 2822
	}
#line 2822

#line 2822

#line 2822
	if(rndup)
#line 2822
	{
#line 2822
		(void) memcpy(xp, nada, rndup);
#line 2822
		xp += rndup;
#line 2822
	}
#line 2822

#line 2822
	*xpp = (void *)xp;
#line 2822
	return status;
#line 2822
}
#line 2822

int
#line 2823
ncx_pad_putn_uchar_double(void **xpp, size_t nelems, const double *tp)
#line 2823
{
#line 2823
	int status = ENOERR;
#line 2823
	size_t rndup = nelems % X_ALIGN;
#line 2823
	uchar *xp = (uchar *) *xpp;
#line 2823

#line 2823
	if(rndup)
#line 2823
		rndup = X_ALIGN - rndup;
#line 2823

#line 2823
	while(nelems-- != 0)
#line 2823
	{
#line 2823
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2823
			status = NC_ERANGE;
#line 2823
		*xp++ = (uchar) *tp++;
#line 2823
	}
#line 2823

#line 2823

#line 2823
	if(rndup)
#line 2823
	{
#line 2823
		(void) memcpy(xp, nada, rndup);
#line 2823
		xp += rndup;
#line 2823
	}
#line 2823

#line 2823
	*xpp = (void *)xp;
#line 2823
	return status;
#line 2823
}
#line 2823

int
#line 2824
ncx_pad_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2824
{
#line 2824
	int status = ENOERR;
#line 2824
	size_t rndup = nelems % X_ALIGN;
#line 2824
	uchar *xp = (uchar *) *xpp;
#line 2824

#line 2824
	if(rndup)
#line 2824
		rndup = X_ALIGN - rndup;
#line 2824

#line 2824
	while(nelems-- != 0)
#line 2824
	{
#line 2824
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2824
			status = NC_ERANGE;
#line 2824
		*xp++ = (uchar) *tp++;
#line 2824
	}
#line 2824

#line 2824

#line 2824
	if(rndup)
#line 2824
	{
#line 2824
		(void) memcpy(xp, nada, rndup);
#line 2824
		xp += rndup;
#line 2824
	}
#line 2824

#line 2824
	*xpp = (void *)xp;
#line 2824
	return status;
#line 2824
}
#line 2824

int
#line 2825
ncx_pad_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2825
{
#line 2825
	int status = ENOERR;
#line 2825
	size_t rndup = nelems % X_ALIGN;
#line 2825
	uchar *xp = (uchar *) *xpp;
#line 2825

#line 2825
	if(rndup)
#line 2825
		rndup = X_ALIGN - rndup;
#line 2825

#line 2825
	while(nelems-- != 0)
#line 2825
	{
#line 2825
		if(*tp > X_UCHAR_MAX )
#line 2825
			status = NC_ERANGE;
#line 2825
		*xp++ = (uchar) *tp++;
#line 2825
	}
#line 2825

#line 2825

#line 2825
	if(rndup)
#line 2825
	{
#line 2825
		(void) memcpy(xp, nada, rndup);
#line 2825
		xp += rndup;
#line 2825
	}
#line 2825

#line 2825
	*xpp = (void *)xp;
#line 2825
	return status;
#line 2825
}
#line 2825

int
#line 2826
ncx_pad_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2826
{
#line 2826
	int status = ENOERR;
#line 2826
	size_t rndup = nelems % X_ALIGN;
#line 2826
	uchar *xp = (uchar *) *xpp;
#line 2826

#line 2826
	if(rndup)
#line 2826
		rndup = X_ALIGN - rndup;
#line 2826

#line 2826
	while(nelems-- != 0)
#line 2826
	{
#line 2826
		if(*tp > X_UCHAR_MAX )
#line 2826
			status = NC_ERANGE;
#line 2826
		*xp++ = (uchar) *tp++;
#line 2826
	}
#line 2826

#line 2826

#line 2826
	if(rndup)
#line 2826
	{
#line 2826
		(void) memcpy(xp, nada, rndup);
#line 2826
		xp += rndup;
#line 2826
	}
#line 2826

#line 2826
	*xpp = (void *)xp;
#line 2826
	return status;
#line 2826
}
#line 2826

int
#line 2827
ncx_pad_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2827
{
#line 2827
	int status = ENOERR;
#line 2827
	size_t rndup = nelems % X_ALIGN;
#line 2827
	uchar *xp = (uchar *) *xpp;
#line 2827

#line 2827
	if(rndup)
#line 2827
		rndup = X_ALIGN - rndup;
#line 2827

#line 2827
	while(nelems-- != 0)
#line 2827
	{
#line 2827
		if(*tp > X_UCHAR_MAX )
#line 2827
			status = NC_ERANGE;
#line 2827
		*xp++ = (uchar) *tp++;
#line 2827
	}
#line 2827

#line 2827

#line 2827
	if(rndup)
#line 2827
	{
#line 2827
		(void) memcpy(xp, nada, rndup);
#line 2827
		xp += rndup;
#line 2827
	}
#line 2827

#line 2827
	*xpp = (void *)xp;
#line 2827
	return status;
#line 2827
}
#line 2827


/* short ---------------------------------------------------------------------*/

#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(short));
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return ENOERR;
}
#else
int
#line 2845
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 2845
{
#line 2845
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2845

#line 2845
 /* basic algorithm is:
#line 2845
  *   - ensure sane alignment of input data
#line 2845
  *   - copy (conversion happens automatically) input data
#line 2845
  *     to output
#line 2845
  *   - update xpp to point at next unconverted input, and tp to point
#line 2845
  *     at next location for converted output
#line 2845
  */
#line 2845
  long i, j, ni;
#line 2845
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2845
  short *xp;
#line 2845
  int nrange = 0;         /* number of range errors */
#line 2845
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2845
  long cxp = (long) *((char**)xpp);
#line 2845

#line 2845
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2845
  /* sjl: manually stripmine so we can limit amount of
#line 2845
   * vector work space reserved to LOOPCNT elements. Also
#line 2845
   * makes vectorisation easy */
#line 2845
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2845
    ni=Min(nelems-j,LOOPCNT);
#line 2845
    if (realign) {
#line 2845
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2845
      xp = tmp;
#line 2845
    } else {
#line 2845
      xp = (short *) *xpp;
#line 2845
    }
#line 2845
   /* copy the next block */
#line 2845
#pragma cdir loopcnt=LOOPCNT
#line 2845
#pragma cdir shortloop
#line 2845
    for (i=0; i<ni; i++) {
#line 2845
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2845
     /* test for range errors (not always needed but do it anyway) */
#line 2845
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2845
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2845
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 2845
    }
#line 2845
   /* update xpp and tp */
#line 2845
    if (realign) xp = (short *) *xpp;
#line 2845
    xp += ni;
#line 2845
    tp += ni;
#line 2845
    *xpp = (void*)xp;
#line 2845
  }
#line 2845
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2845

#line 2845
#else   /* not SX */
#line 2845
	const char *xp = (const char *) *xpp;
#line 2845
	int status = ENOERR;
#line 2845

#line 2845
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2845
	{
#line 2845
		const int lstatus = ncx_get_short_short(xp, tp);
#line 2845
		if(lstatus != ENOERR)
#line 2845
			status = lstatus;
#line 2845
	}
#line 2845

#line 2845
	*xpp = (const void *)xp;
#line 2845
	return status;
#line 2845
#  endif
#line 2845
}
#line 2845

#endif
int
#line 2847
ncx_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 2847
{
#line 2847
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2847

#line 2847
 /* basic algorithm is:
#line 2847
  *   - ensure sane alignment of input data
#line 2847
  *   - copy (conversion happens automatically) input data
#line 2847
  *     to output
#line 2847
  *   - update xpp to point at next unconverted input, and tp to point
#line 2847
  *     at next location for converted output
#line 2847
  */
#line 2847
  long i, j, ni;
#line 2847
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2847
  short *xp;
#line 2847
  int nrange = 0;         /* number of range errors */
#line 2847
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2847
  long cxp = (long) *((char**)xpp);
#line 2847

#line 2847
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2847
  /* sjl: manually stripmine so we can limit amount of
#line 2847
   * vector work space reserved to LOOPCNT elements. Also
#line 2847
   * makes vectorisation easy */
#line 2847
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2847
    ni=Min(nelems-j,LOOPCNT);
#line 2847
    if (realign) {
#line 2847
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2847
      xp = tmp;
#line 2847
    } else {
#line 2847
      xp = (short *) *xpp;
#line 2847
    }
#line 2847
   /* copy the next block */
#line 2847
#pragma cdir loopcnt=LOOPCNT
#line 2847
#pragma cdir shortloop
#line 2847
    for (i=0; i<ni; i++) {
#line 2847
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2847
     /* test for range errors (not always needed but do it anyway) */
#line 2847
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2847
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2847
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 2847
    }
#line 2847
   /* update xpp and tp */
#line 2847
    if (realign) xp = (short *) *xpp;
#line 2847
    xp += ni;
#line 2847
    tp += ni;
#line 2847
    *xpp = (void*)xp;
#line 2847
  }
#line 2847
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2847

#line 2847
#else   /* not SX */
#line 2847
	const char *xp = (const char *) *xpp;
#line 2847
	int status = ENOERR;
#line 2847

#line 2847
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2847
	{
#line 2847
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 2847
		if(lstatus != ENOERR)
#line 2847
			status = lstatus;
#line 2847
	}
#line 2847

#line 2847
	*xpp = (const void *)xp;
#line 2847
	return status;
#line 2847
#  endif
#line 2847
}
#line 2847

int
#line 2848
ncx_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 2848
{
#line 2848
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2848

#line 2848
 /* basic algorithm is:
#line 2848
  *   - ensure sane alignment of input data
#line 2848
  *   - copy (conversion happens automatically) input data
#line 2848
  *     to output
#line 2848
  *   - update xpp to point at next unconverted input, and tp to point
#line 2848
  *     at next location for converted output
#line 2848
  */
#line 2848
  long i, j, ni;
#line 2848
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2848
  short *xp;
#line 2848
  int nrange = 0;         /* number of range errors */
#line 2848
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2848
  long cxp = (long) *((char**)xpp);
#line 2848

#line 2848
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2848
  /* sjl: manually stripmine so we can limit amount of
#line 2848
   * vector work space reserved to LOOPCNT elements. Also
#line 2848
   * makes vectorisation easy */
#line 2848
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2848
    ni=Min(nelems-j,LOOPCNT);
#line 2848
    if (realign) {
#line 2848
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2848
      xp = tmp;
#line 2848
    } else {
#line 2848
      xp = (short *) *xpp;
#line 2848
    }
#line 2848
   /* copy the next block */
#line 2848
#pragma cdir loopcnt=LOOPCNT
#line 2848
#pragma cdir shortloop
#line 2848
    for (i=0; i<ni; i++) {
#line 2848
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2848
     /* test for range errors (not always needed but do it anyway) */
#line 2848
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2848
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2848
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 2848
    }
#line 2848
   /* update xpp and tp */
#line 2848
    if (realign) xp = (short *) *xpp;
#line 2848
    xp += ni;
#line 2848
    tp += ni;
#line 2848
    *xpp = (void*)xp;
#line 2848
  }
#line 2848
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2848

#line 2848
#else   /* not SX */
#line 2848
	const char *xp = (const char *) *xpp;
#line 2848
	int status = ENOERR;
#line 2848

#line 2848
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2848
	{
#line 2848
		const int lstatus = ncx_get_short_int(xp, tp);
#line 2848
		if(lstatus != ENOERR)
#line 2848
			status = lstatus;
#line 2848
	}
#line 2848

#line 2848
	*xpp = (const void *)xp;
#line 2848
	return status;
#line 2848
#  endif
#line 2848
}
#line 2848

int
#line 2849
ncx_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 2849
{
#line 2849
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2849

#line 2849
 /* basic algorithm is:
#line 2849
  *   - ensure sane alignment of input data
#line 2849
  *   - copy (conversion happens automatically) input data
#line 2849
  *     to output
#line 2849
  *   - update xpp to point at next unconverted input, and tp to point
#line 2849
  *     at next location for converted output
#line 2849
  */
#line 2849
  long i, j, ni;
#line 2849
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2849
  short *xp;
#line 2849
  int nrange = 0;         /* number of range errors */
#line 2849
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2849
  long cxp = (long) *((char**)xpp);
#line 2849

#line 2849
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2849
  /* sjl: manually stripmine so we can limit amount of
#line 2849
   * vector work space reserved to LOOPCNT elements. Also
#line 2849
   * makes vectorisation easy */
#line 2849
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2849
    ni=Min(nelems-j,LOOPCNT);
#line 2849
    if (realign) {
#line 2849
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2849
      xp = tmp;
#line 2849
    } else {
#line 2849
      xp = (short *) *xpp;
#line 2849
    }
#line 2849
   /* copy the next block */
#line 2849
#pragma cdir loopcnt=LOOPCNT
#line 2849
#pragma cdir shortloop
#line 2849
    for (i=0; i<ni; i++) {
#line 2849
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2849
     /* test for range errors (not always needed but do it anyway) */
#line 2849
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2849
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2849
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 2849
    }
#line 2849
   /* update xpp and tp */
#line 2849
    if (realign) xp = (short *) *xpp;
#line 2849
    xp += ni;
#line 2849
    tp += ni;
#line 2849
    *xpp = (void*)xp;
#line 2849
  }
#line 2849
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2849

#line 2849
#else   /* not SX */
#line 2849
	const char *xp = (const char *) *xpp;
#line 2849
	int status = ENOERR;
#line 2849

#line 2849
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2849
	{
#line 2849
		const int lstatus = ncx_get_short_float(xp, tp);
#line 2849
		if(lstatus != ENOERR)
#line 2849
			status = lstatus;
#line 2849
	}
#line 2849

#line 2849
	*xpp = (const void *)xp;
#line 2849
	return status;
#line 2849
#  endif
#line 2849
}
#line 2849

int
#line 2850
ncx_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 2850
{
#line 2850
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2850

#line 2850
 /* basic algorithm is:
#line 2850
  *   - ensure sane alignment of input data
#line 2850
  *   - copy (conversion happens automatically) input data
#line 2850
  *     to output
#line 2850
  *   - update xpp to point at next unconverted input, and tp to point
#line 2850
  *     at next location for converted output
#line 2850
  */
#line 2850
  long i, j, ni;
#line 2850
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2850
  short *xp;
#line 2850
  int nrange = 0;         /* number of range errors */
#line 2850
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2850
  long cxp = (long) *((char**)xpp);
#line 2850

#line 2850
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2850
  /* sjl: manually stripmine so we can limit amount of
#line 2850
   * vector work space reserved to LOOPCNT elements. Also
#line 2850
   * makes vectorisation easy */
#line 2850
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2850
    ni=Min(nelems-j,LOOPCNT);
#line 2850
    if (realign) {
#line 2850
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2850
      xp = tmp;
#line 2850
    } else {
#line 2850
      xp = (short *) *xpp;
#line 2850
    }
#line 2850
   /* copy the next block */
#line 2850
#pragma cdir loopcnt=LOOPCNT
#line 2850
#pragma cdir shortloop
#line 2850
    for (i=0; i<ni; i++) {
#line 2850
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2850
     /* test for range errors (not always needed but do it anyway) */
#line 2850
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2850
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2850
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 2850
    }
#line 2850
   /* update xpp and tp */
#line 2850
    if (realign) xp = (short *) *xpp;
#line 2850
    xp += ni;
#line 2850
    tp += ni;
#line 2850
    *xpp = (void*)xp;
#line 2850
  }
#line 2850
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2850

#line 2850
#else   /* not SX */
#line 2850
	const char *xp = (const char *) *xpp;
#line 2850
	int status = ENOERR;
#line 2850

#line 2850
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2850
	{
#line 2850
		const int lstatus = ncx_get_short_double(xp, tp);
#line 2850
		if(lstatus != ENOERR)
#line 2850
			status = lstatus;
#line 2850
	}
#line 2850

#line 2850
	*xpp = (const void *)xp;
#line 2850
	return status;
#line 2850
#  endif
#line 2850
}
#line 2850

int
#line 2851
ncx_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2851
{
#line 2851
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2851

#line 2851
 /* basic algorithm is:
#line 2851
  *   - ensure sane alignment of input data
#line 2851
  *   - copy (conversion happens automatically) input data
#line 2851
  *     to output
#line 2851
  *   - update xpp to point at next unconverted input, and tp to point
#line 2851
  *     at next location for converted output
#line 2851
  */
#line 2851
  long i, j, ni;
#line 2851
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2851
  short *xp;
#line 2851
  int nrange = 0;         /* number of range errors */
#line 2851
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2851
  long cxp = (long) *((char**)xpp);
#line 2851

#line 2851
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2851
  /* sjl: manually stripmine so we can limit amount of
#line 2851
   * vector work space reserved to LOOPCNT elements. Also
#line 2851
   * makes vectorisation easy */
#line 2851
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2851
    ni=Min(nelems-j,LOOPCNT);
#line 2851
    if (realign) {
#line 2851
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2851
      xp = tmp;
#line 2851
    } else {
#line 2851
      xp = (short *) *xpp;
#line 2851
    }
#line 2851
   /* copy the next block */
#line 2851
#pragma cdir loopcnt=LOOPCNT
#line 2851
#pragma cdir shortloop
#line 2851
    for (i=0; i<ni; i++) {
#line 2851
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2851
     /* test for range errors (not always needed but do it anyway) */
#line 2851
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2851
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2851
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 2851
    }
#line 2851
   /* update xpp and tp */
#line 2851
    if (realign) xp = (short *) *xpp;
#line 2851
    xp += ni;
#line 2851
    tp += ni;
#line 2851
    *xpp = (void*)xp;
#line 2851
  }
#line 2851
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2851

#line 2851
#else   /* not SX */
#line 2851
	const char *xp = (const char *) *xpp;
#line 2851
	int status = ENOERR;
#line 2851

#line 2851
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2851
	{
#line 2851
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 2851
		if(lstatus != ENOERR)
#line 2851
			status = lstatus;
#line 2851
	}
#line 2851

#line 2851
	*xpp = (const void *)xp;
#line 2851
	return status;
#line 2851
#  endif
#line 2851
}
#line 2851

int
#line 2852
ncx_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2852
{
#line 2852
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2852

#line 2852
 /* basic algorithm is:
#line 2852
  *   - ensure sane alignment of input data
#line 2852
  *   - copy (conversion happens automatically) input data
#line 2852
  *     to output
#line 2852
  *   - update xpp to point at next unconverted input, and tp to point
#line 2852
  *     at next location for converted output
#line 2852
  */
#line 2852
  long i, j, ni;
#line 2852
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2852
  short *xp;
#line 2852
  int nrange = 0;         /* number of range errors */
#line 2852
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2852
  long cxp = (long) *((char**)xpp);
#line 2852

#line 2852
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2852
  /* sjl: manually stripmine so we can limit amount of
#line 2852
   * vector work space reserved to LOOPCNT elements. Also
#line 2852
   * makes vectorisation easy */
#line 2852
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2852
    ni=Min(nelems-j,LOOPCNT);
#line 2852
    if (realign) {
#line 2852
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2852
      xp = tmp;
#line 2852
    } else {
#line 2852
      xp = (short *) *xpp;
#line 2852
    }
#line 2852
   /* copy the next block */
#line 2852
#pragma cdir loopcnt=LOOPCNT
#line 2852
#pragma cdir shortloop
#line 2852
    for (i=0; i<ni; i++) {
#line 2852
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2852
     /* test for range errors (not always needed but do it anyway) */
#line 2852
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2852
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2852
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 2852
    }
#line 2852
   /* update xpp and tp */
#line 2852
    if (realign) xp = (short *) *xpp;
#line 2852
    xp += ni;
#line 2852
    tp += ni;
#line 2852
    *xpp = (void*)xp;
#line 2852
  }
#line 2852
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2852

#line 2852
#else   /* not SX */
#line 2852
	const char *xp = (const char *) *xpp;
#line 2852
	int status = ENOERR;
#line 2852

#line 2852
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2852
	{
#line 2852
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 2852
		if(lstatus != ENOERR)
#line 2852
			status = lstatus;
#line 2852
	}
#line 2852

#line 2852
	*xpp = (const void *)xp;
#line 2852
	return status;
#line 2852
#  endif
#line 2852
}
#line 2852

int
#line 2853
ncx_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2853
{
#line 2853
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2853

#line 2853
 /* basic algorithm is:
#line 2853
  *   - ensure sane alignment of input data
#line 2853
  *   - copy (conversion happens automatically) input data
#line 2853
  *     to output
#line 2853
  *   - update xpp to point at next unconverted input, and tp to point
#line 2853
  *     at next location for converted output
#line 2853
  */
#line 2853
  long i, j, ni;
#line 2853
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2853
  short *xp;
#line 2853
  int nrange = 0;         /* number of range errors */
#line 2853
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2853
  long cxp = (long) *((char**)xpp);
#line 2853

#line 2853
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2853
  /* sjl: manually stripmine so we can limit amount of
#line 2853
   * vector work space reserved to LOOPCNT elements. Also
#line 2853
   * makes vectorisation easy */
#line 2853
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2853
    ni=Min(nelems-j,LOOPCNT);
#line 2853
    if (realign) {
#line 2853
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2853
      xp = tmp;
#line 2853
    } else {
#line 2853
      xp = (short *) *xpp;
#line 2853
    }
#line 2853
   /* copy the next block */
#line 2853
#pragma cdir loopcnt=LOOPCNT
#line 2853
#pragma cdir shortloop
#line 2853
    for (i=0; i<ni; i++) {
#line 2853
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2853
     /* test for range errors (not always needed but do it anyway) */
#line 2853
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2853
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2853
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 2853
    }
#line 2853
   /* update xpp and tp */
#line 2853
    if (realign) xp = (short *) *xpp;
#line 2853
    xp += ni;
#line 2853
    tp += ni;
#line 2853
    *xpp = (void*)xp;
#line 2853
  }
#line 2853
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2853

#line 2853
#else   /* not SX */
#line 2853
	const char *xp = (const char *) *xpp;
#line 2853
	int status = ENOERR;
#line 2853

#line 2853
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2853
	{
#line 2853
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 2853
		if(lstatus != ENOERR)
#line 2853
			status = lstatus;
#line 2853
	}
#line 2853

#line 2853
	*xpp = (const void *)xp;
#line 2853
	return status;
#line 2853
#  endif
#line 2853
}
#line 2853

int
#line 2854
ncx_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 2854
{
#line 2854
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2854

#line 2854
 /* basic algorithm is:
#line 2854
  *   - ensure sane alignment of input data
#line 2854
  *   - copy (conversion happens automatically) input data
#line 2854
  *     to output
#line 2854
  *   - update xpp to point at next unconverted input, and tp to point
#line 2854
  *     at next location for converted output
#line 2854
  */
#line 2854
  long i, j, ni;
#line 2854
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2854
  short *xp;
#line 2854
  int nrange = 0;         /* number of range errors */
#line 2854
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2854
  long cxp = (long) *((char**)xpp);
#line 2854

#line 2854
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2854
  /* sjl: manually stripmine so we can limit amount of
#line 2854
   * vector work space reserved to LOOPCNT elements. Also
#line 2854
   * makes vectorisation easy */
#line 2854
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2854
    ni=Min(nelems-j,LOOPCNT);
#line 2854
    if (realign) {
#line 2854
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2854
      xp = tmp;
#line 2854
    } else {
#line 2854
      xp = (short *) *xpp;
#line 2854
    }
#line 2854
   /* copy the next block */
#line 2854
#pragma cdir loopcnt=LOOPCNT
#line 2854
#pragma cdir shortloop
#line 2854
    for (i=0; i<ni; i++) {
#line 2854
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2854
     /* test for range errors (not always needed but do it anyway) */
#line 2854
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2854
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2854
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 2854
    }
#line 2854
   /* update xpp and tp */
#line 2854
    if (realign) xp = (short *) *xpp;
#line 2854
    xp += ni;
#line 2854
    tp += ni;
#line 2854
    *xpp = (void*)xp;
#line 2854
  }
#line 2854
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2854

#line 2854
#else   /* not SX */
#line 2854
	const char *xp = (const char *) *xpp;
#line 2854
	int status = ENOERR;
#line 2854

#line 2854
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2854
	{
#line 2854
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 2854
		if(lstatus != ENOERR)
#line 2854
			status = lstatus;
#line 2854
	}
#line 2854

#line 2854
	*xpp = (const void *)xp;
#line 2854
	return status;
#line 2854
#  endif
#line 2854
}
#line 2854

int
#line 2855
ncx_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2855
{
#line 2855
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2855

#line 2855
 /* basic algorithm is:
#line 2855
  *   - ensure sane alignment of input data
#line 2855
  *   - copy (conversion happens automatically) input data
#line 2855
  *     to output
#line 2855
  *   - update xpp to point at next unconverted input, and tp to point
#line 2855
  *     at next location for converted output
#line 2855
  */
#line 2855
  long i, j, ni;
#line 2855
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2855
  short *xp;
#line 2855
  int nrange = 0;         /* number of range errors */
#line 2855
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2855
  long cxp = (long) *((char**)xpp);
#line 2855

#line 2855
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2855
  /* sjl: manually stripmine so we can limit amount of
#line 2855
   * vector work space reserved to LOOPCNT elements. Also
#line 2855
   * makes vectorisation easy */
#line 2855
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2855
    ni=Min(nelems-j,LOOPCNT);
#line 2855
    if (realign) {
#line 2855
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2855
      xp = tmp;
#line 2855
    } else {
#line 2855
      xp = (short *) *xpp;
#line 2855
    }
#line 2855
   /* copy the next block */
#line 2855
#pragma cdir loopcnt=LOOPCNT
#line 2855
#pragma cdir shortloop
#line 2855
    for (i=0; i<ni; i++) {
#line 2855
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2855
     /* test for range errors (not always needed but do it anyway) */
#line 2855
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2855
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2855
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 2855
    }
#line 2855
   /* update xpp and tp */
#line 2855
    if (realign) xp = (short *) *xpp;
#line 2855
    xp += ni;
#line 2855
    tp += ni;
#line 2855
    *xpp = (void*)xp;
#line 2855
  }
#line 2855
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2855

#line 2855
#else   /* not SX */
#line 2855
	const char *xp = (const char *) *xpp;
#line 2855
	int status = ENOERR;
#line 2855

#line 2855
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2855
	{
#line 2855
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 2855
		if(lstatus != ENOERR)
#line 2855
			status = lstatus;
#line 2855
	}
#line 2855

#line 2855
	*xpp = (const void *)xp;
#line 2855
	return status;
#line 2855
#  endif
#line 2855
}
#line 2855


int
#line 2857
ncx_pad_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 2857
{
#line 2857
	const size_t rndup = nelems % 2;
#line 2857

#line 2857
	const char *xp = (const char *) *xpp;
#line 2857
	int status = ENOERR;
#line 2857

#line 2857
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2857
	{
#line 2857
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 2857
		if(lstatus != ENOERR)
#line 2857
			status = lstatus;
#line 2857
	}
#line 2857

#line 2857
	if(rndup != 0)
#line 2857
		xp += X_SIZEOF_SHORT;
#line 2857
		
#line 2857
	*xpp = (void *)xp;
#line 2857
	return status;
#line 2857
}
#line 2857

int
#line 2858
ncx_pad_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2858
{
#line 2858
	const size_t rndup = nelems % 2;
#line 2858

#line 2858
	const char *xp = (const char *) *xpp;
#line 2858
	int status = ENOERR;
#line 2858

#line 2858
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2858
	{
#line 2858
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 2858
		if(lstatus != ENOERR)
#line 2858
			status = lstatus;
#line 2858
	}
#line 2858

#line 2858
	if(rndup != 0)
#line 2858
		xp += X_SIZEOF_SHORT;
#line 2858
		
#line 2858
	*xpp = (void *)xp;
#line 2858
	return status;
#line 2858
}
#line 2858

int
#line 2859
ncx_pad_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 2859
{
#line 2859
	const size_t rndup = nelems % 2;
#line 2859

#line 2859
	const char *xp = (const char *) *xpp;
#line 2859
	int status = ENOERR;
#line 2859

#line 2859
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2859
	{
#line 2859
		const int lstatus = ncx_get_short_short(xp, tp);
#line 2859
		if(lstatus != ENOERR)
#line 2859
			status = lstatus;
#line 2859
	}
#line 2859

#line 2859
	if(rndup != 0)
#line 2859
		xp += X_SIZEOF_SHORT;
#line 2859
		
#line 2859
	*xpp = (void *)xp;
#line 2859
	return status;
#line 2859
}
#line 2859

int
#line 2860
ncx_pad_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 2860
{
#line 2860
	const size_t rndup = nelems % 2;
#line 2860

#line 2860
	const char *xp = (const char *) *xpp;
#line 2860
	int status = ENOERR;
#line 2860

#line 2860
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2860
	{
#line 2860
		const int lstatus = ncx_get_short_int(xp, tp);
#line 2860
		if(lstatus != ENOERR)
#line 2860
			status = lstatus;
#line 2860
	}
#line 2860

#line 2860
	if(rndup != 0)
#line 2860
		xp += X_SIZEOF_SHORT;
#line 2860
		
#line 2860
	*xpp = (void *)xp;
#line 2860
	return status;
#line 2860
}
#line 2860

int
#line 2861
ncx_pad_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 2861
{
#line 2861
	const size_t rndup = nelems % 2;
#line 2861

#line 2861
	const char *xp = (const char *) *xpp;
#line 2861
	int status = ENOERR;
#line 2861

#line 2861
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2861
	{
#line 2861
		const int lstatus = ncx_get_short_float(xp, tp);
#line 2861
		if(lstatus != ENOERR)
#line 2861
			status = lstatus;
#line 2861
	}
#line 2861

#line 2861
	if(rndup != 0)
#line 2861
		xp += X_SIZEOF_SHORT;
#line 2861
		
#line 2861
	*xpp = (void *)xp;
#line 2861
	return status;
#line 2861
}
#line 2861

int
#line 2862
ncx_pad_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 2862
{
#line 2862
	const size_t rndup = nelems % 2;
#line 2862

#line 2862
	const char *xp = (const char *) *xpp;
#line 2862
	int status = ENOERR;
#line 2862

#line 2862
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2862
	{
#line 2862
		const int lstatus = ncx_get_short_double(xp, tp);
#line 2862
		if(lstatus != ENOERR)
#line 2862
			status = lstatus;
#line 2862
	}
#line 2862

#line 2862
	if(rndup != 0)
#line 2862
		xp += X_SIZEOF_SHORT;
#line 2862
		
#line 2862
	*xpp = (void *)xp;
#line 2862
	return status;
#line 2862
}
#line 2862

int
#line 2863
ncx_pad_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 2863
{
#line 2863
	const size_t rndup = nelems % 2;
#line 2863

#line 2863
	const char *xp = (const char *) *xpp;
#line 2863
	int status = ENOERR;
#line 2863

#line 2863
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2863
	{
#line 2863
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 2863
		if(lstatus != ENOERR)
#line 2863
			status = lstatus;
#line 2863
	}
#line 2863

#line 2863
	if(rndup != 0)
#line 2863
		xp += X_SIZEOF_SHORT;
#line 2863
		
#line 2863
	*xpp = (void *)xp;
#line 2863
	return status;
#line 2863
}
#line 2863

int
#line 2864
ncx_pad_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2864
{
#line 2864
	const size_t rndup = nelems % 2;
#line 2864

#line 2864
	const char *xp = (const char *) *xpp;
#line 2864
	int status = ENOERR;
#line 2864

#line 2864
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2864
	{
#line 2864
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 2864
		if(lstatus != ENOERR)
#line 2864
			status = lstatus;
#line 2864
	}
#line 2864

#line 2864
	if(rndup != 0)
#line 2864
		xp += X_SIZEOF_SHORT;
#line 2864
		
#line 2864
	*xpp = (void *)xp;
#line 2864
	return status;
#line 2864
}
#line 2864

int
#line 2865
ncx_pad_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2865
{
#line 2865
	const size_t rndup = nelems % 2;
#line 2865

#line 2865
	const char *xp = (const char *) *xpp;
#line 2865
	int status = ENOERR;
#line 2865

#line 2865
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2865
	{
#line 2865
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 2865
		if(lstatus != ENOERR)
#line 2865
			status = lstatus;
#line 2865
	}
#line 2865

#line 2865
	if(rndup != 0)
#line 2865
		xp += X_SIZEOF_SHORT;
#line 2865
		
#line 2865
	*xpp = (void *)xp;
#line 2865
	return status;
#line 2865
}
#line 2865

int
#line 2866
ncx_pad_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2866
{
#line 2866
	const size_t rndup = nelems % 2;
#line 2866

#line 2866
	const char *xp = (const char *) *xpp;
#line 2866
	int status = ENOERR;
#line 2866

#line 2866
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2866
	{
#line 2866
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 2866
		if(lstatus != ENOERR)
#line 2866
			status = lstatus;
#line 2866
	}
#line 2866

#line 2866
	if(rndup != 0)
#line 2866
		xp += X_SIZEOF_SHORT;
#line 2866
		
#line 2866
	*xpp = (void *)xp;
#line 2866
	return status;
#line 2866
}
#line 2866


#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_SHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return ENOERR;
}
#else
int
#line 2882
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp)
#line 2882
{
#line 2882
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2882

#line 2882
 /* basic algorithm is:
#line 2882
  *   - ensure sane alignment of output data
#line 2882
  *   - copy (conversion happens automatically) input data
#line 2882
  *     to output
#line 2882
  *   - update tp to point at next unconverted input, and xpp to point
#line 2882
  *     at next location for converted output
#line 2882
  */
#line 2882
  long i, j, ni;
#line 2882
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2882
  short *xp;
#line 2882
  int nrange = 0;         /* number of range errors */
#line 2882
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2882
  long cxp = (long) *((char**)xpp);
#line 2882

#line 2882
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2882
  /* sjl: manually stripmine so we can limit amount of
#line 2882
   * vector work space reserved to LOOPCNT elements. Also
#line 2882
   * makes vectorisation easy */
#line 2882
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2882
    ni=Min(nelems-j,LOOPCNT);
#line 2882
    if (realign) {
#line 2882
      xp = tmp;
#line 2882
    } else {
#line 2882
      xp = (short *) *xpp;
#line 2882
    }
#line 2882
   /* copy the next block */
#line 2882
#pragma cdir loopcnt=LOOPCNT
#line 2882
#pragma cdir shortloop
#line 2882
    for (i=0; i<ni; i++) {
#line 2882
      /* the normal case: */
#line 2882
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2882
     /* test for range errors (not always needed but do it anyway) */
#line 2882
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2882
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2882
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2882
    }
#line 2882
   /* copy workspace back if necessary */
#line 2882
    if (realign) {
#line 2882
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2882
      xp = (short *) *xpp;
#line 2882
    }
#line 2882
   /* update xpp and tp */
#line 2882
    xp += ni;
#line 2882
    tp += ni;
#line 2882
    *xpp = (void*)xp;
#line 2882
  }
#line 2882
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2882

#line 2882
#else   /* not SX */
#line 2882

#line 2882
	char *xp = (char *) *xpp;
#line 2882
	int status = ENOERR;
#line 2882

#line 2882
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2882
	{
#line 2882
		int lstatus = ncx_put_short_short(xp, tp);
#line 2882
		if(lstatus != ENOERR)
#line 2882
			status = lstatus;
#line 2882
	}
#line 2882

#line 2882
	*xpp = (void *)xp;
#line 2882
	return status;
#line 2882
#endif
#line 2882
}
#line 2882

#endif
int
#line 2884
ncx_putn_short_schar(void **xpp, size_t nelems, const schar *tp)
#line 2884
{
#line 2884
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2884

#line 2884
 /* basic algorithm is:
#line 2884
  *   - ensure sane alignment of output data
#line 2884
  *   - copy (conversion happens automatically) input data
#line 2884
  *     to output
#line 2884
  *   - update tp to point at next unconverted input, and xpp to point
#line 2884
  *     at next location for converted output
#line 2884
  */
#line 2884
  long i, j, ni;
#line 2884
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2884
  short *xp;
#line 2884
  int nrange = 0;         /* number of range errors */
#line 2884
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2884
  long cxp = (long) *((char**)xpp);
#line 2884

#line 2884
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2884
  /* sjl: manually stripmine so we can limit amount of
#line 2884
   * vector work space reserved to LOOPCNT elements. Also
#line 2884
   * makes vectorisation easy */
#line 2884
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2884
    ni=Min(nelems-j,LOOPCNT);
#line 2884
    if (realign) {
#line 2884
      xp = tmp;
#line 2884
    } else {
#line 2884
      xp = (short *) *xpp;
#line 2884
    }
#line 2884
   /* copy the next block */
#line 2884
#pragma cdir loopcnt=LOOPCNT
#line 2884
#pragma cdir shortloop
#line 2884
    for (i=0; i<ni; i++) {
#line 2884
      /* the normal case: */
#line 2884
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2884
     /* test for range errors (not always needed but do it anyway) */
#line 2884
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2884
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2884
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2884
    }
#line 2884
   /* copy workspace back if necessary */
#line 2884
    if (realign) {
#line 2884
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2884
      xp = (short *) *xpp;
#line 2884
    }
#line 2884
   /* update xpp and tp */
#line 2884
    xp += ni;
#line 2884
    tp += ni;
#line 2884
    *xpp = (void*)xp;
#line 2884
  }
#line 2884
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2884

#line 2884
#else   /* not SX */
#line 2884

#line 2884
	char *xp = (char *) *xpp;
#line 2884
	int status = ENOERR;
#line 2884

#line 2884
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2884
	{
#line 2884
		int lstatus = ncx_put_short_schar(xp, tp);
#line 2884
		if(lstatus != ENOERR)
#line 2884
			status = lstatus;
#line 2884
	}
#line 2884

#line 2884
	*xpp = (void *)xp;
#line 2884
	return status;
#line 2884
#endif
#line 2884
}
#line 2884

int
#line 2885
ncx_putn_short_int(void **xpp, size_t nelems, const int *tp)
#line 2885
{
#line 2885
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2885

#line 2885
 /* basic algorithm is:
#line 2885
  *   - ensure sane alignment of output data
#line 2885
  *   - copy (conversion happens automatically) input data
#line 2885
  *     to output
#line 2885
  *   - update tp to point at next unconverted input, and xpp to point
#line 2885
  *     at next location for converted output
#line 2885
  */
#line 2885
  long i, j, ni;
#line 2885
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2885
  short *xp;
#line 2885
  int nrange = 0;         /* number of range errors */
#line 2885
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2885
  long cxp = (long) *((char**)xpp);
#line 2885

#line 2885
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2885
  /* sjl: manually stripmine so we can limit amount of
#line 2885
   * vector work space reserved to LOOPCNT elements. Also
#line 2885
   * makes vectorisation easy */
#line 2885
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2885
    ni=Min(nelems-j,LOOPCNT);
#line 2885
    if (realign) {
#line 2885
      xp = tmp;
#line 2885
    } else {
#line 2885
      xp = (short *) *xpp;
#line 2885
    }
#line 2885
   /* copy the next block */
#line 2885
#pragma cdir loopcnt=LOOPCNT
#line 2885
#pragma cdir shortloop
#line 2885
    for (i=0; i<ni; i++) {
#line 2885
      /* the normal case: */
#line 2885
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2885
     /* test for range errors (not always needed but do it anyway) */
#line 2885
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2885
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2885
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2885
    }
#line 2885
   /* copy workspace back if necessary */
#line 2885
    if (realign) {
#line 2885
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2885
      xp = (short *) *xpp;
#line 2885
    }
#line 2885
   /* update xpp and tp */
#line 2885
    xp += ni;
#line 2885
    tp += ni;
#line 2885
    *xpp = (void*)xp;
#line 2885
  }
#line 2885
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2885

#line 2885
#else   /* not SX */
#line 2885

#line 2885
	char *xp = (char *) *xpp;
#line 2885
	int status = ENOERR;
#line 2885

#line 2885
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2885
	{
#line 2885
		int lstatus = ncx_put_short_int(xp, tp);
#line 2885
		if(lstatus != ENOERR)
#line 2885
			status = lstatus;
#line 2885
	}
#line 2885

#line 2885
	*xpp = (void *)xp;
#line 2885
	return status;
#line 2885
#endif
#line 2885
}
#line 2885

int
#line 2886
ncx_putn_short_float(void **xpp, size_t nelems, const float *tp)
#line 2886
{
#line 2886
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2886

#line 2886
 /* basic algorithm is:
#line 2886
  *   - ensure sane alignment of output data
#line 2886
  *   - copy (conversion happens automatically) input data
#line 2886
  *     to output
#line 2886
  *   - update tp to point at next unconverted input, and xpp to point
#line 2886
  *     at next location for converted output
#line 2886
  */
#line 2886
  long i, j, ni;
#line 2886
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2886
  short *xp;
#line 2886
  int nrange = 0;         /* number of range errors */
#line 2886
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2886
  long cxp = (long) *((char**)xpp);
#line 2886

#line 2886
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2886
  /* sjl: manually stripmine so we can limit amount of
#line 2886
   * vector work space reserved to LOOPCNT elements. Also
#line 2886
   * makes vectorisation easy */
#line 2886
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2886
    ni=Min(nelems-j,LOOPCNT);
#line 2886
    if (realign) {
#line 2886
      xp = tmp;
#line 2886
    } else {
#line 2886
      xp = (short *) *xpp;
#line 2886
    }
#line 2886
   /* copy the next block */
#line 2886
#pragma cdir loopcnt=LOOPCNT
#line 2886
#pragma cdir shortloop
#line 2886
    for (i=0; i<ni; i++) {
#line 2886
      /* the normal case: */
#line 2886
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2886
     /* test for range errors (not always needed but do it anyway) */
#line 2886
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2886
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2886
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2886
    }
#line 2886
   /* copy workspace back if necessary */
#line 2886
    if (realign) {
#line 2886
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2886
      xp = (short *) *xpp;
#line 2886
    }
#line 2886
   /* update xpp and tp */
#line 2886
    xp += ni;
#line 2886
    tp += ni;
#line 2886
    *xpp = (void*)xp;
#line 2886
  }
#line 2886
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2886

#line 2886
#else   /* not SX */
#line 2886

#line 2886
	char *xp = (char *) *xpp;
#line 2886
	int status = ENOERR;
#line 2886

#line 2886
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2886
	{
#line 2886
		int lstatus = ncx_put_short_float(xp, tp);
#line 2886
		if(lstatus != ENOERR)
#line 2886
			status = lstatus;
#line 2886
	}
#line 2886

#line 2886
	*xpp = (void *)xp;
#line 2886
	return status;
#line 2886
#endif
#line 2886
}
#line 2886

int
#line 2887
ncx_putn_short_double(void **xpp, size_t nelems, const double *tp)
#line 2887
{
#line 2887
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2887

#line 2887
 /* basic algorithm is:
#line 2887
  *   - ensure sane alignment of output data
#line 2887
  *   - copy (conversion happens automatically) input data
#line 2887
  *     to output
#line 2887
  *   - update tp to point at next unconverted input, and xpp to point
#line 2887
  *     at next location for converted output
#line 2887
  */
#line 2887
  long i, j, ni;
#line 2887
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2887
  short *xp;
#line 2887
  int nrange = 0;         /* number of range errors */
#line 2887
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2887
  long cxp = (long) *((char**)xpp);
#line 2887

#line 2887
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2887
  /* sjl: manually stripmine so we can limit amount of
#line 2887
   * vector work space reserved to LOOPCNT elements. Also
#line 2887
   * makes vectorisation easy */
#line 2887
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2887
    ni=Min(nelems-j,LOOPCNT);
#line 2887
    if (realign) {
#line 2887
      xp = tmp;
#line 2887
    } else {
#line 2887
      xp = (short *) *xpp;
#line 2887
    }
#line 2887
   /* copy the next block */
#line 2887
#pragma cdir loopcnt=LOOPCNT
#line 2887
#pragma cdir shortloop
#line 2887
    for (i=0; i<ni; i++) {
#line 2887
      /* the normal case: */
#line 2887
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2887
     /* test for range errors (not always needed but do it anyway) */
#line 2887
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2887
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2887
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2887
    }
#line 2887
   /* copy workspace back if necessary */
#line 2887
    if (realign) {
#line 2887
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2887
      xp = (short *) *xpp;
#line 2887
    }
#line 2887
   /* update xpp and tp */
#line 2887
    xp += ni;
#line 2887
    tp += ni;
#line 2887
    *xpp = (void*)xp;
#line 2887
  }
#line 2887
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2887

#line 2887
#else   /* not SX */
#line 2887

#line 2887
	char *xp = (char *) *xpp;
#line 2887
	int status = ENOERR;
#line 2887

#line 2887
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2887
	{
#line 2887
		int lstatus = ncx_put_short_double(xp, tp);
#line 2887
		if(lstatus != ENOERR)
#line 2887
			status = lstatus;
#line 2887
	}
#line 2887

#line 2887
	*xpp = (void *)xp;
#line 2887
	return status;
#line 2887
#endif
#line 2887
}
#line 2887

int
#line 2888
ncx_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2888
{
#line 2888
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2888

#line 2888
 /* basic algorithm is:
#line 2888
  *   - ensure sane alignment of output data
#line 2888
  *   - copy (conversion happens automatically) input data
#line 2888
  *     to output
#line 2888
  *   - update tp to point at next unconverted input, and xpp to point
#line 2888
  *     at next location for converted output
#line 2888
  */
#line 2888
  long i, j, ni;
#line 2888
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2888
  short *xp;
#line 2888
  int nrange = 0;         /* number of range errors */
#line 2888
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2888
  long cxp = (long) *((char**)xpp);
#line 2888

#line 2888
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2888
  /* sjl: manually stripmine so we can limit amount of
#line 2888
   * vector work space reserved to LOOPCNT elements. Also
#line 2888
   * makes vectorisation easy */
#line 2888
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2888
    ni=Min(nelems-j,LOOPCNT);
#line 2888
    if (realign) {
#line 2888
      xp = tmp;
#line 2888
    } else {
#line 2888
      xp = (short *) *xpp;
#line 2888
    }
#line 2888
   /* copy the next block */
#line 2888
#pragma cdir loopcnt=LOOPCNT
#line 2888
#pragma cdir shortloop
#line 2888
    for (i=0; i<ni; i++) {
#line 2888
      /* the normal case: */
#line 2888
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2888
     /* test for range errors (not always needed but do it anyway) */
#line 2888
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2888
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2888
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2888
    }
#line 2888
   /* copy workspace back if necessary */
#line 2888
    if (realign) {
#line 2888
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2888
      xp = (short *) *xpp;
#line 2888
    }
#line 2888
   /* update xpp and tp */
#line 2888
    xp += ni;
#line 2888
    tp += ni;
#line 2888
    *xpp = (void*)xp;
#line 2888
  }
#line 2888
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2888

#line 2888
#else   /* not SX */
#line 2888

#line 2888
	char *xp = (char *) *xpp;
#line 2888
	int status = ENOERR;
#line 2888

#line 2888
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2888
	{
#line 2888
		int lstatus = ncx_put_short_longlong(xp, tp);
#line 2888
		if(lstatus != ENOERR)
#line 2888
			status = lstatus;
#line 2888
	}
#line 2888

#line 2888
	*xpp = (void *)xp;
#line 2888
	return status;
#line 2888
#endif
#line 2888
}
#line 2888

int
#line 2889
ncx_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2889
{
#line 2889
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2889

#line 2889
 /* basic algorithm is:
#line 2889
  *   - ensure sane alignment of output data
#line 2889
  *   - copy (conversion happens automatically) input data
#line 2889
  *     to output
#line 2889
  *   - update tp to point at next unconverted input, and xpp to point
#line 2889
  *     at next location for converted output
#line 2889
  */
#line 2889
  long i, j, ni;
#line 2889
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2889
  short *xp;
#line 2889
  int nrange = 0;         /* number of range errors */
#line 2889
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2889
  long cxp = (long) *((char**)xpp);
#line 2889

#line 2889
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2889
  /* sjl: manually stripmine so we can limit amount of
#line 2889
   * vector work space reserved to LOOPCNT elements. Also
#line 2889
   * makes vectorisation easy */
#line 2889
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2889
    ni=Min(nelems-j,LOOPCNT);
#line 2889
    if (realign) {
#line 2889
      xp = tmp;
#line 2889
    } else {
#line 2889
      xp = (short *) *xpp;
#line 2889
    }
#line 2889
   /* copy the next block */
#line 2889
#pragma cdir loopcnt=LOOPCNT
#line 2889
#pragma cdir shortloop
#line 2889
    for (i=0; i<ni; i++) {
#line 2889
      /* the normal case: */
#line 2889
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2889
     /* test for range errors (not always needed but do it anyway) */
#line 2889
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2889
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2889
      nrange += tp[i] > X_SHORT_MAX ;
#line 2889
    }
#line 2889
   /* copy workspace back if necessary */
#line 2889
    if (realign) {
#line 2889
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2889
      xp = (short *) *xpp;
#line 2889
    }
#line 2889
   /* update xpp and tp */
#line 2889
    xp += ni;
#line 2889
    tp += ni;
#line 2889
    *xpp = (void*)xp;
#line 2889
  }
#line 2889
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2889

#line 2889
#else   /* not SX */
#line 2889

#line 2889
	char *xp = (char *) *xpp;
#line 2889
	int status = ENOERR;
#line 2889

#line 2889
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2889
	{
#line 2889
		int lstatus = ncx_put_short_uchar(xp, tp);
#line 2889
		if(lstatus != ENOERR)
#line 2889
			status = lstatus;
#line 2889
	}
#line 2889

#line 2889
	*xpp = (void *)xp;
#line 2889
	return status;
#line 2889
#endif
#line 2889
}
#line 2889

int
#line 2890
ncx_putn_short_uint(void **xpp, size_t nelems, const uint *tp)
#line 2890
{
#line 2890
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2890

#line 2890
 /* basic algorithm is:
#line 2890
  *   - ensure sane alignment of output data
#line 2890
  *   - copy (conversion happens automatically) input data
#line 2890
  *     to output
#line 2890
  *   - update tp to point at next unconverted input, and xpp to point
#line 2890
  *     at next location for converted output
#line 2890
  */
#line 2890
  long i, j, ni;
#line 2890
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2890
  short *xp;
#line 2890
  int nrange = 0;         /* number of range errors */
#line 2890
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2890
  long cxp = (long) *((char**)xpp);
#line 2890

#line 2890
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2890
  /* sjl: manually stripmine so we can limit amount of
#line 2890
   * vector work space reserved to LOOPCNT elements. Also
#line 2890
   * makes vectorisation easy */
#line 2890
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2890
    ni=Min(nelems-j,LOOPCNT);
#line 2890
    if (realign) {
#line 2890
      xp = tmp;
#line 2890
    } else {
#line 2890
      xp = (short *) *xpp;
#line 2890
    }
#line 2890
   /* copy the next block */
#line 2890
#pragma cdir loopcnt=LOOPCNT
#line 2890
#pragma cdir shortloop
#line 2890
    for (i=0; i<ni; i++) {
#line 2890
      /* the normal case: */
#line 2890
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2890
     /* test for range errors (not always needed but do it anyway) */
#line 2890
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2890
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2890
      nrange += tp[i] > X_SHORT_MAX ;
#line 2890
    }
#line 2890
   /* copy workspace back if necessary */
#line 2890
    if (realign) {
#line 2890
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2890
      xp = (short *) *xpp;
#line 2890
    }
#line 2890
   /* update xpp and tp */
#line 2890
    xp += ni;
#line 2890
    tp += ni;
#line 2890
    *xpp = (void*)xp;
#line 2890
  }
#line 2890
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2890

#line 2890
#else   /* not SX */
#line 2890

#line 2890
	char *xp = (char *) *xpp;
#line 2890
	int status = ENOERR;
#line 2890

#line 2890
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2890
	{
#line 2890
		int lstatus = ncx_put_short_uint(xp, tp);
#line 2890
		if(lstatus != ENOERR)
#line 2890
			status = lstatus;
#line 2890
	}
#line 2890

#line 2890
	*xpp = (void *)xp;
#line 2890
	return status;
#line 2890
#endif
#line 2890
}
#line 2890

int
#line 2891
ncx_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2891
{
#line 2891
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2891

#line 2891
 /* basic algorithm is:
#line 2891
  *   - ensure sane alignment of output data
#line 2891
  *   - copy (conversion happens automatically) input data
#line 2891
  *     to output
#line 2891
  *   - update tp to point at next unconverted input, and xpp to point
#line 2891
  *     at next location for converted output
#line 2891
  */
#line 2891
  long i, j, ni;
#line 2891
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2891
  short *xp;
#line 2891
  int nrange = 0;         /* number of range errors */
#line 2891
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2891
  long cxp = (long) *((char**)xpp);
#line 2891

#line 2891
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2891
  /* sjl: manually stripmine so we can limit amount of
#line 2891
   * vector work space reserved to LOOPCNT elements. Also
#line 2891
   * makes vectorisation easy */
#line 2891
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2891
    ni=Min(nelems-j,LOOPCNT);
#line 2891
    if (realign) {
#line 2891
      xp = tmp;
#line 2891
    } else {
#line 2891
      xp = (short *) *xpp;
#line 2891
    }
#line 2891
   /* copy the next block */
#line 2891
#pragma cdir loopcnt=LOOPCNT
#line 2891
#pragma cdir shortloop
#line 2891
    for (i=0; i<ni; i++) {
#line 2891
      /* the normal case: */
#line 2891
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2891
     /* test for range errors (not always needed but do it anyway) */
#line 2891
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2891
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2891
      nrange += tp[i] > X_SHORT_MAX ;
#line 2891
    }
#line 2891
   /* copy workspace back if necessary */
#line 2891
    if (realign) {
#line 2891
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2891
      xp = (short *) *xpp;
#line 2891
    }
#line 2891
   /* update xpp and tp */
#line 2891
    xp += ni;
#line 2891
    tp += ni;
#line 2891
    *xpp = (void*)xp;
#line 2891
  }
#line 2891
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2891

#line 2891
#else   /* not SX */
#line 2891

#line 2891
	char *xp = (char *) *xpp;
#line 2891
	int status = ENOERR;
#line 2891

#line 2891
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2891
	{
#line 2891
		int lstatus = ncx_put_short_ulonglong(xp, tp);
#line 2891
		if(lstatus != ENOERR)
#line 2891
			status = lstatus;
#line 2891
	}
#line 2891

#line 2891
	*xpp = (void *)xp;
#line 2891
	return status;
#line 2891
#endif
#line 2891
}
#line 2891

int
#line 2892
ncx_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2892
{
#line 2892
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2892

#line 2892
 /* basic algorithm is:
#line 2892
  *   - ensure sane alignment of output data
#line 2892
  *   - copy (conversion happens automatically) input data
#line 2892
  *     to output
#line 2892
  *   - update tp to point at next unconverted input, and xpp to point
#line 2892
  *     at next location for converted output
#line 2892
  */
#line 2892
  long i, j, ni;
#line 2892
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2892
  short *xp;
#line 2892
  int nrange = 0;         /* number of range errors */
#line 2892
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2892
  long cxp = (long) *((char**)xpp);
#line 2892

#line 2892
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2892
  /* sjl: manually stripmine so we can limit amount of
#line 2892
   * vector work space reserved to LOOPCNT elements. Also
#line 2892
   * makes vectorisation easy */
#line 2892
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2892
    ni=Min(nelems-j,LOOPCNT);
#line 2892
    if (realign) {
#line 2892
      xp = tmp;
#line 2892
    } else {
#line 2892
      xp = (short *) *xpp;
#line 2892
    }
#line 2892
   /* copy the next block */
#line 2892
#pragma cdir loopcnt=LOOPCNT
#line 2892
#pragma cdir shortloop
#line 2892
    for (i=0; i<ni; i++) {
#line 2892
      /* the normal case: */
#line 2892
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2892
     /* test for range errors (not always needed but do it anyway) */
#line 2892
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2892
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2892
      nrange += tp[i] > X_SHORT_MAX ;
#line 2892
    }
#line 2892
   /* copy workspace back if necessary */
#line 2892
    if (realign) {
#line 2892
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2892
      xp = (short *) *xpp;
#line 2892
    }
#line 2892
   /* update xpp and tp */
#line 2892
    xp += ni;
#line 2892
    tp += ni;
#line 2892
    *xpp = (void*)xp;
#line 2892
  }
#line 2892
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2892

#line 2892
#else   /* not SX */
#line 2892

#line 2892
	char *xp = (char *) *xpp;
#line 2892
	int status = ENOERR;
#line 2892

#line 2892
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2892
	{
#line 2892
		int lstatus = ncx_put_short_ushort(xp, tp);
#line 2892
		if(lstatus != ENOERR)
#line 2892
			status = lstatus;
#line 2892
	}
#line 2892

#line 2892
	*xpp = (void *)xp;
#line 2892
	return status;
#line 2892
#endif
#line 2892
}
#line 2892


int
#line 2894
ncx_pad_putn_short_schar(void **xpp, size_t nelems, const schar *tp)
#line 2894
{
#line 2894
	const size_t rndup = nelems % 2;
#line 2894

#line 2894
	char *xp = (char *) *xpp;
#line 2894
	int status = ENOERR;
#line 2894

#line 2894
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2894
	{
#line 2894
		int lstatus = ncx_put_short_schar(xp, tp);
#line 2894
		if(lstatus != ENOERR)
#line 2894
			status = lstatus;
#line 2894
	}
#line 2894

#line 2894
	if(rndup != 0)
#line 2894
	{
#line 2894
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2894
		xp += X_SIZEOF_SHORT;	
#line 2894
	}
#line 2894

#line 2894
	*xpp = (void *)xp;
#line 2894
	return status;
#line 2894
}
#line 2894

int
#line 2895
ncx_pad_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2895
{
#line 2895
	const size_t rndup = nelems % 2;
#line 2895

#line 2895
	char *xp = (char *) *xpp;
#line 2895
	int status = ENOERR;
#line 2895

#line 2895
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2895
	{
#line 2895
		int lstatus = ncx_put_short_uchar(xp, tp);
#line 2895
		if(lstatus != ENOERR)
#line 2895
			status = lstatus;
#line 2895
	}
#line 2895

#line 2895
	if(rndup != 0)
#line 2895
	{
#line 2895
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2895
		xp += X_SIZEOF_SHORT;	
#line 2895
	}
#line 2895

#line 2895
	*xpp = (void *)xp;
#line 2895
	return status;
#line 2895
}
#line 2895

int
#line 2896
ncx_pad_putn_short_short(void **xpp, size_t nelems, const short *tp)
#line 2896
{
#line 2896
	const size_t rndup = nelems % 2;
#line 2896

#line 2896
	char *xp = (char *) *xpp;
#line 2896
	int status = ENOERR;
#line 2896

#line 2896
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2896
	{
#line 2896
		int lstatus = ncx_put_short_short(xp, tp);
#line 2896
		if(lstatus != ENOERR)
#line 2896
			status = lstatus;
#line 2896
	}
#line 2896

#line 2896
	if(rndup != 0)
#line 2896
	{
#line 2896
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2896
		xp += X_SIZEOF_SHORT;	
#line 2896
	}
#line 2896

#line 2896
	*xpp = (void *)xp;
#line 2896
	return status;
#line 2896
}
#line 2896

int
#line 2897
ncx_pad_putn_short_int(void **xpp, size_t nelems, const int *tp)
#line 2897
{
#line 2897
	const size_t rndup = nelems % 2;
#line 2897

#line 2897
	char *xp = (char *) *xpp;
#line 2897
	int status = ENOERR;
#line 2897

#line 2897
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2897
	{
#line 2897
		int lstatus = ncx_put_short_int(xp, tp);
#line 2897
		if(lstatus != ENOERR)
#line 2897
			status = lstatus;
#line 2897
	}
#line 2897

#line 2897
	if(rndup != 0)
#line 2897
	{
#line 2897
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2897
		xp += X_SIZEOF_SHORT;	
#line 2897
	}
#line 2897

#line 2897
	*xpp = (void *)xp;
#line 2897
	return status;
#line 2897
}
#line 2897

int
#line 2898
ncx_pad_putn_short_float(void **xpp, size_t nelems, const float *tp)
#line 2898
{
#line 2898
	const size_t rndup = nelems % 2;
#line 2898

#line 2898
	char *xp = (char *) *xpp;
#line 2898
	int status = ENOERR;
#line 2898

#line 2898
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2898
	{
#line 2898
		int lstatus = ncx_put_short_float(xp, tp);
#line 2898
		if(lstatus != ENOERR)
#line 2898
			status = lstatus;
#line 2898
	}
#line 2898

#line 2898
	if(rndup != 0)
#line 2898
	{
#line 2898
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2898
		xp += X_SIZEOF_SHORT;	
#line 2898
	}
#line 2898

#line 2898
	*xpp = (void *)xp;
#line 2898
	return status;
#line 2898
}
#line 2898

int
#line 2899
ncx_pad_putn_short_double(void **xpp, size_t nelems, const double *tp)
#line 2899
{
#line 2899
	const size_t rndup = nelems % 2;
#line 2899

#line 2899
	char *xp = (char *) *xpp;
#line 2899
	int status = ENOERR;
#line 2899

#line 2899
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2899
	{
#line 2899
		int lstatus = ncx_put_short_double(xp, tp);
#line 2899
		if(lstatus != ENOERR)
#line 2899
			status = lstatus;
#line 2899
	}
#line 2899

#line 2899
	if(rndup != 0)
#line 2899
	{
#line 2899
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2899
		xp += X_SIZEOF_SHORT;	
#line 2899
	}
#line 2899

#line 2899
	*xpp = (void *)xp;
#line 2899
	return status;
#line 2899
}
#line 2899

int
#line 2900
ncx_pad_putn_short_uint(void **xpp, size_t nelems, const uint *tp)
#line 2900
{
#line 2900
	const size_t rndup = nelems % 2;
#line 2900

#line 2900
	char *xp = (char *) *xpp;
#line 2900
	int status = ENOERR;
#line 2900

#line 2900
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2900
	{
#line 2900
		int lstatus = ncx_put_short_uint(xp, tp);
#line 2900
		if(lstatus != ENOERR)
#line 2900
			status = lstatus;
#line 2900
	}
#line 2900

#line 2900
	if(rndup != 0)
#line 2900
	{
#line 2900
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2900
		xp += X_SIZEOF_SHORT;	
#line 2900
	}
#line 2900

#line 2900
	*xpp = (void *)xp;
#line 2900
	return status;
#line 2900
}
#line 2900

int
#line 2901
ncx_pad_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2901
{
#line 2901
	const size_t rndup = nelems % 2;
#line 2901

#line 2901
	char *xp = (char *) *xpp;
#line 2901
	int status = ENOERR;
#line 2901

#line 2901
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2901
	{
#line 2901
		int lstatus = ncx_put_short_longlong(xp, tp);
#line 2901
		if(lstatus != ENOERR)
#line 2901
			status = lstatus;
#line 2901
	}
#line 2901

#line 2901
	if(rndup != 0)
#line 2901
	{
#line 2901
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2901
		xp += X_SIZEOF_SHORT;	
#line 2901
	}
#line 2901

#line 2901
	*xpp = (void *)xp;
#line 2901
	return status;
#line 2901
}
#line 2901

int
#line 2902
ncx_pad_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2902
{
#line 2902
	const size_t rndup = nelems % 2;
#line 2902

#line 2902
	char *xp = (char *) *xpp;
#line 2902
	int status = ENOERR;
#line 2902

#line 2902
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2902
	{
#line 2902
		int lstatus = ncx_put_short_ulonglong(xp, tp);
#line 2902
		if(lstatus != ENOERR)
#line 2902
			status = lstatus;
#line 2902
	}
#line 2902

#line 2902
	if(rndup != 0)
#line 2902
	{
#line 2902
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2902
		xp += X_SIZEOF_SHORT;	
#line 2902
	}
#line 2902

#line 2902
	*xpp = (void *)xp;
#line 2902
	return status;
#line 2902
}
#line 2902

int
#line 2903
ncx_pad_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2903
{
#line 2903
	const size_t rndup = nelems % 2;
#line 2903

#line 2903
	char *xp = (char *) *xpp;
#line 2903
	int status = ENOERR;
#line 2903

#line 2903
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2903
	{
#line 2903
		int lstatus = ncx_put_short_ushort(xp, tp);
#line 2903
		if(lstatus != ENOERR)
#line 2903
			status = lstatus;
#line 2903
	}
#line 2903

#line 2903
	if(rndup != 0)
#line 2903
	{
#line 2903
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2903
		xp += X_SIZEOF_SHORT;	
#line 2903
	}
#line 2903

#line 2903
	*xpp = (void *)xp;
#line 2903
	return status;
#line 2903
}
#line 2903



/* ushort --------------------------------------------------------------------*/

#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, unsigned short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(unsigned short));
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return ENOERR;
}
#else
int
#line 2922
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2922
{
#line 2922
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2922

#line 2922
 /* basic algorithm is:
#line 2922
  *   - ensure sane alignment of input data
#line 2922
  *   - copy (conversion happens automatically) input data
#line 2922
  *     to output
#line 2922
  *   - update xpp to point at next unconverted input, and tp to point
#line 2922
  *     at next location for converted output
#line 2922
  */
#line 2922
  long i, j, ni;
#line 2922
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2922
  ushort *xp;
#line 2922
  int nrange = 0;         /* number of range errors */
#line 2922
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2922
  long cxp = (long) *((char**)xpp);
#line 2922

#line 2922
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2922
  /* sjl: manually stripmine so we can limit amount of
#line 2922
   * vector work space reserved to LOOPCNT elements. Also
#line 2922
   * makes vectorisation easy */
#line 2922
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2922
    ni=Min(nelems-j,LOOPCNT);
#line 2922
    if (realign) {
#line 2922
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2922
      xp = tmp;
#line 2922
    } else {
#line 2922
      xp = (ushort *) *xpp;
#line 2922
    }
#line 2922
   /* copy the next block */
#line 2922
#pragma cdir loopcnt=LOOPCNT
#line 2922
#pragma cdir shortloop
#line 2922
    for (i=0; i<ni; i++) {
#line 2922
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2922
     /* test for range errors (not always needed but do it anyway) */
#line 2922
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2922
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2922
      nrange += xp[i] > USHORT_MAX ;
#line 2922
    }
#line 2922
   /* update xpp and tp */
#line 2922
    if (realign) xp = (ushort *) *xpp;
#line 2922
    xp += ni;
#line 2922
    tp += ni;
#line 2922
    *xpp = (void*)xp;
#line 2922
  }
#line 2922
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2922

#line 2922
#else   /* not SX */
#line 2922
	const char *xp = (const char *) *xpp;
#line 2922
	int status = ENOERR;
#line 2922

#line 2922
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2922
	{
#line 2922
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 2922
		if(lstatus != ENOERR)
#line 2922
			status = lstatus;
#line 2922
	}
#line 2922

#line 2922
	*xpp = (const void *)xp;
#line 2922
	return status;
#line 2922
#  endif
#line 2922
}
#line 2922

#endif
int
#line 2924
ncx_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 2924
{
#line 2924
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2924

#line 2924
 /* basic algorithm is:
#line 2924
  *   - ensure sane alignment of input data
#line 2924
  *   - copy (conversion happens automatically) input data
#line 2924
  *     to output
#line 2924
  *   - update xpp to point at next unconverted input, and tp to point
#line 2924
  *     at next location for converted output
#line 2924
  */
#line 2924
  long i, j, ni;
#line 2924
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2924
  ushort *xp;
#line 2924
  int nrange = 0;         /* number of range errors */
#line 2924
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2924
  long cxp = (long) *((char**)xpp);
#line 2924

#line 2924
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2924
  /* sjl: manually stripmine so we can limit amount of
#line 2924
   * vector work space reserved to LOOPCNT elements. Also
#line 2924
   * makes vectorisation easy */
#line 2924
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2924
    ni=Min(nelems-j,LOOPCNT);
#line 2924
    if (realign) {
#line 2924
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2924
      xp = tmp;
#line 2924
    } else {
#line 2924
      xp = (ushort *) *xpp;
#line 2924
    }
#line 2924
   /* copy the next block */
#line 2924
#pragma cdir loopcnt=LOOPCNT
#line 2924
#pragma cdir shortloop
#line 2924
    for (i=0; i<ni; i++) {
#line 2924
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2924
     /* test for range errors (not always needed but do it anyway) */
#line 2924
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2924
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2924
      nrange += xp[i] > SCHAR_MAX ;
#line 2924
    }
#line 2924
   /* update xpp and tp */
#line 2924
    if (realign) xp = (ushort *) *xpp;
#line 2924
    xp += ni;
#line 2924
    tp += ni;
#line 2924
    *xpp = (void*)xp;
#line 2924
  }
#line 2924
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2924

#line 2924
#else   /* not SX */
#line 2924
	const char *xp = (const char *) *xpp;
#line 2924
	int status = ENOERR;
#line 2924

#line 2924
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2924
	{
#line 2924
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 2924
		if(lstatus != ENOERR)
#line 2924
			status = lstatus;
#line 2924
	}
#line 2924

#line 2924
	*xpp = (const void *)xp;
#line 2924
	return status;
#line 2924
#  endif
#line 2924
}
#line 2924

int
#line 2925
ncx_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 2925
{
#line 2925
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2925

#line 2925
 /* basic algorithm is:
#line 2925
  *   - ensure sane alignment of input data
#line 2925
  *   - copy (conversion happens automatically) input data
#line 2925
  *     to output
#line 2925
  *   - update xpp to point at next unconverted input, and tp to point
#line 2925
  *     at next location for converted output
#line 2925
  */
#line 2925
  long i, j, ni;
#line 2925
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2925
  ushort *xp;
#line 2925
  int nrange = 0;         /* number of range errors */
#line 2925
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2925
  long cxp = (long) *((char**)xpp);
#line 2925

#line 2925
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2925
  /* sjl: manually stripmine so we can limit amount of
#line 2925
   * vector work space reserved to LOOPCNT elements. Also
#line 2925
   * makes vectorisation easy */
#line 2925
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2925
    ni=Min(nelems-j,LOOPCNT);
#line 2925
    if (realign) {
#line 2925
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2925
      xp = tmp;
#line 2925
    } else {
#line 2925
      xp = (ushort *) *xpp;
#line 2925
    }
#line 2925
   /* copy the next block */
#line 2925
#pragma cdir loopcnt=LOOPCNT
#line 2925
#pragma cdir shortloop
#line 2925
    for (i=0; i<ni; i++) {
#line 2925
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2925
     /* test for range errors (not always needed but do it anyway) */
#line 2925
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2925
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2925
      nrange += xp[i] > SHORT_MAX ;
#line 2925
    }
#line 2925
   /* update xpp and tp */
#line 2925
    if (realign) xp = (ushort *) *xpp;
#line 2925
    xp += ni;
#line 2925
    tp += ni;
#line 2925
    *xpp = (void*)xp;
#line 2925
  }
#line 2925
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2925

#line 2925
#else   /* not SX */
#line 2925
	const char *xp = (const char *) *xpp;
#line 2925
	int status = ENOERR;
#line 2925

#line 2925
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2925
	{
#line 2925
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 2925
		if(lstatus != ENOERR)
#line 2925
			status = lstatus;
#line 2925
	}
#line 2925

#line 2925
	*xpp = (const void *)xp;
#line 2925
	return status;
#line 2925
#  endif
#line 2925
}
#line 2925

int
#line 2926
ncx_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 2926
{
#line 2926
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2926

#line 2926
 /* basic algorithm is:
#line 2926
  *   - ensure sane alignment of input data
#line 2926
  *   - copy (conversion happens automatically) input data
#line 2926
  *     to output
#line 2926
  *   - update xpp to point at next unconverted input, and tp to point
#line 2926
  *     at next location for converted output
#line 2926
  */
#line 2926
  long i, j, ni;
#line 2926
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2926
  ushort *xp;
#line 2926
  int nrange = 0;         /* number of range errors */
#line 2926
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2926
  long cxp = (long) *((char**)xpp);
#line 2926

#line 2926
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2926
  /* sjl: manually stripmine so we can limit amount of
#line 2926
   * vector work space reserved to LOOPCNT elements. Also
#line 2926
   * makes vectorisation easy */
#line 2926
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2926
    ni=Min(nelems-j,LOOPCNT);
#line 2926
    if (realign) {
#line 2926
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2926
      xp = tmp;
#line 2926
    } else {
#line 2926
      xp = (ushort *) *xpp;
#line 2926
    }
#line 2926
   /* copy the next block */
#line 2926
#pragma cdir loopcnt=LOOPCNT
#line 2926
#pragma cdir shortloop
#line 2926
    for (i=0; i<ni; i++) {
#line 2926
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2926
     /* test for range errors (not always needed but do it anyway) */
#line 2926
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2926
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2926
      nrange += xp[i] > INT_MAX ;
#line 2926
    }
#line 2926
   /* update xpp and tp */
#line 2926
    if (realign) xp = (ushort *) *xpp;
#line 2926
    xp += ni;
#line 2926
    tp += ni;
#line 2926
    *xpp = (void*)xp;
#line 2926
  }
#line 2926
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2926

#line 2926
#else   /* not SX */
#line 2926
	const char *xp = (const char *) *xpp;
#line 2926
	int status = ENOERR;
#line 2926

#line 2926
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2926
	{
#line 2926
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 2926
		if(lstatus != ENOERR)
#line 2926
			status = lstatus;
#line 2926
	}
#line 2926

#line 2926
	*xpp = (const void *)xp;
#line 2926
	return status;
#line 2926
#  endif
#line 2926
}
#line 2926

int
#line 2927
ncx_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 2927
{
#line 2927
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2927

#line 2927
 /* basic algorithm is:
#line 2927
  *   - ensure sane alignment of input data
#line 2927
  *   - copy (conversion happens automatically) input data
#line 2927
  *     to output
#line 2927
  *   - update xpp to point at next unconverted input, and tp to point
#line 2927
  *     at next location for converted output
#line 2927
  */
#line 2927
  long i, j, ni;
#line 2927
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2927
  ushort *xp;
#line 2927
  int nrange = 0;         /* number of range errors */
#line 2927
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2927
  long cxp = (long) *((char**)xpp);
#line 2927

#line 2927
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2927
  /* sjl: manually stripmine so we can limit amount of
#line 2927
   * vector work space reserved to LOOPCNT elements. Also
#line 2927
   * makes vectorisation easy */
#line 2927
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2927
    ni=Min(nelems-j,LOOPCNT);
#line 2927
    if (realign) {
#line 2927
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2927
      xp = tmp;
#line 2927
    } else {
#line 2927
      xp = (ushort *) *xpp;
#line 2927
    }
#line 2927
   /* copy the next block */
#line 2927
#pragma cdir loopcnt=LOOPCNT
#line 2927
#pragma cdir shortloop
#line 2927
    for (i=0; i<ni; i++) {
#line 2927
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2927
     /* test for range errors (not always needed but do it anyway) */
#line 2927
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2927
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2927
      nrange += xp[i] > FLOAT_MAX ;
#line 2927
    }
#line 2927
   /* update xpp and tp */
#line 2927
    if (realign) xp = (ushort *) *xpp;
#line 2927
    xp += ni;
#line 2927
    tp += ni;
#line 2927
    *xpp = (void*)xp;
#line 2927
  }
#line 2927
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2927

#line 2927
#else   /* not SX */
#line 2927
	const char *xp = (const char *) *xpp;
#line 2927
	int status = ENOERR;
#line 2927

#line 2927
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2927
	{
#line 2927
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 2927
		if(lstatus != ENOERR)
#line 2927
			status = lstatus;
#line 2927
	}
#line 2927

#line 2927
	*xpp = (const void *)xp;
#line 2927
	return status;
#line 2927
#  endif
#line 2927
}
#line 2927

int
#line 2928
ncx_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 2928
{
#line 2928
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2928

#line 2928
 /* basic algorithm is:
#line 2928
  *   - ensure sane alignment of input data
#line 2928
  *   - copy (conversion happens automatically) input data
#line 2928
  *     to output
#line 2928
  *   - update xpp to point at next unconverted input, and tp to point
#line 2928
  *     at next location for converted output
#line 2928
  */
#line 2928
  long i, j, ni;
#line 2928
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2928
  ushort *xp;
#line 2928
  int nrange = 0;         /* number of range errors */
#line 2928
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2928
  long cxp = (long) *((char**)xpp);
#line 2928

#line 2928
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2928
  /* sjl: manually stripmine so we can limit amount of
#line 2928
   * vector work space reserved to LOOPCNT elements. Also
#line 2928
   * makes vectorisation easy */
#line 2928
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2928
    ni=Min(nelems-j,LOOPCNT);
#line 2928
    if (realign) {
#line 2928
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2928
      xp = tmp;
#line 2928
    } else {
#line 2928
      xp = (ushort *) *xpp;
#line 2928
    }
#line 2928
   /* copy the next block */
#line 2928
#pragma cdir loopcnt=LOOPCNT
#line 2928
#pragma cdir shortloop
#line 2928
    for (i=0; i<ni; i++) {
#line 2928
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2928
     /* test for range errors (not always needed but do it anyway) */
#line 2928
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2928
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2928
      nrange += xp[i] > DOUBLE_MAX ;
#line 2928
    }
#line 2928
   /* update xpp and tp */
#line 2928
    if (realign) xp = (ushort *) *xpp;
#line 2928
    xp += ni;
#line 2928
    tp += ni;
#line 2928
    *xpp = (void*)xp;
#line 2928
  }
#line 2928
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2928

#line 2928
#else   /* not SX */
#line 2928
	const char *xp = (const char *) *xpp;
#line 2928
	int status = ENOERR;
#line 2928

#line 2928
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2928
	{
#line 2928
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 2928
		if(lstatus != ENOERR)
#line 2928
			status = lstatus;
#line 2928
	}
#line 2928

#line 2928
	*xpp = (const void *)xp;
#line 2928
	return status;
#line 2928
#  endif
#line 2928
}
#line 2928

int
#line 2929
ncx_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2929
{
#line 2929
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2929

#line 2929
 /* basic algorithm is:
#line 2929
  *   - ensure sane alignment of input data
#line 2929
  *   - copy (conversion happens automatically) input data
#line 2929
  *     to output
#line 2929
  *   - update xpp to point at next unconverted input, and tp to point
#line 2929
  *     at next location for converted output
#line 2929
  */
#line 2929
  long i, j, ni;
#line 2929
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2929
  ushort *xp;
#line 2929
  int nrange = 0;         /* number of range errors */
#line 2929
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2929
  long cxp = (long) *((char**)xpp);
#line 2929

#line 2929
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2929
  /* sjl: manually stripmine so we can limit amount of
#line 2929
   * vector work space reserved to LOOPCNT elements. Also
#line 2929
   * makes vectorisation easy */
#line 2929
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2929
    ni=Min(nelems-j,LOOPCNT);
#line 2929
    if (realign) {
#line 2929
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2929
      xp = tmp;
#line 2929
    } else {
#line 2929
      xp = (ushort *) *xpp;
#line 2929
    }
#line 2929
   /* copy the next block */
#line 2929
#pragma cdir loopcnt=LOOPCNT
#line 2929
#pragma cdir shortloop
#line 2929
    for (i=0; i<ni; i++) {
#line 2929
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2929
     /* test for range errors (not always needed but do it anyway) */
#line 2929
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2929
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2929
      nrange += xp[i] > LONGLONG_MAX ;
#line 2929
    }
#line 2929
   /* update xpp and tp */
#line 2929
    if (realign) xp = (ushort *) *xpp;
#line 2929
    xp += ni;
#line 2929
    tp += ni;
#line 2929
    *xpp = (void*)xp;
#line 2929
  }
#line 2929
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2929

#line 2929
#else   /* not SX */
#line 2929
	const char *xp = (const char *) *xpp;
#line 2929
	int status = ENOERR;
#line 2929

#line 2929
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2929
	{
#line 2929
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 2929
		if(lstatus != ENOERR)
#line 2929
			status = lstatus;
#line 2929
	}
#line 2929

#line 2929
	*xpp = (const void *)xp;
#line 2929
	return status;
#line 2929
#  endif
#line 2929
}
#line 2929

int
#line 2930
ncx_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2930
{
#line 2930
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2930

#line 2930
 /* basic algorithm is:
#line 2930
  *   - ensure sane alignment of input data
#line 2930
  *   - copy (conversion happens automatically) input data
#line 2930
  *     to output
#line 2930
  *   - update xpp to point at next unconverted input, and tp to point
#line 2930
  *     at next location for converted output
#line 2930
  */
#line 2930
  long i, j, ni;
#line 2930
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2930
  ushort *xp;
#line 2930
  int nrange = 0;         /* number of range errors */
#line 2930
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2930
  long cxp = (long) *((char**)xpp);
#line 2930

#line 2930
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2930
  /* sjl: manually stripmine so we can limit amount of
#line 2930
   * vector work space reserved to LOOPCNT elements. Also
#line 2930
   * makes vectorisation easy */
#line 2930
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2930
    ni=Min(nelems-j,LOOPCNT);
#line 2930
    if (realign) {
#line 2930
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2930
      xp = tmp;
#line 2930
    } else {
#line 2930
      xp = (ushort *) *xpp;
#line 2930
    }
#line 2930
   /* copy the next block */
#line 2930
#pragma cdir loopcnt=LOOPCNT
#line 2930
#pragma cdir shortloop
#line 2930
    for (i=0; i<ni; i++) {
#line 2930
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2930
     /* test for range errors (not always needed but do it anyway) */
#line 2930
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2930
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2930
      nrange += xp[i] > UCHAR_MAX ;
#line 2930
    }
#line 2930
   /* update xpp and tp */
#line 2930
    if (realign) xp = (ushort *) *xpp;
#line 2930
    xp += ni;
#line 2930
    tp += ni;
#line 2930
    *xpp = (void*)xp;
#line 2930
  }
#line 2930
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2930

#line 2930
#else   /* not SX */
#line 2930
	const char *xp = (const char *) *xpp;
#line 2930
	int status = ENOERR;
#line 2930

#line 2930
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2930
	{
#line 2930
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 2930
		if(lstatus != ENOERR)
#line 2930
			status = lstatus;
#line 2930
	}
#line 2930

#line 2930
	*xpp = (const void *)xp;
#line 2930
	return status;
#line 2930
#  endif
#line 2930
}
#line 2930

int
#line 2931
ncx_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 2931
{
#line 2931
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2931

#line 2931
 /* basic algorithm is:
#line 2931
  *   - ensure sane alignment of input data
#line 2931
  *   - copy (conversion happens automatically) input data
#line 2931
  *     to output
#line 2931
  *   - update xpp to point at next unconverted input, and tp to point
#line 2931
  *     at next location for converted output
#line 2931
  */
#line 2931
  long i, j, ni;
#line 2931
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2931
  ushort *xp;
#line 2931
  int nrange = 0;         /* number of range errors */
#line 2931
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2931
  long cxp = (long) *((char**)xpp);
#line 2931

#line 2931
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2931
  /* sjl: manually stripmine so we can limit amount of
#line 2931
   * vector work space reserved to LOOPCNT elements. Also
#line 2931
   * makes vectorisation easy */
#line 2931
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2931
    ni=Min(nelems-j,LOOPCNT);
#line 2931
    if (realign) {
#line 2931
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2931
      xp = tmp;
#line 2931
    } else {
#line 2931
      xp = (ushort *) *xpp;
#line 2931
    }
#line 2931
   /* copy the next block */
#line 2931
#pragma cdir loopcnt=LOOPCNT
#line 2931
#pragma cdir shortloop
#line 2931
    for (i=0; i<ni; i++) {
#line 2931
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2931
     /* test for range errors (not always needed but do it anyway) */
#line 2931
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2931
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2931
      nrange += xp[i] > UINT_MAX ;
#line 2931
    }
#line 2931
   /* update xpp and tp */
#line 2931
    if (realign) xp = (ushort *) *xpp;
#line 2931
    xp += ni;
#line 2931
    tp += ni;
#line 2931
    *xpp = (void*)xp;
#line 2931
  }
#line 2931
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2931

#line 2931
#else   /* not SX */
#line 2931
	const char *xp = (const char *) *xpp;
#line 2931
	int status = ENOERR;
#line 2931

#line 2931
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2931
	{
#line 2931
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 2931
		if(lstatus != ENOERR)
#line 2931
			status = lstatus;
#line 2931
	}
#line 2931

#line 2931
	*xpp = (const void *)xp;
#line 2931
	return status;
#line 2931
#  endif
#line 2931
}
#line 2931

int
#line 2932
ncx_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2932
{
#line 2932
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2932

#line 2932
 /* basic algorithm is:
#line 2932
  *   - ensure sane alignment of input data
#line 2932
  *   - copy (conversion happens automatically) input data
#line 2932
  *     to output
#line 2932
  *   - update xpp to point at next unconverted input, and tp to point
#line 2932
  *     at next location for converted output
#line 2932
  */
#line 2932
  long i, j, ni;
#line 2932
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2932
  ushort *xp;
#line 2932
  int nrange = 0;         /* number of range errors */
#line 2932
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2932
  long cxp = (long) *((char**)xpp);
#line 2932

#line 2932
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2932
  /* sjl: manually stripmine so we can limit amount of
#line 2932
   * vector work space reserved to LOOPCNT elements. Also
#line 2932
   * makes vectorisation easy */
#line 2932
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2932
    ni=Min(nelems-j,LOOPCNT);
#line 2932
    if (realign) {
#line 2932
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2932
      xp = tmp;
#line 2932
    } else {
#line 2932
      xp = (ushort *) *xpp;
#line 2932
    }
#line 2932
   /* copy the next block */
#line 2932
#pragma cdir loopcnt=LOOPCNT
#line 2932
#pragma cdir shortloop
#line 2932
    for (i=0; i<ni; i++) {
#line 2932
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2932
     /* test for range errors (not always needed but do it anyway) */
#line 2932
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2932
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2932
      nrange += xp[i] > ULONGLONG_MAX ;
#line 2932
    }
#line 2932
   /* update xpp and tp */
#line 2932
    if (realign) xp = (ushort *) *xpp;
#line 2932
    xp += ni;
#line 2932
    tp += ni;
#line 2932
    *xpp = (void*)xp;
#line 2932
  }
#line 2932
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2932

#line 2932
#else   /* not SX */
#line 2932
	const char *xp = (const char *) *xpp;
#line 2932
	int status = ENOERR;
#line 2932

#line 2932
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2932
	{
#line 2932
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 2932
		if(lstatus != ENOERR)
#line 2932
			status = lstatus;
#line 2932
	}
#line 2932

#line 2932
	*xpp = (const void *)xp;
#line 2932
	return status;
#line 2932
#  endif
#line 2932
}
#line 2932


int
#line 2934
ncx_pad_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 2934
{
#line 2934
	const size_t rndup = nelems % 2;
#line 2934

#line 2934
	const char *xp = (const char *) *xpp;
#line 2934
	int status = ENOERR;
#line 2934

#line 2934
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2934
	{
#line 2934
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 2934
		if(lstatus != ENOERR)
#line 2934
			status = lstatus;
#line 2934
	}
#line 2934

#line 2934
	if(rndup != 0)
#line 2934
		xp += X_SIZEOF_USHORT;
#line 2934
		
#line 2934
	*xpp = (void *)xp;
#line 2934
	return status;
#line 2934
}
#line 2934

int
#line 2935
ncx_pad_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2935
{
#line 2935
	const size_t rndup = nelems % 2;
#line 2935

#line 2935
	const char *xp = (const char *) *xpp;
#line 2935
	int status = ENOERR;
#line 2935

#line 2935
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2935
	{
#line 2935
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 2935
		if(lstatus != ENOERR)
#line 2935
			status = lstatus;
#line 2935
	}
#line 2935

#line 2935
	if(rndup != 0)
#line 2935
		xp += X_SIZEOF_USHORT;
#line 2935
		
#line 2935
	*xpp = (void *)xp;
#line 2935
	return status;
#line 2935
}
#line 2935

int
#line 2936
ncx_pad_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 2936
{
#line 2936
	const size_t rndup = nelems % 2;
#line 2936

#line 2936
	const char *xp = (const char *) *xpp;
#line 2936
	int status = ENOERR;
#line 2936

#line 2936
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2936
	{
#line 2936
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 2936
		if(lstatus != ENOERR)
#line 2936
			status = lstatus;
#line 2936
	}
#line 2936

#line 2936
	if(rndup != 0)
#line 2936
		xp += X_SIZEOF_USHORT;
#line 2936
		
#line 2936
	*xpp = (void *)xp;
#line 2936
	return status;
#line 2936
}
#line 2936

int
#line 2937
ncx_pad_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2937
{
#line 2937
	const size_t rndup = nelems % 2;
#line 2937

#line 2937
	const char *xp = (const char *) *xpp;
#line 2937
	int status = ENOERR;
#line 2937

#line 2937
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2937
	{
#line 2937
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 2937
		if(lstatus != ENOERR)
#line 2937
			status = lstatus;
#line 2937
	}
#line 2937

#line 2937
	if(rndup != 0)
#line 2937
		xp += X_SIZEOF_USHORT;
#line 2937
		
#line 2937
	*xpp = (void *)xp;
#line 2937
	return status;
#line 2937
}
#line 2937

int
#line 2938
ncx_pad_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 2938
{
#line 2938
	const size_t rndup = nelems % 2;
#line 2938

#line 2938
	const char *xp = (const char *) *xpp;
#line 2938
	int status = ENOERR;
#line 2938

#line 2938
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2938
	{
#line 2938
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 2938
		if(lstatus != ENOERR)
#line 2938
			status = lstatus;
#line 2938
	}
#line 2938

#line 2938
	if(rndup != 0)
#line 2938
		xp += X_SIZEOF_USHORT;
#line 2938
		
#line 2938
	*xpp = (void *)xp;
#line 2938
	return status;
#line 2938
}
#line 2938

int
#line 2939
ncx_pad_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 2939
{
#line 2939
	const size_t rndup = nelems % 2;
#line 2939

#line 2939
	const char *xp = (const char *) *xpp;
#line 2939
	int status = ENOERR;
#line 2939

#line 2939
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2939
	{
#line 2939
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 2939
		if(lstatus != ENOERR)
#line 2939
			status = lstatus;
#line 2939
	}
#line 2939

#line 2939
	if(rndup != 0)
#line 2939
		xp += X_SIZEOF_USHORT;
#line 2939
		
#line 2939
	*xpp = (void *)xp;
#line 2939
	return status;
#line 2939
}
#line 2939

int
#line 2940
ncx_pad_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 2940
{
#line 2940
	const size_t rndup = nelems % 2;
#line 2940

#line 2940
	const char *xp = (const char *) *xpp;
#line 2940
	int status = ENOERR;
#line 2940

#line 2940
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2940
	{
#line 2940
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 2940
		if(lstatus != ENOERR)
#line 2940
			status = lstatus;
#line 2940
	}
#line 2940

#line 2940
	if(rndup != 0)
#line 2940
		xp += X_SIZEOF_USHORT;
#line 2940
		
#line 2940
	*xpp = (void *)xp;
#line 2940
	return status;
#line 2940
}
#line 2940

int
#line 2941
ncx_pad_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 2941
{
#line 2941
	const size_t rndup = nelems % 2;
#line 2941

#line 2941
	const char *xp = (const char *) *xpp;
#line 2941
	int status = ENOERR;
#line 2941

#line 2941
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2941
	{
#line 2941
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 2941
		if(lstatus != ENOERR)
#line 2941
			status = lstatus;
#line 2941
	}
#line 2941

#line 2941
	if(rndup != 0)
#line 2941
		xp += X_SIZEOF_USHORT;
#line 2941
		
#line 2941
	*xpp = (void *)xp;
#line 2941
	return status;
#line 2941
}
#line 2941

int
#line 2942
ncx_pad_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2942
{
#line 2942
	const size_t rndup = nelems % 2;
#line 2942

#line 2942
	const char *xp = (const char *) *xpp;
#line 2942
	int status = ENOERR;
#line 2942

#line 2942
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2942
	{
#line 2942
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 2942
		if(lstatus != ENOERR)
#line 2942
			status = lstatus;
#line 2942
	}
#line 2942

#line 2942
	if(rndup != 0)
#line 2942
		xp += X_SIZEOF_USHORT;
#line 2942
		
#line 2942
	*xpp = (void *)xp;
#line 2942
	return status;
#line 2942
}
#line 2942

int
#line 2943
ncx_pad_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2943
{
#line 2943
	const size_t rndup = nelems % 2;
#line 2943

#line 2943
	const char *xp = (const char *) *xpp;
#line 2943
	int status = ENOERR;
#line 2943

#line 2943
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2943
	{
#line 2943
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 2943
		if(lstatus != ENOERR)
#line 2943
			status = lstatus;
#line 2943
	}
#line 2943

#line 2943
	if(rndup != 0)
#line 2943
		xp += X_SIZEOF_USHORT;
#line 2943
		
#line 2943
	*xpp = (void *)xp;
#line 2943
	return status;
#line 2943
}
#line 2943


#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const unsigned short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_USHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return ENOERR;
}
#else
int
#line 2959
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2959
{
#line 2959
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2959

#line 2959
 /* basic algorithm is:
#line 2959
  *   - ensure sane alignment of output data
#line 2959
  *   - copy (conversion happens automatically) input data
#line 2959
  *     to output
#line 2959
  *   - update tp to point at next unconverted input, and xpp to point
#line 2959
  *     at next location for converted output
#line 2959
  */
#line 2959
  long i, j, ni;
#line 2959
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2959
  ushort *xp;
#line 2959
  int nrange = 0;         /* number of range errors */
#line 2959
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2959
  long cxp = (long) *((char**)xpp);
#line 2959

#line 2959
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2959
  /* sjl: manually stripmine so we can limit amount of
#line 2959
   * vector work space reserved to LOOPCNT elements. Also
#line 2959
   * makes vectorisation easy */
#line 2959
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2959
    ni=Min(nelems-j,LOOPCNT);
#line 2959
    if (realign) {
#line 2959
      xp = tmp;
#line 2959
    } else {
#line 2959
      xp = (ushort *) *xpp;
#line 2959
    }
#line 2959
   /* copy the next block */
#line 2959
#pragma cdir loopcnt=LOOPCNT
#line 2959
#pragma cdir shortloop
#line 2959
    for (i=0; i<ni; i++) {
#line 2959
      /* the normal case: */
#line 2959
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2959
     /* test for range errors (not always needed but do it anyway) */
#line 2959
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2959
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2959
      nrange += tp[i] > X_USHORT_MAX ;
#line 2959
    }
#line 2959
   /* copy workspace back if necessary */
#line 2959
    if (realign) {
#line 2959
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2959
      xp = (ushort *) *xpp;
#line 2959
    }
#line 2959
   /* update xpp and tp */
#line 2959
    xp += ni;
#line 2959
    tp += ni;
#line 2959
    *xpp = (void*)xp;
#line 2959
  }
#line 2959
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2959

#line 2959
#else   /* not SX */
#line 2959

#line 2959
	char *xp = (char *) *xpp;
#line 2959
	int status = ENOERR;
#line 2959

#line 2959
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2959
	{
#line 2959
		int lstatus = ncx_put_ushort_ushort(xp, tp);
#line 2959
		if(lstatus != ENOERR)
#line 2959
			status = lstatus;
#line 2959
	}
#line 2959

#line 2959
	*xpp = (void *)xp;
#line 2959
	return status;
#line 2959
#endif
#line 2959
}
#line 2959

#endif
int
#line 2961
ncx_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp)
#line 2961
{
#line 2961
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2961

#line 2961
 /* basic algorithm is:
#line 2961
  *   - ensure sane alignment of output data
#line 2961
  *   - copy (conversion happens automatically) input data
#line 2961
  *     to output
#line 2961
  *   - update tp to point at next unconverted input, and xpp to point
#line 2961
  *     at next location for converted output
#line 2961
  */
#line 2961
  long i, j, ni;
#line 2961
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2961
  ushort *xp;
#line 2961
  int nrange = 0;         /* number of range errors */
#line 2961
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2961
  long cxp = (long) *((char**)xpp);
#line 2961

#line 2961
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2961
  /* sjl: manually stripmine so we can limit amount of
#line 2961
   * vector work space reserved to LOOPCNT elements. Also
#line 2961
   * makes vectorisation easy */
#line 2961
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2961
    ni=Min(nelems-j,LOOPCNT);
#line 2961
    if (realign) {
#line 2961
      xp = tmp;
#line 2961
    } else {
#line 2961
      xp = (ushort *) *xpp;
#line 2961
    }
#line 2961
   /* copy the next block */
#line 2961
#pragma cdir loopcnt=LOOPCNT
#line 2961
#pragma cdir shortloop
#line 2961
    for (i=0; i<ni; i++) {
#line 2961
      /* the normal case: */
#line 2961
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2961
     /* test for range errors (not always needed but do it anyway) */
#line 2961
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2961
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2961
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2961
    }
#line 2961
   /* copy workspace back if necessary */
#line 2961
    if (realign) {
#line 2961
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2961
      xp = (ushort *) *xpp;
#line 2961
    }
#line 2961
   /* update xpp and tp */
#line 2961
    xp += ni;
#line 2961
    tp += ni;
#line 2961
    *xpp = (void*)xp;
#line 2961
  }
#line 2961
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2961

#line 2961
#else   /* not SX */
#line 2961

#line 2961
	char *xp = (char *) *xpp;
#line 2961
	int status = ENOERR;
#line 2961

#line 2961
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2961
	{
#line 2961
		int lstatus = ncx_put_ushort_schar(xp, tp);
#line 2961
		if(lstatus != ENOERR)
#line 2961
			status = lstatus;
#line 2961
	}
#line 2961

#line 2961
	*xpp = (void *)xp;
#line 2961
	return status;
#line 2961
#endif
#line 2961
}
#line 2961

int
#line 2962
ncx_putn_ushort_short(void **xpp, size_t nelems, const short *tp)
#line 2962
{
#line 2962
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2962

#line 2962
 /* basic algorithm is:
#line 2962
  *   - ensure sane alignment of output data
#line 2962
  *   - copy (conversion happens automatically) input data
#line 2962
  *     to output
#line 2962
  *   - update tp to point at next unconverted input, and xpp to point
#line 2962
  *     at next location for converted output
#line 2962
  */
#line 2962
  long i, j, ni;
#line 2962
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2962
  ushort *xp;
#line 2962
  int nrange = 0;         /* number of range errors */
#line 2962
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2962
  long cxp = (long) *((char**)xpp);
#line 2962

#line 2962
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2962
  /* sjl: manually stripmine so we can limit amount of
#line 2962
   * vector work space reserved to LOOPCNT elements. Also
#line 2962
   * makes vectorisation easy */
#line 2962
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2962
    ni=Min(nelems-j,LOOPCNT);
#line 2962
    if (realign) {
#line 2962
      xp = tmp;
#line 2962
    } else {
#line 2962
      xp = (ushort *) *xpp;
#line 2962
    }
#line 2962
   /* copy the next block */
#line 2962
#pragma cdir loopcnt=LOOPCNT
#line 2962
#pragma cdir shortloop
#line 2962
    for (i=0; i<ni; i++) {
#line 2962
      /* the normal case: */
#line 2962
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2962
     /* test for range errors (not always needed but do it anyway) */
#line 2962
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2962
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2962
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2962
    }
#line 2962
   /* copy workspace back if necessary */
#line 2962
    if (realign) {
#line 2962
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2962
      xp = (ushort *) *xpp;
#line 2962
    }
#line 2962
   /* update xpp and tp */
#line 2962
    xp += ni;
#line 2962
    tp += ni;
#line 2962
    *xpp = (void*)xp;
#line 2962
  }
#line 2962
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2962

#line 2962
#else   /* not SX */
#line 2962

#line 2962
	char *xp = (char *) *xpp;
#line 2962
	int status = ENOERR;
#line 2962

#line 2962
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2962
	{
#line 2962
		int lstatus = ncx_put_ushort_short(xp, tp);
#line 2962
		if(lstatus != ENOERR)
#line 2962
			status = lstatus;
#line 2962
	}
#line 2962

#line 2962
	*xpp = (void *)xp;
#line 2962
	return status;
#line 2962
#endif
#line 2962
}
#line 2962

int
#line 2963
ncx_putn_ushort_int(void **xpp, size_t nelems, const int *tp)
#line 2963
{
#line 2963
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2963

#line 2963
 /* basic algorithm is:
#line 2963
  *   - ensure sane alignment of output data
#line 2963
  *   - copy (conversion happens automatically) input data
#line 2963
  *     to output
#line 2963
  *   - update tp to point at next unconverted input, and xpp to point
#line 2963
  *     at next location for converted output
#line 2963
  */
#line 2963
  long i, j, ni;
#line 2963
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2963
  ushort *xp;
#line 2963
  int nrange = 0;         /* number of range errors */
#line 2963
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2963
  long cxp = (long) *((char**)xpp);
#line 2963

#line 2963
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2963
  /* sjl: manually stripmine so we can limit amount of
#line 2963
   * vector work space reserved to LOOPCNT elements. Also
#line 2963
   * makes vectorisation easy */
#line 2963
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2963
    ni=Min(nelems-j,LOOPCNT);
#line 2963
    if (realign) {
#line 2963
      xp = tmp;
#line 2963
    } else {
#line 2963
      xp = (ushort *) *xpp;
#line 2963
    }
#line 2963
   /* copy the next block */
#line 2963
#pragma cdir loopcnt=LOOPCNT
#line 2963
#pragma cdir shortloop
#line 2963
    for (i=0; i<ni; i++) {
#line 2963
      /* the normal case: */
#line 2963
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2963
     /* test for range errors (not always needed but do it anyway) */
#line 2963
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2963
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2963
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2963
    }
#line 2963
   /* copy workspace back if necessary */
#line 2963
    if (realign) {
#line 2963
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2963
      xp = (ushort *) *xpp;
#line 2963
    }
#line 2963
   /* update xpp and tp */
#line 2963
    xp += ni;
#line 2963
    tp += ni;
#line 2963
    *xpp = (void*)xp;
#line 2963
  }
#line 2963
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2963

#line 2963
#else   /* not SX */
#line 2963

#line 2963
	char *xp = (char *) *xpp;
#line 2963
	int status = ENOERR;
#line 2963

#line 2963
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2963
	{
#line 2963
		int lstatus = ncx_put_ushort_int(xp, tp);
#line 2963
		if(lstatus != ENOERR)
#line 2963
			status = lstatus;
#line 2963
	}
#line 2963

#line 2963
	*xpp = (void *)xp;
#line 2963
	return status;
#line 2963
#endif
#line 2963
}
#line 2963

int
#line 2964
ncx_putn_ushort_float(void **xpp, size_t nelems, const float *tp)
#line 2964
{
#line 2964
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2964

#line 2964
 /* basic algorithm is:
#line 2964
  *   - ensure sane alignment of output data
#line 2964
  *   - copy (conversion happens automatically) input data
#line 2964
  *     to output
#line 2964
  *   - update tp to point at next unconverted input, and xpp to point
#line 2964
  *     at next location for converted output
#line 2964
  */
#line 2964
  long i, j, ni;
#line 2964
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2964
  ushort *xp;
#line 2964
  int nrange = 0;         /* number of range errors */
#line 2964
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2964
  long cxp = (long) *((char**)xpp);
#line 2964

#line 2964
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2964
  /* sjl: manually stripmine so we can limit amount of
#line 2964
   * vector work space reserved to LOOPCNT elements. Also
#line 2964
   * makes vectorisation easy */
#line 2964
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2964
    ni=Min(nelems-j,LOOPCNT);
#line 2964
    if (realign) {
#line 2964
      xp = tmp;
#line 2964
    } else {
#line 2964
      xp = (ushort *) *xpp;
#line 2964
    }
#line 2964
   /* copy the next block */
#line 2964
#pragma cdir loopcnt=LOOPCNT
#line 2964
#pragma cdir shortloop
#line 2964
    for (i=0; i<ni; i++) {
#line 2964
      /* the normal case: */
#line 2964
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2964
     /* test for range errors (not always needed but do it anyway) */
#line 2964
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2964
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2964
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2964
    }
#line 2964
   /* copy workspace back if necessary */
#line 2964
    if (realign) {
#line 2964
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2964
      xp = (ushort *) *xpp;
#line 2964
    }
#line 2964
   /* update xpp and tp */
#line 2964
    xp += ni;
#line 2964
    tp += ni;
#line 2964
    *xpp = (void*)xp;
#line 2964
  }
#line 2964
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2964

#line 2964
#else   /* not SX */
#line 2964

#line 2964
	char *xp = (char *) *xpp;
#line 2964
	int status = ENOERR;
#line 2964

#line 2964
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2964
	{
#line 2964
		int lstatus = ncx_put_ushort_float(xp, tp);
#line 2964
		if(lstatus != ENOERR)
#line 2964
			status = lstatus;
#line 2964
	}
#line 2964

#line 2964
	*xpp = (void *)xp;
#line 2964
	return status;
#line 2964
#endif
#line 2964
}
#line 2964

int
#line 2965
ncx_putn_ushort_double(void **xpp, size_t nelems, const double *tp)
#line 2965
{
#line 2965
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2965

#line 2965
 /* basic algorithm is:
#line 2965
  *   - ensure sane alignment of output data
#line 2965
  *   - copy (conversion happens automatically) input data
#line 2965
  *     to output
#line 2965
  *   - update tp to point at next unconverted input, and xpp to point
#line 2965
  *     at next location for converted output
#line 2965
  */
#line 2965
  long i, j, ni;
#line 2965
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2965
  ushort *xp;
#line 2965
  int nrange = 0;         /* number of range errors */
#line 2965
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2965
  long cxp = (long) *((char**)xpp);
#line 2965

#line 2965
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2965
  /* sjl: manually stripmine so we can limit amount of
#line 2965
   * vector work space reserved to LOOPCNT elements. Also
#line 2965
   * makes vectorisation easy */
#line 2965
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2965
    ni=Min(nelems-j,LOOPCNT);
#line 2965
    if (realign) {
#line 2965
      xp = tmp;
#line 2965
    } else {
#line 2965
      xp = (ushort *) *xpp;
#line 2965
    }
#line 2965
   /* copy the next block */
#line 2965
#pragma cdir loopcnt=LOOPCNT
#line 2965
#pragma cdir shortloop
#line 2965
    for (i=0; i<ni; i++) {
#line 2965
      /* the normal case: */
#line 2965
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2965
     /* test for range errors (not always needed but do it anyway) */
#line 2965
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2965
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2965
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2965
    }
#line 2965
   /* copy workspace back if necessary */
#line 2965
    if (realign) {
#line 2965
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2965
      xp = (ushort *) *xpp;
#line 2965
    }
#line 2965
   /* update xpp and tp */
#line 2965
    xp += ni;
#line 2965
    tp += ni;
#line 2965
    *xpp = (void*)xp;
#line 2965
  }
#line 2965
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2965

#line 2965
#else   /* not SX */
#line 2965

#line 2965
	char *xp = (char *) *xpp;
#line 2965
	int status = ENOERR;
#line 2965

#line 2965
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2965
	{
#line 2965
		int lstatus = ncx_put_ushort_double(xp, tp);
#line 2965
		if(lstatus != ENOERR)
#line 2965
			status = lstatus;
#line 2965
	}
#line 2965

#line 2965
	*xpp = (void *)xp;
#line 2965
	return status;
#line 2965
#endif
#line 2965
}
#line 2965

int
#line 2966
ncx_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2966
{
#line 2966
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2966

#line 2966
 /* basic algorithm is:
#line 2966
  *   - ensure sane alignment of output data
#line 2966
  *   - copy (conversion happens automatically) input data
#line 2966
  *     to output
#line 2966
  *   - update tp to point at next unconverted input, and xpp to point
#line 2966
  *     at next location for converted output
#line 2966
  */
#line 2966
  long i, j, ni;
#line 2966
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2966
  ushort *xp;
#line 2966
  int nrange = 0;         /* number of range errors */
#line 2966
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2966
  long cxp = (long) *((char**)xpp);
#line 2966

#line 2966
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2966
  /* sjl: manually stripmine so we can limit amount of
#line 2966
   * vector work space reserved to LOOPCNT elements. Also
#line 2966
   * makes vectorisation easy */
#line 2966
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2966
    ni=Min(nelems-j,LOOPCNT);
#line 2966
    if (realign) {
#line 2966
      xp = tmp;
#line 2966
    } else {
#line 2966
      xp = (ushort *) *xpp;
#line 2966
    }
#line 2966
   /* copy the next block */
#line 2966
#pragma cdir loopcnt=LOOPCNT
#line 2966
#pragma cdir shortloop
#line 2966
    for (i=0; i<ni; i++) {
#line 2966
      /* the normal case: */
#line 2966
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2966
     /* test for range errors (not always needed but do it anyway) */
#line 2966
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2966
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2966
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2966
    }
#line 2966
   /* copy workspace back if necessary */
#line 2966
    if (realign) {
#line 2966
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2966
      xp = (ushort *) *xpp;
#line 2966
    }
#line 2966
   /* update xpp and tp */
#line 2966
    xp += ni;
#line 2966
    tp += ni;
#line 2966
    *xpp = (void*)xp;
#line 2966
  }
#line 2966
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2966

#line 2966
#else   /* not SX */
#line 2966

#line 2966
	char *xp = (char *) *xpp;
#line 2966
	int status = ENOERR;
#line 2966

#line 2966
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2966
	{
#line 2966
		int lstatus = ncx_put_ushort_longlong(xp, tp);
#line 2966
		if(lstatus != ENOERR)
#line 2966
			status = lstatus;
#line 2966
	}
#line 2966

#line 2966
	*xpp = (void *)xp;
#line 2966
	return status;
#line 2966
#endif
#line 2966
}
#line 2966

int
#line 2967
ncx_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2967
{
#line 2967
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2967

#line 2967
 /* basic algorithm is:
#line 2967
  *   - ensure sane alignment of output data
#line 2967
  *   - copy (conversion happens automatically) input data
#line 2967
  *     to output
#line 2967
  *   - update tp to point at next unconverted input, and xpp to point
#line 2967
  *     at next location for converted output
#line 2967
  */
#line 2967
  long i, j, ni;
#line 2967
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2967
  ushort *xp;
#line 2967
  int nrange = 0;         /* number of range errors */
#line 2967
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2967
  long cxp = (long) *((char**)xpp);
#line 2967

#line 2967
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2967
  /* sjl: manually stripmine so we can limit amount of
#line 2967
   * vector work space reserved to LOOPCNT elements. Also
#line 2967
   * makes vectorisation easy */
#line 2967
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2967
    ni=Min(nelems-j,LOOPCNT);
#line 2967
    if (realign) {
#line 2967
      xp = tmp;
#line 2967
    } else {
#line 2967
      xp = (ushort *) *xpp;
#line 2967
    }
#line 2967
   /* copy the next block */
#line 2967
#pragma cdir loopcnt=LOOPCNT
#line 2967
#pragma cdir shortloop
#line 2967
    for (i=0; i<ni; i++) {
#line 2967
      /* the normal case: */
#line 2967
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2967
     /* test for range errors (not always needed but do it anyway) */
#line 2967
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2967
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2967
      nrange += tp[i] > X_USHORT_MAX ;
#line 2967
    }
#line 2967
   /* copy workspace back if necessary */
#line 2967
    if (realign) {
#line 2967
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2967
      xp = (ushort *) *xpp;
#line 2967
    }
#line 2967
   /* update xpp and tp */
#line 2967
    xp += ni;
#line 2967
    tp += ni;
#line 2967
    *xpp = (void*)xp;
#line 2967
  }
#line 2967
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2967

#line 2967
#else   /* not SX */
#line 2967

#line 2967
	char *xp = (char *) *xpp;
#line 2967
	int status = ENOERR;
#line 2967

#line 2967
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2967
	{
#line 2967
		int lstatus = ncx_put_ushort_uchar(xp, tp);
#line 2967
		if(lstatus != ENOERR)
#line 2967
			status = lstatus;
#line 2967
	}
#line 2967

#line 2967
	*xpp = (void *)xp;
#line 2967
	return status;
#line 2967
#endif
#line 2967
}
#line 2967

int
#line 2968
ncx_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp)
#line 2968
{
#line 2968
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2968

#line 2968
 /* basic algorithm is:
#line 2968
  *   - ensure sane alignment of output data
#line 2968
  *   - copy (conversion happens automatically) input data
#line 2968
  *     to output
#line 2968
  *   - update tp to point at next unconverted input, and xpp to point
#line 2968
  *     at next location for converted output
#line 2968
  */
#line 2968
  long i, j, ni;
#line 2968
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2968
  ushort *xp;
#line 2968
  int nrange = 0;         /* number of range errors */
#line 2968
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2968
  long cxp = (long) *((char**)xpp);
#line 2968

#line 2968
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2968
  /* sjl: manually stripmine so we can limit amount of
#line 2968
   * vector work space reserved to LOOPCNT elements. Also
#line 2968
   * makes vectorisation easy */
#line 2968
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2968
    ni=Min(nelems-j,LOOPCNT);
#line 2968
    if (realign) {
#line 2968
      xp = tmp;
#line 2968
    } else {
#line 2968
      xp = (ushort *) *xpp;
#line 2968
    }
#line 2968
   /* copy the next block */
#line 2968
#pragma cdir loopcnt=LOOPCNT
#line 2968
#pragma cdir shortloop
#line 2968
    for (i=0; i<ni; i++) {
#line 2968
      /* the normal case: */
#line 2968
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2968
     /* test for range errors (not always needed but do it anyway) */
#line 2968
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2968
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2968
      nrange += tp[i] > X_USHORT_MAX ;
#line 2968
    }
#line 2968
   /* copy workspace back if necessary */
#line 2968
    if (realign) {
#line 2968
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2968
      xp = (ushort *) *xpp;
#line 2968
    }
#line 2968
   /* update xpp and tp */
#line 2968
    xp += ni;
#line 2968
    tp += ni;
#line 2968
    *xpp = (void*)xp;
#line 2968
  }
#line 2968
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2968

#line 2968
#else   /* not SX */
#line 2968

#line 2968
	char *xp = (char *) *xpp;
#line 2968
	int status = ENOERR;
#line 2968

#line 2968
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2968
	{
#line 2968
		int lstatus = ncx_put_ushort_uint(xp, tp);
#line 2968
		if(lstatus != ENOERR)
#line 2968
			status = lstatus;
#line 2968
	}
#line 2968

#line 2968
	*xpp = (void *)xp;
#line 2968
	return status;
#line 2968
#endif
#line 2968
}
#line 2968

int
#line 2969
ncx_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2969
{
#line 2969
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2969

#line 2969
 /* basic algorithm is:
#line 2969
  *   - ensure sane alignment of output data
#line 2969
  *   - copy (conversion happens automatically) input data
#line 2969
  *     to output
#line 2969
  *   - update tp to point at next unconverted input, and xpp to point
#line 2969
  *     at next location for converted output
#line 2969
  */
#line 2969
  long i, j, ni;
#line 2969
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2969
  ushort *xp;
#line 2969
  int nrange = 0;         /* number of range errors */
#line 2969
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2969
  long cxp = (long) *((char**)xpp);
#line 2969

#line 2969
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2969
  /* sjl: manually stripmine so we can limit amount of
#line 2969
   * vector work space reserved to LOOPCNT elements. Also
#line 2969
   * makes vectorisation easy */
#line 2969
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2969
    ni=Min(nelems-j,LOOPCNT);
#line 2969
    if (realign) {
#line 2969
      xp = tmp;
#line 2969
    } else {
#line 2969
      xp = (ushort *) *xpp;
#line 2969
    }
#line 2969
   /* copy the next block */
#line 2969
#pragma cdir loopcnt=LOOPCNT
#line 2969
#pragma cdir shortloop
#line 2969
    for (i=0; i<ni; i++) {
#line 2969
      /* the normal case: */
#line 2969
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2969
     /* test for range errors (not always needed but do it anyway) */
#line 2969
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2969
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2969
      nrange += tp[i] > X_USHORT_MAX ;
#line 2969
    }
#line 2969
   /* copy workspace back if necessary */
#line 2969
    if (realign) {
#line 2969
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2969
      xp = (ushort *) *xpp;
#line 2969
    }
#line 2969
   /* update xpp and tp */
#line 2969
    xp += ni;
#line 2969
    tp += ni;
#line 2969
    *xpp = (void*)xp;
#line 2969
  }
#line 2969
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2969

#line 2969
#else   /* not SX */
#line 2969

#line 2969
	char *xp = (char *) *xpp;
#line 2969
	int status = ENOERR;
#line 2969

#line 2969
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2969
	{
#line 2969
		int lstatus = ncx_put_ushort_ulonglong(xp, tp);
#line 2969
		if(lstatus != ENOERR)
#line 2969
			status = lstatus;
#line 2969
	}
#line 2969

#line 2969
	*xpp = (void *)xp;
#line 2969
	return status;
#line 2969
#endif
#line 2969
}
#line 2969


int
#line 2971
ncx_pad_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp)
#line 2971
{
#line 2971
	const size_t rndup = nelems % 2;
#line 2971

#line 2971
	char *xp = (char *) *xpp;
#line 2971
	int status = ENOERR;
#line 2971

#line 2971
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2971
	{
#line 2971
		int lstatus = ncx_put_ushort_schar(xp, tp);
#line 2971
		if(lstatus != ENOERR)
#line 2971
			status = lstatus;
#line 2971
	}
#line 2971

#line 2971
	if(rndup != 0)
#line 2971
	{
#line 2971
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2971
		xp += X_SIZEOF_USHORT;	
#line 2971
	}
#line 2971

#line 2971
	*xpp = (void *)xp;
#line 2971
	return status;
#line 2971
}
#line 2971

int
#line 2972
ncx_pad_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2972
{
#line 2972
	const size_t rndup = nelems % 2;
#line 2972

#line 2972
	char *xp = (char *) *xpp;
#line 2972
	int status = ENOERR;
#line 2972

#line 2972
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2972
	{
#line 2972
		int lstatus = ncx_put_ushort_uchar(xp, tp);
#line 2972
		if(lstatus != ENOERR)
#line 2972
			status = lstatus;
#line 2972
	}
#line 2972

#line 2972
	if(rndup != 0)
#line 2972
	{
#line 2972
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2972
		xp += X_SIZEOF_USHORT;	
#line 2972
	}
#line 2972

#line 2972
	*xpp = (void *)xp;
#line 2972
	return status;
#line 2972
}
#line 2972

int
#line 2973
ncx_pad_putn_ushort_short(void **xpp, size_t nelems, const short *tp)
#line 2973
{
#line 2973
	const size_t rndup = nelems % 2;
#line 2973

#line 2973
	char *xp = (char *) *xpp;
#line 2973
	int status = ENOERR;
#line 2973

#line 2973
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2973
	{
#line 2973
		int lstatus = ncx_put_ushort_short(xp, tp);
#line 2973
		if(lstatus != ENOERR)
#line 2973
			status = lstatus;
#line 2973
	}
#line 2973

#line 2973
	if(rndup != 0)
#line 2973
	{
#line 2973
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2973
		xp += X_SIZEOF_USHORT;	
#line 2973
	}
#line 2973

#line 2973
	*xpp = (void *)xp;
#line 2973
	return status;
#line 2973
}
#line 2973

int
#line 2974
ncx_pad_putn_ushort_int(void **xpp, size_t nelems, const int *tp)
#line 2974
{
#line 2974
	const size_t rndup = nelems % 2;
#line 2974

#line 2974
	char *xp = (char *) *xpp;
#line 2974
	int status = ENOERR;
#line 2974

#line 2974
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2974
	{
#line 2974
		int lstatus = ncx_put_ushort_int(xp, tp);
#line 2974
		if(lstatus != ENOERR)
#line 2974
			status = lstatus;
#line 2974
	}
#line 2974

#line 2974
	if(rndup != 0)
#line 2974
	{
#line 2974
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2974
		xp += X_SIZEOF_USHORT;	
#line 2974
	}
#line 2974

#line 2974
	*xpp = (void *)xp;
#line 2974
	return status;
#line 2974
}
#line 2974

int
#line 2975
ncx_pad_putn_ushort_float(void **xpp, size_t nelems, const float *tp)
#line 2975
{
#line 2975
	const size_t rndup = nelems % 2;
#line 2975

#line 2975
	char *xp = (char *) *xpp;
#line 2975
	int status = ENOERR;
#line 2975

#line 2975
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2975
	{
#line 2975
		int lstatus = ncx_put_ushort_float(xp, tp);
#line 2975
		if(lstatus != ENOERR)
#line 2975
			status = lstatus;
#line 2975
	}
#line 2975

#line 2975
	if(rndup != 0)
#line 2975
	{
#line 2975
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2975
		xp += X_SIZEOF_USHORT;	
#line 2975
	}
#line 2975

#line 2975
	*xpp = (void *)xp;
#line 2975
	return status;
#line 2975
}
#line 2975

int
#line 2976
ncx_pad_putn_ushort_double(void **xpp, size_t nelems, const double *tp)
#line 2976
{
#line 2976
	const size_t rndup = nelems % 2;
#line 2976

#line 2976
	char *xp = (char *) *xpp;
#line 2976
	int status = ENOERR;
#line 2976

#line 2976
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2976
	{
#line 2976
		int lstatus = ncx_put_ushort_double(xp, tp);
#line 2976
		if(lstatus != ENOERR)
#line 2976
			status = lstatus;
#line 2976
	}
#line 2976

#line 2976
	if(rndup != 0)
#line 2976
	{
#line 2976
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2976
		xp += X_SIZEOF_USHORT;	
#line 2976
	}
#line 2976

#line 2976
	*xpp = (void *)xp;
#line 2976
	return status;
#line 2976
}
#line 2976

int
#line 2977
ncx_pad_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp)
#line 2977
{
#line 2977
	const size_t rndup = nelems % 2;
#line 2977

#line 2977
	char *xp = (char *) *xpp;
#line 2977
	int status = ENOERR;
#line 2977

#line 2977
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2977
	{
#line 2977
		int lstatus = ncx_put_ushort_uint(xp, tp);
#line 2977
		if(lstatus != ENOERR)
#line 2977
			status = lstatus;
#line 2977
	}
#line 2977

#line 2977
	if(rndup != 0)
#line 2977
	{
#line 2977
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2977
		xp += X_SIZEOF_USHORT;	
#line 2977
	}
#line 2977

#line 2977
	*xpp = (void *)xp;
#line 2977
	return status;
#line 2977
}
#line 2977

int
#line 2978
ncx_pad_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2978
{
#line 2978
	const size_t rndup = nelems % 2;
#line 2978

#line 2978
	char *xp = (char *) *xpp;
#line 2978
	int status = ENOERR;
#line 2978

#line 2978
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2978
	{
#line 2978
		int lstatus = ncx_put_ushort_longlong(xp, tp);
#line 2978
		if(lstatus != ENOERR)
#line 2978
			status = lstatus;
#line 2978
	}
#line 2978

#line 2978
	if(rndup != 0)
#line 2978
	{
#line 2978
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2978
		xp += X_SIZEOF_USHORT;	
#line 2978
	}
#line 2978

#line 2978
	*xpp = (void *)xp;
#line 2978
	return status;
#line 2978
}
#line 2978

int
#line 2979
ncx_pad_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2979
{
#line 2979
	const size_t rndup = nelems % 2;
#line 2979

#line 2979
	char *xp = (char *) *xpp;
#line 2979
	int status = ENOERR;
#line 2979

#line 2979
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2979
	{
#line 2979
		int lstatus = ncx_put_ushort_ulonglong(xp, tp);
#line 2979
		if(lstatus != ENOERR)
#line 2979
			status = lstatus;
#line 2979
	}
#line 2979

#line 2979
	if(rndup != 0)
#line 2979
	{
#line 2979
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2979
		xp += X_SIZEOF_USHORT;	
#line 2979
	}
#line 2979

#line 2979
	*xpp = (void *)xp;
#line 2979
	return status;
#line 2979
}
#line 2979

int
#line 2980
ncx_pad_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2980
{
#line 2980
	const size_t rndup = nelems % 2;
#line 2980

#line 2980
	char *xp = (char *) *xpp;
#line 2980
	int status = ENOERR;
#line 2980

#line 2980
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2980
	{
#line 2980
		int lstatus = ncx_put_ushort_ushort(xp, tp);
#line 2980
		if(lstatus != ENOERR)
#line 2980
			status = lstatus;
#line 2980
	}
#line 2980

#line 2980
	if(rndup != 0)
#line 2980
	{
#line 2980
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2980
		xp += X_SIZEOF_USHORT;	
#line 2980
	}
#line 2980

#line 2980
	*xpp = (void *)xp;
#line 2980
	return status;
#line 2980
}
#line 2980



/* int -----------------------------------------------------------------------*/

#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(int));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
#else
int
#line 2999
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
#line 2999
{
#line 2999
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2999

#line 2999
 /* basic algorithm is:
#line 2999
  *   - ensure sane alignment of input data
#line 2999
  *   - copy (conversion happens automatically) input data
#line 2999
  *     to output
#line 2999
  *   - update xpp to point at next unconverted input, and tp to point
#line 2999
  *     at next location for converted output
#line 2999
  */
#line 2999
  long i, j, ni;
#line 2999
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2999
  int *xp;
#line 2999
  int nrange = 0;         /* number of range errors */
#line 2999
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2999
  long cxp = (long) *((char**)xpp);
#line 2999

#line 2999
  realign = (cxp & 7) % SIZEOF_INT;
#line 2999
  /* sjl: manually stripmine so we can limit amount of
#line 2999
   * vector work space reserved to LOOPCNT elements. Also
#line 2999
   * makes vectorisation easy */
#line 2999
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2999
    ni=Min(nelems-j,LOOPCNT);
#line 2999
    if (realign) {
#line 2999
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2999
      xp = tmp;
#line 2999
    } else {
#line 2999
      xp = (int *) *xpp;
#line 2999
    }
#line 2999
   /* copy the next block */
#line 2999
#pragma cdir loopcnt=LOOPCNT
#line 2999
#pragma cdir shortloop
#line 2999
    for (i=0; i<ni; i++) {
#line 2999
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2999
     /* test for range errors (not always needed but do it anyway) */
#line 2999
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2999
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2999
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 2999
    }
#line 2999
   /* update xpp and tp */
#line 2999
    if (realign) xp = (int *) *xpp;
#line 2999
    xp += ni;
#line 2999
    tp += ni;
#line 2999
    *xpp = (void*)xp;
#line 2999
  }
#line 2999
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2999

#line 2999
#else   /* not SX */
#line 2999
	const char *xp = (const char *) *xpp;
#line 2999
	int status = ENOERR;
#line 2999

#line 2999
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2999
	{
#line 2999
		const int lstatus = ncx_get_int_int(xp, tp);
#line 2999
		if(lstatus != ENOERR)
#line 2999
			status = lstatus;
#line 2999
	}
#line 2999

#line 2999
	*xpp = (const void *)xp;
#line 2999
	return status;
#line 2999
#  endif
#line 2999
}
#line 2999

#endif
int
#line 3001
ncx_getn_int_schar(const void **xpp, size_t nelems, schar *tp)
#line 3001
{
#line 3001
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3001

#line 3001
 /* basic algorithm is:
#line 3001
  *   - ensure sane alignment of input data
#line 3001
  *   - copy (conversion happens automatically) input data
#line 3001
  *     to output
#line 3001
  *   - update xpp to point at next unconverted input, and tp to point
#line 3001
  *     at next location for converted output
#line 3001
  */
#line 3001
  long i, j, ni;
#line 3001
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3001
  int *xp;
#line 3001
  int nrange = 0;         /* number of range errors */
#line 3001
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3001
  long cxp = (long) *((char**)xpp);
#line 3001

#line 3001
  realign = (cxp & 7) % SIZEOF_INT;
#line 3001
  /* sjl: manually stripmine so we can limit amount of
#line 3001
   * vector work space reserved to LOOPCNT elements. Also
#line 3001
   * makes vectorisation easy */
#line 3001
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3001
    ni=Min(nelems-j,LOOPCNT);
#line 3001
    if (realign) {
#line 3001
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3001
      xp = tmp;
#line 3001
    } else {
#line 3001
      xp = (int *) *xpp;
#line 3001
    }
#line 3001
   /* copy the next block */
#line 3001
#pragma cdir loopcnt=LOOPCNT
#line 3001
#pragma cdir shortloop
#line 3001
    for (i=0; i<ni; i++) {
#line 3001
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3001
     /* test for range errors (not always needed but do it anyway) */
#line 3001
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3001
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3001
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3001
    }
#line 3001
   /* update xpp and tp */
#line 3001
    if (realign) xp = (int *) *xpp;
#line 3001
    xp += ni;
#line 3001
    tp += ni;
#line 3001
    *xpp = (void*)xp;
#line 3001
  }
#line 3001
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3001

#line 3001
#else   /* not SX */
#line 3001
	const char *xp = (const char *) *xpp;
#line 3001
	int status = ENOERR;
#line 3001

#line 3001
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3001
	{
#line 3001
		const int lstatus = ncx_get_int_schar(xp, tp);
#line 3001
		if(lstatus != ENOERR)
#line 3001
			status = lstatus;
#line 3001
	}
#line 3001

#line 3001
	*xpp = (const void *)xp;
#line 3001
	return status;
#line 3001
#  endif
#line 3001
}
#line 3001

int
#line 3002
ncx_getn_int_short(const void **xpp, size_t nelems, short *tp)
#line 3002
{
#line 3002
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3002

#line 3002
 /* basic algorithm is:
#line 3002
  *   - ensure sane alignment of input data
#line 3002
  *   - copy (conversion happens automatically) input data
#line 3002
  *     to output
#line 3002
  *   - update xpp to point at next unconverted input, and tp to point
#line 3002
  *     at next location for converted output
#line 3002
  */
#line 3002
  long i, j, ni;
#line 3002
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3002
  int *xp;
#line 3002
  int nrange = 0;         /* number of range errors */
#line 3002
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3002
  long cxp = (long) *((char**)xpp);
#line 3002

#line 3002
  realign = (cxp & 7) % SIZEOF_INT;
#line 3002
  /* sjl: manually stripmine so we can limit amount of
#line 3002
   * vector work space reserved to LOOPCNT elements. Also
#line 3002
   * makes vectorisation easy */
#line 3002
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3002
    ni=Min(nelems-j,LOOPCNT);
#line 3002
    if (realign) {
#line 3002
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3002
      xp = tmp;
#line 3002
    } else {
#line 3002
      xp = (int *) *xpp;
#line 3002
    }
#line 3002
   /* copy the next block */
#line 3002
#pragma cdir loopcnt=LOOPCNT
#line 3002
#pragma cdir shortloop
#line 3002
    for (i=0; i<ni; i++) {
#line 3002
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3002
     /* test for range errors (not always needed but do it anyway) */
#line 3002
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3002
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3002
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3002
    }
#line 3002
   /* update xpp and tp */
#line 3002
    if (realign) xp = (int *) *xpp;
#line 3002
    xp += ni;
#line 3002
    tp += ni;
#line 3002
    *xpp = (void*)xp;
#line 3002
  }
#line 3002
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3002

#line 3002
#else   /* not SX */
#line 3002
	const char *xp = (const char *) *xpp;
#line 3002
	int status = ENOERR;
#line 3002

#line 3002
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3002
	{
#line 3002
		const int lstatus = ncx_get_int_short(xp, tp);
#line 3002
		if(lstatus != ENOERR)
#line 3002
			status = lstatus;
#line 3002
	}
#line 3002

#line 3002
	*xpp = (const void *)xp;
#line 3002
	return status;
#line 3002
#  endif
#line 3002
}
#line 3002

int
#line 3003
ncx_getn_int_float(const void **xpp, size_t nelems, float *tp)
#line 3003
{
#line 3003
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3003

#line 3003
 /* basic algorithm is:
#line 3003
  *   - ensure sane alignment of input data
#line 3003
  *   - copy (conversion happens automatically) input data
#line 3003
  *     to output
#line 3003
  *   - update xpp to point at next unconverted input, and tp to point
#line 3003
  *     at next location for converted output
#line 3003
  */
#line 3003
  long i, j, ni;
#line 3003
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3003
  int *xp;
#line 3003
  int nrange = 0;         /* number of range errors */
#line 3003
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3003
  long cxp = (long) *((char**)xpp);
#line 3003

#line 3003
  realign = (cxp & 7) % SIZEOF_INT;
#line 3003
  /* sjl: manually stripmine so we can limit amount of
#line 3003
   * vector work space reserved to LOOPCNT elements. Also
#line 3003
   * makes vectorisation easy */
#line 3003
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3003
    ni=Min(nelems-j,LOOPCNT);
#line 3003
    if (realign) {
#line 3003
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3003
      xp = tmp;
#line 3003
    } else {
#line 3003
      xp = (int *) *xpp;
#line 3003
    }
#line 3003
   /* copy the next block */
#line 3003
#pragma cdir loopcnt=LOOPCNT
#line 3003
#pragma cdir shortloop
#line 3003
    for (i=0; i<ni; i++) {
#line 3003
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3003
     /* test for range errors (not always needed but do it anyway) */
#line 3003
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3003
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3003
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3003
    }
#line 3003
   /* update xpp and tp */
#line 3003
    if (realign) xp = (int *) *xpp;
#line 3003
    xp += ni;
#line 3003
    tp += ni;
#line 3003
    *xpp = (void*)xp;
#line 3003
  }
#line 3003
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3003

#line 3003
#else   /* not SX */
#line 3003
	const char *xp = (const char *) *xpp;
#line 3003
	int status = ENOERR;
#line 3003

#line 3003
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3003
	{
#line 3003
		const int lstatus = ncx_get_int_float(xp, tp);
#line 3003
		if(lstatus != ENOERR)
#line 3003
			status = lstatus;
#line 3003
	}
#line 3003

#line 3003
	*xpp = (const void *)xp;
#line 3003
	return status;
#line 3003
#  endif
#line 3003
}
#line 3003

int
#line 3004
ncx_getn_int_double(const void **xpp, size_t nelems, double *tp)
#line 3004
{
#line 3004
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3004

#line 3004
 /* basic algorithm is:
#line 3004
  *   - ensure sane alignment of input data
#line 3004
  *   - copy (conversion happens automatically) input data
#line 3004
  *     to output
#line 3004
  *   - update xpp to point at next unconverted input, and tp to point
#line 3004
  *     at next location for converted output
#line 3004
  */
#line 3004
  long i, j, ni;
#line 3004
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3004
  int *xp;
#line 3004
  int nrange = 0;         /* number of range errors */
#line 3004
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3004
  long cxp = (long) *((char**)xpp);
#line 3004

#line 3004
  realign = (cxp & 7) % SIZEOF_INT;
#line 3004
  /* sjl: manually stripmine so we can limit amount of
#line 3004
   * vector work space reserved to LOOPCNT elements. Also
#line 3004
   * makes vectorisation easy */
#line 3004
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3004
    ni=Min(nelems-j,LOOPCNT);
#line 3004
    if (realign) {
#line 3004
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3004
      xp = tmp;
#line 3004
    } else {
#line 3004
      xp = (int *) *xpp;
#line 3004
    }
#line 3004
   /* copy the next block */
#line 3004
#pragma cdir loopcnt=LOOPCNT
#line 3004
#pragma cdir shortloop
#line 3004
    for (i=0; i<ni; i++) {
#line 3004
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3004
     /* test for range errors (not always needed but do it anyway) */
#line 3004
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3004
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3004
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3004
    }
#line 3004
   /* update xpp and tp */
#line 3004
    if (realign) xp = (int *) *xpp;
#line 3004
    xp += ni;
#line 3004
    tp += ni;
#line 3004
    *xpp = (void*)xp;
#line 3004
  }
#line 3004
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3004

#line 3004
#else   /* not SX */
#line 3004
	const char *xp = (const char *) *xpp;
#line 3004
	int status = ENOERR;
#line 3004

#line 3004
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3004
	{
#line 3004
		const int lstatus = ncx_get_int_double(xp, tp);
#line 3004
		if(lstatus != ENOERR)
#line 3004
			status = lstatus;
#line 3004
	}
#line 3004

#line 3004
	*xpp = (const void *)xp;
#line 3004
	return status;
#line 3004
#  endif
#line 3004
}
#line 3004

int
#line 3005
ncx_getn_int_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3005
{
#line 3005
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3005

#line 3005
 /* basic algorithm is:
#line 3005
  *   - ensure sane alignment of input data
#line 3005
  *   - copy (conversion happens automatically) input data
#line 3005
  *     to output
#line 3005
  *   - update xpp to point at next unconverted input, and tp to point
#line 3005
  *     at next location for converted output
#line 3005
  */
#line 3005
  long i, j, ni;
#line 3005
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3005
  int *xp;
#line 3005
  int nrange = 0;         /* number of range errors */
#line 3005
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3005
  long cxp = (long) *((char**)xpp);
#line 3005

#line 3005
  realign = (cxp & 7) % SIZEOF_INT;
#line 3005
  /* sjl: manually stripmine so we can limit amount of
#line 3005
   * vector work space reserved to LOOPCNT elements. Also
#line 3005
   * makes vectorisation easy */
#line 3005
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3005
    ni=Min(nelems-j,LOOPCNT);
#line 3005
    if (realign) {
#line 3005
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3005
      xp = tmp;
#line 3005
    } else {
#line 3005
      xp = (int *) *xpp;
#line 3005
    }
#line 3005
   /* copy the next block */
#line 3005
#pragma cdir loopcnt=LOOPCNT
#line 3005
#pragma cdir shortloop
#line 3005
    for (i=0; i<ni; i++) {
#line 3005
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3005
     /* test for range errors (not always needed but do it anyway) */
#line 3005
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3005
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3005
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3005
    }
#line 3005
   /* update xpp and tp */
#line 3005
    if (realign) xp = (int *) *xpp;
#line 3005
    xp += ni;
#line 3005
    tp += ni;
#line 3005
    *xpp = (void*)xp;
#line 3005
  }
#line 3005
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3005

#line 3005
#else   /* not SX */
#line 3005
	const char *xp = (const char *) *xpp;
#line 3005
	int status = ENOERR;
#line 3005

#line 3005
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3005
	{
#line 3005
		const int lstatus = ncx_get_int_longlong(xp, tp);
#line 3005
		if(lstatus != ENOERR)
#line 3005
			status = lstatus;
#line 3005
	}
#line 3005

#line 3005
	*xpp = (const void *)xp;
#line 3005
	return status;
#line 3005
#  endif
#line 3005
}
#line 3005

int
#line 3006
ncx_getn_int_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3006
{
#line 3006
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3006

#line 3006
 /* basic algorithm is:
#line 3006
  *   - ensure sane alignment of input data
#line 3006
  *   - copy (conversion happens automatically) input data
#line 3006
  *     to output
#line 3006
  *   - update xpp to point at next unconverted input, and tp to point
#line 3006
  *     at next location for converted output
#line 3006
  */
#line 3006
  long i, j, ni;
#line 3006
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3006
  int *xp;
#line 3006
  int nrange = 0;         /* number of range errors */
#line 3006
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3006
  long cxp = (long) *((char**)xpp);
#line 3006

#line 3006
  realign = (cxp & 7) % SIZEOF_INT;
#line 3006
  /* sjl: manually stripmine so we can limit amount of
#line 3006
   * vector work space reserved to LOOPCNT elements. Also
#line 3006
   * makes vectorisation easy */
#line 3006
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3006
    ni=Min(nelems-j,LOOPCNT);
#line 3006
    if (realign) {
#line 3006
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3006
      xp = tmp;
#line 3006
    } else {
#line 3006
      xp = (int *) *xpp;
#line 3006
    }
#line 3006
   /* copy the next block */
#line 3006
#pragma cdir loopcnt=LOOPCNT
#line 3006
#pragma cdir shortloop
#line 3006
    for (i=0; i<ni; i++) {
#line 3006
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3006
     /* test for range errors (not always needed but do it anyway) */
#line 3006
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3006
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3006
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3006
    }
#line 3006
   /* update xpp and tp */
#line 3006
    if (realign) xp = (int *) *xpp;
#line 3006
    xp += ni;
#line 3006
    tp += ni;
#line 3006
    *xpp = (void*)xp;
#line 3006
  }
#line 3006
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3006

#line 3006
#else   /* not SX */
#line 3006
	const char *xp = (const char *) *xpp;
#line 3006
	int status = ENOERR;
#line 3006

#line 3006
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3006
	{
#line 3006
		const int lstatus = ncx_get_int_uchar(xp, tp);
#line 3006
		if(lstatus != ENOERR)
#line 3006
			status = lstatus;
#line 3006
	}
#line 3006

#line 3006
	*xpp = (const void *)xp;
#line 3006
	return status;
#line 3006
#  endif
#line 3006
}
#line 3006

int
#line 3007
ncx_getn_int_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3007
{
#line 3007
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3007

#line 3007
 /* basic algorithm is:
#line 3007
  *   - ensure sane alignment of input data
#line 3007
  *   - copy (conversion happens automatically) input data
#line 3007
  *     to output
#line 3007
  *   - update xpp to point at next unconverted input, and tp to point
#line 3007
  *     at next location for converted output
#line 3007
  */
#line 3007
  long i, j, ni;
#line 3007
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3007
  int *xp;
#line 3007
  int nrange = 0;         /* number of range errors */
#line 3007
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3007
  long cxp = (long) *((char**)xpp);
#line 3007

#line 3007
  realign = (cxp & 7) % SIZEOF_INT;
#line 3007
  /* sjl: manually stripmine so we can limit amount of
#line 3007
   * vector work space reserved to LOOPCNT elements. Also
#line 3007
   * makes vectorisation easy */
#line 3007
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3007
    ni=Min(nelems-j,LOOPCNT);
#line 3007
    if (realign) {
#line 3007
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3007
      xp = tmp;
#line 3007
    } else {
#line 3007
      xp = (int *) *xpp;
#line 3007
    }
#line 3007
   /* copy the next block */
#line 3007
#pragma cdir loopcnt=LOOPCNT
#line 3007
#pragma cdir shortloop
#line 3007
    for (i=0; i<ni; i++) {
#line 3007
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3007
     /* test for range errors (not always needed but do it anyway) */
#line 3007
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3007
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3007
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3007
    }
#line 3007
   /* update xpp and tp */
#line 3007
    if (realign) xp = (int *) *xpp;
#line 3007
    xp += ni;
#line 3007
    tp += ni;
#line 3007
    *xpp = (void*)xp;
#line 3007
  }
#line 3007
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3007

#line 3007
#else   /* not SX */
#line 3007
	const char *xp = (const char *) *xpp;
#line 3007
	int status = ENOERR;
#line 3007

#line 3007
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3007
	{
#line 3007
		const int lstatus = ncx_get_int_ushort(xp, tp);
#line 3007
		if(lstatus != ENOERR)
#line 3007
			status = lstatus;
#line 3007
	}
#line 3007

#line 3007
	*xpp = (const void *)xp;
#line 3007
	return status;
#line 3007
#  endif
#line 3007
}
#line 3007

int
#line 3008
ncx_getn_int_uint(const void **xpp, size_t nelems, uint *tp)
#line 3008
{
#line 3008
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3008

#line 3008
 /* basic algorithm is:
#line 3008
  *   - ensure sane alignment of input data
#line 3008
  *   - copy (conversion happens automatically) input data
#line 3008
  *     to output
#line 3008
  *   - update xpp to point at next unconverted input, and tp to point
#line 3008
  *     at next location for converted output
#line 3008
  */
#line 3008
  long i, j, ni;
#line 3008
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3008
  int *xp;
#line 3008
  int nrange = 0;         /* number of range errors */
#line 3008
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3008
  long cxp = (long) *((char**)xpp);
#line 3008

#line 3008
  realign = (cxp & 7) % SIZEOF_INT;
#line 3008
  /* sjl: manually stripmine so we can limit amount of
#line 3008
   * vector work space reserved to LOOPCNT elements. Also
#line 3008
   * makes vectorisation easy */
#line 3008
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3008
    ni=Min(nelems-j,LOOPCNT);
#line 3008
    if (realign) {
#line 3008
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3008
      xp = tmp;
#line 3008
    } else {
#line 3008
      xp = (int *) *xpp;
#line 3008
    }
#line 3008
   /* copy the next block */
#line 3008
#pragma cdir loopcnt=LOOPCNT
#line 3008
#pragma cdir shortloop
#line 3008
    for (i=0; i<ni; i++) {
#line 3008
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3008
     /* test for range errors (not always needed but do it anyway) */
#line 3008
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3008
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3008
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3008
    }
#line 3008
   /* update xpp and tp */
#line 3008
    if (realign) xp = (int *) *xpp;
#line 3008
    xp += ni;
#line 3008
    tp += ni;
#line 3008
    *xpp = (void*)xp;
#line 3008
  }
#line 3008
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3008

#line 3008
#else   /* not SX */
#line 3008
	const char *xp = (const char *) *xpp;
#line 3008
	int status = ENOERR;
#line 3008

#line 3008
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3008
	{
#line 3008
		const int lstatus = ncx_get_int_uint(xp, tp);
#line 3008
		if(lstatus != ENOERR)
#line 3008
			status = lstatus;
#line 3008
	}
#line 3008

#line 3008
	*xpp = (const void *)xp;
#line 3008
	return status;
#line 3008
#  endif
#line 3008
}
#line 3008

int
#line 3009
ncx_getn_int_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3009
{
#line 3009
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3009

#line 3009
 /* basic algorithm is:
#line 3009
  *   - ensure sane alignment of input data
#line 3009
  *   - copy (conversion happens automatically) input data
#line 3009
  *     to output
#line 3009
  *   - update xpp to point at next unconverted input, and tp to point
#line 3009
  *     at next location for converted output
#line 3009
  */
#line 3009
  long i, j, ni;
#line 3009
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3009
  int *xp;
#line 3009
  int nrange = 0;         /* number of range errors */
#line 3009
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3009
  long cxp = (long) *((char**)xpp);
#line 3009

#line 3009
  realign = (cxp & 7) % SIZEOF_INT;
#line 3009
  /* sjl: manually stripmine so we can limit amount of
#line 3009
   * vector work space reserved to LOOPCNT elements. Also
#line 3009
   * makes vectorisation easy */
#line 3009
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3009
    ni=Min(nelems-j,LOOPCNT);
#line 3009
    if (realign) {
#line 3009
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 3009
      xp = tmp;
#line 3009
    } else {
#line 3009
      xp = (int *) *xpp;
#line 3009
    }
#line 3009
   /* copy the next block */
#line 3009
#pragma cdir loopcnt=LOOPCNT
#line 3009
#pragma cdir shortloop
#line 3009
    for (i=0; i<ni; i++) {
#line 3009
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3009
     /* test for range errors (not always needed but do it anyway) */
#line 3009
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3009
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3009
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3009
    }
#line 3009
   /* update xpp and tp */
#line 3009
    if (realign) xp = (int *) *xpp;
#line 3009
    xp += ni;
#line 3009
    tp += ni;
#line 3009
    *xpp = (void*)xp;
#line 3009
  }
#line 3009
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3009

#line 3009
#else   /* not SX */
#line 3009
	const char *xp = (const char *) *xpp;
#line 3009
	int status = ENOERR;
#line 3009

#line 3009
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3009
	{
#line 3009
		const int lstatus = ncx_get_int_ulonglong(xp, tp);
#line 3009
		if(lstatus != ENOERR)
#line 3009
			status = lstatus;
#line 3009
	}
#line 3009

#line 3009
	*xpp = (const void *)xp;
#line 3009
	return status;
#line 3009
#  endif
#line 3009
}
#line 3009


#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_INT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
#else
int
#line 3025
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp)
#line 3025
{
#line 3025
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3025

#line 3025
 /* basic algorithm is:
#line 3025
  *   - ensure sane alignment of output data
#line 3025
  *   - copy (conversion happens automatically) input data
#line 3025
  *     to output
#line 3025
  *   - update tp to point at next unconverted input, and xpp to point
#line 3025
  *     at next location for converted output
#line 3025
  */
#line 3025
  long i, j, ni;
#line 3025
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3025
  int *xp;
#line 3025
  int nrange = 0;         /* number of range errors */
#line 3025
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3025
  long cxp = (long) *((char**)xpp);
#line 3025

#line 3025
  realign = (cxp & 7) % SIZEOF_INT;
#line 3025
  /* sjl: manually stripmine so we can limit amount of
#line 3025
   * vector work space reserved to LOOPCNT elements. Also
#line 3025
   * makes vectorisation easy */
#line 3025
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3025
    ni=Min(nelems-j,LOOPCNT);
#line 3025
    if (realign) {
#line 3025
      xp = tmp;
#line 3025
    } else {
#line 3025
      xp = (int *) *xpp;
#line 3025
    }
#line 3025
   /* copy the next block */
#line 3025
#pragma cdir loopcnt=LOOPCNT
#line 3025
#pragma cdir shortloop
#line 3025
    for (i=0; i<ni; i++) {
#line 3025
      /* the normal case: */
#line 3025
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3025
     /* test for range errors (not always needed but do it anyway) */
#line 3025
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3025
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3025
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3025
    }
#line 3025
   /* copy workspace back if necessary */
#line 3025
    if (realign) {
#line 3025
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3025
      xp = (int *) *xpp;
#line 3025
    }
#line 3025
   /* update xpp and tp */
#line 3025
    xp += ni;
#line 3025
    tp += ni;
#line 3025
    *xpp = (void*)xp;
#line 3025
  }
#line 3025
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3025

#line 3025
#else   /* not SX */
#line 3025

#line 3025
	char *xp = (char *) *xpp;
#line 3025
	int status = ENOERR;
#line 3025

#line 3025
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3025
	{
#line 3025
		int lstatus = ncx_put_int_int(xp, tp);
#line 3025
		if(lstatus != ENOERR)
#line 3025
			status = lstatus;
#line 3025
	}
#line 3025

#line 3025
	*xpp = (void *)xp;
#line 3025
	return status;
#line 3025
#endif
#line 3025
}
#line 3025

#endif
int
#line 3027
ncx_putn_int_schar(void **xpp, size_t nelems, const schar *tp)
#line 3027
{
#line 3027
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3027

#line 3027
 /* basic algorithm is:
#line 3027
  *   - ensure sane alignment of output data
#line 3027
  *   - copy (conversion happens automatically) input data
#line 3027
  *     to output
#line 3027
  *   - update tp to point at next unconverted input, and xpp to point
#line 3027
  *     at next location for converted output
#line 3027
  */
#line 3027
  long i, j, ni;
#line 3027
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3027
  int *xp;
#line 3027
  int nrange = 0;         /* number of range errors */
#line 3027
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3027
  long cxp = (long) *((char**)xpp);
#line 3027

#line 3027
  realign = (cxp & 7) % SIZEOF_INT;
#line 3027
  /* sjl: manually stripmine so we can limit amount of
#line 3027
   * vector work space reserved to LOOPCNT elements. Also
#line 3027
   * makes vectorisation easy */
#line 3027
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3027
    ni=Min(nelems-j,LOOPCNT);
#line 3027
    if (realign) {
#line 3027
      xp = tmp;
#line 3027
    } else {
#line 3027
      xp = (int *) *xpp;
#line 3027
    }
#line 3027
   /* copy the next block */
#line 3027
#pragma cdir loopcnt=LOOPCNT
#line 3027
#pragma cdir shortloop
#line 3027
    for (i=0; i<ni; i++) {
#line 3027
      /* the normal case: */
#line 3027
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3027
     /* test for range errors (not always needed but do it anyway) */
#line 3027
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3027
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3027
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3027
    }
#line 3027
   /* copy workspace back if necessary */
#line 3027
    if (realign) {
#line 3027
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3027
      xp = (int *) *xpp;
#line 3027
    }
#line 3027
   /* update xpp and tp */
#line 3027
    xp += ni;
#line 3027
    tp += ni;
#line 3027
    *xpp = (void*)xp;
#line 3027
  }
#line 3027
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3027

#line 3027
#else   /* not SX */
#line 3027

#line 3027
	char *xp = (char *) *xpp;
#line 3027
	int status = ENOERR;
#line 3027

#line 3027
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3027
	{
#line 3027
		int lstatus = ncx_put_int_schar(xp, tp);
#line 3027
		if(lstatus != ENOERR)
#line 3027
			status = lstatus;
#line 3027
	}
#line 3027

#line 3027
	*xpp = (void *)xp;
#line 3027
	return status;
#line 3027
#endif
#line 3027
}
#line 3027

int
#line 3028
ncx_putn_int_short(void **xpp, size_t nelems, const short *tp)
#line 3028
{
#line 3028
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3028

#line 3028
 /* basic algorithm is:
#line 3028
  *   - ensure sane alignment of output data
#line 3028
  *   - copy (conversion happens automatically) input data
#line 3028
  *     to output
#line 3028
  *   - update tp to point at next unconverted input, and xpp to point
#line 3028
  *     at next location for converted output
#line 3028
  */
#line 3028
  long i, j, ni;
#line 3028
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3028
  int *xp;
#line 3028
  int nrange = 0;         /* number of range errors */
#line 3028
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3028
  long cxp = (long) *((char**)xpp);
#line 3028

#line 3028
  realign = (cxp & 7) % SIZEOF_INT;
#line 3028
  /* sjl: manually stripmine so we can limit amount of
#line 3028
   * vector work space reserved to LOOPCNT elements. Also
#line 3028
   * makes vectorisation easy */
#line 3028
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3028
    ni=Min(nelems-j,LOOPCNT);
#line 3028
    if (realign) {
#line 3028
      xp = tmp;
#line 3028
    } else {
#line 3028
      xp = (int *) *xpp;
#line 3028
    }
#line 3028
   /* copy the next block */
#line 3028
#pragma cdir loopcnt=LOOPCNT
#line 3028
#pragma cdir shortloop
#line 3028
    for (i=0; i<ni; i++) {
#line 3028
      /* the normal case: */
#line 3028
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3028
     /* test for range errors (not always needed but do it anyway) */
#line 3028
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3028
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3028
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3028
    }
#line 3028
   /* copy workspace back if necessary */
#line 3028
    if (realign) {
#line 3028
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3028
      xp = (int *) *xpp;
#line 3028
    }
#line 3028
   /* update xpp and tp */
#line 3028
    xp += ni;
#line 3028
    tp += ni;
#line 3028
    *xpp = (void*)xp;
#line 3028
  }
#line 3028
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3028

#line 3028
#else   /* not SX */
#line 3028

#line 3028
	char *xp = (char *) *xpp;
#line 3028
	int status = ENOERR;
#line 3028

#line 3028
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3028
	{
#line 3028
		int lstatus = ncx_put_int_short(xp, tp);
#line 3028
		if(lstatus != ENOERR)
#line 3028
			status = lstatus;
#line 3028
	}
#line 3028

#line 3028
	*xpp = (void *)xp;
#line 3028
	return status;
#line 3028
#endif
#line 3028
}
#line 3028

int
#line 3029
ncx_putn_int_float(void **xpp, size_t nelems, const float *tp)
#line 3029
{
#line 3029
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3029

#line 3029
 /* basic algorithm is:
#line 3029
  *   - ensure sane alignment of output data
#line 3029
  *   - copy (conversion happens automatically) input data
#line 3029
  *     to output
#line 3029
  *   - update tp to point at next unconverted input, and xpp to point
#line 3029
  *     at next location for converted output
#line 3029
  */
#line 3029
  long i, j, ni;
#line 3029
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3029
  int *xp;
#line 3029
  double d;               /* special case for ncx_putn_int_float */
#line 3029
  int nrange = 0;         /* number of range errors */
#line 3029
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3029
  long cxp = (long) *((char**)xpp);
#line 3029

#line 3029
  realign = (cxp & 7) % SIZEOF_INT;
#line 3029
  /* sjl: manually stripmine so we can limit amount of
#line 3029
   * vector work space reserved to LOOPCNT elements. Also
#line 3029
   * makes vectorisation easy */
#line 3029
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3029
    ni=Min(nelems-j,LOOPCNT);
#line 3029
    if (realign) {
#line 3029
      xp = tmp;
#line 3029
    } else {
#line 3029
      xp = (int *) *xpp;
#line 3029
    }
#line 3029
   /* copy the next block */
#line 3029
#pragma cdir loopcnt=LOOPCNT
#line 3029
#pragma cdir shortloop
#line 3029
    for (i=0; i<ni; i++) {
#line 3029
      /* for some reason int to float, for putn, requires a special case */
#line 3029
      d = tp[i];
#line 3029
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) d));
#line 3029
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3029
    }
#line 3029
   /* copy workspace back if necessary */
#line 3029
    if (realign) {
#line 3029
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3029
      xp = (int *) *xpp;
#line 3029
    }
#line 3029
   /* update xpp and tp */
#line 3029
    xp += ni;
#line 3029
    tp += ni;
#line 3029
    *xpp = (void*)xp;
#line 3029
  }
#line 3029
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3029

#line 3029
#else   /* not SX */
#line 3029

#line 3029
	char *xp = (char *) *xpp;
#line 3029
	int status = ENOERR;
#line 3029

#line 3029
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3029
	{
#line 3029
		int lstatus = ncx_put_int_float(xp, tp);
#line 3029
		if(lstatus != ENOERR)
#line 3029
			status = lstatus;
#line 3029
	}
#line 3029

#line 3029
	*xpp = (void *)xp;
#line 3029
	return status;
#line 3029
#endif
#line 3029
}
#line 3029

int
#line 3030
ncx_putn_int_double(void **xpp, size_t nelems, const double *tp)
#line 3030
{
#line 3030
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3030

#line 3030
 /* basic algorithm is:
#line 3030
  *   - ensure sane alignment of output data
#line 3030
  *   - copy (conversion happens automatically) input data
#line 3030
  *     to output
#line 3030
  *   - update tp to point at next unconverted input, and xpp to point
#line 3030
  *     at next location for converted output
#line 3030
  */
#line 3030
  long i, j, ni;
#line 3030
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3030
  int *xp;
#line 3030
  int nrange = 0;         /* number of range errors */
#line 3030
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3030
  long cxp = (long) *((char**)xpp);
#line 3030

#line 3030
  realign = (cxp & 7) % SIZEOF_INT;
#line 3030
  /* sjl: manually stripmine so we can limit amount of
#line 3030
   * vector work space reserved to LOOPCNT elements. Also
#line 3030
   * makes vectorisation easy */
#line 3030
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3030
    ni=Min(nelems-j,LOOPCNT);
#line 3030
    if (realign) {
#line 3030
      xp = tmp;
#line 3030
    } else {
#line 3030
      xp = (int *) *xpp;
#line 3030
    }
#line 3030
   /* copy the next block */
#line 3030
#pragma cdir loopcnt=LOOPCNT
#line 3030
#pragma cdir shortloop
#line 3030
    for (i=0; i<ni; i++) {
#line 3030
      /* the normal case: */
#line 3030
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3030
     /* test for range errors (not always needed but do it anyway) */
#line 3030
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3030
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3030
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3030
    }
#line 3030
   /* copy workspace back if necessary */
#line 3030
    if (realign) {
#line 3030
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3030
      xp = (int *) *xpp;
#line 3030
    }
#line 3030
   /* update xpp and tp */
#line 3030
    xp += ni;
#line 3030
    tp += ni;
#line 3030
    *xpp = (void*)xp;
#line 3030
  }
#line 3030
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3030

#line 3030
#else   /* not SX */
#line 3030

#line 3030
	char *xp = (char *) *xpp;
#line 3030
	int status = ENOERR;
#line 3030

#line 3030
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3030
	{
#line 3030
		int lstatus = ncx_put_int_double(xp, tp);
#line 3030
		if(lstatus != ENOERR)
#line 3030
			status = lstatus;
#line 3030
	}
#line 3030

#line 3030
	*xpp = (void *)xp;
#line 3030
	return status;
#line 3030
#endif
#line 3030
}
#line 3030

int
#line 3031
ncx_putn_int_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3031
{
#line 3031
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3031

#line 3031
 /* basic algorithm is:
#line 3031
  *   - ensure sane alignment of output data
#line 3031
  *   - copy (conversion happens automatically) input data
#line 3031
  *     to output
#line 3031
  *   - update tp to point at next unconverted input, and xpp to point
#line 3031
  *     at next location for converted output
#line 3031
  */
#line 3031
  long i, j, ni;
#line 3031
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3031
  int *xp;
#line 3031
  int nrange = 0;         /* number of range errors */
#line 3031
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3031
  long cxp = (long) *((char**)xpp);
#line 3031

#line 3031
  realign = (cxp & 7) % SIZEOF_INT;
#line 3031
  /* sjl: manually stripmine so we can limit amount of
#line 3031
   * vector work space reserved to LOOPCNT elements. Also
#line 3031
   * makes vectorisation easy */
#line 3031
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3031
    ni=Min(nelems-j,LOOPCNT);
#line 3031
    if (realign) {
#line 3031
      xp = tmp;
#line 3031
    } else {
#line 3031
      xp = (int *) *xpp;
#line 3031
    }
#line 3031
   /* copy the next block */
#line 3031
#pragma cdir loopcnt=LOOPCNT
#line 3031
#pragma cdir shortloop
#line 3031
    for (i=0; i<ni; i++) {
#line 3031
      /* the normal case: */
#line 3031
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3031
     /* test for range errors (not always needed but do it anyway) */
#line 3031
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3031
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3031
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 3031
    }
#line 3031
   /* copy workspace back if necessary */
#line 3031
    if (realign) {
#line 3031
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3031
      xp = (int *) *xpp;
#line 3031
    }
#line 3031
   /* update xpp and tp */
#line 3031
    xp += ni;
#line 3031
    tp += ni;
#line 3031
    *xpp = (void*)xp;
#line 3031
  }
#line 3031
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3031

#line 3031
#else   /* not SX */
#line 3031

#line 3031
	char *xp = (char *) *xpp;
#line 3031
	int status = ENOERR;
#line 3031

#line 3031
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3031
	{
#line 3031
		int lstatus = ncx_put_int_longlong(xp, tp);
#line 3031
		if(lstatus != ENOERR)
#line 3031
			status = lstatus;
#line 3031
	}
#line 3031

#line 3031
	*xpp = (void *)xp;
#line 3031
	return status;
#line 3031
#endif
#line 3031
}
#line 3031

int
#line 3032
ncx_putn_int_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3032
{
#line 3032
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3032

#line 3032
 /* basic algorithm is:
#line 3032
  *   - ensure sane alignment of output data
#line 3032
  *   - copy (conversion happens automatically) input data
#line 3032
  *     to output
#line 3032
  *   - update tp to point at next unconverted input, and xpp to point
#line 3032
  *     at next location for converted output
#line 3032
  */
#line 3032
  long i, j, ni;
#line 3032
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3032
  int *xp;
#line 3032
  int nrange = 0;         /* number of range errors */
#line 3032
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3032
  long cxp = (long) *((char**)xpp);
#line 3032

#line 3032
  realign = (cxp & 7) % SIZEOF_INT;
#line 3032
  /* sjl: manually stripmine so we can limit amount of
#line 3032
   * vector work space reserved to LOOPCNT elements. Also
#line 3032
   * makes vectorisation easy */
#line 3032
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3032
    ni=Min(nelems-j,LOOPCNT);
#line 3032
    if (realign) {
#line 3032
      xp = tmp;
#line 3032
    } else {
#line 3032
      xp = (int *) *xpp;
#line 3032
    }
#line 3032
   /* copy the next block */
#line 3032
#pragma cdir loopcnt=LOOPCNT
#line 3032
#pragma cdir shortloop
#line 3032
    for (i=0; i<ni; i++) {
#line 3032
      /* the normal case: */
#line 3032
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3032
     /* test for range errors (not always needed but do it anyway) */
#line 3032
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3032
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3032
      nrange += tp[i] > X_INT_MAX ;
#line 3032
    }
#line 3032
   /* copy workspace back if necessary */
#line 3032
    if (realign) {
#line 3032
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3032
      xp = (int *) *xpp;
#line 3032
    }
#line 3032
   /* update xpp and tp */
#line 3032
    xp += ni;
#line 3032
    tp += ni;
#line 3032
    *xpp = (void*)xp;
#line 3032
  }
#line 3032
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3032

#line 3032
#else   /* not SX */
#line 3032

#line 3032
	char *xp = (char *) *xpp;
#line 3032
	int status = ENOERR;
#line 3032

#line 3032
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3032
	{
#line 3032
		int lstatus = ncx_put_int_uchar(xp, tp);
#line 3032
		if(lstatus != ENOERR)
#line 3032
			status = lstatus;
#line 3032
	}
#line 3032

#line 3032
	*xpp = (void *)xp;
#line 3032
	return status;
#line 3032
#endif
#line 3032
}
#line 3032

int
#line 3033
ncx_putn_int_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3033
{
#line 3033
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3033

#line 3033
 /* basic algorithm is:
#line 3033
  *   - ensure sane alignment of output data
#line 3033
  *   - copy (conversion happens automatically) input data
#line 3033
  *     to output
#line 3033
  *   - update tp to point at next unconverted input, and xpp to point
#line 3033
  *     at next location for converted output
#line 3033
  */
#line 3033
  long i, j, ni;
#line 3033
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3033
  int *xp;
#line 3033
  int nrange = 0;         /* number of range errors */
#line 3033
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3033
  long cxp = (long) *((char**)xpp);
#line 3033

#line 3033
  realign = (cxp & 7) % SIZEOF_INT;
#line 3033
  /* sjl: manually stripmine so we can limit amount of
#line 3033
   * vector work space reserved to LOOPCNT elements. Also
#line 3033
   * makes vectorisation easy */
#line 3033
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3033
    ni=Min(nelems-j,LOOPCNT);
#line 3033
    if (realign) {
#line 3033
      xp = tmp;
#line 3033
    } else {
#line 3033
      xp = (int *) *xpp;
#line 3033
    }
#line 3033
   /* copy the next block */
#line 3033
#pragma cdir loopcnt=LOOPCNT
#line 3033
#pragma cdir shortloop
#line 3033
    for (i=0; i<ni; i++) {
#line 3033
      /* the normal case: */
#line 3033
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3033
     /* test for range errors (not always needed but do it anyway) */
#line 3033
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3033
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3033
      nrange += tp[i] > X_INT_MAX ;
#line 3033
    }
#line 3033
   /* copy workspace back if necessary */
#line 3033
    if (realign) {
#line 3033
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3033
      xp = (int *) *xpp;
#line 3033
    }
#line 3033
   /* update xpp and tp */
#line 3033
    xp += ni;
#line 3033
    tp += ni;
#line 3033
    *xpp = (void*)xp;
#line 3033
  }
#line 3033
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3033

#line 3033
#else   /* not SX */
#line 3033

#line 3033
	char *xp = (char *) *xpp;
#line 3033
	int status = ENOERR;
#line 3033

#line 3033
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3033
	{
#line 3033
		int lstatus = ncx_put_int_ushort(xp, tp);
#line 3033
		if(lstatus != ENOERR)
#line 3033
			status = lstatus;
#line 3033
	}
#line 3033

#line 3033
	*xpp = (void *)xp;
#line 3033
	return status;
#line 3033
#endif
#line 3033
}
#line 3033

int
#line 3034
ncx_putn_int_uint(void **xpp, size_t nelems, const uint *tp)
#line 3034
{
#line 3034
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3034

#line 3034
 /* basic algorithm is:
#line 3034
  *   - ensure sane alignment of output data
#line 3034
  *   - copy (conversion happens automatically) input data
#line 3034
  *     to output
#line 3034
  *   - update tp to point at next unconverted input, and xpp to point
#line 3034
  *     at next location for converted output
#line 3034
  */
#line 3034
  long i, j, ni;
#line 3034
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3034
  int *xp;
#line 3034
  int nrange = 0;         /* number of range errors */
#line 3034
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3034
  long cxp = (long) *((char**)xpp);
#line 3034

#line 3034
  realign = (cxp & 7) % SIZEOF_INT;
#line 3034
  /* sjl: manually stripmine so we can limit amount of
#line 3034
   * vector work space reserved to LOOPCNT elements. Also
#line 3034
   * makes vectorisation easy */
#line 3034
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3034
    ni=Min(nelems-j,LOOPCNT);
#line 3034
    if (realign) {
#line 3034
      xp = tmp;
#line 3034
    } else {
#line 3034
      xp = (int *) *xpp;
#line 3034
    }
#line 3034
   /* copy the next block */
#line 3034
#pragma cdir loopcnt=LOOPCNT
#line 3034
#pragma cdir shortloop
#line 3034
    for (i=0; i<ni; i++) {
#line 3034
      /* the normal case: */
#line 3034
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3034
     /* test for range errors (not always needed but do it anyway) */
#line 3034
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3034
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3034
      nrange += tp[i] > X_INT_MAX ;
#line 3034
    }
#line 3034
   /* copy workspace back if necessary */
#line 3034
    if (realign) {
#line 3034
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3034
      xp = (int *) *xpp;
#line 3034
    }
#line 3034
   /* update xpp and tp */
#line 3034
    xp += ni;
#line 3034
    tp += ni;
#line 3034
    *xpp = (void*)xp;
#line 3034
  }
#line 3034
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3034

#line 3034
#else   /* not SX */
#line 3034

#line 3034
	char *xp = (char *) *xpp;
#line 3034
	int status = ENOERR;
#line 3034

#line 3034
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3034
	{
#line 3034
		int lstatus = ncx_put_int_uint(xp, tp);
#line 3034
		if(lstatus != ENOERR)
#line 3034
			status = lstatus;
#line 3034
	}
#line 3034

#line 3034
	*xpp = (void *)xp;
#line 3034
	return status;
#line 3034
#endif
#line 3034
}
#line 3034

int
#line 3035
ncx_putn_int_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3035
{
#line 3035
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 3035

#line 3035
 /* basic algorithm is:
#line 3035
  *   - ensure sane alignment of output data
#line 3035
  *   - copy (conversion happens automatically) input data
#line 3035
  *     to output
#line 3035
  *   - update tp to point at next unconverted input, and xpp to point
#line 3035
  *     at next location for converted output
#line 3035
  */
#line 3035
  long i, j, ni;
#line 3035
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 3035
  int *xp;
#line 3035
  int nrange = 0;         /* number of range errors */
#line 3035
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3035
  long cxp = (long) *((char**)xpp);
#line 3035

#line 3035
  realign = (cxp & 7) % SIZEOF_INT;
#line 3035
  /* sjl: manually stripmine so we can limit amount of
#line 3035
   * vector work space reserved to LOOPCNT elements. Also
#line 3035
   * makes vectorisation easy */
#line 3035
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3035
    ni=Min(nelems-j,LOOPCNT);
#line 3035
    if (realign) {
#line 3035
      xp = tmp;
#line 3035
    } else {
#line 3035
      xp = (int *) *xpp;
#line 3035
    }
#line 3035
   /* copy the next block */
#line 3035
#pragma cdir loopcnt=LOOPCNT
#line 3035
#pragma cdir shortloop
#line 3035
    for (i=0; i<ni; i++) {
#line 3035
      /* the normal case: */
#line 3035
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 3035
     /* test for range errors (not always needed but do it anyway) */
#line 3035
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3035
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3035
      nrange += tp[i] > X_INT_MAX ;
#line 3035
    }
#line 3035
   /* copy workspace back if necessary */
#line 3035
    if (realign) {
#line 3035
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 3035
      xp = (int *) *xpp;
#line 3035
    }
#line 3035
   /* update xpp and tp */
#line 3035
    xp += ni;
#line 3035
    tp += ni;
#line 3035
    *xpp = (void*)xp;
#line 3035
  }
#line 3035
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3035

#line 3035
#else   /* not SX */
#line 3035

#line 3035
	char *xp = (char *) *xpp;
#line 3035
	int status = ENOERR;
#line 3035

#line 3035
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 3035
	{
#line 3035
		int lstatus = ncx_put_int_ulonglong(xp, tp);
#line 3035
		if(lstatus != ENOERR)
#line 3035
			status = lstatus;
#line 3035
	}
#line 3035

#line 3035
	*xpp = (void *)xp;
#line 3035
	return status;
#line 3035
#endif
#line 3035
}
#line 3035


/* uint ----------------------------------------------------------------------*/

#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_getn_uint_uint(const void **xpp, size_t nelems, unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(uint));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return ENOERR;
}
#else
int
#line 3053
ncx_getn_uint_uint(const void **xpp, size_t nelems, uint *tp)
#line 3053
{
#line 3053
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3053

#line 3053
 /* basic algorithm is:
#line 3053
  *   - ensure sane alignment of input data
#line 3053
  *   - copy (conversion happens automatically) input data
#line 3053
  *     to output
#line 3053
  *   - update xpp to point at next unconverted input, and tp to point
#line 3053
  *     at next location for converted output
#line 3053
  */
#line 3053
  long i, j, ni;
#line 3053
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3053
  uint *xp;
#line 3053
  int nrange = 0;         /* number of range errors */
#line 3053
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3053
  long cxp = (long) *((char**)xpp);
#line 3053

#line 3053
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3053
  /* sjl: manually stripmine so we can limit amount of
#line 3053
   * vector work space reserved to LOOPCNT elements. Also
#line 3053
   * makes vectorisation easy */
#line 3053
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3053
    ni=Min(nelems-j,LOOPCNT);
#line 3053
    if (realign) {
#line 3053
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3053
      xp = tmp;
#line 3053
    } else {
#line 3053
      xp = (uint *) *xpp;
#line 3053
    }
#line 3053
   /* copy the next block */
#line 3053
#pragma cdir loopcnt=LOOPCNT
#line 3053
#pragma cdir shortloop
#line 3053
    for (i=0; i<ni; i++) {
#line 3053
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3053
     /* test for range errors (not always needed but do it anyway) */
#line 3053
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3053
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3053
      nrange += xp[i] > UINT_MAX ;
#line 3053
    }
#line 3053
   /* update xpp and tp */
#line 3053
    if (realign) xp = (uint *) *xpp;
#line 3053
    xp += ni;
#line 3053
    tp += ni;
#line 3053
    *xpp = (void*)xp;
#line 3053
  }
#line 3053
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3053

#line 3053
#else   /* not SX */
#line 3053
	const char *xp = (const char *) *xpp;
#line 3053
	int status = ENOERR;
#line 3053

#line 3053
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3053
	{
#line 3053
		const int lstatus = ncx_get_uint_uint(xp, tp);
#line 3053
		if(lstatus != ENOERR)
#line 3053
			status = lstatus;
#line 3053
	}
#line 3053

#line 3053
	*xpp = (const void *)xp;
#line 3053
	return status;
#line 3053
#  endif
#line 3053
}
#line 3053

#endif
int
#line 3055
ncx_getn_uint_schar(const void **xpp, size_t nelems, schar *tp)
#line 3055
{
#line 3055
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3055

#line 3055
 /* basic algorithm is:
#line 3055
  *   - ensure sane alignment of input data
#line 3055
  *   - copy (conversion happens automatically) input data
#line 3055
  *     to output
#line 3055
  *   - update xpp to point at next unconverted input, and tp to point
#line 3055
  *     at next location for converted output
#line 3055
  */
#line 3055
  long i, j, ni;
#line 3055
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3055
  uint *xp;
#line 3055
  int nrange = 0;         /* number of range errors */
#line 3055
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3055
  long cxp = (long) *((char**)xpp);
#line 3055

#line 3055
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3055
  /* sjl: manually stripmine so we can limit amount of
#line 3055
   * vector work space reserved to LOOPCNT elements. Also
#line 3055
   * makes vectorisation easy */
#line 3055
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3055
    ni=Min(nelems-j,LOOPCNT);
#line 3055
    if (realign) {
#line 3055
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3055
      xp = tmp;
#line 3055
    } else {
#line 3055
      xp = (uint *) *xpp;
#line 3055
    }
#line 3055
   /* copy the next block */
#line 3055
#pragma cdir loopcnt=LOOPCNT
#line 3055
#pragma cdir shortloop
#line 3055
    for (i=0; i<ni; i++) {
#line 3055
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3055
     /* test for range errors (not always needed but do it anyway) */
#line 3055
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3055
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3055
      nrange += xp[i] > SCHAR_MAX ;
#line 3055
    }
#line 3055
   /* update xpp and tp */
#line 3055
    if (realign) xp = (uint *) *xpp;
#line 3055
    xp += ni;
#line 3055
    tp += ni;
#line 3055
    *xpp = (void*)xp;
#line 3055
  }
#line 3055
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3055

#line 3055
#else   /* not SX */
#line 3055
	const char *xp = (const char *) *xpp;
#line 3055
	int status = ENOERR;
#line 3055

#line 3055
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3055
	{
#line 3055
		const int lstatus = ncx_get_uint_schar(xp, tp);
#line 3055
		if(lstatus != ENOERR)
#line 3055
			status = lstatus;
#line 3055
	}
#line 3055

#line 3055
	*xpp = (const void *)xp;
#line 3055
	return status;
#line 3055
#  endif
#line 3055
}
#line 3055

int
#line 3056
ncx_getn_uint_short(const void **xpp, size_t nelems, short *tp)
#line 3056
{
#line 3056
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3056

#line 3056
 /* basic algorithm is:
#line 3056
  *   - ensure sane alignment of input data
#line 3056
  *   - copy (conversion happens automatically) input data
#line 3056
  *     to output
#line 3056
  *   - update xpp to point at next unconverted input, and tp to point
#line 3056
  *     at next location for converted output
#line 3056
  */
#line 3056
  long i, j, ni;
#line 3056
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3056
  uint *xp;
#line 3056
  int nrange = 0;         /* number of range errors */
#line 3056
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3056
  long cxp = (long) *((char**)xpp);
#line 3056

#line 3056
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3056
  /* sjl: manually stripmine so we can limit amount of
#line 3056
   * vector work space reserved to LOOPCNT elements. Also
#line 3056
   * makes vectorisation easy */
#line 3056
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3056
    ni=Min(nelems-j,LOOPCNT);
#line 3056
    if (realign) {
#line 3056
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3056
      xp = tmp;
#line 3056
    } else {
#line 3056
      xp = (uint *) *xpp;
#line 3056
    }
#line 3056
   /* copy the next block */
#line 3056
#pragma cdir loopcnt=LOOPCNT
#line 3056
#pragma cdir shortloop
#line 3056
    for (i=0; i<ni; i++) {
#line 3056
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3056
     /* test for range errors (not always needed but do it anyway) */
#line 3056
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3056
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3056
      nrange += xp[i] > SHORT_MAX ;
#line 3056
    }
#line 3056
   /* update xpp and tp */
#line 3056
    if (realign) xp = (uint *) *xpp;
#line 3056
    xp += ni;
#line 3056
    tp += ni;
#line 3056
    *xpp = (void*)xp;
#line 3056
  }
#line 3056
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3056

#line 3056
#else   /* not SX */
#line 3056
	const char *xp = (const char *) *xpp;
#line 3056
	int status = ENOERR;
#line 3056

#line 3056
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3056
	{
#line 3056
		const int lstatus = ncx_get_uint_short(xp, tp);
#line 3056
		if(lstatus != ENOERR)
#line 3056
			status = lstatus;
#line 3056
	}
#line 3056

#line 3056
	*xpp = (const void *)xp;
#line 3056
	return status;
#line 3056
#  endif
#line 3056
}
#line 3056

int
#line 3057
ncx_getn_uint_int(const void **xpp, size_t nelems, int *tp)
#line 3057
{
#line 3057
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3057

#line 3057
 /* basic algorithm is:
#line 3057
  *   - ensure sane alignment of input data
#line 3057
  *   - copy (conversion happens automatically) input data
#line 3057
  *     to output
#line 3057
  *   - update xpp to point at next unconverted input, and tp to point
#line 3057
  *     at next location for converted output
#line 3057
  */
#line 3057
  long i, j, ni;
#line 3057
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3057
  uint *xp;
#line 3057
  int nrange = 0;         /* number of range errors */
#line 3057
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3057
  long cxp = (long) *((char**)xpp);
#line 3057

#line 3057
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3057
  /* sjl: manually stripmine so we can limit amount of
#line 3057
   * vector work space reserved to LOOPCNT elements. Also
#line 3057
   * makes vectorisation easy */
#line 3057
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3057
    ni=Min(nelems-j,LOOPCNT);
#line 3057
    if (realign) {
#line 3057
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3057
      xp = tmp;
#line 3057
    } else {
#line 3057
      xp = (uint *) *xpp;
#line 3057
    }
#line 3057
   /* copy the next block */
#line 3057
#pragma cdir loopcnt=LOOPCNT
#line 3057
#pragma cdir shortloop
#line 3057
    for (i=0; i<ni; i++) {
#line 3057
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3057
     /* test for range errors (not always needed but do it anyway) */
#line 3057
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3057
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3057
      nrange += xp[i] > INT_MAX ;
#line 3057
    }
#line 3057
   /* update xpp and tp */
#line 3057
    if (realign) xp = (uint *) *xpp;
#line 3057
    xp += ni;
#line 3057
    tp += ni;
#line 3057
    *xpp = (void*)xp;
#line 3057
  }
#line 3057
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3057

#line 3057
#else   /* not SX */
#line 3057
	const char *xp = (const char *) *xpp;
#line 3057
	int status = ENOERR;
#line 3057

#line 3057
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3057
	{
#line 3057
		const int lstatus = ncx_get_uint_int(xp, tp);
#line 3057
		if(lstatus != ENOERR)
#line 3057
			status = lstatus;
#line 3057
	}
#line 3057

#line 3057
	*xpp = (const void *)xp;
#line 3057
	return status;
#line 3057
#  endif
#line 3057
}
#line 3057

int
#line 3058
ncx_getn_uint_float(const void **xpp, size_t nelems, float *tp)
#line 3058
{
#line 3058
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3058

#line 3058
 /* basic algorithm is:
#line 3058
  *   - ensure sane alignment of input data
#line 3058
  *   - copy (conversion happens automatically) input data
#line 3058
  *     to output
#line 3058
  *   - update xpp to point at next unconverted input, and tp to point
#line 3058
  *     at next location for converted output
#line 3058
  */
#line 3058
  long i, j, ni;
#line 3058
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3058
  uint *xp;
#line 3058
  int nrange = 0;         /* number of range errors */
#line 3058
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3058
  long cxp = (long) *((char**)xpp);
#line 3058

#line 3058
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3058
  /* sjl: manually stripmine so we can limit amount of
#line 3058
   * vector work space reserved to LOOPCNT elements. Also
#line 3058
   * makes vectorisation easy */
#line 3058
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3058
    ni=Min(nelems-j,LOOPCNT);
#line 3058
    if (realign) {
#line 3058
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3058
      xp = tmp;
#line 3058
    } else {
#line 3058
      xp = (uint *) *xpp;
#line 3058
    }
#line 3058
   /* copy the next block */
#line 3058
#pragma cdir loopcnt=LOOPCNT
#line 3058
#pragma cdir shortloop
#line 3058
    for (i=0; i<ni; i++) {
#line 3058
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3058
     /* test for range errors (not always needed but do it anyway) */
#line 3058
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3058
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3058
      nrange += xp[i] > FLOAT_MAX ;
#line 3058
    }
#line 3058
   /* update xpp and tp */
#line 3058
    if (realign) xp = (uint *) *xpp;
#line 3058
    xp += ni;
#line 3058
    tp += ni;
#line 3058
    *xpp = (void*)xp;
#line 3058
  }
#line 3058
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3058

#line 3058
#else   /* not SX */
#line 3058
	const char *xp = (const char *) *xpp;
#line 3058
	int status = ENOERR;
#line 3058

#line 3058
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3058
	{
#line 3058
		const int lstatus = ncx_get_uint_float(xp, tp);
#line 3058
		if(lstatus != ENOERR)
#line 3058
			status = lstatus;
#line 3058
	}
#line 3058

#line 3058
	*xpp = (const void *)xp;
#line 3058
	return status;
#line 3058
#  endif
#line 3058
}
#line 3058

int
#line 3059
ncx_getn_uint_double(const void **xpp, size_t nelems, double *tp)
#line 3059
{
#line 3059
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3059

#line 3059
 /* basic algorithm is:
#line 3059
  *   - ensure sane alignment of input data
#line 3059
  *   - copy (conversion happens automatically) input data
#line 3059
  *     to output
#line 3059
  *   - update xpp to point at next unconverted input, and tp to point
#line 3059
  *     at next location for converted output
#line 3059
  */
#line 3059
  long i, j, ni;
#line 3059
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3059
  uint *xp;
#line 3059
  int nrange = 0;         /* number of range errors */
#line 3059
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3059
  long cxp = (long) *((char**)xpp);
#line 3059

#line 3059
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3059
  /* sjl: manually stripmine so we can limit amount of
#line 3059
   * vector work space reserved to LOOPCNT elements. Also
#line 3059
   * makes vectorisation easy */
#line 3059
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3059
    ni=Min(nelems-j,LOOPCNT);
#line 3059
    if (realign) {
#line 3059
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3059
      xp = tmp;
#line 3059
    } else {
#line 3059
      xp = (uint *) *xpp;
#line 3059
    }
#line 3059
   /* copy the next block */
#line 3059
#pragma cdir loopcnt=LOOPCNT
#line 3059
#pragma cdir shortloop
#line 3059
    for (i=0; i<ni; i++) {
#line 3059
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3059
     /* test for range errors (not always needed but do it anyway) */
#line 3059
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3059
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3059
      nrange += xp[i] > DOUBLE_MAX ;
#line 3059
    }
#line 3059
   /* update xpp and tp */
#line 3059
    if (realign) xp = (uint *) *xpp;
#line 3059
    xp += ni;
#line 3059
    tp += ni;
#line 3059
    *xpp = (void*)xp;
#line 3059
  }
#line 3059
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3059

#line 3059
#else   /* not SX */
#line 3059
	const char *xp = (const char *) *xpp;
#line 3059
	int status = ENOERR;
#line 3059

#line 3059
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3059
	{
#line 3059
		const int lstatus = ncx_get_uint_double(xp, tp);
#line 3059
		if(lstatus != ENOERR)
#line 3059
			status = lstatus;
#line 3059
	}
#line 3059

#line 3059
	*xpp = (const void *)xp;
#line 3059
	return status;
#line 3059
#  endif
#line 3059
}
#line 3059

int
#line 3060
ncx_getn_uint_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3060
{
#line 3060
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3060

#line 3060
 /* basic algorithm is:
#line 3060
  *   - ensure sane alignment of input data
#line 3060
  *   - copy (conversion happens automatically) input data
#line 3060
  *     to output
#line 3060
  *   - update xpp to point at next unconverted input, and tp to point
#line 3060
  *     at next location for converted output
#line 3060
  */
#line 3060
  long i, j, ni;
#line 3060
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3060
  uint *xp;
#line 3060
  int nrange = 0;         /* number of range errors */
#line 3060
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3060
  long cxp = (long) *((char**)xpp);
#line 3060

#line 3060
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3060
  /* sjl: manually stripmine so we can limit amount of
#line 3060
   * vector work space reserved to LOOPCNT elements. Also
#line 3060
   * makes vectorisation easy */
#line 3060
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3060
    ni=Min(nelems-j,LOOPCNT);
#line 3060
    if (realign) {
#line 3060
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3060
      xp = tmp;
#line 3060
    } else {
#line 3060
      xp = (uint *) *xpp;
#line 3060
    }
#line 3060
   /* copy the next block */
#line 3060
#pragma cdir loopcnt=LOOPCNT
#line 3060
#pragma cdir shortloop
#line 3060
    for (i=0; i<ni; i++) {
#line 3060
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3060
     /* test for range errors (not always needed but do it anyway) */
#line 3060
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3060
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3060
      nrange += xp[i] > LONGLONG_MAX ;
#line 3060
    }
#line 3060
   /* update xpp and tp */
#line 3060
    if (realign) xp = (uint *) *xpp;
#line 3060
    xp += ni;
#line 3060
    tp += ni;
#line 3060
    *xpp = (void*)xp;
#line 3060
  }
#line 3060
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3060

#line 3060
#else   /* not SX */
#line 3060
	const char *xp = (const char *) *xpp;
#line 3060
	int status = ENOERR;
#line 3060

#line 3060
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3060
	{
#line 3060
		const int lstatus = ncx_get_uint_longlong(xp, tp);
#line 3060
		if(lstatus != ENOERR)
#line 3060
			status = lstatus;
#line 3060
	}
#line 3060

#line 3060
	*xpp = (const void *)xp;
#line 3060
	return status;
#line 3060
#  endif
#line 3060
}
#line 3060

int
#line 3061
ncx_getn_uint_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3061
{
#line 3061
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3061

#line 3061
 /* basic algorithm is:
#line 3061
  *   - ensure sane alignment of input data
#line 3061
  *   - copy (conversion happens automatically) input data
#line 3061
  *     to output
#line 3061
  *   - update xpp to point at next unconverted input, and tp to point
#line 3061
  *     at next location for converted output
#line 3061
  */
#line 3061
  long i, j, ni;
#line 3061
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3061
  uint *xp;
#line 3061
  int nrange = 0;         /* number of range errors */
#line 3061
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3061
  long cxp = (long) *((char**)xpp);
#line 3061

#line 3061
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3061
  /* sjl: manually stripmine so we can limit amount of
#line 3061
   * vector work space reserved to LOOPCNT elements. Also
#line 3061
   * makes vectorisation easy */
#line 3061
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3061
    ni=Min(nelems-j,LOOPCNT);
#line 3061
    if (realign) {
#line 3061
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3061
      xp = tmp;
#line 3061
    } else {
#line 3061
      xp = (uint *) *xpp;
#line 3061
    }
#line 3061
   /* copy the next block */
#line 3061
#pragma cdir loopcnt=LOOPCNT
#line 3061
#pragma cdir shortloop
#line 3061
    for (i=0; i<ni; i++) {
#line 3061
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3061
     /* test for range errors (not always needed but do it anyway) */
#line 3061
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3061
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3061
      nrange += xp[i] > UCHAR_MAX ;
#line 3061
    }
#line 3061
   /* update xpp and tp */
#line 3061
    if (realign) xp = (uint *) *xpp;
#line 3061
    xp += ni;
#line 3061
    tp += ni;
#line 3061
    *xpp = (void*)xp;
#line 3061
  }
#line 3061
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3061

#line 3061
#else   /* not SX */
#line 3061
	const char *xp = (const char *) *xpp;
#line 3061
	int status = ENOERR;
#line 3061

#line 3061
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3061
	{
#line 3061
		const int lstatus = ncx_get_uint_uchar(xp, tp);
#line 3061
		if(lstatus != ENOERR)
#line 3061
			status = lstatus;
#line 3061
	}
#line 3061

#line 3061
	*xpp = (const void *)xp;
#line 3061
	return status;
#line 3061
#  endif
#line 3061
}
#line 3061

int
#line 3062
ncx_getn_uint_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3062
{
#line 3062
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3062

#line 3062
 /* basic algorithm is:
#line 3062
  *   - ensure sane alignment of input data
#line 3062
  *   - copy (conversion happens automatically) input data
#line 3062
  *     to output
#line 3062
  *   - update xpp to point at next unconverted input, and tp to point
#line 3062
  *     at next location for converted output
#line 3062
  */
#line 3062
  long i, j, ni;
#line 3062
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3062
  uint *xp;
#line 3062
  int nrange = 0;         /* number of range errors */
#line 3062
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3062
  long cxp = (long) *((char**)xpp);
#line 3062

#line 3062
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3062
  /* sjl: manually stripmine so we can limit amount of
#line 3062
   * vector work space reserved to LOOPCNT elements. Also
#line 3062
   * makes vectorisation easy */
#line 3062
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3062
    ni=Min(nelems-j,LOOPCNT);
#line 3062
    if (realign) {
#line 3062
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3062
      xp = tmp;
#line 3062
    } else {
#line 3062
      xp = (uint *) *xpp;
#line 3062
    }
#line 3062
   /* copy the next block */
#line 3062
#pragma cdir loopcnt=LOOPCNT
#line 3062
#pragma cdir shortloop
#line 3062
    for (i=0; i<ni; i++) {
#line 3062
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3062
     /* test for range errors (not always needed but do it anyway) */
#line 3062
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3062
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3062
      nrange += xp[i] > USHORT_MAX ;
#line 3062
    }
#line 3062
   /* update xpp and tp */
#line 3062
    if (realign) xp = (uint *) *xpp;
#line 3062
    xp += ni;
#line 3062
    tp += ni;
#line 3062
    *xpp = (void*)xp;
#line 3062
  }
#line 3062
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3062

#line 3062
#else   /* not SX */
#line 3062
	const char *xp = (const char *) *xpp;
#line 3062
	int status = ENOERR;
#line 3062

#line 3062
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3062
	{
#line 3062
		const int lstatus = ncx_get_uint_ushort(xp, tp);
#line 3062
		if(lstatus != ENOERR)
#line 3062
			status = lstatus;
#line 3062
	}
#line 3062

#line 3062
	*xpp = (const void *)xp;
#line 3062
	return status;
#line 3062
#  endif
#line 3062
}
#line 3062

int
#line 3063
ncx_getn_uint_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3063
{
#line 3063
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3063

#line 3063
 /* basic algorithm is:
#line 3063
  *   - ensure sane alignment of input data
#line 3063
  *   - copy (conversion happens automatically) input data
#line 3063
  *     to output
#line 3063
  *   - update xpp to point at next unconverted input, and tp to point
#line 3063
  *     at next location for converted output
#line 3063
  */
#line 3063
  long i, j, ni;
#line 3063
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3063
  uint *xp;
#line 3063
  int nrange = 0;         /* number of range errors */
#line 3063
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3063
  long cxp = (long) *((char**)xpp);
#line 3063

#line 3063
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3063
  /* sjl: manually stripmine so we can limit amount of
#line 3063
   * vector work space reserved to LOOPCNT elements. Also
#line 3063
   * makes vectorisation easy */
#line 3063
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3063
    ni=Min(nelems-j,LOOPCNT);
#line 3063
    if (realign) {
#line 3063
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 3063
      xp = tmp;
#line 3063
    } else {
#line 3063
      xp = (uint *) *xpp;
#line 3063
    }
#line 3063
   /* copy the next block */
#line 3063
#pragma cdir loopcnt=LOOPCNT
#line 3063
#pragma cdir shortloop
#line 3063
    for (i=0; i<ni; i++) {
#line 3063
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3063
     /* test for range errors (not always needed but do it anyway) */
#line 3063
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3063
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3063
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3063
    }
#line 3063
   /* update xpp and tp */
#line 3063
    if (realign) xp = (uint *) *xpp;
#line 3063
    xp += ni;
#line 3063
    tp += ni;
#line 3063
    *xpp = (void*)xp;
#line 3063
  }
#line 3063
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3063

#line 3063
#else   /* not SX */
#line 3063
	const char *xp = (const char *) *xpp;
#line 3063
	int status = ENOERR;
#line 3063

#line 3063
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3063
	{
#line 3063
		const int lstatus = ncx_get_uint_ulonglong(xp, tp);
#line 3063
		if(lstatus != ENOERR)
#line 3063
			status = lstatus;
#line 3063
	}
#line 3063

#line 3063
	*xpp = (const void *)xp;
#line 3063
	return status;
#line 3063
#  endif
#line 3063
}
#line 3063


#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_putn_uint_uint(void **xpp, size_t nelems, const unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_UINT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return ENOERR;
}
#else
int
#line 3079
ncx_putn_uint_uint(void **xpp, size_t nelems, const uint *tp)
#line 3079
{
#line 3079
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3079

#line 3079
 /* basic algorithm is:
#line 3079
  *   - ensure sane alignment of output data
#line 3079
  *   - copy (conversion happens automatically) input data
#line 3079
  *     to output
#line 3079
  *   - update tp to point at next unconverted input, and xpp to point
#line 3079
  *     at next location for converted output
#line 3079
  */
#line 3079
  long i, j, ni;
#line 3079
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3079
  uint *xp;
#line 3079
  int nrange = 0;         /* number of range errors */
#line 3079
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3079
  long cxp = (long) *((char**)xpp);
#line 3079

#line 3079
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3079
  /* sjl: manually stripmine so we can limit amount of
#line 3079
   * vector work space reserved to LOOPCNT elements. Also
#line 3079
   * makes vectorisation easy */
#line 3079
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3079
    ni=Min(nelems-j,LOOPCNT);
#line 3079
    if (realign) {
#line 3079
      xp = tmp;
#line 3079
    } else {
#line 3079
      xp = (uint *) *xpp;
#line 3079
    }
#line 3079
   /* copy the next block */
#line 3079
#pragma cdir loopcnt=LOOPCNT
#line 3079
#pragma cdir shortloop
#line 3079
    for (i=0; i<ni; i++) {
#line 3079
      /* the normal case: */
#line 3079
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3079
     /* test for range errors (not always needed but do it anyway) */
#line 3079
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3079
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3079
      nrange += tp[i] > X_UINT_MAX ;
#line 3079
    }
#line 3079
   /* copy workspace back if necessary */
#line 3079
    if (realign) {
#line 3079
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3079
      xp = (uint *) *xpp;
#line 3079
    }
#line 3079
   /* update xpp and tp */
#line 3079
    xp += ni;
#line 3079
    tp += ni;
#line 3079
    *xpp = (void*)xp;
#line 3079
  }
#line 3079
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3079

#line 3079
#else   /* not SX */
#line 3079

#line 3079
	char *xp = (char *) *xpp;
#line 3079
	int status = ENOERR;
#line 3079

#line 3079
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3079
	{
#line 3079
		int lstatus = ncx_put_uint_uint(xp, tp);
#line 3079
		if(lstatus != ENOERR)
#line 3079
			status = lstatus;
#line 3079
	}
#line 3079

#line 3079
	*xpp = (void *)xp;
#line 3079
	return status;
#line 3079
#endif
#line 3079
}
#line 3079

#endif
int
#line 3081
ncx_putn_uint_schar(void **xpp, size_t nelems, const schar *tp)
#line 3081
{
#line 3081
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3081

#line 3081
 /* basic algorithm is:
#line 3081
  *   - ensure sane alignment of output data
#line 3081
  *   - copy (conversion happens automatically) input data
#line 3081
  *     to output
#line 3081
  *   - update tp to point at next unconverted input, and xpp to point
#line 3081
  *     at next location for converted output
#line 3081
  */
#line 3081
  long i, j, ni;
#line 3081
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3081
  uint *xp;
#line 3081
  int nrange = 0;         /* number of range errors */
#line 3081
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3081
  long cxp = (long) *((char**)xpp);
#line 3081

#line 3081
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3081
  /* sjl: manually stripmine so we can limit amount of
#line 3081
   * vector work space reserved to LOOPCNT elements. Also
#line 3081
   * makes vectorisation easy */
#line 3081
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3081
    ni=Min(nelems-j,LOOPCNT);
#line 3081
    if (realign) {
#line 3081
      xp = tmp;
#line 3081
    } else {
#line 3081
      xp = (uint *) *xpp;
#line 3081
    }
#line 3081
   /* copy the next block */
#line 3081
#pragma cdir loopcnt=LOOPCNT
#line 3081
#pragma cdir shortloop
#line 3081
    for (i=0; i<ni; i++) {
#line 3081
      /* the normal case: */
#line 3081
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3081
     /* test for range errors (not always needed but do it anyway) */
#line 3081
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3081
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3081
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3081
    }
#line 3081
   /* copy workspace back if necessary */
#line 3081
    if (realign) {
#line 3081
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3081
      xp = (uint *) *xpp;
#line 3081
    }
#line 3081
   /* update xpp and tp */
#line 3081
    xp += ni;
#line 3081
    tp += ni;
#line 3081
    *xpp = (void*)xp;
#line 3081
  }
#line 3081
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3081

#line 3081
#else   /* not SX */
#line 3081

#line 3081
	char *xp = (char *) *xpp;
#line 3081
	int status = ENOERR;
#line 3081

#line 3081
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3081
	{
#line 3081
		int lstatus = ncx_put_uint_schar(xp, tp);
#line 3081
		if(lstatus != ENOERR)
#line 3081
			status = lstatus;
#line 3081
	}
#line 3081

#line 3081
	*xpp = (void *)xp;
#line 3081
	return status;
#line 3081
#endif
#line 3081
}
#line 3081

int
#line 3082
ncx_putn_uint_short(void **xpp, size_t nelems, const short *tp)
#line 3082
{
#line 3082
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3082

#line 3082
 /* basic algorithm is:
#line 3082
  *   - ensure sane alignment of output data
#line 3082
  *   - copy (conversion happens automatically) input data
#line 3082
  *     to output
#line 3082
  *   - update tp to point at next unconverted input, and xpp to point
#line 3082
  *     at next location for converted output
#line 3082
  */
#line 3082
  long i, j, ni;
#line 3082
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3082
  uint *xp;
#line 3082
  int nrange = 0;         /* number of range errors */
#line 3082
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3082
  long cxp = (long) *((char**)xpp);
#line 3082

#line 3082
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3082
  /* sjl: manually stripmine so we can limit amount of
#line 3082
   * vector work space reserved to LOOPCNT elements. Also
#line 3082
   * makes vectorisation easy */
#line 3082
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3082
    ni=Min(nelems-j,LOOPCNT);
#line 3082
    if (realign) {
#line 3082
      xp = tmp;
#line 3082
    } else {
#line 3082
      xp = (uint *) *xpp;
#line 3082
    }
#line 3082
   /* copy the next block */
#line 3082
#pragma cdir loopcnt=LOOPCNT
#line 3082
#pragma cdir shortloop
#line 3082
    for (i=0; i<ni; i++) {
#line 3082
      /* the normal case: */
#line 3082
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3082
     /* test for range errors (not always needed but do it anyway) */
#line 3082
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3082
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3082
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3082
    }
#line 3082
   /* copy workspace back if necessary */
#line 3082
    if (realign) {
#line 3082
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3082
      xp = (uint *) *xpp;
#line 3082
    }
#line 3082
   /* update xpp and tp */
#line 3082
    xp += ni;
#line 3082
    tp += ni;
#line 3082
    *xpp = (void*)xp;
#line 3082
  }
#line 3082
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3082

#line 3082
#else   /* not SX */
#line 3082

#line 3082
	char *xp = (char *) *xpp;
#line 3082
	int status = ENOERR;
#line 3082

#line 3082
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3082
	{
#line 3082
		int lstatus = ncx_put_uint_short(xp, tp);
#line 3082
		if(lstatus != ENOERR)
#line 3082
			status = lstatus;
#line 3082
	}
#line 3082

#line 3082
	*xpp = (void *)xp;
#line 3082
	return status;
#line 3082
#endif
#line 3082
}
#line 3082

int
#line 3083
ncx_putn_uint_int(void **xpp, size_t nelems, const int *tp)
#line 3083
{
#line 3083
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3083

#line 3083
 /* basic algorithm is:
#line 3083
  *   - ensure sane alignment of output data
#line 3083
  *   - copy (conversion happens automatically) input data
#line 3083
  *     to output
#line 3083
  *   - update tp to point at next unconverted input, and xpp to point
#line 3083
  *     at next location for converted output
#line 3083
  */
#line 3083
  long i, j, ni;
#line 3083
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3083
  uint *xp;
#line 3083
  int nrange = 0;         /* number of range errors */
#line 3083
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3083
  long cxp = (long) *((char**)xpp);
#line 3083

#line 3083
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3083
  /* sjl: manually stripmine so we can limit amount of
#line 3083
   * vector work space reserved to LOOPCNT elements. Also
#line 3083
   * makes vectorisation easy */
#line 3083
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3083
    ni=Min(nelems-j,LOOPCNT);
#line 3083
    if (realign) {
#line 3083
      xp = tmp;
#line 3083
    } else {
#line 3083
      xp = (uint *) *xpp;
#line 3083
    }
#line 3083
   /* copy the next block */
#line 3083
#pragma cdir loopcnt=LOOPCNT
#line 3083
#pragma cdir shortloop
#line 3083
    for (i=0; i<ni; i++) {
#line 3083
      /* the normal case: */
#line 3083
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3083
     /* test for range errors (not always needed but do it anyway) */
#line 3083
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3083
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3083
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3083
    }
#line 3083
   /* copy workspace back if necessary */
#line 3083
    if (realign) {
#line 3083
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3083
      xp = (uint *) *xpp;
#line 3083
    }
#line 3083
   /* update xpp and tp */
#line 3083
    xp += ni;
#line 3083
    tp += ni;
#line 3083
    *xpp = (void*)xp;
#line 3083
  }
#line 3083
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3083

#line 3083
#else   /* not SX */
#line 3083

#line 3083
	char *xp = (char *) *xpp;
#line 3083
	int status = ENOERR;
#line 3083

#line 3083
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3083
	{
#line 3083
		int lstatus = ncx_put_uint_int(xp, tp);
#line 3083
		if(lstatus != ENOERR)
#line 3083
			status = lstatus;
#line 3083
	}
#line 3083

#line 3083
	*xpp = (void *)xp;
#line 3083
	return status;
#line 3083
#endif
#line 3083
}
#line 3083

int
#line 3084
ncx_putn_uint_float(void **xpp, size_t nelems, const float *tp)
#line 3084
{
#line 3084
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3084

#line 3084
 /* basic algorithm is:
#line 3084
  *   - ensure sane alignment of output data
#line 3084
  *   - copy (conversion happens automatically) input data
#line 3084
  *     to output
#line 3084
  *   - update tp to point at next unconverted input, and xpp to point
#line 3084
  *     at next location for converted output
#line 3084
  */
#line 3084
  long i, j, ni;
#line 3084
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3084
  uint *xp;
#line 3084
  int nrange = 0;         /* number of range errors */
#line 3084
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3084
  long cxp = (long) *((char**)xpp);
#line 3084

#line 3084
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3084
  /* sjl: manually stripmine so we can limit amount of
#line 3084
   * vector work space reserved to LOOPCNT elements. Also
#line 3084
   * makes vectorisation easy */
#line 3084
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3084
    ni=Min(nelems-j,LOOPCNT);
#line 3084
    if (realign) {
#line 3084
      xp = tmp;
#line 3084
    } else {
#line 3084
      xp = (uint *) *xpp;
#line 3084
    }
#line 3084
   /* copy the next block */
#line 3084
#pragma cdir loopcnt=LOOPCNT
#line 3084
#pragma cdir shortloop
#line 3084
    for (i=0; i<ni; i++) {
#line 3084
      /* the normal case: */
#line 3084
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3084
     /* test for range errors (not always needed but do it anyway) */
#line 3084
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3084
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3084
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3084
    }
#line 3084
   /* copy workspace back if necessary */
#line 3084
    if (realign) {
#line 3084
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3084
      xp = (uint *) *xpp;
#line 3084
    }
#line 3084
   /* update xpp and tp */
#line 3084
    xp += ni;
#line 3084
    tp += ni;
#line 3084
    *xpp = (void*)xp;
#line 3084
  }
#line 3084
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3084

#line 3084
#else   /* not SX */
#line 3084

#line 3084
	char *xp = (char *) *xpp;
#line 3084
	int status = ENOERR;
#line 3084

#line 3084
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3084
	{
#line 3084
		int lstatus = ncx_put_uint_float(xp, tp);
#line 3084
		if(lstatus != ENOERR)
#line 3084
			status = lstatus;
#line 3084
	}
#line 3084

#line 3084
	*xpp = (void *)xp;
#line 3084
	return status;
#line 3084
#endif
#line 3084
}
#line 3084

int
#line 3085
ncx_putn_uint_double(void **xpp, size_t nelems, const double *tp)
#line 3085
{
#line 3085
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3085

#line 3085
 /* basic algorithm is:
#line 3085
  *   - ensure sane alignment of output data
#line 3085
  *   - copy (conversion happens automatically) input data
#line 3085
  *     to output
#line 3085
  *   - update tp to point at next unconverted input, and xpp to point
#line 3085
  *     at next location for converted output
#line 3085
  */
#line 3085
  long i, j, ni;
#line 3085
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3085
  uint *xp;
#line 3085
  int nrange = 0;         /* number of range errors */
#line 3085
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3085
  long cxp = (long) *((char**)xpp);
#line 3085

#line 3085
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3085
  /* sjl: manually stripmine so we can limit amount of
#line 3085
   * vector work space reserved to LOOPCNT elements. Also
#line 3085
   * makes vectorisation easy */
#line 3085
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3085
    ni=Min(nelems-j,LOOPCNT);
#line 3085
    if (realign) {
#line 3085
      xp = tmp;
#line 3085
    } else {
#line 3085
      xp = (uint *) *xpp;
#line 3085
    }
#line 3085
   /* copy the next block */
#line 3085
#pragma cdir loopcnt=LOOPCNT
#line 3085
#pragma cdir shortloop
#line 3085
    for (i=0; i<ni; i++) {
#line 3085
      /* the normal case: */
#line 3085
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3085
     /* test for range errors (not always needed but do it anyway) */
#line 3085
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3085
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3085
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3085
    }
#line 3085
   /* copy workspace back if necessary */
#line 3085
    if (realign) {
#line 3085
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3085
      xp = (uint *) *xpp;
#line 3085
    }
#line 3085
   /* update xpp and tp */
#line 3085
    xp += ni;
#line 3085
    tp += ni;
#line 3085
    *xpp = (void*)xp;
#line 3085
  }
#line 3085
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3085

#line 3085
#else   /* not SX */
#line 3085

#line 3085
	char *xp = (char *) *xpp;
#line 3085
	int status = ENOERR;
#line 3085

#line 3085
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3085
	{
#line 3085
		int lstatus = ncx_put_uint_double(xp, tp);
#line 3085
		if(lstatus != ENOERR)
#line 3085
			status = lstatus;
#line 3085
	}
#line 3085

#line 3085
	*xpp = (void *)xp;
#line 3085
	return status;
#line 3085
#endif
#line 3085
}
#line 3085

int
#line 3086
ncx_putn_uint_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3086
{
#line 3086
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3086

#line 3086
 /* basic algorithm is:
#line 3086
  *   - ensure sane alignment of output data
#line 3086
  *   - copy (conversion happens automatically) input data
#line 3086
  *     to output
#line 3086
  *   - update tp to point at next unconverted input, and xpp to point
#line 3086
  *     at next location for converted output
#line 3086
  */
#line 3086
  long i, j, ni;
#line 3086
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3086
  uint *xp;
#line 3086
  int nrange = 0;         /* number of range errors */
#line 3086
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3086
  long cxp = (long) *((char**)xpp);
#line 3086

#line 3086
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3086
  /* sjl: manually stripmine so we can limit amount of
#line 3086
   * vector work space reserved to LOOPCNT elements. Also
#line 3086
   * makes vectorisation easy */
#line 3086
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3086
    ni=Min(nelems-j,LOOPCNT);
#line 3086
    if (realign) {
#line 3086
      xp = tmp;
#line 3086
    } else {
#line 3086
      xp = (uint *) *xpp;
#line 3086
    }
#line 3086
   /* copy the next block */
#line 3086
#pragma cdir loopcnt=LOOPCNT
#line 3086
#pragma cdir shortloop
#line 3086
    for (i=0; i<ni; i++) {
#line 3086
      /* the normal case: */
#line 3086
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3086
     /* test for range errors (not always needed but do it anyway) */
#line 3086
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3086
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3086
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 3086
    }
#line 3086
   /* copy workspace back if necessary */
#line 3086
    if (realign) {
#line 3086
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3086
      xp = (uint *) *xpp;
#line 3086
    }
#line 3086
   /* update xpp and tp */
#line 3086
    xp += ni;
#line 3086
    tp += ni;
#line 3086
    *xpp = (void*)xp;
#line 3086
  }
#line 3086
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3086

#line 3086
#else   /* not SX */
#line 3086

#line 3086
	char *xp = (char *) *xpp;
#line 3086
	int status = ENOERR;
#line 3086

#line 3086
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3086
	{
#line 3086
		int lstatus = ncx_put_uint_longlong(xp, tp);
#line 3086
		if(lstatus != ENOERR)
#line 3086
			status = lstatus;
#line 3086
	}
#line 3086

#line 3086
	*xpp = (void *)xp;
#line 3086
	return status;
#line 3086
#endif
#line 3086
}
#line 3086

int
#line 3087
ncx_putn_uint_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3087
{
#line 3087
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3087

#line 3087
 /* basic algorithm is:
#line 3087
  *   - ensure sane alignment of output data
#line 3087
  *   - copy (conversion happens automatically) input data
#line 3087
  *     to output
#line 3087
  *   - update tp to point at next unconverted input, and xpp to point
#line 3087
  *     at next location for converted output
#line 3087
  */
#line 3087
  long i, j, ni;
#line 3087
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3087
  uint *xp;
#line 3087
  int nrange = 0;         /* number of range errors */
#line 3087
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3087
  long cxp = (long) *((char**)xpp);
#line 3087

#line 3087
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3087
  /* sjl: manually stripmine so we can limit amount of
#line 3087
   * vector work space reserved to LOOPCNT elements. Also
#line 3087
   * makes vectorisation easy */
#line 3087
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3087
    ni=Min(nelems-j,LOOPCNT);
#line 3087
    if (realign) {
#line 3087
      xp = tmp;
#line 3087
    } else {
#line 3087
      xp = (uint *) *xpp;
#line 3087
    }
#line 3087
   /* copy the next block */
#line 3087
#pragma cdir loopcnt=LOOPCNT
#line 3087
#pragma cdir shortloop
#line 3087
    for (i=0; i<ni; i++) {
#line 3087
      /* the normal case: */
#line 3087
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3087
     /* test for range errors (not always needed but do it anyway) */
#line 3087
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3087
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3087
      nrange += tp[i] > X_UINT_MAX ;
#line 3087
    }
#line 3087
   /* copy workspace back if necessary */
#line 3087
    if (realign) {
#line 3087
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3087
      xp = (uint *) *xpp;
#line 3087
    }
#line 3087
   /* update xpp and tp */
#line 3087
    xp += ni;
#line 3087
    tp += ni;
#line 3087
    *xpp = (void*)xp;
#line 3087
  }
#line 3087
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3087

#line 3087
#else   /* not SX */
#line 3087

#line 3087
	char *xp = (char *) *xpp;
#line 3087
	int status = ENOERR;
#line 3087

#line 3087
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3087
	{
#line 3087
		int lstatus = ncx_put_uint_uchar(xp, tp);
#line 3087
		if(lstatus != ENOERR)
#line 3087
			status = lstatus;
#line 3087
	}
#line 3087

#line 3087
	*xpp = (void *)xp;
#line 3087
	return status;
#line 3087
#endif
#line 3087
}
#line 3087

int
#line 3088
ncx_putn_uint_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3088
{
#line 3088
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3088

#line 3088
 /* basic algorithm is:
#line 3088
  *   - ensure sane alignment of output data
#line 3088
  *   - copy (conversion happens automatically) input data
#line 3088
  *     to output
#line 3088
  *   - update tp to point at next unconverted input, and xpp to point
#line 3088
  *     at next location for converted output
#line 3088
  */
#line 3088
  long i, j, ni;
#line 3088
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3088
  uint *xp;
#line 3088
  int nrange = 0;         /* number of range errors */
#line 3088
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3088
  long cxp = (long) *((char**)xpp);
#line 3088

#line 3088
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3088
  /* sjl: manually stripmine so we can limit amount of
#line 3088
   * vector work space reserved to LOOPCNT elements. Also
#line 3088
   * makes vectorisation easy */
#line 3088
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3088
    ni=Min(nelems-j,LOOPCNT);
#line 3088
    if (realign) {
#line 3088
      xp = tmp;
#line 3088
    } else {
#line 3088
      xp = (uint *) *xpp;
#line 3088
    }
#line 3088
   /* copy the next block */
#line 3088
#pragma cdir loopcnt=LOOPCNT
#line 3088
#pragma cdir shortloop
#line 3088
    for (i=0; i<ni; i++) {
#line 3088
      /* the normal case: */
#line 3088
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3088
     /* test for range errors (not always needed but do it anyway) */
#line 3088
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3088
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3088
      nrange += tp[i] > X_UINT_MAX ;
#line 3088
    }
#line 3088
   /* copy workspace back if necessary */
#line 3088
    if (realign) {
#line 3088
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3088
      xp = (uint *) *xpp;
#line 3088
    }
#line 3088
   /* update xpp and tp */
#line 3088
    xp += ni;
#line 3088
    tp += ni;
#line 3088
    *xpp = (void*)xp;
#line 3088
  }
#line 3088
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3088

#line 3088
#else   /* not SX */
#line 3088

#line 3088
	char *xp = (char *) *xpp;
#line 3088
	int status = ENOERR;
#line 3088

#line 3088
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3088
	{
#line 3088
		int lstatus = ncx_put_uint_ushort(xp, tp);
#line 3088
		if(lstatus != ENOERR)
#line 3088
			status = lstatus;
#line 3088
	}
#line 3088

#line 3088
	*xpp = (void *)xp;
#line 3088
	return status;
#line 3088
#endif
#line 3088
}
#line 3088

int
#line 3089
ncx_putn_uint_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3089
{
#line 3089
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 3089

#line 3089
 /* basic algorithm is:
#line 3089
  *   - ensure sane alignment of output data
#line 3089
  *   - copy (conversion happens automatically) input data
#line 3089
  *     to output
#line 3089
  *   - update tp to point at next unconverted input, and xpp to point
#line 3089
  *     at next location for converted output
#line 3089
  */
#line 3089
  long i, j, ni;
#line 3089
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 3089
  uint *xp;
#line 3089
  int nrange = 0;         /* number of range errors */
#line 3089
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3089
  long cxp = (long) *((char**)xpp);
#line 3089

#line 3089
  realign = (cxp & 7) % SIZEOF_UINT;
#line 3089
  /* sjl: manually stripmine so we can limit amount of
#line 3089
   * vector work space reserved to LOOPCNT elements. Also
#line 3089
   * makes vectorisation easy */
#line 3089
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3089
    ni=Min(nelems-j,LOOPCNT);
#line 3089
    if (realign) {
#line 3089
      xp = tmp;
#line 3089
    } else {
#line 3089
      xp = (uint *) *xpp;
#line 3089
    }
#line 3089
   /* copy the next block */
#line 3089
#pragma cdir loopcnt=LOOPCNT
#line 3089
#pragma cdir shortloop
#line 3089
    for (i=0; i<ni; i++) {
#line 3089
      /* the normal case: */
#line 3089
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 3089
     /* test for range errors (not always needed but do it anyway) */
#line 3089
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3089
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3089
      nrange += tp[i] > X_UINT_MAX ;
#line 3089
    }
#line 3089
   /* copy workspace back if necessary */
#line 3089
    if (realign) {
#line 3089
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 3089
      xp = (uint *) *xpp;
#line 3089
    }
#line 3089
   /* update xpp and tp */
#line 3089
    xp += ni;
#line 3089
    tp += ni;
#line 3089
    *xpp = (void*)xp;
#line 3089
  }
#line 3089
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3089

#line 3089
#else   /* not SX */
#line 3089

#line 3089
	char *xp = (char *) *xpp;
#line 3089
	int status = ENOERR;
#line 3089

#line 3089
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 3089
	{
#line 3089
		int lstatus = ncx_put_uint_ulonglong(xp, tp);
#line 3089
		if(lstatus != ENOERR)
#line 3089
			status = lstatus;
#line 3089
	}
#line 3089

#line 3089
	*xpp = (void *)xp;
#line 3089
	return status;
#line 3089
#endif
#line 3089
}
#line 3089


/* float ---------------------------------------------------------------------*/
#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(float));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return ENOERR;
}
#elif vax
int
ncx_getn_float_float(const void **xpp, size_t nfloats, float *ip)
{
	float *const end = ip + nfloats;

	while(ip < end)
	{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 3113
		const struct ieee_single *const isp =
#line 3113
			 (const struct ieee_single *) (*xpp);
#line 3113
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 3113

#line 3113
		switch(exp) {
#line 3113
		case 0 :
#line 3113
			/* ieee subnormal */
#line 3113
			if(isp->mant_hi == min.ieee.mant_hi
#line 3113
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 3113
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 3113
			{
#line 3113
				*vsp = min.s;
#line 3113
			}
#line 3113
			else
#line 3113
			{
#line 3113
				unsigned mantissa = (isp->mant_hi << 16)
#line 3113
					 | isp->mant_lo_hi << 8
#line 3113
					 | isp->mant_lo_lo;
#line 3113
				unsigned tmp = mantissa >> 20;
#line 3113
				if(tmp >= 4) {
#line 3113
					vsp->exp = 2;
#line 3113
				} else if (tmp >= 2) {
#line 3113
					vsp->exp = 1;
#line 3113
				} else {
#line 3113
					*vsp = min.s;
#line 3113
					break;
#line 3113
				} /* else */
#line 3113
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 3113
				tmp <<= 3 - vsp->exp;
#line 3113
				vsp->mantissa2 = tmp;
#line 3113
				vsp->mantissa1 = (tmp >> 16);
#line 3113
			}
#line 3113
			break;
#line 3113
		case 0xfe :
#line 3113
		case 0xff :
#line 3113
			*vsp = max.s;
#line 3113
			break;
#line 3113
		default :
#line 3113
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 3113
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 3113
			vsp->mantissa1 = isp->mant_hi;
#line 3113
		}
#line 3113

#line 3113
		vsp->sign = isp->sign;
#line 3113


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return ENOERR;
}
#else
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
	const char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		const int lstatus = ncx_get_float_float(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}

#endif
int
#line 3139
ncx_getn_float_schar(const void **xpp, size_t nelems, schar *tp)
#line 3139
{
#line 3139
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3139

#line 3139
 /* basic algorithm is:
#line 3139
  *   - ensure sane alignment of input data
#line 3139
  *   - copy (conversion happens automatically) input data
#line 3139
  *     to output
#line 3139
  *   - update xpp to point at next unconverted input, and tp to point
#line 3139
  *     at next location for converted output
#line 3139
  */
#line 3139
  long i, j, ni;
#line 3139
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3139
  float *xp;
#line 3139
  int nrange = 0;         /* number of range errors */
#line 3139
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3139
  long cxp = (long) *((char**)xpp);
#line 3139

#line 3139
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3139
  /* sjl: manually stripmine so we can limit amount of
#line 3139
   * vector work space reserved to LOOPCNT elements. Also
#line 3139
   * makes vectorisation easy */
#line 3139
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3139
    ni=Min(nelems-j,LOOPCNT);
#line 3139
    if (realign) {
#line 3139
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3139
      xp = tmp;
#line 3139
    } else {
#line 3139
      xp = (float *) *xpp;
#line 3139
    }
#line 3139
   /* copy the next block */
#line 3139
#pragma cdir loopcnt=LOOPCNT
#line 3139
#pragma cdir shortloop
#line 3139
    for (i=0; i<ni; i++) {
#line 3139
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3139
     /* test for range errors (not always needed but do it anyway) */
#line 3139
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3139
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3139
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3139
    }
#line 3139
   /* update xpp and tp */
#line 3139
    if (realign) xp = (float *) *xpp;
#line 3139
    xp += ni;
#line 3139
    tp += ni;
#line 3139
    *xpp = (void*)xp;
#line 3139
  }
#line 3139
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3139

#line 3139
#else   /* not SX */
#line 3139
	const char *xp = (const char *) *xpp;
#line 3139
	int status = ENOERR;
#line 3139

#line 3139
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3139
	{
#line 3139
		const int lstatus = ncx_get_float_schar(xp, tp);
#line 3139
		if(lstatus != ENOERR)
#line 3139
			status = lstatus;
#line 3139
	}
#line 3139

#line 3139
	*xpp = (const void *)xp;
#line 3139
	return status;
#line 3139
#  endif
#line 3139
}
#line 3139

int
#line 3140
ncx_getn_float_short(const void **xpp, size_t nelems, short *tp)
#line 3140
{
#line 3140
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3140

#line 3140
 /* basic algorithm is:
#line 3140
  *   - ensure sane alignment of input data
#line 3140
  *   - copy (conversion happens automatically) input data
#line 3140
  *     to output
#line 3140
  *   - update xpp to point at next unconverted input, and tp to point
#line 3140
  *     at next location for converted output
#line 3140
  */
#line 3140
  long i, j, ni;
#line 3140
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3140
  float *xp;
#line 3140
  int nrange = 0;         /* number of range errors */
#line 3140
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3140
  long cxp = (long) *((char**)xpp);
#line 3140

#line 3140
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3140
  /* sjl: manually stripmine so we can limit amount of
#line 3140
   * vector work space reserved to LOOPCNT elements. Also
#line 3140
   * makes vectorisation easy */
#line 3140
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3140
    ni=Min(nelems-j,LOOPCNT);
#line 3140
    if (realign) {
#line 3140
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3140
      xp = tmp;
#line 3140
    } else {
#line 3140
      xp = (float *) *xpp;
#line 3140
    }
#line 3140
   /* copy the next block */
#line 3140
#pragma cdir loopcnt=LOOPCNT
#line 3140
#pragma cdir shortloop
#line 3140
    for (i=0; i<ni; i++) {
#line 3140
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3140
     /* test for range errors (not always needed but do it anyway) */
#line 3140
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3140
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3140
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3140
    }
#line 3140
   /* update xpp and tp */
#line 3140
    if (realign) xp = (float *) *xpp;
#line 3140
    xp += ni;
#line 3140
    tp += ni;
#line 3140
    *xpp = (void*)xp;
#line 3140
  }
#line 3140
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3140

#line 3140
#else   /* not SX */
#line 3140
	const char *xp = (const char *) *xpp;
#line 3140
	int status = ENOERR;
#line 3140

#line 3140
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3140
	{
#line 3140
		const int lstatus = ncx_get_float_short(xp, tp);
#line 3140
		if(lstatus != ENOERR)
#line 3140
			status = lstatus;
#line 3140
	}
#line 3140

#line 3140
	*xpp = (const void *)xp;
#line 3140
	return status;
#line 3140
#  endif
#line 3140
}
#line 3140

int
#line 3141
ncx_getn_float_int(const void **xpp, size_t nelems, int *tp)
#line 3141
{
#line 3141
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3141

#line 3141
 /* basic algorithm is:
#line 3141
  *   - ensure sane alignment of input data
#line 3141
  *   - copy (conversion happens automatically) input data
#line 3141
  *     to output
#line 3141
  *   - update xpp to point at next unconverted input, and tp to point
#line 3141
  *     at next location for converted output
#line 3141
  */
#line 3141
  long i, j, ni;
#line 3141
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3141
  float *xp;
#line 3141
  int nrange = 0;         /* number of range errors */
#line 3141
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3141
  long cxp = (long) *((char**)xpp);
#line 3141

#line 3141
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3141
  /* sjl: manually stripmine so we can limit amount of
#line 3141
   * vector work space reserved to LOOPCNT elements. Also
#line 3141
   * makes vectorisation easy */
#line 3141
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3141
    ni=Min(nelems-j,LOOPCNT);
#line 3141
    if (realign) {
#line 3141
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3141
      xp = tmp;
#line 3141
    } else {
#line 3141
      xp = (float *) *xpp;
#line 3141
    }
#line 3141
   /* copy the next block */
#line 3141
#pragma cdir loopcnt=LOOPCNT
#line 3141
#pragma cdir shortloop
#line 3141
    for (i=0; i<ni; i++) {
#line 3141
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3141
     /* test for range errors (not always needed but do it anyway) */
#line 3141
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3141
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3141
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3141
    }
#line 3141
   /* update xpp and tp */
#line 3141
    if (realign) xp = (float *) *xpp;
#line 3141
    xp += ni;
#line 3141
    tp += ni;
#line 3141
    *xpp = (void*)xp;
#line 3141
  }
#line 3141
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3141

#line 3141
#else   /* not SX */
#line 3141
	const char *xp = (const char *) *xpp;
#line 3141
	int status = ENOERR;
#line 3141

#line 3141
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3141
	{
#line 3141
		const int lstatus = ncx_get_float_int(xp, tp);
#line 3141
		if(lstatus != ENOERR)
#line 3141
			status = lstatus;
#line 3141
	}
#line 3141

#line 3141
	*xpp = (const void *)xp;
#line 3141
	return status;
#line 3141
#  endif
#line 3141
}
#line 3141

int
#line 3142
ncx_getn_float_double(const void **xpp, size_t nelems, double *tp)
#line 3142
{
#line 3142
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3142

#line 3142
 /* basic algorithm is:
#line 3142
  *   - ensure sane alignment of input data
#line 3142
  *   - copy (conversion happens automatically) input data
#line 3142
  *     to output
#line 3142
  *   - update xpp to point at next unconverted input, and tp to point
#line 3142
  *     at next location for converted output
#line 3142
  */
#line 3142
  long i, j, ni;
#line 3142
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3142
  float *xp;
#line 3142
  int nrange = 0;         /* number of range errors */
#line 3142
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3142
  long cxp = (long) *((char**)xpp);
#line 3142

#line 3142
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3142
  /* sjl: manually stripmine so we can limit amount of
#line 3142
   * vector work space reserved to LOOPCNT elements. Also
#line 3142
   * makes vectorisation easy */
#line 3142
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3142
    ni=Min(nelems-j,LOOPCNT);
#line 3142
    if (realign) {
#line 3142
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3142
      xp = tmp;
#line 3142
    } else {
#line 3142
      xp = (float *) *xpp;
#line 3142
    }
#line 3142
   /* copy the next block */
#line 3142
#pragma cdir loopcnt=LOOPCNT
#line 3142
#pragma cdir shortloop
#line 3142
    for (i=0; i<ni; i++) {
#line 3142
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3142
     /* test for range errors (not always needed but do it anyway) */
#line 3142
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3142
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3142
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3142
    }
#line 3142
   /* update xpp and tp */
#line 3142
    if (realign) xp = (float *) *xpp;
#line 3142
    xp += ni;
#line 3142
    tp += ni;
#line 3142
    *xpp = (void*)xp;
#line 3142
  }
#line 3142
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3142

#line 3142
#else   /* not SX */
#line 3142
	const char *xp = (const char *) *xpp;
#line 3142
	int status = ENOERR;
#line 3142

#line 3142
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3142
	{
#line 3142
		const int lstatus = ncx_get_float_double(xp, tp);
#line 3142
		if(lstatus != ENOERR)
#line 3142
			status = lstatus;
#line 3142
	}
#line 3142

#line 3142
	*xpp = (const void *)xp;
#line 3142
	return status;
#line 3142
#  endif
#line 3142
}
#line 3142

int
#line 3143
ncx_getn_float_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3143
{
#line 3143
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3143

#line 3143
 /* basic algorithm is:
#line 3143
  *   - ensure sane alignment of input data
#line 3143
  *   - copy (conversion happens automatically) input data
#line 3143
  *     to output
#line 3143
  *   - update xpp to point at next unconverted input, and tp to point
#line 3143
  *     at next location for converted output
#line 3143
  */
#line 3143
  long i, j, ni;
#line 3143
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3143
  float *xp;
#line 3143
  int nrange = 0;         /* number of range errors */
#line 3143
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3143
  long cxp = (long) *((char**)xpp);
#line 3143

#line 3143
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3143
  /* sjl: manually stripmine so we can limit amount of
#line 3143
   * vector work space reserved to LOOPCNT elements. Also
#line 3143
   * makes vectorisation easy */
#line 3143
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3143
    ni=Min(nelems-j,LOOPCNT);
#line 3143
    if (realign) {
#line 3143
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3143
      xp = tmp;
#line 3143
    } else {
#line 3143
      xp = (float *) *xpp;
#line 3143
    }
#line 3143
   /* copy the next block */
#line 3143
#pragma cdir loopcnt=LOOPCNT
#line 3143
#pragma cdir shortloop
#line 3143
    for (i=0; i<ni; i++) {
#line 3143
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3143
     /* test for range errors (not always needed but do it anyway) */
#line 3143
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3143
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3143
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3143
    }
#line 3143
   /* update xpp and tp */
#line 3143
    if (realign) xp = (float *) *xpp;
#line 3143
    xp += ni;
#line 3143
    tp += ni;
#line 3143
    *xpp = (void*)xp;
#line 3143
  }
#line 3143
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3143

#line 3143
#else   /* not SX */
#line 3143
	const char *xp = (const char *) *xpp;
#line 3143
	int status = ENOERR;
#line 3143

#line 3143
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3143
	{
#line 3143
		const int lstatus = ncx_get_float_longlong(xp, tp);
#line 3143
		if(lstatus != ENOERR)
#line 3143
			status = lstatus;
#line 3143
	}
#line 3143

#line 3143
	*xpp = (const void *)xp;
#line 3143
	return status;
#line 3143
#  endif
#line 3143
}
#line 3143

int
#line 3144
ncx_getn_float_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3144
{
#line 3144
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3144

#line 3144
 /* basic algorithm is:
#line 3144
  *   - ensure sane alignment of input data
#line 3144
  *   - copy (conversion happens automatically) input data
#line 3144
  *     to output
#line 3144
  *   - update xpp to point at next unconverted input, and tp to point
#line 3144
  *     at next location for converted output
#line 3144
  */
#line 3144
  long i, j, ni;
#line 3144
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3144
  float *xp;
#line 3144
  int nrange = 0;         /* number of range errors */
#line 3144
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3144
  long cxp = (long) *((char**)xpp);
#line 3144

#line 3144
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3144
  /* sjl: manually stripmine so we can limit amount of
#line 3144
   * vector work space reserved to LOOPCNT elements. Also
#line 3144
   * makes vectorisation easy */
#line 3144
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3144
    ni=Min(nelems-j,LOOPCNT);
#line 3144
    if (realign) {
#line 3144
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3144
      xp = tmp;
#line 3144
    } else {
#line 3144
      xp = (float *) *xpp;
#line 3144
    }
#line 3144
   /* copy the next block */
#line 3144
#pragma cdir loopcnt=LOOPCNT
#line 3144
#pragma cdir shortloop
#line 3144
    for (i=0; i<ni; i++) {
#line 3144
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3144
     /* test for range errors (not always needed but do it anyway) */
#line 3144
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3144
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3144
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3144
    }
#line 3144
   /* update xpp and tp */
#line 3144
    if (realign) xp = (float *) *xpp;
#line 3144
    xp += ni;
#line 3144
    tp += ni;
#line 3144
    *xpp = (void*)xp;
#line 3144
  }
#line 3144
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3144

#line 3144
#else   /* not SX */
#line 3144
	const char *xp = (const char *) *xpp;
#line 3144
	int status = ENOERR;
#line 3144

#line 3144
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3144
	{
#line 3144
		const int lstatus = ncx_get_float_ushort(xp, tp);
#line 3144
		if(lstatus != ENOERR)
#line 3144
			status = lstatus;
#line 3144
	}
#line 3144

#line 3144
	*xpp = (const void *)xp;
#line 3144
	return status;
#line 3144
#  endif
#line 3144
}
#line 3144

int
#line 3145
ncx_getn_float_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3145
{
#line 3145
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3145

#line 3145
 /* basic algorithm is:
#line 3145
  *   - ensure sane alignment of input data
#line 3145
  *   - copy (conversion happens automatically) input data
#line 3145
  *     to output
#line 3145
  *   - update xpp to point at next unconverted input, and tp to point
#line 3145
  *     at next location for converted output
#line 3145
  */
#line 3145
  long i, j, ni;
#line 3145
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3145
  float *xp;
#line 3145
  int nrange = 0;         /* number of range errors */
#line 3145
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3145
  long cxp = (long) *((char**)xpp);
#line 3145

#line 3145
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3145
  /* sjl: manually stripmine so we can limit amount of
#line 3145
   * vector work space reserved to LOOPCNT elements. Also
#line 3145
   * makes vectorisation easy */
#line 3145
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3145
    ni=Min(nelems-j,LOOPCNT);
#line 3145
    if (realign) {
#line 3145
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3145
      xp = tmp;
#line 3145
    } else {
#line 3145
      xp = (float *) *xpp;
#line 3145
    }
#line 3145
   /* copy the next block */
#line 3145
#pragma cdir loopcnt=LOOPCNT
#line 3145
#pragma cdir shortloop
#line 3145
    for (i=0; i<ni; i++) {
#line 3145
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3145
     /* test for range errors (not always needed but do it anyway) */
#line 3145
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3145
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3145
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3145
    }
#line 3145
   /* update xpp and tp */
#line 3145
    if (realign) xp = (float *) *xpp;
#line 3145
    xp += ni;
#line 3145
    tp += ni;
#line 3145
    *xpp = (void*)xp;
#line 3145
  }
#line 3145
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3145

#line 3145
#else   /* not SX */
#line 3145
	const char *xp = (const char *) *xpp;
#line 3145
	int status = ENOERR;
#line 3145

#line 3145
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3145
	{
#line 3145
		const int lstatus = ncx_get_float_uchar(xp, tp);
#line 3145
		if(lstatus != ENOERR)
#line 3145
			status = lstatus;
#line 3145
	}
#line 3145

#line 3145
	*xpp = (const void *)xp;
#line 3145
	return status;
#line 3145
#  endif
#line 3145
}
#line 3145

int
#line 3146
ncx_getn_float_uint(const void **xpp, size_t nelems, uint *tp)
#line 3146
{
#line 3146
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3146

#line 3146
 /* basic algorithm is:
#line 3146
  *   - ensure sane alignment of input data
#line 3146
  *   - copy (conversion happens automatically) input data
#line 3146
  *     to output
#line 3146
  *   - update xpp to point at next unconverted input, and tp to point
#line 3146
  *     at next location for converted output
#line 3146
  */
#line 3146
  long i, j, ni;
#line 3146
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3146
  float *xp;
#line 3146
  int nrange = 0;         /* number of range errors */
#line 3146
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3146
  long cxp = (long) *((char**)xpp);
#line 3146

#line 3146
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3146
  /* sjl: manually stripmine so we can limit amount of
#line 3146
   * vector work space reserved to LOOPCNT elements. Also
#line 3146
   * makes vectorisation easy */
#line 3146
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3146
    ni=Min(nelems-j,LOOPCNT);
#line 3146
    if (realign) {
#line 3146
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3146
      xp = tmp;
#line 3146
    } else {
#line 3146
      xp = (float *) *xpp;
#line 3146
    }
#line 3146
   /* copy the next block */
#line 3146
#pragma cdir loopcnt=LOOPCNT
#line 3146
#pragma cdir shortloop
#line 3146
    for (i=0; i<ni; i++) {
#line 3146
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3146
     /* test for range errors (not always needed but do it anyway) */
#line 3146
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3146
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3146
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3146
    }
#line 3146
   /* update xpp and tp */
#line 3146
    if (realign) xp = (float *) *xpp;
#line 3146
    xp += ni;
#line 3146
    tp += ni;
#line 3146
    *xpp = (void*)xp;
#line 3146
  }
#line 3146
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3146

#line 3146
#else   /* not SX */
#line 3146
	const char *xp = (const char *) *xpp;
#line 3146
	int status = ENOERR;
#line 3146

#line 3146
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3146
	{
#line 3146
		const int lstatus = ncx_get_float_uint(xp, tp);
#line 3146
		if(lstatus != ENOERR)
#line 3146
			status = lstatus;
#line 3146
	}
#line 3146

#line 3146
	*xpp = (const void *)xp;
#line 3146
	return status;
#line 3146
#  endif
#line 3146
}
#line 3146

int
#line 3147
ncx_getn_float_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3147
{
#line 3147
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3147

#line 3147
 /* basic algorithm is:
#line 3147
  *   - ensure sane alignment of input data
#line 3147
  *   - copy (conversion happens automatically) input data
#line 3147
  *     to output
#line 3147
  *   - update xpp to point at next unconverted input, and tp to point
#line 3147
  *     at next location for converted output
#line 3147
  */
#line 3147
  long i, j, ni;
#line 3147
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3147
  float *xp;
#line 3147
  int nrange = 0;         /* number of range errors */
#line 3147
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3147
  long cxp = (long) *((char**)xpp);
#line 3147

#line 3147
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3147
  /* sjl: manually stripmine so we can limit amount of
#line 3147
   * vector work space reserved to LOOPCNT elements. Also
#line 3147
   * makes vectorisation easy */
#line 3147
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3147
    ni=Min(nelems-j,LOOPCNT);
#line 3147
    if (realign) {
#line 3147
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3147
      xp = tmp;
#line 3147
    } else {
#line 3147
      xp = (float *) *xpp;
#line 3147
    }
#line 3147
   /* copy the next block */
#line 3147
#pragma cdir loopcnt=LOOPCNT
#line 3147
#pragma cdir shortloop
#line 3147
    for (i=0; i<ni; i++) {
#line 3147
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3147
     /* test for range errors (not always needed but do it anyway) */
#line 3147
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3147
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3147
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3147
    }
#line 3147
   /* update xpp and tp */
#line 3147
    if (realign) xp = (float *) *xpp;
#line 3147
    xp += ni;
#line 3147
    tp += ni;
#line 3147
    *xpp = (void*)xp;
#line 3147
  }
#line 3147
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3147

#line 3147
#else   /* not SX */
#line 3147
	const char *xp = (const char *) *xpp;
#line 3147
	int status = ENOERR;
#line 3147

#line 3147
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3147
	{
#line 3147
		const int lstatus = ncx_get_float_ulonglong(xp, tp);
#line 3147
		if(lstatus != ENOERR)
#line 3147
			status = lstatus;
#line 3147
	}
#line 3147

#line 3147
	*xpp = (const void *)xp;
#line 3147
	return status;
#line 3147
#  endif
#line 3147
}
#line 3147


#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_FLOAT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return ENOERR;
}
#elif vax
int
ncx_putn_float_float(void **xpp, size_t nfloats, const float *ip)
{
	const float *const end = ip + nfloats;

	while(ip < end)
	{
		const struct vax_single *const vsp =
#line 3170
			 (const struct vax_single *)ip;
#line 3170
		struct ieee_single *const isp = (struct ieee_single *) (*xpp);
#line 3170

#line 3170
		switch(vsp->exp){
#line 3170
		case 0 :
#line 3170
			/* all vax float with zero exponent map to zero */
#line 3170
			*isp = min.ieee;
#line 3170
			break;
#line 3170
		case 2 :
#line 3170
		case 1 :
#line 3170
		{
#line 3170
			/* These will map to subnormals */
#line 3170
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 3170
					 | vsp->mantissa2;
#line 3170
			mantissa >>= 3 - vsp->exp;
#line 3170
			mantissa += (1 << (20 + vsp->exp));
#line 3170
			isp->mant_lo_lo = mantissa;
#line 3170
			isp->mant_lo_hi = mantissa >> 8;
#line 3170
			isp->mant_hi = mantissa >> 16;
#line 3170
			isp->exp_lo = 0;
#line 3170
			isp->exp_hi = 0;
#line 3170
		}
#line 3170
			break;
#line 3170
		case 0xff : /* max.s.exp */
#line 3170
			if( vsp->mantissa2 == max.s.mantissa2
#line 3170
				&& vsp->mantissa1 == max.s.mantissa1)
#line 3170
			{
#line 3170
				/* map largest vax float to ieee infinity */
#line 3170
				*isp = max.ieee;
#line 3170
				break;
#line 3170
			} /* else, fall thru */
#line 3170
		default :
#line 3170
		{
#line 3170
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 3170
			isp->exp_hi = exp >> 1;
#line 3170
			isp->exp_lo = exp;
#line 3170
			isp->mant_lo_lo = vsp->mantissa2;
#line 3170
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 3170
			isp->mant_hi = vsp->mantissa1;
#line 3170
		}
#line 3170
		}
#line 3170

#line 3170
		isp->sign = vsp->sign;
#line 3170


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return ENOERR;
}
#else
int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp)
{
	char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		int lstatus = ncx_put_float_float(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3195
ncx_putn_float_schar(void **xpp, size_t nelems, const schar *tp)
#line 3195
{
#line 3195
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3195

#line 3195
 /* basic algorithm is:
#line 3195
  *   - ensure sane alignment of output data
#line 3195
  *   - copy (conversion happens automatically) input data
#line 3195
  *     to output
#line 3195
  *   - update tp to point at next unconverted input, and xpp to point
#line 3195
  *     at next location for converted output
#line 3195
  */
#line 3195
  long i, j, ni;
#line 3195
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3195
  float *xp;
#line 3195
  int nrange = 0;         /* number of range errors */
#line 3195
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3195
  long cxp = (long) *((char**)xpp);
#line 3195

#line 3195
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3195
  /* sjl: manually stripmine so we can limit amount of
#line 3195
   * vector work space reserved to LOOPCNT elements. Also
#line 3195
   * makes vectorisation easy */
#line 3195
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3195
    ni=Min(nelems-j,LOOPCNT);
#line 3195
    if (realign) {
#line 3195
      xp = tmp;
#line 3195
    } else {
#line 3195
      xp = (float *) *xpp;
#line 3195
    }
#line 3195
   /* copy the next block */
#line 3195
#pragma cdir loopcnt=LOOPCNT
#line 3195
#pragma cdir shortloop
#line 3195
    for (i=0; i<ni; i++) {
#line 3195
      /* the normal case: */
#line 3195
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3195
     /* test for range errors (not always needed but do it anyway) */
#line 3195
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3195
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3195
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3195
    }
#line 3195
   /* copy workspace back if necessary */
#line 3195
    if (realign) {
#line 3195
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3195
      xp = (float *) *xpp;
#line 3195
    }
#line 3195
   /* update xpp and tp */
#line 3195
    xp += ni;
#line 3195
    tp += ni;
#line 3195
    *xpp = (void*)xp;
#line 3195
  }
#line 3195
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3195

#line 3195
#else   /* not SX */
#line 3195

#line 3195
	char *xp = (char *) *xpp;
#line 3195
	int status = ENOERR;
#line 3195

#line 3195
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3195
	{
#line 3195
		int lstatus = ncx_put_float_schar(xp, tp);
#line 3195
		if(lstatus != ENOERR)
#line 3195
			status = lstatus;
#line 3195
	}
#line 3195

#line 3195
	*xpp = (void *)xp;
#line 3195
	return status;
#line 3195
#endif
#line 3195
}
#line 3195

int
#line 3196
ncx_putn_float_short(void **xpp, size_t nelems, const short *tp)
#line 3196
{
#line 3196
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3196

#line 3196
 /* basic algorithm is:
#line 3196
  *   - ensure sane alignment of output data
#line 3196
  *   - copy (conversion happens automatically) input data
#line 3196
  *     to output
#line 3196
  *   - update tp to point at next unconverted input, and xpp to point
#line 3196
  *     at next location for converted output
#line 3196
  */
#line 3196
  long i, j, ni;
#line 3196
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3196
  float *xp;
#line 3196
  int nrange = 0;         /* number of range errors */
#line 3196
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3196
  long cxp = (long) *((char**)xpp);
#line 3196

#line 3196
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3196
  /* sjl: manually stripmine so we can limit amount of
#line 3196
   * vector work space reserved to LOOPCNT elements. Also
#line 3196
   * makes vectorisation easy */
#line 3196
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3196
    ni=Min(nelems-j,LOOPCNT);
#line 3196
    if (realign) {
#line 3196
      xp = tmp;
#line 3196
    } else {
#line 3196
      xp = (float *) *xpp;
#line 3196
    }
#line 3196
   /* copy the next block */
#line 3196
#pragma cdir loopcnt=LOOPCNT
#line 3196
#pragma cdir shortloop
#line 3196
    for (i=0; i<ni; i++) {
#line 3196
      /* the normal case: */
#line 3196
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3196
     /* test for range errors (not always needed but do it anyway) */
#line 3196
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3196
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3196
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3196
    }
#line 3196
   /* copy workspace back if necessary */
#line 3196
    if (realign) {
#line 3196
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3196
      xp = (float *) *xpp;
#line 3196
    }
#line 3196
   /* update xpp and tp */
#line 3196
    xp += ni;
#line 3196
    tp += ni;
#line 3196
    *xpp = (void*)xp;
#line 3196
  }
#line 3196
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3196

#line 3196
#else   /* not SX */
#line 3196

#line 3196
	char *xp = (char *) *xpp;
#line 3196
	int status = ENOERR;
#line 3196

#line 3196
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3196
	{
#line 3196
		int lstatus = ncx_put_float_short(xp, tp);
#line 3196
		if(lstatus != ENOERR)
#line 3196
			status = lstatus;
#line 3196
	}
#line 3196

#line 3196
	*xpp = (void *)xp;
#line 3196
	return status;
#line 3196
#endif
#line 3196
}
#line 3196

int
#line 3197
ncx_putn_float_int(void **xpp, size_t nelems, const int *tp)
#line 3197
{
#line 3197
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3197

#line 3197
 /* basic algorithm is:
#line 3197
  *   - ensure sane alignment of output data
#line 3197
  *   - copy (conversion happens automatically) input data
#line 3197
  *     to output
#line 3197
  *   - update tp to point at next unconverted input, and xpp to point
#line 3197
  *     at next location for converted output
#line 3197
  */
#line 3197
  long i, j, ni;
#line 3197
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3197
  float *xp;
#line 3197
  int nrange = 0;         /* number of range errors */
#line 3197
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3197
  long cxp = (long) *((char**)xpp);
#line 3197

#line 3197
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3197
  /* sjl: manually stripmine so we can limit amount of
#line 3197
   * vector work space reserved to LOOPCNT elements. Also
#line 3197
   * makes vectorisation easy */
#line 3197
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3197
    ni=Min(nelems-j,LOOPCNT);
#line 3197
    if (realign) {
#line 3197
      xp = tmp;
#line 3197
    } else {
#line 3197
      xp = (float *) *xpp;
#line 3197
    }
#line 3197
   /* copy the next block */
#line 3197
#pragma cdir loopcnt=LOOPCNT
#line 3197
#pragma cdir shortloop
#line 3197
    for (i=0; i<ni; i++) {
#line 3197
      /* the normal case: */
#line 3197
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3197
     /* test for range errors (not always needed but do it anyway) */
#line 3197
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3197
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3197
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3197
    }
#line 3197
   /* copy workspace back if necessary */
#line 3197
    if (realign) {
#line 3197
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3197
      xp = (float *) *xpp;
#line 3197
    }
#line 3197
   /* update xpp and tp */
#line 3197
    xp += ni;
#line 3197
    tp += ni;
#line 3197
    *xpp = (void*)xp;
#line 3197
  }
#line 3197
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3197

#line 3197
#else   /* not SX */
#line 3197

#line 3197
	char *xp = (char *) *xpp;
#line 3197
	int status = ENOERR;
#line 3197

#line 3197
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3197
	{
#line 3197
		int lstatus = ncx_put_float_int(xp, tp);
#line 3197
		if(lstatus != ENOERR)
#line 3197
			status = lstatus;
#line 3197
	}
#line 3197

#line 3197
	*xpp = (void *)xp;
#line 3197
	return status;
#line 3197
#endif
#line 3197
}
#line 3197

int
#line 3198
ncx_putn_float_double(void **xpp, size_t nelems, const double *tp)
#line 3198
{
#line 3198
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3198

#line 3198
 /* basic algorithm is:
#line 3198
  *   - ensure sane alignment of output data
#line 3198
  *   - copy (conversion happens automatically) input data
#line 3198
  *     to output
#line 3198
  *   - update tp to point at next unconverted input, and xpp to point
#line 3198
  *     at next location for converted output
#line 3198
  */
#line 3198
  long i, j, ni;
#line 3198
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3198
  float *xp;
#line 3198
  int nrange = 0;         /* number of range errors */
#line 3198
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3198
  long cxp = (long) *((char**)xpp);
#line 3198

#line 3198
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3198
  /* sjl: manually stripmine so we can limit amount of
#line 3198
   * vector work space reserved to LOOPCNT elements. Also
#line 3198
   * makes vectorisation easy */
#line 3198
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3198
    ni=Min(nelems-j,LOOPCNT);
#line 3198
    if (realign) {
#line 3198
      xp = tmp;
#line 3198
    } else {
#line 3198
      xp = (float *) *xpp;
#line 3198
    }
#line 3198
   /* copy the next block */
#line 3198
#pragma cdir loopcnt=LOOPCNT
#line 3198
#pragma cdir shortloop
#line 3198
    for (i=0; i<ni; i++) {
#line 3198
      /* the normal case: */
#line 3198
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3198
     /* test for range errors (not always needed but do it anyway) */
#line 3198
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3198
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3198
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3198
    }
#line 3198
   /* copy workspace back if necessary */
#line 3198
    if (realign) {
#line 3198
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3198
      xp = (float *) *xpp;
#line 3198
    }
#line 3198
   /* update xpp and tp */
#line 3198
    xp += ni;
#line 3198
    tp += ni;
#line 3198
    *xpp = (void*)xp;
#line 3198
  }
#line 3198
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3198

#line 3198
#else   /* not SX */
#line 3198

#line 3198
	char *xp = (char *) *xpp;
#line 3198
	int status = ENOERR;
#line 3198

#line 3198
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3198
	{
#line 3198
		int lstatus = ncx_put_float_double(xp, tp);
#line 3198
		if(lstatus != ENOERR)
#line 3198
			status = lstatus;
#line 3198
	}
#line 3198

#line 3198
	*xpp = (void *)xp;
#line 3198
	return status;
#line 3198
#endif
#line 3198
}
#line 3198

int
#line 3199
ncx_putn_float_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3199
{
#line 3199
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3199

#line 3199
 /* basic algorithm is:
#line 3199
  *   - ensure sane alignment of output data
#line 3199
  *   - copy (conversion happens automatically) input data
#line 3199
  *     to output
#line 3199
  *   - update tp to point at next unconverted input, and xpp to point
#line 3199
  *     at next location for converted output
#line 3199
  */
#line 3199
  long i, j, ni;
#line 3199
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3199
  float *xp;
#line 3199
  int nrange = 0;         /* number of range errors */
#line 3199
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3199
  long cxp = (long) *((char**)xpp);
#line 3199

#line 3199
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3199
  /* sjl: manually stripmine so we can limit amount of
#line 3199
   * vector work space reserved to LOOPCNT elements. Also
#line 3199
   * makes vectorisation easy */
#line 3199
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3199
    ni=Min(nelems-j,LOOPCNT);
#line 3199
    if (realign) {
#line 3199
      xp = tmp;
#line 3199
    } else {
#line 3199
      xp = (float *) *xpp;
#line 3199
    }
#line 3199
   /* copy the next block */
#line 3199
#pragma cdir loopcnt=LOOPCNT
#line 3199
#pragma cdir shortloop
#line 3199
    for (i=0; i<ni; i++) {
#line 3199
      /* the normal case: */
#line 3199
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3199
     /* test for range errors (not always needed but do it anyway) */
#line 3199
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3199
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3199
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3199
    }
#line 3199
   /* copy workspace back if necessary */
#line 3199
    if (realign) {
#line 3199
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3199
      xp = (float *) *xpp;
#line 3199
    }
#line 3199
   /* update xpp and tp */
#line 3199
    xp += ni;
#line 3199
    tp += ni;
#line 3199
    *xpp = (void*)xp;
#line 3199
  }
#line 3199
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3199

#line 3199
#else   /* not SX */
#line 3199

#line 3199
	char *xp = (char *) *xpp;
#line 3199
	int status = ENOERR;
#line 3199

#line 3199
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3199
	{
#line 3199
		int lstatus = ncx_put_float_longlong(xp, tp);
#line 3199
		if(lstatus != ENOERR)
#line 3199
			status = lstatus;
#line 3199
	}
#line 3199

#line 3199
	*xpp = (void *)xp;
#line 3199
	return status;
#line 3199
#endif
#line 3199
}
#line 3199

int
#line 3200
ncx_putn_float_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3200
{
#line 3200
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3200

#line 3200
 /* basic algorithm is:
#line 3200
  *   - ensure sane alignment of output data
#line 3200
  *   - copy (conversion happens automatically) input data
#line 3200
  *     to output
#line 3200
  *   - update tp to point at next unconverted input, and xpp to point
#line 3200
  *     at next location for converted output
#line 3200
  */
#line 3200
  long i, j, ni;
#line 3200
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3200
  float *xp;
#line 3200
  int nrange = 0;         /* number of range errors */
#line 3200
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3200
  long cxp = (long) *((char**)xpp);
#line 3200

#line 3200
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3200
  /* sjl: manually stripmine so we can limit amount of
#line 3200
   * vector work space reserved to LOOPCNT elements. Also
#line 3200
   * makes vectorisation easy */
#line 3200
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3200
    ni=Min(nelems-j,LOOPCNT);
#line 3200
    if (realign) {
#line 3200
      xp = tmp;
#line 3200
    } else {
#line 3200
      xp = (float *) *xpp;
#line 3200
    }
#line 3200
   /* copy the next block */
#line 3200
#pragma cdir loopcnt=LOOPCNT
#line 3200
#pragma cdir shortloop
#line 3200
    for (i=0; i<ni; i++) {
#line 3200
      /* the normal case: */
#line 3200
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3200
     /* test for range errors (not always needed but do it anyway) */
#line 3200
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3200
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3200
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3200
    }
#line 3200
   /* copy workspace back if necessary */
#line 3200
    if (realign) {
#line 3200
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3200
      xp = (float *) *xpp;
#line 3200
    }
#line 3200
   /* update xpp and tp */
#line 3200
    xp += ni;
#line 3200
    tp += ni;
#line 3200
    *xpp = (void*)xp;
#line 3200
  }
#line 3200
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3200

#line 3200
#else   /* not SX */
#line 3200

#line 3200
	char *xp = (char *) *xpp;
#line 3200
	int status = ENOERR;
#line 3200

#line 3200
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3200
	{
#line 3200
		int lstatus = ncx_put_float_uchar(xp, tp);
#line 3200
		if(lstatus != ENOERR)
#line 3200
			status = lstatus;
#line 3200
	}
#line 3200

#line 3200
	*xpp = (void *)xp;
#line 3200
	return status;
#line 3200
#endif
#line 3200
}
#line 3200

int
#line 3201
ncx_putn_float_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3201
{
#line 3201
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3201

#line 3201
 /* basic algorithm is:
#line 3201
  *   - ensure sane alignment of output data
#line 3201
  *   - copy (conversion happens automatically) input data
#line 3201
  *     to output
#line 3201
  *   - update tp to point at next unconverted input, and xpp to point
#line 3201
  *     at next location for converted output
#line 3201
  */
#line 3201
  long i, j, ni;
#line 3201
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3201
  float *xp;
#line 3201
  int nrange = 0;         /* number of range errors */
#line 3201
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3201
  long cxp = (long) *((char**)xpp);
#line 3201

#line 3201
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3201
  /* sjl: manually stripmine so we can limit amount of
#line 3201
   * vector work space reserved to LOOPCNT elements. Also
#line 3201
   * makes vectorisation easy */
#line 3201
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3201
    ni=Min(nelems-j,LOOPCNT);
#line 3201
    if (realign) {
#line 3201
      xp = tmp;
#line 3201
    } else {
#line 3201
      xp = (float *) *xpp;
#line 3201
    }
#line 3201
   /* copy the next block */
#line 3201
#pragma cdir loopcnt=LOOPCNT
#line 3201
#pragma cdir shortloop
#line 3201
    for (i=0; i<ni; i++) {
#line 3201
      /* the normal case: */
#line 3201
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3201
     /* test for range errors (not always needed but do it anyway) */
#line 3201
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3201
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3201
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3201
    }
#line 3201
   /* copy workspace back if necessary */
#line 3201
    if (realign) {
#line 3201
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3201
      xp = (float *) *xpp;
#line 3201
    }
#line 3201
   /* update xpp and tp */
#line 3201
    xp += ni;
#line 3201
    tp += ni;
#line 3201
    *xpp = (void*)xp;
#line 3201
  }
#line 3201
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3201

#line 3201
#else   /* not SX */
#line 3201

#line 3201
	char *xp = (char *) *xpp;
#line 3201
	int status = ENOERR;
#line 3201

#line 3201
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3201
	{
#line 3201
		int lstatus = ncx_put_float_ushort(xp, tp);
#line 3201
		if(lstatus != ENOERR)
#line 3201
			status = lstatus;
#line 3201
	}
#line 3201

#line 3201
	*xpp = (void *)xp;
#line 3201
	return status;
#line 3201
#endif
#line 3201
}
#line 3201

int
#line 3202
ncx_putn_float_uint(void **xpp, size_t nelems, const uint *tp)
#line 3202
{
#line 3202
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3202

#line 3202
 /* basic algorithm is:
#line 3202
  *   - ensure sane alignment of output data
#line 3202
  *   - copy (conversion happens automatically) input data
#line 3202
  *     to output
#line 3202
  *   - update tp to point at next unconverted input, and xpp to point
#line 3202
  *     at next location for converted output
#line 3202
  */
#line 3202
  long i, j, ni;
#line 3202
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3202
  float *xp;
#line 3202
  int nrange = 0;         /* number of range errors */
#line 3202
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3202
  long cxp = (long) *((char**)xpp);
#line 3202

#line 3202
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3202
  /* sjl: manually stripmine so we can limit amount of
#line 3202
   * vector work space reserved to LOOPCNT elements. Also
#line 3202
   * makes vectorisation easy */
#line 3202
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3202
    ni=Min(nelems-j,LOOPCNT);
#line 3202
    if (realign) {
#line 3202
      xp = tmp;
#line 3202
    } else {
#line 3202
      xp = (float *) *xpp;
#line 3202
    }
#line 3202
   /* copy the next block */
#line 3202
#pragma cdir loopcnt=LOOPCNT
#line 3202
#pragma cdir shortloop
#line 3202
    for (i=0; i<ni; i++) {
#line 3202
      /* the normal case: */
#line 3202
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3202
     /* test for range errors (not always needed but do it anyway) */
#line 3202
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3202
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3202
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3202
    }
#line 3202
   /* copy workspace back if necessary */
#line 3202
    if (realign) {
#line 3202
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3202
      xp = (float *) *xpp;
#line 3202
    }
#line 3202
   /* update xpp and tp */
#line 3202
    xp += ni;
#line 3202
    tp += ni;
#line 3202
    *xpp = (void*)xp;
#line 3202
  }
#line 3202
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3202

#line 3202
#else   /* not SX */
#line 3202

#line 3202
	char *xp = (char *) *xpp;
#line 3202
	int status = ENOERR;
#line 3202

#line 3202
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3202
	{
#line 3202
		int lstatus = ncx_put_float_uint(xp, tp);
#line 3202
		if(lstatus != ENOERR)
#line 3202
			status = lstatus;
#line 3202
	}
#line 3202

#line 3202
	*xpp = (void *)xp;
#line 3202
	return status;
#line 3202
#endif
#line 3202
}
#line 3202

int
#line 3203
ncx_putn_float_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3203
{
#line 3203
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3203

#line 3203
 /* basic algorithm is:
#line 3203
  *   - ensure sane alignment of output data
#line 3203
  *   - copy (conversion happens automatically) input data
#line 3203
  *     to output
#line 3203
  *   - update tp to point at next unconverted input, and xpp to point
#line 3203
  *     at next location for converted output
#line 3203
  */
#line 3203
  long i, j, ni;
#line 3203
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3203
  float *xp;
#line 3203
  int nrange = 0;         /* number of range errors */
#line 3203
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3203
  long cxp = (long) *((char**)xpp);
#line 3203

#line 3203
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3203
  /* sjl: manually stripmine so we can limit amount of
#line 3203
   * vector work space reserved to LOOPCNT elements. Also
#line 3203
   * makes vectorisation easy */
#line 3203
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3203
    ni=Min(nelems-j,LOOPCNT);
#line 3203
    if (realign) {
#line 3203
      xp = tmp;
#line 3203
    } else {
#line 3203
      xp = (float *) *xpp;
#line 3203
    }
#line 3203
   /* copy the next block */
#line 3203
#pragma cdir loopcnt=LOOPCNT
#line 3203
#pragma cdir shortloop
#line 3203
    for (i=0; i<ni; i++) {
#line 3203
      /* the normal case: */
#line 3203
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3203
     /* test for range errors (not always needed but do it anyway) */
#line 3203
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3203
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3203
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3203
    }
#line 3203
   /* copy workspace back if necessary */
#line 3203
    if (realign) {
#line 3203
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3203
      xp = (float *) *xpp;
#line 3203
    }
#line 3203
   /* update xpp and tp */
#line 3203
    xp += ni;
#line 3203
    tp += ni;
#line 3203
    *xpp = (void*)xp;
#line 3203
  }
#line 3203
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3203

#line 3203
#else   /* not SX */
#line 3203

#line 3203
	char *xp = (char *) *xpp;
#line 3203
	int status = ENOERR;
#line 3203

#line 3203
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3203
	{
#line 3203
		int lstatus = ncx_put_float_ulonglong(xp, tp);
#line 3203
		if(lstatus != ENOERR)
#line 3203
			status = lstatus;
#line 3203
	}
#line 3203

#line 3203
	*xpp = (void *)xp;
#line 3203
	return status;
#line 3203
#endif
#line 3203
}
#line 3203


/* double --------------------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(double));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return ENOERR;
}
#elif vax
int
ncx_getn_double_double(const void **xpp, size_t ndoubles, double *ip)
{
	double *const end = ip + ndoubles;

	while(ip < end)
	{
	struct vax_double *const vdp =
#line 3228
			 (struct vax_double *)ip;
#line 3228
	const struct ieee_double *const idp =
#line 3228
			 (const struct ieee_double *) (*xpp);
#line 3228
	{
#line 3228
		const struct dbl_limits *lim;
#line 3228
		int ii;
#line 3228
		for (ii = 0, lim = dbl_limits;
#line 3228
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 3228
			ii++, lim++)
#line 3228
		{
#line 3228
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 3228
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 3228
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 3228
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 3228
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 3228
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 3228
				)
#line 3228
			{
#line 3228
				*vdp = lim->d;
#line 3228
				goto doneit;
#line 3228
			}
#line 3228
		}
#line 3228
	}
#line 3228
	{
#line 3228
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 3228
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 3228
	}
#line 3228
	{
#line 3228
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 3228
				 | (idp->mant_5 << 8)
#line 3228
				 | idp->mant_4);
#line 3228
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 3228
		vdp->mantissa1 = (mant_hi >> 13);
#line 3228
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 3228
				| (mant_lo >> 29);
#line 3228
		vdp->mantissa3 = (mant_lo >> 13);
#line 3228
		vdp->mantissa4 = (mant_lo << 3);
#line 3228
	}
#line 3228
	doneit:
#line 3228
		vdp->sign = idp->sign;
#line 3228

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return ENOERR;
}
	/* vax */
#else
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
	const char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		const int lstatus = ncx_get_double_double(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}
#endif
int
#line 3253
ncx_getn_double_schar(const void **xpp, size_t nelems, schar *tp)
#line 3253
{
#line 3253
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3253

#line 3253
 /* basic algorithm is:
#line 3253
  *   - ensure sane alignment of input data
#line 3253
  *   - copy (conversion happens automatically) input data
#line 3253
  *     to output
#line 3253
  *   - update xpp to point at next unconverted input, and tp to point
#line 3253
  *     at next location for converted output
#line 3253
  */
#line 3253
  long i, j, ni;
#line 3253
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3253
  double *xp;
#line 3253
  int nrange = 0;         /* number of range errors */
#line 3253
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3253
  long cxp = (long) *((char**)xpp);
#line 3253

#line 3253
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3253
  /* sjl: manually stripmine so we can limit amount of
#line 3253
   * vector work space reserved to LOOPCNT elements. Also
#line 3253
   * makes vectorisation easy */
#line 3253
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3253
    ni=Min(nelems-j,LOOPCNT);
#line 3253
    if (realign) {
#line 3253
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3253
      xp = tmp;
#line 3253
    } else {
#line 3253
      xp = (double *) *xpp;
#line 3253
    }
#line 3253
   /* copy the next block */
#line 3253
#pragma cdir loopcnt=LOOPCNT
#line 3253
#pragma cdir shortloop
#line 3253
    for (i=0; i<ni; i++) {
#line 3253
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3253
     /* test for range errors (not always needed but do it anyway) */
#line 3253
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3253
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3253
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3253
    }
#line 3253
   /* update xpp and tp */
#line 3253
    if (realign) xp = (double *) *xpp;
#line 3253
    xp += ni;
#line 3253
    tp += ni;
#line 3253
    *xpp = (void*)xp;
#line 3253
  }
#line 3253
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3253

#line 3253
#else   /* not SX */
#line 3253
	const char *xp = (const char *) *xpp;
#line 3253
	int status = ENOERR;
#line 3253

#line 3253
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3253
	{
#line 3253
		const int lstatus = ncx_get_double_schar(xp, tp);
#line 3253
		if(lstatus != ENOERR)
#line 3253
			status = lstatus;
#line 3253
	}
#line 3253

#line 3253
	*xpp = (const void *)xp;
#line 3253
	return status;
#line 3253
#  endif
#line 3253
}
#line 3253

int
#line 3254
ncx_getn_double_short(const void **xpp, size_t nelems, short *tp)
#line 3254
{
#line 3254
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3254

#line 3254
 /* basic algorithm is:
#line 3254
  *   - ensure sane alignment of input data
#line 3254
  *   - copy (conversion happens automatically) input data
#line 3254
  *     to output
#line 3254
  *   - update xpp to point at next unconverted input, and tp to point
#line 3254
  *     at next location for converted output
#line 3254
  */
#line 3254
  long i, j, ni;
#line 3254
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3254
  double *xp;
#line 3254
  int nrange = 0;         /* number of range errors */
#line 3254
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3254
  long cxp = (long) *((char**)xpp);
#line 3254

#line 3254
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3254
  /* sjl: manually stripmine so we can limit amount of
#line 3254
   * vector work space reserved to LOOPCNT elements. Also
#line 3254
   * makes vectorisation easy */
#line 3254
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3254
    ni=Min(nelems-j,LOOPCNT);
#line 3254
    if (realign) {
#line 3254
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3254
      xp = tmp;
#line 3254
    } else {
#line 3254
      xp = (double *) *xpp;
#line 3254
    }
#line 3254
   /* copy the next block */
#line 3254
#pragma cdir loopcnt=LOOPCNT
#line 3254
#pragma cdir shortloop
#line 3254
    for (i=0; i<ni; i++) {
#line 3254
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3254
     /* test for range errors (not always needed but do it anyway) */
#line 3254
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3254
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3254
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3254
    }
#line 3254
   /* update xpp and tp */
#line 3254
    if (realign) xp = (double *) *xpp;
#line 3254
    xp += ni;
#line 3254
    tp += ni;
#line 3254
    *xpp = (void*)xp;
#line 3254
  }
#line 3254
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3254

#line 3254
#else   /* not SX */
#line 3254
	const char *xp = (const char *) *xpp;
#line 3254
	int status = ENOERR;
#line 3254

#line 3254
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3254
	{
#line 3254
		const int lstatus = ncx_get_double_short(xp, tp);
#line 3254
		if(lstatus != ENOERR)
#line 3254
			status = lstatus;
#line 3254
	}
#line 3254

#line 3254
	*xpp = (const void *)xp;
#line 3254
	return status;
#line 3254
#  endif
#line 3254
}
#line 3254

int
#line 3255
ncx_getn_double_int(const void **xpp, size_t nelems, int *tp)
#line 3255
{
#line 3255
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3255

#line 3255
 /* basic algorithm is:
#line 3255
  *   - ensure sane alignment of input data
#line 3255
  *   - copy (conversion happens automatically) input data
#line 3255
  *     to output
#line 3255
  *   - update xpp to point at next unconverted input, and tp to point
#line 3255
  *     at next location for converted output
#line 3255
  */
#line 3255
  long i, j, ni;
#line 3255
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3255
  double *xp;
#line 3255
  int nrange = 0;         /* number of range errors */
#line 3255
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3255
  long cxp = (long) *((char**)xpp);
#line 3255

#line 3255
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3255
  /* sjl: manually stripmine so we can limit amount of
#line 3255
   * vector work space reserved to LOOPCNT elements. Also
#line 3255
   * makes vectorisation easy */
#line 3255
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3255
    ni=Min(nelems-j,LOOPCNT);
#line 3255
    if (realign) {
#line 3255
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3255
      xp = tmp;
#line 3255
    } else {
#line 3255
      xp = (double *) *xpp;
#line 3255
    }
#line 3255
   /* copy the next block */
#line 3255
#pragma cdir loopcnt=LOOPCNT
#line 3255
#pragma cdir shortloop
#line 3255
    for (i=0; i<ni; i++) {
#line 3255
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3255
     /* test for range errors (not always needed but do it anyway) */
#line 3255
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3255
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3255
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3255
    }
#line 3255
   /* update xpp and tp */
#line 3255
    if (realign) xp = (double *) *xpp;
#line 3255
    xp += ni;
#line 3255
    tp += ni;
#line 3255
    *xpp = (void*)xp;
#line 3255
  }
#line 3255
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3255

#line 3255
#else   /* not SX */
#line 3255
	const char *xp = (const char *) *xpp;
#line 3255
	int status = ENOERR;
#line 3255

#line 3255
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3255
	{
#line 3255
		const int lstatus = ncx_get_double_int(xp, tp);
#line 3255
		if(lstatus != ENOERR)
#line 3255
			status = lstatus;
#line 3255
	}
#line 3255

#line 3255
	*xpp = (const void *)xp;
#line 3255
	return status;
#line 3255
#  endif
#line 3255
}
#line 3255

int
#line 3256
ncx_getn_double_float(const void **xpp, size_t nelems, float *tp)
#line 3256
{
#line 3256
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3256

#line 3256
 /* basic algorithm is:
#line 3256
  *   - ensure sane alignment of input data
#line 3256
  *   - copy (conversion happens automatically) input data
#line 3256
  *     to output
#line 3256
  *   - update xpp to point at next unconverted input, and tp to point
#line 3256
  *     at next location for converted output
#line 3256
  */
#line 3256
  long i, j, ni;
#line 3256
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3256
  double *xp;
#line 3256
  int nrange = 0;         /* number of range errors */
#line 3256
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3256
  long cxp = (long) *((char**)xpp);
#line 3256

#line 3256
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3256
  /* sjl: manually stripmine so we can limit amount of
#line 3256
   * vector work space reserved to LOOPCNT elements. Also
#line 3256
   * makes vectorisation easy */
#line 3256
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3256
    ni=Min(nelems-j,LOOPCNT);
#line 3256
    if (realign) {
#line 3256
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3256
      xp = tmp;
#line 3256
    } else {
#line 3256
      xp = (double *) *xpp;
#line 3256
    }
#line 3256
   /* copy the next block */
#line 3256
#pragma cdir loopcnt=LOOPCNT
#line 3256
#pragma cdir shortloop
#line 3256
    for (i=0; i<ni; i++) {
#line 3256
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3256
     /* test for range errors (not always needed but do it anyway) */
#line 3256
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3256
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3256
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3256
    }
#line 3256
   /* update xpp and tp */
#line 3256
    if (realign) xp = (double *) *xpp;
#line 3256
    xp += ni;
#line 3256
    tp += ni;
#line 3256
    *xpp = (void*)xp;
#line 3256
  }
#line 3256
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3256

#line 3256
#else   /* not SX */
#line 3256
	const char *xp = (const char *) *xpp;
#line 3256
	int status = ENOERR;
#line 3256

#line 3256
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3256
	{
#line 3256
		const int lstatus = ncx_get_double_float(xp, tp);
#line 3256
		if(lstatus != ENOERR)
#line 3256
			status = lstatus;
#line 3256
	}
#line 3256

#line 3256
	*xpp = (const void *)xp;
#line 3256
	return status;
#line 3256
#  endif
#line 3256
}
#line 3256

int
#line 3257
ncx_getn_double_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3257
{
#line 3257
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3257

#line 3257
 /* basic algorithm is:
#line 3257
  *   - ensure sane alignment of input data
#line 3257
  *   - copy (conversion happens automatically) input data
#line 3257
  *     to output
#line 3257
  *   - update xpp to point at next unconverted input, and tp to point
#line 3257
  *     at next location for converted output
#line 3257
  */
#line 3257
  long i, j, ni;
#line 3257
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3257
  double *xp;
#line 3257
  int nrange = 0;         /* number of range errors */
#line 3257
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3257
  long cxp = (long) *((char**)xpp);
#line 3257

#line 3257
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3257
  /* sjl: manually stripmine so we can limit amount of
#line 3257
   * vector work space reserved to LOOPCNT elements. Also
#line 3257
   * makes vectorisation easy */
#line 3257
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3257
    ni=Min(nelems-j,LOOPCNT);
#line 3257
    if (realign) {
#line 3257
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3257
      xp = tmp;
#line 3257
    } else {
#line 3257
      xp = (double *) *xpp;
#line 3257
    }
#line 3257
   /* copy the next block */
#line 3257
#pragma cdir loopcnt=LOOPCNT
#line 3257
#pragma cdir shortloop
#line 3257
    for (i=0; i<ni; i++) {
#line 3257
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3257
     /* test for range errors (not always needed but do it anyway) */
#line 3257
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3257
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3257
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3257
    }
#line 3257
   /* update xpp and tp */
#line 3257
    if (realign) xp = (double *) *xpp;
#line 3257
    xp += ni;
#line 3257
    tp += ni;
#line 3257
    *xpp = (void*)xp;
#line 3257
  }
#line 3257
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3257

#line 3257
#else   /* not SX */
#line 3257
	const char *xp = (const char *) *xpp;
#line 3257
	int status = ENOERR;
#line 3257

#line 3257
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3257
	{
#line 3257
		const int lstatus = ncx_get_double_longlong(xp, tp);
#line 3257
		if(lstatus != ENOERR)
#line 3257
			status = lstatus;
#line 3257
	}
#line 3257

#line 3257
	*xpp = (const void *)xp;
#line 3257
	return status;
#line 3257
#  endif
#line 3257
}
#line 3257

int
#line 3258
ncx_getn_double_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3258
{
#line 3258
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3258

#line 3258
 /* basic algorithm is:
#line 3258
  *   - ensure sane alignment of input data
#line 3258
  *   - copy (conversion happens automatically) input data
#line 3258
  *     to output
#line 3258
  *   - update xpp to point at next unconverted input, and tp to point
#line 3258
  *     at next location for converted output
#line 3258
  */
#line 3258
  long i, j, ni;
#line 3258
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3258
  double *xp;
#line 3258
  int nrange = 0;         /* number of range errors */
#line 3258
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3258
  long cxp = (long) *((char**)xpp);
#line 3258

#line 3258
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3258
  /* sjl: manually stripmine so we can limit amount of
#line 3258
   * vector work space reserved to LOOPCNT elements. Also
#line 3258
   * makes vectorisation easy */
#line 3258
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3258
    ni=Min(nelems-j,LOOPCNT);
#line 3258
    if (realign) {
#line 3258
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3258
      xp = tmp;
#line 3258
    } else {
#line 3258
      xp = (double *) *xpp;
#line 3258
    }
#line 3258
   /* copy the next block */
#line 3258
#pragma cdir loopcnt=LOOPCNT
#line 3258
#pragma cdir shortloop
#line 3258
    for (i=0; i<ni; i++) {
#line 3258
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3258
     /* test for range errors (not always needed but do it anyway) */
#line 3258
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3258
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3258
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3258
    }
#line 3258
   /* update xpp and tp */
#line 3258
    if (realign) xp = (double *) *xpp;
#line 3258
    xp += ni;
#line 3258
    tp += ni;
#line 3258
    *xpp = (void*)xp;
#line 3258
  }
#line 3258
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3258

#line 3258
#else   /* not SX */
#line 3258
	const char *xp = (const char *) *xpp;
#line 3258
	int status = ENOERR;
#line 3258

#line 3258
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3258
	{
#line 3258
		const int lstatus = ncx_get_double_uchar(xp, tp);
#line 3258
		if(lstatus != ENOERR)
#line 3258
			status = lstatus;
#line 3258
	}
#line 3258

#line 3258
	*xpp = (const void *)xp;
#line 3258
	return status;
#line 3258
#  endif
#line 3258
}
#line 3258

int
#line 3259
ncx_getn_double_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3259
{
#line 3259
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3259

#line 3259
 /* basic algorithm is:
#line 3259
  *   - ensure sane alignment of input data
#line 3259
  *   - copy (conversion happens automatically) input data
#line 3259
  *     to output
#line 3259
  *   - update xpp to point at next unconverted input, and tp to point
#line 3259
  *     at next location for converted output
#line 3259
  */
#line 3259
  long i, j, ni;
#line 3259
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3259
  double *xp;
#line 3259
  int nrange = 0;         /* number of range errors */
#line 3259
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3259
  long cxp = (long) *((char**)xpp);
#line 3259

#line 3259
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3259
  /* sjl: manually stripmine so we can limit amount of
#line 3259
   * vector work space reserved to LOOPCNT elements. Also
#line 3259
   * makes vectorisation easy */
#line 3259
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3259
    ni=Min(nelems-j,LOOPCNT);
#line 3259
    if (realign) {
#line 3259
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3259
      xp = tmp;
#line 3259
    } else {
#line 3259
      xp = (double *) *xpp;
#line 3259
    }
#line 3259
   /* copy the next block */
#line 3259
#pragma cdir loopcnt=LOOPCNT
#line 3259
#pragma cdir shortloop
#line 3259
    for (i=0; i<ni; i++) {
#line 3259
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3259
     /* test for range errors (not always needed but do it anyway) */
#line 3259
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3259
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3259
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3259
    }
#line 3259
   /* update xpp and tp */
#line 3259
    if (realign) xp = (double *) *xpp;
#line 3259
    xp += ni;
#line 3259
    tp += ni;
#line 3259
    *xpp = (void*)xp;
#line 3259
  }
#line 3259
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3259

#line 3259
#else   /* not SX */
#line 3259
	const char *xp = (const char *) *xpp;
#line 3259
	int status = ENOERR;
#line 3259

#line 3259
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3259
	{
#line 3259
		const int lstatus = ncx_get_double_ushort(xp, tp);
#line 3259
		if(lstatus != ENOERR)
#line 3259
			status = lstatus;
#line 3259
	}
#line 3259

#line 3259
	*xpp = (const void *)xp;
#line 3259
	return status;
#line 3259
#  endif
#line 3259
}
#line 3259

int
#line 3260
ncx_getn_double_uint(const void **xpp, size_t nelems, uint *tp)
#line 3260
{
#line 3260
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3260

#line 3260
 /* basic algorithm is:
#line 3260
  *   - ensure sane alignment of input data
#line 3260
  *   - copy (conversion happens automatically) input data
#line 3260
  *     to output
#line 3260
  *   - update xpp to point at next unconverted input, and tp to point
#line 3260
  *     at next location for converted output
#line 3260
  */
#line 3260
  long i, j, ni;
#line 3260
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3260
  double *xp;
#line 3260
  int nrange = 0;         /* number of range errors */
#line 3260
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3260
  long cxp = (long) *((char**)xpp);
#line 3260

#line 3260
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3260
  /* sjl: manually stripmine so we can limit amount of
#line 3260
   * vector work space reserved to LOOPCNT elements. Also
#line 3260
   * makes vectorisation easy */
#line 3260
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3260
    ni=Min(nelems-j,LOOPCNT);
#line 3260
    if (realign) {
#line 3260
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3260
      xp = tmp;
#line 3260
    } else {
#line 3260
      xp = (double *) *xpp;
#line 3260
    }
#line 3260
   /* copy the next block */
#line 3260
#pragma cdir loopcnt=LOOPCNT
#line 3260
#pragma cdir shortloop
#line 3260
    for (i=0; i<ni; i++) {
#line 3260
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3260
     /* test for range errors (not always needed but do it anyway) */
#line 3260
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3260
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3260
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3260
    }
#line 3260
   /* update xpp and tp */
#line 3260
    if (realign) xp = (double *) *xpp;
#line 3260
    xp += ni;
#line 3260
    tp += ni;
#line 3260
    *xpp = (void*)xp;
#line 3260
  }
#line 3260
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3260

#line 3260
#else   /* not SX */
#line 3260
	const char *xp = (const char *) *xpp;
#line 3260
	int status = ENOERR;
#line 3260

#line 3260
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3260
	{
#line 3260
		const int lstatus = ncx_get_double_uint(xp, tp);
#line 3260
		if(lstatus != ENOERR)
#line 3260
			status = lstatus;
#line 3260
	}
#line 3260

#line 3260
	*xpp = (const void *)xp;
#line 3260
	return status;
#line 3260
#  endif
#line 3260
}
#line 3260

int
#line 3261
ncx_getn_double_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3261
{
#line 3261
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3261

#line 3261
 /* basic algorithm is:
#line 3261
  *   - ensure sane alignment of input data
#line 3261
  *   - copy (conversion happens automatically) input data
#line 3261
  *     to output
#line 3261
  *   - update xpp to point at next unconverted input, and tp to point
#line 3261
  *     at next location for converted output
#line 3261
  */
#line 3261
  long i, j, ni;
#line 3261
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3261
  double *xp;
#line 3261
  int nrange = 0;         /* number of range errors */
#line 3261
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3261
  long cxp = (long) *((char**)xpp);
#line 3261

#line 3261
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3261
  /* sjl: manually stripmine so we can limit amount of
#line 3261
   * vector work space reserved to LOOPCNT elements. Also
#line 3261
   * makes vectorisation easy */
#line 3261
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3261
    ni=Min(nelems-j,LOOPCNT);
#line 3261
    if (realign) {
#line 3261
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3261
      xp = tmp;
#line 3261
    } else {
#line 3261
      xp = (double *) *xpp;
#line 3261
    }
#line 3261
   /* copy the next block */
#line 3261
#pragma cdir loopcnt=LOOPCNT
#line 3261
#pragma cdir shortloop
#line 3261
    for (i=0; i<ni; i++) {
#line 3261
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3261
     /* test for range errors (not always needed but do it anyway) */
#line 3261
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3261
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3261
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3261
    }
#line 3261
   /* update xpp and tp */
#line 3261
    if (realign) xp = (double *) *xpp;
#line 3261
    xp += ni;
#line 3261
    tp += ni;
#line 3261
    *xpp = (void*)xp;
#line 3261
  }
#line 3261
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3261

#line 3261
#else   /* not SX */
#line 3261
	const char *xp = (const char *) *xpp;
#line 3261
	int status = ENOERR;
#line 3261

#line 3261
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3261
	{
#line 3261
		const int lstatus = ncx_get_double_ulonglong(xp, tp);
#line 3261
		if(lstatus != ENOERR)
#line 3261
			status = lstatus;
#line 3261
	}
#line 3261

#line 3261
	*xpp = (const void *)xp;
#line 3261
	return status;
#line 3261
#  endif
#line 3261
}
#line 3261


#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_DOUBLE);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return ENOERR;
}
#elif vax
int
ncx_putn_double_double(void **xpp, size_t ndoubles, const double *ip)
{
	const double *const end = ip + ndoubles;

	while(ip < end)
	{
	const struct vax_double *const vdp =
#line 3284
			(const struct vax_double *)ip;
#line 3284
	struct ieee_double *const idp =
#line 3284
			 (struct ieee_double *) (*xpp);
#line 3284

#line 3284
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 3284
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 3284
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 3284
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 3284
		(vdp->exp == dbl_limits[0].d.exp))
#line 3284
	{
#line 3284
		*idp = dbl_limits[0].ieee;
#line 3284
		goto shipit;
#line 3284
	}
#line 3284
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 3284
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 3284
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 3284
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 3284
		(vdp->exp == dbl_limits[1].d.exp))
#line 3284
	{
#line 3284
		*idp = dbl_limits[1].ieee;
#line 3284
		goto shipit;
#line 3284
	}
#line 3284

#line 3284
	{
#line 3284
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 3284

#line 3284
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 3284
			(vdp->mantissa3 << 13) |
#line 3284
			((vdp->mantissa4 >> 3) & MASK(13));
#line 3284

#line 3284
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 3284
				 | (vdp->mantissa2 >> 3);
#line 3284

#line 3284
		if((vdp->mantissa4 & 7) > 4)
#line 3284
		{
#line 3284
			/* round up */
#line 3284
			mant_lo++;
#line 3284
			if(mant_lo == 0)
#line 3284
			{
#line 3284
				mant_hi++;
#line 3284
				if(mant_hi > 0xffffff)
#line 3284
				{
#line 3284
					mant_hi = 0;
#line 3284
					exp++;
#line 3284
				}
#line 3284
			}
#line 3284
		}
#line 3284

#line 3284
		idp->mant_lo = SWAP4(mant_lo);
#line 3284
		idp->mant_6 = mant_hi >> 16;
#line 3284
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 3284
		idp->mant_4 = mant_hi;
#line 3284
		idp->exp_hi = exp >> 4;
#line 3284
		idp->exp_lo = exp;
#line 3284
	}
#line 3284

#line 3284
	shipit:
#line 3284
		idp->sign = vdp->sign;
#line 3284

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return ENOERR;
}
	/* vax */
#else
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp)
{
	char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		int lstatus = ncx_put_double_double(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3309
ncx_putn_double_schar(void **xpp, size_t nelems, const schar *tp)
#line 3309
{
#line 3309
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3309

#line 3309
 /* basic algorithm is:
#line 3309
  *   - ensure sane alignment of output data
#line 3309
  *   - copy (conversion happens automatically) input data
#line 3309
  *     to output
#line 3309
  *   - update tp to point at next unconverted input, and xpp to point
#line 3309
  *     at next location for converted output
#line 3309
  */
#line 3309
  long i, j, ni;
#line 3309
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3309
  double *xp;
#line 3309
  int nrange = 0;         /* number of range errors */
#line 3309
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3309
  long cxp = (long) *((char**)xpp);
#line 3309

#line 3309
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3309
  /* sjl: manually stripmine so we can limit amount of
#line 3309
   * vector work space reserved to LOOPCNT elements. Also
#line 3309
   * makes vectorisation easy */
#line 3309
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3309
    ni=Min(nelems-j,LOOPCNT);
#line 3309
    if (realign) {
#line 3309
      xp = tmp;
#line 3309
    } else {
#line 3309
      xp = (double *) *xpp;
#line 3309
    }
#line 3309
   /* copy the next block */
#line 3309
#pragma cdir loopcnt=LOOPCNT
#line 3309
#pragma cdir shortloop
#line 3309
    for (i=0; i<ni; i++) {
#line 3309
      /* the normal case: */
#line 3309
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3309
     /* test for range errors (not always needed but do it anyway) */
#line 3309
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3309
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3309
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3309
    }
#line 3309
   /* copy workspace back if necessary */
#line 3309
    if (realign) {
#line 3309
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3309
      xp = (double *) *xpp;
#line 3309
    }
#line 3309
   /* update xpp and tp */
#line 3309
    xp += ni;
#line 3309
    tp += ni;
#line 3309
    *xpp = (void*)xp;
#line 3309
  }
#line 3309
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3309

#line 3309
#else   /* not SX */
#line 3309

#line 3309
	char *xp = (char *) *xpp;
#line 3309
	int status = ENOERR;
#line 3309

#line 3309
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3309
	{
#line 3309
		int lstatus = ncx_put_double_schar(xp, tp);
#line 3309
		if(lstatus != ENOERR)
#line 3309
			status = lstatus;
#line 3309
	}
#line 3309

#line 3309
	*xpp = (void *)xp;
#line 3309
	return status;
#line 3309
#endif
#line 3309
}
#line 3309

int
#line 3310
ncx_putn_double_short(void **xpp, size_t nelems, const short *tp)
#line 3310
{
#line 3310
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3310

#line 3310
 /* basic algorithm is:
#line 3310
  *   - ensure sane alignment of output data
#line 3310
  *   - copy (conversion happens automatically) input data
#line 3310
  *     to output
#line 3310
  *   - update tp to point at next unconverted input, and xpp to point
#line 3310
  *     at next location for converted output
#line 3310
  */
#line 3310
  long i, j, ni;
#line 3310
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3310
  double *xp;
#line 3310
  int nrange = 0;         /* number of range errors */
#line 3310
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3310
  long cxp = (long) *((char**)xpp);
#line 3310

#line 3310
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3310
  /* sjl: manually stripmine so we can limit amount of
#line 3310
   * vector work space reserved to LOOPCNT elements. Also
#line 3310
   * makes vectorisation easy */
#line 3310
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3310
    ni=Min(nelems-j,LOOPCNT);
#line 3310
    if (realign) {
#line 3310
      xp = tmp;
#line 3310
    } else {
#line 3310
      xp = (double *) *xpp;
#line 3310
    }
#line 3310
   /* copy the next block */
#line 3310
#pragma cdir loopcnt=LOOPCNT
#line 3310
#pragma cdir shortloop
#line 3310
    for (i=0; i<ni; i++) {
#line 3310
      /* the normal case: */
#line 3310
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3310
     /* test for range errors (not always needed but do it anyway) */
#line 3310
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3310
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3310
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3310
    }
#line 3310
   /* copy workspace back if necessary */
#line 3310
    if (realign) {
#line 3310
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3310
      xp = (double *) *xpp;
#line 3310
    }
#line 3310
   /* update xpp and tp */
#line 3310
    xp += ni;
#line 3310
    tp += ni;
#line 3310
    *xpp = (void*)xp;
#line 3310
  }
#line 3310
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3310

#line 3310
#else   /* not SX */
#line 3310

#line 3310
	char *xp = (char *) *xpp;
#line 3310
	int status = ENOERR;
#line 3310

#line 3310
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3310
	{
#line 3310
		int lstatus = ncx_put_double_short(xp, tp);
#line 3310
		if(lstatus != ENOERR)
#line 3310
			status = lstatus;
#line 3310
	}
#line 3310

#line 3310
	*xpp = (void *)xp;
#line 3310
	return status;
#line 3310
#endif
#line 3310
}
#line 3310

int
#line 3311
ncx_putn_double_int(void **xpp, size_t nelems, const int *tp)
#line 3311
{
#line 3311
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3311

#line 3311
 /* basic algorithm is:
#line 3311
  *   - ensure sane alignment of output data
#line 3311
  *   - copy (conversion happens automatically) input data
#line 3311
  *     to output
#line 3311
  *   - update tp to point at next unconverted input, and xpp to point
#line 3311
  *     at next location for converted output
#line 3311
  */
#line 3311
  long i, j, ni;
#line 3311
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3311
  double *xp;
#line 3311
  int nrange = 0;         /* number of range errors */
#line 3311
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3311
  long cxp = (long) *((char**)xpp);
#line 3311

#line 3311
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3311
  /* sjl: manually stripmine so we can limit amount of
#line 3311
   * vector work space reserved to LOOPCNT elements. Also
#line 3311
   * makes vectorisation easy */
#line 3311
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3311
    ni=Min(nelems-j,LOOPCNT);
#line 3311
    if (realign) {
#line 3311
      xp = tmp;
#line 3311
    } else {
#line 3311
      xp = (double *) *xpp;
#line 3311
    }
#line 3311
   /* copy the next block */
#line 3311
#pragma cdir loopcnt=LOOPCNT
#line 3311
#pragma cdir shortloop
#line 3311
    for (i=0; i<ni; i++) {
#line 3311
      /* the normal case: */
#line 3311
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3311
     /* test for range errors (not always needed but do it anyway) */
#line 3311
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3311
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3311
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3311
    }
#line 3311
   /* copy workspace back if necessary */
#line 3311
    if (realign) {
#line 3311
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3311
      xp = (double *) *xpp;
#line 3311
    }
#line 3311
   /* update xpp and tp */
#line 3311
    xp += ni;
#line 3311
    tp += ni;
#line 3311
    *xpp = (void*)xp;
#line 3311
  }
#line 3311
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3311

#line 3311
#else   /* not SX */
#line 3311

#line 3311
	char *xp = (char *) *xpp;
#line 3311
	int status = ENOERR;
#line 3311

#line 3311
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3311
	{
#line 3311
		int lstatus = ncx_put_double_int(xp, tp);
#line 3311
		if(lstatus != ENOERR)
#line 3311
			status = lstatus;
#line 3311
	}
#line 3311

#line 3311
	*xpp = (void *)xp;
#line 3311
	return status;
#line 3311
#endif
#line 3311
}
#line 3311

int
#line 3312
ncx_putn_double_float(void **xpp, size_t nelems, const float *tp)
#line 3312
{
#line 3312
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3312

#line 3312
 /* basic algorithm is:
#line 3312
  *   - ensure sane alignment of output data
#line 3312
  *   - copy (conversion happens automatically) input data
#line 3312
  *     to output
#line 3312
  *   - update tp to point at next unconverted input, and xpp to point
#line 3312
  *     at next location for converted output
#line 3312
  */
#line 3312
  long i, j, ni;
#line 3312
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3312
  double *xp;
#line 3312
  int nrange = 0;         /* number of range errors */
#line 3312
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3312
  long cxp = (long) *((char**)xpp);
#line 3312

#line 3312
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3312
  /* sjl: manually stripmine so we can limit amount of
#line 3312
   * vector work space reserved to LOOPCNT elements. Also
#line 3312
   * makes vectorisation easy */
#line 3312
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3312
    ni=Min(nelems-j,LOOPCNT);
#line 3312
    if (realign) {
#line 3312
      xp = tmp;
#line 3312
    } else {
#line 3312
      xp = (double *) *xpp;
#line 3312
    }
#line 3312
   /* copy the next block */
#line 3312
#pragma cdir loopcnt=LOOPCNT
#line 3312
#pragma cdir shortloop
#line 3312
    for (i=0; i<ni; i++) {
#line 3312
      /* the normal case: */
#line 3312
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3312
     /* test for range errors (not always needed but do it anyway) */
#line 3312
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3312
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3312
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3312
    }
#line 3312
   /* copy workspace back if necessary */
#line 3312
    if (realign) {
#line 3312
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3312
      xp = (double *) *xpp;
#line 3312
    }
#line 3312
   /* update xpp and tp */
#line 3312
    xp += ni;
#line 3312
    tp += ni;
#line 3312
    *xpp = (void*)xp;
#line 3312
  }
#line 3312
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3312

#line 3312
#else   /* not SX */
#line 3312

#line 3312
	char *xp = (char *) *xpp;
#line 3312
	int status = ENOERR;
#line 3312

#line 3312
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3312
	{
#line 3312
		int lstatus = ncx_put_double_float(xp, tp);
#line 3312
		if(lstatus != ENOERR)
#line 3312
			status = lstatus;
#line 3312
	}
#line 3312

#line 3312
	*xpp = (void *)xp;
#line 3312
	return status;
#line 3312
#endif
#line 3312
}
#line 3312

int
#line 3313
ncx_putn_double_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3313
{
#line 3313
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3313

#line 3313
 /* basic algorithm is:
#line 3313
  *   - ensure sane alignment of output data
#line 3313
  *   - copy (conversion happens automatically) input data
#line 3313
  *     to output
#line 3313
  *   - update tp to point at next unconverted input, and xpp to point
#line 3313
  *     at next location for converted output
#line 3313
  */
#line 3313
  long i, j, ni;
#line 3313
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3313
  double *xp;
#line 3313
  int nrange = 0;         /* number of range errors */
#line 3313
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3313
  long cxp = (long) *((char**)xpp);
#line 3313

#line 3313
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3313
  /* sjl: manually stripmine so we can limit amount of
#line 3313
   * vector work space reserved to LOOPCNT elements. Also
#line 3313
   * makes vectorisation easy */
#line 3313
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3313
    ni=Min(nelems-j,LOOPCNT);
#line 3313
    if (realign) {
#line 3313
      xp = tmp;
#line 3313
    } else {
#line 3313
      xp = (double *) *xpp;
#line 3313
    }
#line 3313
   /* copy the next block */
#line 3313
#pragma cdir loopcnt=LOOPCNT
#line 3313
#pragma cdir shortloop
#line 3313
    for (i=0; i<ni; i++) {
#line 3313
      /* the normal case: */
#line 3313
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3313
     /* test for range errors (not always needed but do it anyway) */
#line 3313
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3313
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3313
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3313
    }
#line 3313
   /* copy workspace back if necessary */
#line 3313
    if (realign) {
#line 3313
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3313
      xp = (double *) *xpp;
#line 3313
    }
#line 3313
   /* update xpp and tp */
#line 3313
    xp += ni;
#line 3313
    tp += ni;
#line 3313
    *xpp = (void*)xp;
#line 3313
  }
#line 3313
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3313

#line 3313
#else   /* not SX */
#line 3313

#line 3313
	char *xp = (char *) *xpp;
#line 3313
	int status = ENOERR;
#line 3313

#line 3313
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3313
	{
#line 3313
		int lstatus = ncx_put_double_longlong(xp, tp);
#line 3313
		if(lstatus != ENOERR)
#line 3313
			status = lstatus;
#line 3313
	}
#line 3313

#line 3313
	*xpp = (void *)xp;
#line 3313
	return status;
#line 3313
#endif
#line 3313
}
#line 3313

int
#line 3314
ncx_putn_double_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3314
{
#line 3314
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3314

#line 3314
 /* basic algorithm is:
#line 3314
  *   - ensure sane alignment of output data
#line 3314
  *   - copy (conversion happens automatically) input data
#line 3314
  *     to output
#line 3314
  *   - update tp to point at next unconverted input, and xpp to point
#line 3314
  *     at next location for converted output
#line 3314
  */
#line 3314
  long i, j, ni;
#line 3314
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3314
  double *xp;
#line 3314
  int nrange = 0;         /* number of range errors */
#line 3314
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3314
  long cxp = (long) *((char**)xpp);
#line 3314

#line 3314
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3314
  /* sjl: manually stripmine so we can limit amount of
#line 3314
   * vector work space reserved to LOOPCNT elements. Also
#line 3314
   * makes vectorisation easy */
#line 3314
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3314
    ni=Min(nelems-j,LOOPCNT);
#line 3314
    if (realign) {
#line 3314
      xp = tmp;
#line 3314
    } else {
#line 3314
      xp = (double *) *xpp;
#line 3314
    }
#line 3314
   /* copy the next block */
#line 3314
#pragma cdir loopcnt=LOOPCNT
#line 3314
#pragma cdir shortloop
#line 3314
    for (i=0; i<ni; i++) {
#line 3314
      /* the normal case: */
#line 3314
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3314
     /* test for range errors (not always needed but do it anyway) */
#line 3314
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3314
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3314
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3314
    }
#line 3314
   /* copy workspace back if necessary */
#line 3314
    if (realign) {
#line 3314
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3314
      xp = (double *) *xpp;
#line 3314
    }
#line 3314
   /* update xpp and tp */
#line 3314
    xp += ni;
#line 3314
    tp += ni;
#line 3314
    *xpp = (void*)xp;
#line 3314
  }
#line 3314
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3314

#line 3314
#else   /* not SX */
#line 3314

#line 3314
	char *xp = (char *) *xpp;
#line 3314
	int status = ENOERR;
#line 3314

#line 3314
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3314
	{
#line 3314
		int lstatus = ncx_put_double_uchar(xp, tp);
#line 3314
		if(lstatus != ENOERR)
#line 3314
			status = lstatus;
#line 3314
	}
#line 3314

#line 3314
	*xpp = (void *)xp;
#line 3314
	return status;
#line 3314
#endif
#line 3314
}
#line 3314

int
#line 3315
ncx_putn_double_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3315
{
#line 3315
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3315

#line 3315
 /* basic algorithm is:
#line 3315
  *   - ensure sane alignment of output data
#line 3315
  *   - copy (conversion happens automatically) input data
#line 3315
  *     to output
#line 3315
  *   - update tp to point at next unconverted input, and xpp to point
#line 3315
  *     at next location for converted output
#line 3315
  */
#line 3315
  long i, j, ni;
#line 3315
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3315
  double *xp;
#line 3315
  int nrange = 0;         /* number of range errors */
#line 3315
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3315
  long cxp = (long) *((char**)xpp);
#line 3315

#line 3315
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3315
  /* sjl: manually stripmine so we can limit amount of
#line 3315
   * vector work space reserved to LOOPCNT elements. Also
#line 3315
   * makes vectorisation easy */
#line 3315
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3315
    ni=Min(nelems-j,LOOPCNT);
#line 3315
    if (realign) {
#line 3315
      xp = tmp;
#line 3315
    } else {
#line 3315
      xp = (double *) *xpp;
#line 3315
    }
#line 3315
   /* copy the next block */
#line 3315
#pragma cdir loopcnt=LOOPCNT
#line 3315
#pragma cdir shortloop
#line 3315
    for (i=0; i<ni; i++) {
#line 3315
      /* the normal case: */
#line 3315
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3315
     /* test for range errors (not always needed but do it anyway) */
#line 3315
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3315
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3315
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3315
    }
#line 3315
   /* copy workspace back if necessary */
#line 3315
    if (realign) {
#line 3315
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3315
      xp = (double *) *xpp;
#line 3315
    }
#line 3315
   /* update xpp and tp */
#line 3315
    xp += ni;
#line 3315
    tp += ni;
#line 3315
    *xpp = (void*)xp;
#line 3315
  }
#line 3315
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3315

#line 3315
#else   /* not SX */
#line 3315

#line 3315
	char *xp = (char *) *xpp;
#line 3315
	int status = ENOERR;
#line 3315

#line 3315
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3315
	{
#line 3315
		int lstatus = ncx_put_double_ushort(xp, tp);
#line 3315
		if(lstatus != ENOERR)
#line 3315
			status = lstatus;
#line 3315
	}
#line 3315

#line 3315
	*xpp = (void *)xp;
#line 3315
	return status;
#line 3315
#endif
#line 3315
}
#line 3315

int
#line 3316
ncx_putn_double_uint(void **xpp, size_t nelems, const uint *tp)
#line 3316
{
#line 3316
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3316

#line 3316
 /* basic algorithm is:
#line 3316
  *   - ensure sane alignment of output data
#line 3316
  *   - copy (conversion happens automatically) input data
#line 3316
  *     to output
#line 3316
  *   - update tp to point at next unconverted input, and xpp to point
#line 3316
  *     at next location for converted output
#line 3316
  */
#line 3316
  long i, j, ni;
#line 3316
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3316
  double *xp;
#line 3316
  int nrange = 0;         /* number of range errors */
#line 3316
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3316
  long cxp = (long) *((char**)xpp);
#line 3316

#line 3316
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3316
  /* sjl: manually stripmine so we can limit amount of
#line 3316
   * vector work space reserved to LOOPCNT elements. Also
#line 3316
   * makes vectorisation easy */
#line 3316
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3316
    ni=Min(nelems-j,LOOPCNT);
#line 3316
    if (realign) {
#line 3316
      xp = tmp;
#line 3316
    } else {
#line 3316
      xp = (double *) *xpp;
#line 3316
    }
#line 3316
   /* copy the next block */
#line 3316
#pragma cdir loopcnt=LOOPCNT
#line 3316
#pragma cdir shortloop
#line 3316
    for (i=0; i<ni; i++) {
#line 3316
      /* the normal case: */
#line 3316
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3316
     /* test for range errors (not always needed but do it anyway) */
#line 3316
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3316
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3316
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3316
    }
#line 3316
   /* copy workspace back if necessary */
#line 3316
    if (realign) {
#line 3316
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3316
      xp = (double *) *xpp;
#line 3316
    }
#line 3316
   /* update xpp and tp */
#line 3316
    xp += ni;
#line 3316
    tp += ni;
#line 3316
    *xpp = (void*)xp;
#line 3316
  }
#line 3316
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3316

#line 3316
#else   /* not SX */
#line 3316

#line 3316
	char *xp = (char *) *xpp;
#line 3316
	int status = ENOERR;
#line 3316

#line 3316
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3316
	{
#line 3316
		int lstatus = ncx_put_double_uint(xp, tp);
#line 3316
		if(lstatus != ENOERR)
#line 3316
			status = lstatus;
#line 3316
	}
#line 3316

#line 3316
	*xpp = (void *)xp;
#line 3316
	return status;
#line 3316
#endif
#line 3316
}
#line 3316

int
#line 3317
ncx_putn_double_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3317
{
#line 3317
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3317

#line 3317
 /* basic algorithm is:
#line 3317
  *   - ensure sane alignment of output data
#line 3317
  *   - copy (conversion happens automatically) input data
#line 3317
  *     to output
#line 3317
  *   - update tp to point at next unconverted input, and xpp to point
#line 3317
  *     at next location for converted output
#line 3317
  */
#line 3317
  long i, j, ni;
#line 3317
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3317
  double *xp;
#line 3317
  int nrange = 0;         /* number of range errors */
#line 3317
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3317
  long cxp = (long) *((char**)xpp);
#line 3317

#line 3317
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3317
  /* sjl: manually stripmine so we can limit amount of
#line 3317
   * vector work space reserved to LOOPCNT elements. Also
#line 3317
   * makes vectorisation easy */
#line 3317
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3317
    ni=Min(nelems-j,LOOPCNT);
#line 3317
    if (realign) {
#line 3317
      xp = tmp;
#line 3317
    } else {
#line 3317
      xp = (double *) *xpp;
#line 3317
    }
#line 3317
   /* copy the next block */
#line 3317
#pragma cdir loopcnt=LOOPCNT
#line 3317
#pragma cdir shortloop
#line 3317
    for (i=0; i<ni; i++) {
#line 3317
      /* the normal case: */
#line 3317
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3317
     /* test for range errors (not always needed but do it anyway) */
#line 3317
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3317
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3317
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3317
    }
#line 3317
   /* copy workspace back if necessary */
#line 3317
    if (realign) {
#line 3317
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3317
      xp = (double *) *xpp;
#line 3317
    }
#line 3317
   /* update xpp and tp */
#line 3317
    xp += ni;
#line 3317
    tp += ni;
#line 3317
    *xpp = (void*)xp;
#line 3317
  }
#line 3317
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3317

#line 3317
#else   /* not SX */
#line 3317

#line 3317
	char *xp = (char *) *xpp;
#line 3317
	int status = ENOERR;
#line 3317

#line 3317
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3317
	{
#line 3317
		int lstatus = ncx_put_double_ulonglong(xp, tp);
#line 3317
		if(lstatus != ENOERR)
#line 3317
			status = lstatus;
#line 3317
	}
#line 3317

#line 3317
	*xpp = (void *)xp;
#line 3317
	return status;
#line 3317
#endif
#line 3317
}
#line 3317



/* longlong -----------------------------------------------------------------------*/

#if X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
/* optimized version */
int
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(long long));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_LONGLONG);
	return ENOERR;
}
#else
int
#line 3336
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3336
{
#line 3336
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3336

#line 3336
 /* basic algorithm is:
#line 3336
  *   - ensure sane alignment of input data
#line 3336
  *   - copy (conversion happens automatically) input data
#line 3336
  *     to output
#line 3336
  *   - update xpp to point at next unconverted input, and tp to point
#line 3336
  *     at next location for converted output
#line 3336
  */
#line 3336
  long i, j, ni;
#line 3336
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3336
  longlong *xp;
#line 3336
  int nrange = 0;         /* number of range errors */
#line 3336
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3336
  long cxp = (long) *((char**)xpp);
#line 3336

#line 3336
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3336
  /* sjl: manually stripmine so we can limit amount of
#line 3336
   * vector work space reserved to LOOPCNT elements. Also
#line 3336
   * makes vectorisation easy */
#line 3336
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3336
    ni=Min(nelems-j,LOOPCNT);
#line 3336
    if (realign) {
#line 3336
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3336
      xp = tmp;
#line 3336
    } else {
#line 3336
      xp = (longlong *) *xpp;
#line 3336
    }
#line 3336
   /* copy the next block */
#line 3336
#pragma cdir loopcnt=LOOPCNT
#line 3336
#pragma cdir shortloop
#line 3336
    for (i=0; i<ni; i++) {
#line 3336
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3336
     /* test for range errors (not always needed but do it anyway) */
#line 3336
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3336
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3336
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3336
    }
#line 3336
   /* update xpp and tp */
#line 3336
    if (realign) xp = (longlong *) *xpp;
#line 3336
    xp += ni;
#line 3336
    tp += ni;
#line 3336
    *xpp = (void*)xp;
#line 3336
  }
#line 3336
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3336

#line 3336
#else   /* not SX */
#line 3336
	const char *xp = (const char *) *xpp;
#line 3336
	int status = ENOERR;
#line 3336

#line 3336
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3336
	{
#line 3336
		const int lstatus = ncx_get_longlong_longlong(xp, tp);
#line 3336
		if(lstatus != ENOERR)
#line 3336
			status = lstatus;
#line 3336
	}
#line 3336

#line 3336
	*xpp = (const void *)xp;
#line 3336
	return status;
#line 3336
#  endif
#line 3336
}
#line 3336

#endif
int
#line 3338
ncx_getn_longlong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3338
{
#line 3338
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3338

#line 3338
 /* basic algorithm is:
#line 3338
  *   - ensure sane alignment of input data
#line 3338
  *   - copy (conversion happens automatically) input data
#line 3338
  *     to output
#line 3338
  *   - update xpp to point at next unconverted input, and tp to point
#line 3338
  *     at next location for converted output
#line 3338
  */
#line 3338
  long i, j, ni;
#line 3338
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3338
  longlong *xp;
#line 3338
  int nrange = 0;         /* number of range errors */
#line 3338
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3338
  long cxp = (long) *((char**)xpp);
#line 3338

#line 3338
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3338
  /* sjl: manually stripmine so we can limit amount of
#line 3338
   * vector work space reserved to LOOPCNT elements. Also
#line 3338
   * makes vectorisation easy */
#line 3338
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3338
    ni=Min(nelems-j,LOOPCNT);
#line 3338
    if (realign) {
#line 3338
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3338
      xp = tmp;
#line 3338
    } else {
#line 3338
      xp = (longlong *) *xpp;
#line 3338
    }
#line 3338
   /* copy the next block */
#line 3338
#pragma cdir loopcnt=LOOPCNT
#line 3338
#pragma cdir shortloop
#line 3338
    for (i=0; i<ni; i++) {
#line 3338
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3338
     /* test for range errors (not always needed but do it anyway) */
#line 3338
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3338
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3338
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3338
    }
#line 3338
   /* update xpp and tp */
#line 3338
    if (realign) xp = (longlong *) *xpp;
#line 3338
    xp += ni;
#line 3338
    tp += ni;
#line 3338
    *xpp = (void*)xp;
#line 3338
  }
#line 3338
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3338

#line 3338
#else   /* not SX */
#line 3338
	const char *xp = (const char *) *xpp;
#line 3338
	int status = ENOERR;
#line 3338

#line 3338
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3338
	{
#line 3338
		const int lstatus = ncx_get_longlong_schar(xp, tp);
#line 3338
		if(lstatus != ENOERR)
#line 3338
			status = lstatus;
#line 3338
	}
#line 3338

#line 3338
	*xpp = (const void *)xp;
#line 3338
	return status;
#line 3338
#  endif
#line 3338
}
#line 3338

int
#line 3339
ncx_getn_longlong_short(const void **xpp, size_t nelems, short *tp)
#line 3339
{
#line 3339
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3339

#line 3339
 /* basic algorithm is:
#line 3339
  *   - ensure sane alignment of input data
#line 3339
  *   - copy (conversion happens automatically) input data
#line 3339
  *     to output
#line 3339
  *   - update xpp to point at next unconverted input, and tp to point
#line 3339
  *     at next location for converted output
#line 3339
  */
#line 3339
  long i, j, ni;
#line 3339
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3339
  longlong *xp;
#line 3339
  int nrange = 0;         /* number of range errors */
#line 3339
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3339
  long cxp = (long) *((char**)xpp);
#line 3339

#line 3339
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3339
  /* sjl: manually stripmine so we can limit amount of
#line 3339
   * vector work space reserved to LOOPCNT elements. Also
#line 3339
   * makes vectorisation easy */
#line 3339
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3339
    ni=Min(nelems-j,LOOPCNT);
#line 3339
    if (realign) {
#line 3339
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3339
      xp = tmp;
#line 3339
    } else {
#line 3339
      xp = (longlong *) *xpp;
#line 3339
    }
#line 3339
   /* copy the next block */
#line 3339
#pragma cdir loopcnt=LOOPCNT
#line 3339
#pragma cdir shortloop
#line 3339
    for (i=0; i<ni; i++) {
#line 3339
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3339
     /* test for range errors (not always needed but do it anyway) */
#line 3339
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3339
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3339
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3339
    }
#line 3339
   /* update xpp and tp */
#line 3339
    if (realign) xp = (longlong *) *xpp;
#line 3339
    xp += ni;
#line 3339
    tp += ni;
#line 3339
    *xpp = (void*)xp;
#line 3339
  }
#line 3339
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3339

#line 3339
#else   /* not SX */
#line 3339
	const char *xp = (const char *) *xpp;
#line 3339
	int status = ENOERR;
#line 3339

#line 3339
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3339
	{
#line 3339
		const int lstatus = ncx_get_longlong_short(xp, tp);
#line 3339
		if(lstatus != ENOERR)
#line 3339
			status = lstatus;
#line 3339
	}
#line 3339

#line 3339
	*xpp = (const void *)xp;
#line 3339
	return status;
#line 3339
#  endif
#line 3339
}
#line 3339

int
#line 3340
ncx_getn_longlong_int(const void **xpp, size_t nelems, int *tp)
#line 3340
{
#line 3340
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3340

#line 3340
 /* basic algorithm is:
#line 3340
  *   - ensure sane alignment of input data
#line 3340
  *   - copy (conversion happens automatically) input data
#line 3340
  *     to output
#line 3340
  *   - update xpp to point at next unconverted input, and tp to point
#line 3340
  *     at next location for converted output
#line 3340
  */
#line 3340
  long i, j, ni;
#line 3340
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3340
  longlong *xp;
#line 3340
  int nrange = 0;         /* number of range errors */
#line 3340
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3340
  long cxp = (long) *((char**)xpp);
#line 3340

#line 3340
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3340
  /* sjl: manually stripmine so we can limit amount of
#line 3340
   * vector work space reserved to LOOPCNT elements. Also
#line 3340
   * makes vectorisation easy */
#line 3340
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3340
    ni=Min(nelems-j,LOOPCNT);
#line 3340
    if (realign) {
#line 3340
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3340
      xp = tmp;
#line 3340
    } else {
#line 3340
      xp = (longlong *) *xpp;
#line 3340
    }
#line 3340
   /* copy the next block */
#line 3340
#pragma cdir loopcnt=LOOPCNT
#line 3340
#pragma cdir shortloop
#line 3340
    for (i=0; i<ni; i++) {
#line 3340
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3340
     /* test for range errors (not always needed but do it anyway) */
#line 3340
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3340
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3340
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3340
    }
#line 3340
   /* update xpp and tp */
#line 3340
    if (realign) xp = (longlong *) *xpp;
#line 3340
    xp += ni;
#line 3340
    tp += ni;
#line 3340
    *xpp = (void*)xp;
#line 3340
  }
#line 3340
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3340

#line 3340
#else   /* not SX */
#line 3340
	const char *xp = (const char *) *xpp;
#line 3340
	int status = ENOERR;
#line 3340

#line 3340
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3340
	{
#line 3340
		const int lstatus = ncx_get_longlong_int(xp, tp);
#line 3340
		if(lstatus != ENOERR)
#line 3340
			status = lstatus;
#line 3340
	}
#line 3340

#line 3340
	*xpp = (const void *)xp;
#line 3340
	return status;
#line 3340
#  endif
#line 3340
}
#line 3340

int
#line 3341
ncx_getn_longlong_float(const void **xpp, size_t nelems, float *tp)
#line 3341
{
#line 3341
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3341

#line 3341
 /* basic algorithm is:
#line 3341
  *   - ensure sane alignment of input data
#line 3341
  *   - copy (conversion happens automatically) input data
#line 3341
  *     to output
#line 3341
  *   - update xpp to point at next unconverted input, and tp to point
#line 3341
  *     at next location for converted output
#line 3341
  */
#line 3341
  long i, j, ni;
#line 3341
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3341
  longlong *xp;
#line 3341
  int nrange = 0;         /* number of range errors */
#line 3341
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3341
  long cxp = (long) *((char**)xpp);
#line 3341

#line 3341
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3341
  /* sjl: manually stripmine so we can limit amount of
#line 3341
   * vector work space reserved to LOOPCNT elements. Also
#line 3341
   * makes vectorisation easy */
#line 3341
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3341
    ni=Min(nelems-j,LOOPCNT);
#line 3341
    if (realign) {
#line 3341
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3341
      xp = tmp;
#line 3341
    } else {
#line 3341
      xp = (longlong *) *xpp;
#line 3341
    }
#line 3341
   /* copy the next block */
#line 3341
#pragma cdir loopcnt=LOOPCNT
#line 3341
#pragma cdir shortloop
#line 3341
    for (i=0; i<ni; i++) {
#line 3341
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3341
     /* test for range errors (not always needed but do it anyway) */
#line 3341
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3341
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3341
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3341
    }
#line 3341
   /* update xpp and tp */
#line 3341
    if (realign) xp = (longlong *) *xpp;
#line 3341
    xp += ni;
#line 3341
    tp += ni;
#line 3341
    *xpp = (void*)xp;
#line 3341
  }
#line 3341
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3341

#line 3341
#else   /* not SX */
#line 3341
	const char *xp = (const char *) *xpp;
#line 3341
	int status = ENOERR;
#line 3341

#line 3341
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3341
	{
#line 3341
		const int lstatus = ncx_get_longlong_float(xp, tp);
#line 3341
		if(lstatus != ENOERR)
#line 3341
			status = lstatus;
#line 3341
	}
#line 3341

#line 3341
	*xpp = (const void *)xp;
#line 3341
	return status;
#line 3341
#  endif
#line 3341
}
#line 3341

int
#line 3342
ncx_getn_longlong_double(const void **xpp, size_t nelems, double *tp)
#line 3342
{
#line 3342
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3342

#line 3342
 /* basic algorithm is:
#line 3342
  *   - ensure sane alignment of input data
#line 3342
  *   - copy (conversion happens automatically) input data
#line 3342
  *     to output
#line 3342
  *   - update xpp to point at next unconverted input, and tp to point
#line 3342
  *     at next location for converted output
#line 3342
  */
#line 3342
  long i, j, ni;
#line 3342
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3342
  longlong *xp;
#line 3342
  int nrange = 0;         /* number of range errors */
#line 3342
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3342
  long cxp = (long) *((char**)xpp);
#line 3342

#line 3342
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3342
  /* sjl: manually stripmine so we can limit amount of
#line 3342
   * vector work space reserved to LOOPCNT elements. Also
#line 3342
   * makes vectorisation easy */
#line 3342
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3342
    ni=Min(nelems-j,LOOPCNT);
#line 3342
    if (realign) {
#line 3342
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3342
      xp = tmp;
#line 3342
    } else {
#line 3342
      xp = (longlong *) *xpp;
#line 3342
    }
#line 3342
   /* copy the next block */
#line 3342
#pragma cdir loopcnt=LOOPCNT
#line 3342
#pragma cdir shortloop
#line 3342
    for (i=0; i<ni; i++) {
#line 3342
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3342
     /* test for range errors (not always needed but do it anyway) */
#line 3342
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3342
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3342
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3342
    }
#line 3342
   /* update xpp and tp */
#line 3342
    if (realign) xp = (longlong *) *xpp;
#line 3342
    xp += ni;
#line 3342
    tp += ni;
#line 3342
    *xpp = (void*)xp;
#line 3342
  }
#line 3342
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3342

#line 3342
#else   /* not SX */
#line 3342
	const char *xp = (const char *) *xpp;
#line 3342
	int status = ENOERR;
#line 3342

#line 3342
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3342
	{
#line 3342
		const int lstatus = ncx_get_longlong_double(xp, tp);
#line 3342
		if(lstatus != ENOERR)
#line 3342
			status = lstatus;
#line 3342
	}
#line 3342

#line 3342
	*xpp = (const void *)xp;
#line 3342
	return status;
#line 3342
#  endif
#line 3342
}
#line 3342

int
#line 3343
ncx_getn_longlong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3343
{
#line 3343
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3343

#line 3343
 /* basic algorithm is:
#line 3343
  *   - ensure sane alignment of input data
#line 3343
  *   - copy (conversion happens automatically) input data
#line 3343
  *     to output
#line 3343
  *   - update xpp to point at next unconverted input, and tp to point
#line 3343
  *     at next location for converted output
#line 3343
  */
#line 3343
  long i, j, ni;
#line 3343
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3343
  longlong *xp;
#line 3343
  int nrange = 0;         /* number of range errors */
#line 3343
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3343
  long cxp = (long) *((char**)xpp);
#line 3343

#line 3343
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3343
  /* sjl: manually stripmine so we can limit amount of
#line 3343
   * vector work space reserved to LOOPCNT elements. Also
#line 3343
   * makes vectorisation easy */
#line 3343
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3343
    ni=Min(nelems-j,LOOPCNT);
#line 3343
    if (realign) {
#line 3343
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3343
      xp = tmp;
#line 3343
    } else {
#line 3343
      xp = (longlong *) *xpp;
#line 3343
    }
#line 3343
   /* copy the next block */
#line 3343
#pragma cdir loopcnt=LOOPCNT
#line 3343
#pragma cdir shortloop
#line 3343
    for (i=0; i<ni; i++) {
#line 3343
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3343
     /* test for range errors (not always needed but do it anyway) */
#line 3343
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3343
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3343
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3343
    }
#line 3343
   /* update xpp and tp */
#line 3343
    if (realign) xp = (longlong *) *xpp;
#line 3343
    xp += ni;
#line 3343
    tp += ni;
#line 3343
    *xpp = (void*)xp;
#line 3343
  }
#line 3343
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3343

#line 3343
#else   /* not SX */
#line 3343
	const char *xp = (const char *) *xpp;
#line 3343
	int status = ENOERR;
#line 3343

#line 3343
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3343
	{
#line 3343
		const int lstatus = ncx_get_longlong_uchar(xp, tp);
#line 3343
		if(lstatus != ENOERR)
#line 3343
			status = lstatus;
#line 3343
	}
#line 3343

#line 3343
	*xpp = (const void *)xp;
#line 3343
	return status;
#line 3343
#  endif
#line 3343
}
#line 3343

int
#line 3344
ncx_getn_longlong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3344
{
#line 3344
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3344

#line 3344
 /* basic algorithm is:
#line 3344
  *   - ensure sane alignment of input data
#line 3344
  *   - copy (conversion happens automatically) input data
#line 3344
  *     to output
#line 3344
  *   - update xpp to point at next unconverted input, and tp to point
#line 3344
  *     at next location for converted output
#line 3344
  */
#line 3344
  long i, j, ni;
#line 3344
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3344
  longlong *xp;
#line 3344
  int nrange = 0;         /* number of range errors */
#line 3344
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3344
  long cxp = (long) *((char**)xpp);
#line 3344

#line 3344
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3344
  /* sjl: manually stripmine so we can limit amount of
#line 3344
   * vector work space reserved to LOOPCNT elements. Also
#line 3344
   * makes vectorisation easy */
#line 3344
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3344
    ni=Min(nelems-j,LOOPCNT);
#line 3344
    if (realign) {
#line 3344
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3344
      xp = tmp;
#line 3344
    } else {
#line 3344
      xp = (longlong *) *xpp;
#line 3344
    }
#line 3344
   /* copy the next block */
#line 3344
#pragma cdir loopcnt=LOOPCNT
#line 3344
#pragma cdir shortloop
#line 3344
    for (i=0; i<ni; i++) {
#line 3344
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3344
     /* test for range errors (not always needed but do it anyway) */
#line 3344
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3344
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3344
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3344
    }
#line 3344
   /* update xpp and tp */
#line 3344
    if (realign) xp = (longlong *) *xpp;
#line 3344
    xp += ni;
#line 3344
    tp += ni;
#line 3344
    *xpp = (void*)xp;
#line 3344
  }
#line 3344
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3344

#line 3344
#else   /* not SX */
#line 3344
	const char *xp = (const char *) *xpp;
#line 3344
	int status = ENOERR;
#line 3344

#line 3344
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3344
	{
#line 3344
		const int lstatus = ncx_get_longlong_ushort(xp, tp);
#line 3344
		if(lstatus != ENOERR)
#line 3344
			status = lstatus;
#line 3344
	}
#line 3344

#line 3344
	*xpp = (const void *)xp;
#line 3344
	return status;
#line 3344
#  endif
#line 3344
}
#line 3344

int
#line 3345
ncx_getn_longlong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3345
{
#line 3345
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3345

#line 3345
 /* basic algorithm is:
#line 3345
  *   - ensure sane alignment of input data
#line 3345
  *   - copy (conversion happens automatically) input data
#line 3345
  *     to output
#line 3345
  *   - update xpp to point at next unconverted input, and tp to point
#line 3345
  *     at next location for converted output
#line 3345
  */
#line 3345
  long i, j, ni;
#line 3345
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3345
  longlong *xp;
#line 3345
  int nrange = 0;         /* number of range errors */
#line 3345
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3345
  long cxp = (long) *((char**)xpp);
#line 3345

#line 3345
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3345
  /* sjl: manually stripmine so we can limit amount of
#line 3345
   * vector work space reserved to LOOPCNT elements. Also
#line 3345
   * makes vectorisation easy */
#line 3345
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3345
    ni=Min(nelems-j,LOOPCNT);
#line 3345
    if (realign) {
#line 3345
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3345
      xp = tmp;
#line 3345
    } else {
#line 3345
      xp = (longlong *) *xpp;
#line 3345
    }
#line 3345
   /* copy the next block */
#line 3345
#pragma cdir loopcnt=LOOPCNT
#line 3345
#pragma cdir shortloop
#line 3345
    for (i=0; i<ni; i++) {
#line 3345
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3345
     /* test for range errors (not always needed but do it anyway) */
#line 3345
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3345
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3345
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3345
    }
#line 3345
   /* update xpp and tp */
#line 3345
    if (realign) xp = (longlong *) *xpp;
#line 3345
    xp += ni;
#line 3345
    tp += ni;
#line 3345
    *xpp = (void*)xp;
#line 3345
  }
#line 3345
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3345

#line 3345
#else   /* not SX */
#line 3345
	const char *xp = (const char *) *xpp;
#line 3345
	int status = ENOERR;
#line 3345

#line 3345
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3345
	{
#line 3345
		const int lstatus = ncx_get_longlong_uint(xp, tp);
#line 3345
		if(lstatus != ENOERR)
#line 3345
			status = lstatus;
#line 3345
	}
#line 3345

#line 3345
	*xpp = (const void *)xp;
#line 3345
	return status;
#line 3345
#  endif
#line 3345
}
#line 3345

int
#line 3346
ncx_getn_longlong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3346
{
#line 3346
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3346

#line 3346
 /* basic algorithm is:
#line 3346
  *   - ensure sane alignment of input data
#line 3346
  *   - copy (conversion happens automatically) input data
#line 3346
  *     to output
#line 3346
  *   - update xpp to point at next unconverted input, and tp to point
#line 3346
  *     at next location for converted output
#line 3346
  */
#line 3346
  long i, j, ni;
#line 3346
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3346
  longlong *xp;
#line 3346
  int nrange = 0;         /* number of range errors */
#line 3346
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3346
  long cxp = (long) *((char**)xpp);
#line 3346

#line 3346
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3346
  /* sjl: manually stripmine so we can limit amount of
#line 3346
   * vector work space reserved to LOOPCNT elements. Also
#line 3346
   * makes vectorisation easy */
#line 3346
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3346
    ni=Min(nelems-j,LOOPCNT);
#line 3346
    if (realign) {
#line 3346
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3346
      xp = tmp;
#line 3346
    } else {
#line 3346
      xp = (longlong *) *xpp;
#line 3346
    }
#line 3346
   /* copy the next block */
#line 3346
#pragma cdir loopcnt=LOOPCNT
#line 3346
#pragma cdir shortloop
#line 3346
    for (i=0; i<ni; i++) {
#line 3346
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3346
     /* test for range errors (not always needed but do it anyway) */
#line 3346
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3346
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3346
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3346
    }
#line 3346
   /* update xpp and tp */
#line 3346
    if (realign) xp = (longlong *) *xpp;
#line 3346
    xp += ni;
#line 3346
    tp += ni;
#line 3346
    *xpp = (void*)xp;
#line 3346
  }
#line 3346
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3346

#line 3346
#else   /* not SX */
#line 3346
	const char *xp = (const char *) *xpp;
#line 3346
	int status = ENOERR;
#line 3346

#line 3346
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3346
	{
#line 3346
		const int lstatus = ncx_get_longlong_ulonglong(xp, tp);
#line 3346
		if(lstatus != ENOERR)
#line 3346
			status = lstatus;
#line 3346
	}
#line 3346

#line 3346
	*xpp = (const void *)xp;
#line 3346
	return status;
#line 3346
#  endif
#line 3346
}
#line 3346


#if X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
/* optimized version */
int
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_LONGLONG);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_LONGLONG);
	return ENOERR;
}
#else
int
#line 3362
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3362
{
#line 3362
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3362

#line 3362
 /* basic algorithm is:
#line 3362
  *   - ensure sane alignment of output data
#line 3362
  *   - copy (conversion happens automatically) input data
#line 3362
  *     to output
#line 3362
  *   - update tp to point at next unconverted input, and xpp to point
#line 3362
  *     at next location for converted output
#line 3362
  */
#line 3362
  long i, j, ni;
#line 3362
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3362
  longlong *xp;
#line 3362
  int nrange = 0;         /* number of range errors */
#line 3362
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3362
  long cxp = (long) *((char**)xpp);
#line 3362

#line 3362
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3362
  /* sjl: manually stripmine so we can limit amount of
#line 3362
   * vector work space reserved to LOOPCNT elements. Also
#line 3362
   * makes vectorisation easy */
#line 3362
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3362
    ni=Min(nelems-j,LOOPCNT);
#line 3362
    if (realign) {
#line 3362
      xp = tmp;
#line 3362
    } else {
#line 3362
      xp = (longlong *) *xpp;
#line 3362
    }
#line 3362
   /* copy the next block */
#line 3362
#pragma cdir loopcnt=LOOPCNT
#line 3362
#pragma cdir shortloop
#line 3362
    for (i=0; i<ni; i++) {
#line 3362
      /* the normal case: */
#line 3362
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3362
     /* test for range errors (not always needed but do it anyway) */
#line 3362
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3362
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3362
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3362
    }
#line 3362
   /* copy workspace back if necessary */
#line 3362
    if (realign) {
#line 3362
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3362
      xp = (longlong *) *xpp;
#line 3362
    }
#line 3362
   /* update xpp and tp */
#line 3362
    xp += ni;
#line 3362
    tp += ni;
#line 3362
    *xpp = (void*)xp;
#line 3362
  }
#line 3362
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3362

#line 3362
#else   /* not SX */
#line 3362

#line 3362
	char *xp = (char *) *xpp;
#line 3362
	int status = ENOERR;
#line 3362

#line 3362
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3362
	{
#line 3362
		int lstatus = ncx_put_longlong_longlong(xp, tp);
#line 3362
		if(lstatus != ENOERR)
#line 3362
			status = lstatus;
#line 3362
	}
#line 3362

#line 3362
	*xpp = (void *)xp;
#line 3362
	return status;
#line 3362
#endif
#line 3362
}
#line 3362

#endif
int
#line 3364
ncx_putn_longlong_schar(void **xpp, size_t nelems, const schar *tp)
#line 3364
{
#line 3364
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3364

#line 3364
 /* basic algorithm is:
#line 3364
  *   - ensure sane alignment of output data
#line 3364
  *   - copy (conversion happens automatically) input data
#line 3364
  *     to output
#line 3364
  *   - update tp to point at next unconverted input, and xpp to point
#line 3364
  *     at next location for converted output
#line 3364
  */
#line 3364
  long i, j, ni;
#line 3364
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3364
  longlong *xp;
#line 3364
  int nrange = 0;         /* number of range errors */
#line 3364
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3364
  long cxp = (long) *((char**)xpp);
#line 3364

#line 3364
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3364
  /* sjl: manually stripmine so we can limit amount of
#line 3364
   * vector work space reserved to LOOPCNT elements. Also
#line 3364
   * makes vectorisation easy */
#line 3364
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3364
    ni=Min(nelems-j,LOOPCNT);
#line 3364
    if (realign) {
#line 3364
      xp = tmp;
#line 3364
    } else {
#line 3364
      xp = (longlong *) *xpp;
#line 3364
    }
#line 3364
   /* copy the next block */
#line 3364
#pragma cdir loopcnt=LOOPCNT
#line 3364
#pragma cdir shortloop
#line 3364
    for (i=0; i<ni; i++) {
#line 3364
      /* the normal case: */
#line 3364
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3364
     /* test for range errors (not always needed but do it anyway) */
#line 3364
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3364
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3364
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3364
    }
#line 3364
   /* copy workspace back if necessary */
#line 3364
    if (realign) {
#line 3364
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3364
      xp = (longlong *) *xpp;
#line 3364
    }
#line 3364
   /* update xpp and tp */
#line 3364
    xp += ni;
#line 3364
    tp += ni;
#line 3364
    *xpp = (void*)xp;
#line 3364
  }
#line 3364
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3364

#line 3364
#else   /* not SX */
#line 3364

#line 3364
	char *xp = (char *) *xpp;
#line 3364
	int status = ENOERR;
#line 3364

#line 3364
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3364
	{
#line 3364
		int lstatus = ncx_put_longlong_schar(xp, tp);
#line 3364
		if(lstatus != ENOERR)
#line 3364
			status = lstatus;
#line 3364
	}
#line 3364

#line 3364
	*xpp = (void *)xp;
#line 3364
	return status;
#line 3364
#endif
#line 3364
}
#line 3364

int
#line 3365
ncx_putn_longlong_short(void **xpp, size_t nelems, const short *tp)
#line 3365
{
#line 3365
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3365

#line 3365
 /* basic algorithm is:
#line 3365
  *   - ensure sane alignment of output data
#line 3365
  *   - copy (conversion happens automatically) input data
#line 3365
  *     to output
#line 3365
  *   - update tp to point at next unconverted input, and xpp to point
#line 3365
  *     at next location for converted output
#line 3365
  */
#line 3365
  long i, j, ni;
#line 3365
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3365
  longlong *xp;
#line 3365
  int nrange = 0;         /* number of range errors */
#line 3365
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3365
  long cxp = (long) *((char**)xpp);
#line 3365

#line 3365
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3365
  /* sjl: manually stripmine so we can limit amount of
#line 3365
   * vector work space reserved to LOOPCNT elements. Also
#line 3365
   * makes vectorisation easy */
#line 3365
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3365
    ni=Min(nelems-j,LOOPCNT);
#line 3365
    if (realign) {
#line 3365
      xp = tmp;
#line 3365
    } else {
#line 3365
      xp = (longlong *) *xpp;
#line 3365
    }
#line 3365
   /* copy the next block */
#line 3365
#pragma cdir loopcnt=LOOPCNT
#line 3365
#pragma cdir shortloop
#line 3365
    for (i=0; i<ni; i++) {
#line 3365
      /* the normal case: */
#line 3365
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3365
     /* test for range errors (not always needed but do it anyway) */
#line 3365
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3365
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3365
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3365
    }
#line 3365
   /* copy workspace back if necessary */
#line 3365
    if (realign) {
#line 3365
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3365
      xp = (longlong *) *xpp;
#line 3365
    }
#line 3365
   /* update xpp and tp */
#line 3365
    xp += ni;
#line 3365
    tp += ni;
#line 3365
    *xpp = (void*)xp;
#line 3365
  }
#line 3365
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3365

#line 3365
#else   /* not SX */
#line 3365

#line 3365
	char *xp = (char *) *xpp;
#line 3365
	int status = ENOERR;
#line 3365

#line 3365
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3365
	{
#line 3365
		int lstatus = ncx_put_longlong_short(xp, tp);
#line 3365
		if(lstatus != ENOERR)
#line 3365
			status = lstatus;
#line 3365
	}
#line 3365

#line 3365
	*xpp = (void *)xp;
#line 3365
	return status;
#line 3365
#endif
#line 3365
}
#line 3365

int
#line 3366
ncx_putn_longlong_int(void **xpp, size_t nelems, const int *tp)
#line 3366
{
#line 3366
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3366

#line 3366
 /* basic algorithm is:
#line 3366
  *   - ensure sane alignment of output data
#line 3366
  *   - copy (conversion happens automatically) input data
#line 3366
  *     to output
#line 3366
  *   - update tp to point at next unconverted input, and xpp to point
#line 3366
  *     at next location for converted output
#line 3366
  */
#line 3366
  long i, j, ni;
#line 3366
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3366
  longlong *xp;
#line 3366
  int nrange = 0;         /* number of range errors */
#line 3366
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3366
  long cxp = (long) *((char**)xpp);
#line 3366

#line 3366
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3366
  /* sjl: manually stripmine so we can limit amount of
#line 3366
   * vector work space reserved to LOOPCNT elements. Also
#line 3366
   * makes vectorisation easy */
#line 3366
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3366
    ni=Min(nelems-j,LOOPCNT);
#line 3366
    if (realign) {
#line 3366
      xp = tmp;
#line 3366
    } else {
#line 3366
      xp = (longlong *) *xpp;
#line 3366
    }
#line 3366
   /* copy the next block */
#line 3366
#pragma cdir loopcnt=LOOPCNT
#line 3366
#pragma cdir shortloop
#line 3366
    for (i=0; i<ni; i++) {
#line 3366
      /* the normal case: */
#line 3366
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3366
     /* test for range errors (not always needed but do it anyway) */
#line 3366
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3366
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3366
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3366
    }
#line 3366
   /* copy workspace back if necessary */
#line 3366
    if (realign) {
#line 3366
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3366
      xp = (longlong *) *xpp;
#line 3366
    }
#line 3366
   /* update xpp and tp */
#line 3366
    xp += ni;
#line 3366
    tp += ni;
#line 3366
    *xpp = (void*)xp;
#line 3366
  }
#line 3366
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3366

#line 3366
#else   /* not SX */
#line 3366

#line 3366
	char *xp = (char *) *xpp;
#line 3366
	int status = ENOERR;
#line 3366

#line 3366
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3366
	{
#line 3366
		int lstatus = ncx_put_longlong_int(xp, tp);
#line 3366
		if(lstatus != ENOERR)
#line 3366
			status = lstatus;
#line 3366
	}
#line 3366

#line 3366
	*xpp = (void *)xp;
#line 3366
	return status;
#line 3366
#endif
#line 3366
}
#line 3366

int
#line 3367
ncx_putn_longlong_float(void **xpp, size_t nelems, const float *tp)
#line 3367
{
#line 3367
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3367

#line 3367
 /* basic algorithm is:
#line 3367
  *   - ensure sane alignment of output data
#line 3367
  *   - copy (conversion happens automatically) input data
#line 3367
  *     to output
#line 3367
  *   - update tp to point at next unconverted input, and xpp to point
#line 3367
  *     at next location for converted output
#line 3367
  */
#line 3367
  long i, j, ni;
#line 3367
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3367
  longlong *xp;
#line 3367
  int nrange = 0;         /* number of range errors */
#line 3367
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3367
  long cxp = (long) *((char**)xpp);
#line 3367

#line 3367
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3367
  /* sjl: manually stripmine so we can limit amount of
#line 3367
   * vector work space reserved to LOOPCNT elements. Also
#line 3367
   * makes vectorisation easy */
#line 3367
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3367
    ni=Min(nelems-j,LOOPCNT);
#line 3367
    if (realign) {
#line 3367
      xp = tmp;
#line 3367
    } else {
#line 3367
      xp = (longlong *) *xpp;
#line 3367
    }
#line 3367
   /* copy the next block */
#line 3367
#pragma cdir loopcnt=LOOPCNT
#line 3367
#pragma cdir shortloop
#line 3367
    for (i=0; i<ni; i++) {
#line 3367
      /* the normal case: */
#line 3367
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3367
     /* test for range errors (not always needed but do it anyway) */
#line 3367
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3367
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3367
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3367
    }
#line 3367
   /* copy workspace back if necessary */
#line 3367
    if (realign) {
#line 3367
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3367
      xp = (longlong *) *xpp;
#line 3367
    }
#line 3367
   /* update xpp and tp */
#line 3367
    xp += ni;
#line 3367
    tp += ni;
#line 3367
    *xpp = (void*)xp;
#line 3367
  }
#line 3367
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3367

#line 3367
#else   /* not SX */
#line 3367

#line 3367
	char *xp = (char *) *xpp;
#line 3367
	int status = ENOERR;
#line 3367

#line 3367
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3367
	{
#line 3367
		int lstatus = ncx_put_longlong_float(xp, tp);
#line 3367
		if(lstatus != ENOERR)
#line 3367
			status = lstatus;
#line 3367
	}
#line 3367

#line 3367
	*xpp = (void *)xp;
#line 3367
	return status;
#line 3367
#endif
#line 3367
}
#line 3367

int
#line 3368
ncx_putn_longlong_double(void **xpp, size_t nelems, const double *tp)
#line 3368
{
#line 3368
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3368

#line 3368
 /* basic algorithm is:
#line 3368
  *   - ensure sane alignment of output data
#line 3368
  *   - copy (conversion happens automatically) input data
#line 3368
  *     to output
#line 3368
  *   - update tp to point at next unconverted input, and xpp to point
#line 3368
  *     at next location for converted output
#line 3368
  */
#line 3368
  long i, j, ni;
#line 3368
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3368
  longlong *xp;
#line 3368
  int nrange = 0;         /* number of range errors */
#line 3368
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3368
  long cxp = (long) *((char**)xpp);
#line 3368

#line 3368
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3368
  /* sjl: manually stripmine so we can limit amount of
#line 3368
   * vector work space reserved to LOOPCNT elements. Also
#line 3368
   * makes vectorisation easy */
#line 3368
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3368
    ni=Min(nelems-j,LOOPCNT);
#line 3368
    if (realign) {
#line 3368
      xp = tmp;
#line 3368
    } else {
#line 3368
      xp = (longlong *) *xpp;
#line 3368
    }
#line 3368
   /* copy the next block */
#line 3368
#pragma cdir loopcnt=LOOPCNT
#line 3368
#pragma cdir shortloop
#line 3368
    for (i=0; i<ni; i++) {
#line 3368
      /* the normal case: */
#line 3368
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3368
     /* test for range errors (not always needed but do it anyway) */
#line 3368
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3368
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3368
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3368
    }
#line 3368
   /* copy workspace back if necessary */
#line 3368
    if (realign) {
#line 3368
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3368
      xp = (longlong *) *xpp;
#line 3368
    }
#line 3368
   /* update xpp and tp */
#line 3368
    xp += ni;
#line 3368
    tp += ni;
#line 3368
    *xpp = (void*)xp;
#line 3368
  }
#line 3368
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3368

#line 3368
#else   /* not SX */
#line 3368

#line 3368
	char *xp = (char *) *xpp;
#line 3368
	int status = ENOERR;
#line 3368

#line 3368
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3368
	{
#line 3368
		int lstatus = ncx_put_longlong_double(xp, tp);
#line 3368
		if(lstatus != ENOERR)
#line 3368
			status = lstatus;
#line 3368
	}
#line 3368

#line 3368
	*xpp = (void *)xp;
#line 3368
	return status;
#line 3368
#endif
#line 3368
}
#line 3368

int
#line 3369
ncx_putn_longlong_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3369
{
#line 3369
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3369

#line 3369
 /* basic algorithm is:
#line 3369
  *   - ensure sane alignment of output data
#line 3369
  *   - copy (conversion happens automatically) input data
#line 3369
  *     to output
#line 3369
  *   - update tp to point at next unconverted input, and xpp to point
#line 3369
  *     at next location for converted output
#line 3369
  */
#line 3369
  long i, j, ni;
#line 3369
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3369
  longlong *xp;
#line 3369
  int nrange = 0;         /* number of range errors */
#line 3369
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3369
  long cxp = (long) *((char**)xpp);
#line 3369

#line 3369
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3369
  /* sjl: manually stripmine so we can limit amount of
#line 3369
   * vector work space reserved to LOOPCNT elements. Also
#line 3369
   * makes vectorisation easy */
#line 3369
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3369
    ni=Min(nelems-j,LOOPCNT);
#line 3369
    if (realign) {
#line 3369
      xp = tmp;
#line 3369
    } else {
#line 3369
      xp = (longlong *) *xpp;
#line 3369
    }
#line 3369
   /* copy the next block */
#line 3369
#pragma cdir loopcnt=LOOPCNT
#line 3369
#pragma cdir shortloop
#line 3369
    for (i=0; i<ni; i++) {
#line 3369
      /* the normal case: */
#line 3369
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3369
     /* test for range errors (not always needed but do it anyway) */
#line 3369
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3369
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3369
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3369
    }
#line 3369
   /* copy workspace back if necessary */
#line 3369
    if (realign) {
#line 3369
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3369
      xp = (longlong *) *xpp;
#line 3369
    }
#line 3369
   /* update xpp and tp */
#line 3369
    xp += ni;
#line 3369
    tp += ni;
#line 3369
    *xpp = (void*)xp;
#line 3369
  }
#line 3369
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3369

#line 3369
#else   /* not SX */
#line 3369

#line 3369
	char *xp = (char *) *xpp;
#line 3369
	int status = ENOERR;
#line 3369

#line 3369
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3369
	{
#line 3369
		int lstatus = ncx_put_longlong_uchar(xp, tp);
#line 3369
		if(lstatus != ENOERR)
#line 3369
			status = lstatus;
#line 3369
	}
#line 3369

#line 3369
	*xpp = (void *)xp;
#line 3369
	return status;
#line 3369
#endif
#line 3369
}
#line 3369

int
#line 3370
ncx_putn_longlong_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3370
{
#line 3370
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3370

#line 3370
 /* basic algorithm is:
#line 3370
  *   - ensure sane alignment of output data
#line 3370
  *   - copy (conversion happens automatically) input data
#line 3370
  *     to output
#line 3370
  *   - update tp to point at next unconverted input, and xpp to point
#line 3370
  *     at next location for converted output
#line 3370
  */
#line 3370
  long i, j, ni;
#line 3370
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3370
  longlong *xp;
#line 3370
  int nrange = 0;         /* number of range errors */
#line 3370
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3370
  long cxp = (long) *((char**)xpp);
#line 3370

#line 3370
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3370
  /* sjl: manually stripmine so we can limit amount of
#line 3370
   * vector work space reserved to LOOPCNT elements. Also
#line 3370
   * makes vectorisation easy */
#line 3370
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3370
    ni=Min(nelems-j,LOOPCNT);
#line 3370
    if (realign) {
#line 3370
      xp = tmp;
#line 3370
    } else {
#line 3370
      xp = (longlong *) *xpp;
#line 3370
    }
#line 3370
   /* copy the next block */
#line 3370
#pragma cdir loopcnt=LOOPCNT
#line 3370
#pragma cdir shortloop
#line 3370
    for (i=0; i<ni; i++) {
#line 3370
      /* the normal case: */
#line 3370
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3370
     /* test for range errors (not always needed but do it anyway) */
#line 3370
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3370
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3370
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3370
    }
#line 3370
   /* copy workspace back if necessary */
#line 3370
    if (realign) {
#line 3370
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3370
      xp = (longlong *) *xpp;
#line 3370
    }
#line 3370
   /* update xpp and tp */
#line 3370
    xp += ni;
#line 3370
    tp += ni;
#line 3370
    *xpp = (void*)xp;
#line 3370
  }
#line 3370
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3370

#line 3370
#else   /* not SX */
#line 3370

#line 3370
	char *xp = (char *) *xpp;
#line 3370
	int status = ENOERR;
#line 3370

#line 3370
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3370
	{
#line 3370
		int lstatus = ncx_put_longlong_ushort(xp, tp);
#line 3370
		if(lstatus != ENOERR)
#line 3370
			status = lstatus;
#line 3370
	}
#line 3370

#line 3370
	*xpp = (void *)xp;
#line 3370
	return status;
#line 3370
#endif
#line 3370
}
#line 3370

int
#line 3371
ncx_putn_longlong_uint(void **xpp, size_t nelems, const uint *tp)
#line 3371
{
#line 3371
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3371

#line 3371
 /* basic algorithm is:
#line 3371
  *   - ensure sane alignment of output data
#line 3371
  *   - copy (conversion happens automatically) input data
#line 3371
  *     to output
#line 3371
  *   - update tp to point at next unconverted input, and xpp to point
#line 3371
  *     at next location for converted output
#line 3371
  */
#line 3371
  long i, j, ni;
#line 3371
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3371
  longlong *xp;
#line 3371
  int nrange = 0;         /* number of range errors */
#line 3371
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3371
  long cxp = (long) *((char**)xpp);
#line 3371

#line 3371
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3371
  /* sjl: manually stripmine so we can limit amount of
#line 3371
   * vector work space reserved to LOOPCNT elements. Also
#line 3371
   * makes vectorisation easy */
#line 3371
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3371
    ni=Min(nelems-j,LOOPCNT);
#line 3371
    if (realign) {
#line 3371
      xp = tmp;
#line 3371
    } else {
#line 3371
      xp = (longlong *) *xpp;
#line 3371
    }
#line 3371
   /* copy the next block */
#line 3371
#pragma cdir loopcnt=LOOPCNT
#line 3371
#pragma cdir shortloop
#line 3371
    for (i=0; i<ni; i++) {
#line 3371
      /* the normal case: */
#line 3371
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3371
     /* test for range errors (not always needed but do it anyway) */
#line 3371
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3371
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3371
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3371
    }
#line 3371
   /* copy workspace back if necessary */
#line 3371
    if (realign) {
#line 3371
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3371
      xp = (longlong *) *xpp;
#line 3371
    }
#line 3371
   /* update xpp and tp */
#line 3371
    xp += ni;
#line 3371
    tp += ni;
#line 3371
    *xpp = (void*)xp;
#line 3371
  }
#line 3371
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3371

#line 3371
#else   /* not SX */
#line 3371

#line 3371
	char *xp = (char *) *xpp;
#line 3371
	int status = ENOERR;
#line 3371

#line 3371
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3371
	{
#line 3371
		int lstatus = ncx_put_longlong_uint(xp, tp);
#line 3371
		if(lstatus != ENOERR)
#line 3371
			status = lstatus;
#line 3371
	}
#line 3371

#line 3371
	*xpp = (void *)xp;
#line 3371
	return status;
#line 3371
#endif
#line 3371
}
#line 3371

int
#line 3372
ncx_putn_longlong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3372
{
#line 3372
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3372

#line 3372
 /* basic algorithm is:
#line 3372
  *   - ensure sane alignment of output data
#line 3372
  *   - copy (conversion happens automatically) input data
#line 3372
  *     to output
#line 3372
  *   - update tp to point at next unconverted input, and xpp to point
#line 3372
  *     at next location for converted output
#line 3372
  */
#line 3372
  long i, j, ni;
#line 3372
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3372
  longlong *xp;
#line 3372
  int nrange = 0;         /* number of range errors */
#line 3372
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3372
  long cxp = (long) *((char**)xpp);
#line 3372

#line 3372
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3372
  /* sjl: manually stripmine so we can limit amount of
#line 3372
   * vector work space reserved to LOOPCNT elements. Also
#line 3372
   * makes vectorisation easy */
#line 3372
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3372
    ni=Min(nelems-j,LOOPCNT);
#line 3372
    if (realign) {
#line 3372
      xp = tmp;
#line 3372
    } else {
#line 3372
      xp = (longlong *) *xpp;
#line 3372
    }
#line 3372
   /* copy the next block */
#line 3372
#pragma cdir loopcnt=LOOPCNT
#line 3372
#pragma cdir shortloop
#line 3372
    for (i=0; i<ni; i++) {
#line 3372
      /* the normal case: */
#line 3372
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3372
     /* test for range errors (not always needed but do it anyway) */
#line 3372
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3372
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3372
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3372
    }
#line 3372
   /* copy workspace back if necessary */
#line 3372
    if (realign) {
#line 3372
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3372
      xp = (longlong *) *xpp;
#line 3372
    }
#line 3372
   /* update xpp and tp */
#line 3372
    xp += ni;
#line 3372
    tp += ni;
#line 3372
    *xpp = (void*)xp;
#line 3372
  }
#line 3372
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3372

#line 3372
#else   /* not SX */
#line 3372

#line 3372
	char *xp = (char *) *xpp;
#line 3372
	int status = ENOERR;
#line 3372

#line 3372
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3372
	{
#line 3372
		int lstatus = ncx_put_longlong_ulonglong(xp, tp);
#line 3372
		if(lstatus != ENOERR)
#line 3372
			status = lstatus;
#line 3372
	}
#line 3372

#line 3372
	*xpp = (void *)xp;
#line 3372
	return status;
#line 3372
#endif
#line 3372
}
#line 3372


/* ulonglong ----------------------------------------------------------------------*/

#if X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, unsigned long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(unsigned long long));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_ULONGLONG);
	return ENOERR;
}
#else
int
#line 3390
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3390
{
#line 3390
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3390

#line 3390
 /* basic algorithm is:
#line 3390
  *   - ensure sane alignment of input data
#line 3390
  *   - copy (conversion happens automatically) input data
#line 3390
  *     to output
#line 3390
  *   - update xpp to point at next unconverted input, and tp to point
#line 3390
  *     at next location for converted output
#line 3390
  */
#line 3390
  long i, j, ni;
#line 3390
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3390
  ulonglong *xp;
#line 3390
  int nrange = 0;         /* number of range errors */
#line 3390
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3390
  long cxp = (long) *((char**)xpp);
#line 3390

#line 3390
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3390
  /* sjl: manually stripmine so we can limit amount of
#line 3390
   * vector work space reserved to LOOPCNT elements. Also
#line 3390
   * makes vectorisation easy */
#line 3390
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3390
    ni=Min(nelems-j,LOOPCNT);
#line 3390
    if (realign) {
#line 3390
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3390
      xp = tmp;
#line 3390
    } else {
#line 3390
      xp = (ulonglong *) *xpp;
#line 3390
    }
#line 3390
   /* copy the next block */
#line 3390
#pragma cdir loopcnt=LOOPCNT
#line 3390
#pragma cdir shortloop
#line 3390
    for (i=0; i<ni; i++) {
#line 3390
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3390
     /* test for range errors (not always needed but do it anyway) */
#line 3390
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3390
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3390
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3390
    }
#line 3390
   /* update xpp and tp */
#line 3390
    if (realign) xp = (ulonglong *) *xpp;
#line 3390
    xp += ni;
#line 3390
    tp += ni;
#line 3390
    *xpp = (void*)xp;
#line 3390
  }
#line 3390
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3390

#line 3390
#else   /* not SX */
#line 3390
	const char *xp = (const char *) *xpp;
#line 3390
	int status = ENOERR;
#line 3390

#line 3390
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3390
	{
#line 3390
		const int lstatus = ncx_get_ulonglong_ulonglong(xp, tp);
#line 3390
		if(lstatus != ENOERR)
#line 3390
			status = lstatus;
#line 3390
	}
#line 3390

#line 3390
	*xpp = (const void *)xp;
#line 3390
	return status;
#line 3390
#  endif
#line 3390
}
#line 3390

#endif
int
#line 3392
ncx_getn_ulonglong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3392
{
#line 3392
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3392

#line 3392
 /* basic algorithm is:
#line 3392
  *   - ensure sane alignment of input data
#line 3392
  *   - copy (conversion happens automatically) input data
#line 3392
  *     to output
#line 3392
  *   - update xpp to point at next unconverted input, and tp to point
#line 3392
  *     at next location for converted output
#line 3392
  */
#line 3392
  long i, j, ni;
#line 3392
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3392
  ulonglong *xp;
#line 3392
  int nrange = 0;         /* number of range errors */
#line 3392
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3392
  long cxp = (long) *((char**)xpp);
#line 3392

#line 3392
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3392
  /* sjl: manually stripmine so we can limit amount of
#line 3392
   * vector work space reserved to LOOPCNT elements. Also
#line 3392
   * makes vectorisation easy */
#line 3392
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3392
    ni=Min(nelems-j,LOOPCNT);
#line 3392
    if (realign) {
#line 3392
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3392
      xp = tmp;
#line 3392
    } else {
#line 3392
      xp = (ulonglong *) *xpp;
#line 3392
    }
#line 3392
   /* copy the next block */
#line 3392
#pragma cdir loopcnt=LOOPCNT
#line 3392
#pragma cdir shortloop
#line 3392
    for (i=0; i<ni; i++) {
#line 3392
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3392
     /* test for range errors (not always needed but do it anyway) */
#line 3392
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3392
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3392
      nrange += xp[i] > SCHAR_MAX ;
#line 3392
    }
#line 3392
   /* update xpp and tp */
#line 3392
    if (realign) xp = (ulonglong *) *xpp;
#line 3392
    xp += ni;
#line 3392
    tp += ni;
#line 3392
    *xpp = (void*)xp;
#line 3392
  }
#line 3392
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3392

#line 3392
#else   /* not SX */
#line 3392
	const char *xp = (const char *) *xpp;
#line 3392
	int status = ENOERR;
#line 3392

#line 3392
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3392
	{
#line 3392
		const int lstatus = ncx_get_ulonglong_schar(xp, tp);
#line 3392
		if(lstatus != ENOERR)
#line 3392
			status = lstatus;
#line 3392
	}
#line 3392

#line 3392
	*xpp = (const void *)xp;
#line 3392
	return status;
#line 3392
#  endif
#line 3392
}
#line 3392

int
#line 3393
ncx_getn_ulonglong_short(const void **xpp, size_t nelems, short *tp)
#line 3393
{
#line 3393
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3393

#line 3393
 /* basic algorithm is:
#line 3393
  *   - ensure sane alignment of input data
#line 3393
  *   - copy (conversion happens automatically) input data
#line 3393
  *     to output
#line 3393
  *   - update xpp to point at next unconverted input, and tp to point
#line 3393
  *     at next location for converted output
#line 3393
  */
#line 3393
  long i, j, ni;
#line 3393
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3393
  ulonglong *xp;
#line 3393
  int nrange = 0;         /* number of range errors */
#line 3393
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3393
  long cxp = (long) *((char**)xpp);
#line 3393

#line 3393
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3393
  /* sjl: manually stripmine so we can limit amount of
#line 3393
   * vector work space reserved to LOOPCNT elements. Also
#line 3393
   * makes vectorisation easy */
#line 3393
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3393
    ni=Min(nelems-j,LOOPCNT);
#line 3393
    if (realign) {
#line 3393
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3393
      xp = tmp;
#line 3393
    } else {
#line 3393
      xp = (ulonglong *) *xpp;
#line 3393
    }
#line 3393
   /* copy the next block */
#line 3393
#pragma cdir loopcnt=LOOPCNT
#line 3393
#pragma cdir shortloop
#line 3393
    for (i=0; i<ni; i++) {
#line 3393
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3393
     /* test for range errors (not always needed but do it anyway) */
#line 3393
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3393
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3393
      nrange += xp[i] > SHORT_MAX ;
#line 3393
    }
#line 3393
   /* update xpp and tp */
#line 3393
    if (realign) xp = (ulonglong *) *xpp;
#line 3393
    xp += ni;
#line 3393
    tp += ni;
#line 3393
    *xpp = (void*)xp;
#line 3393
  }
#line 3393
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3393

#line 3393
#else   /* not SX */
#line 3393
	const char *xp = (const char *) *xpp;
#line 3393
	int status = ENOERR;
#line 3393

#line 3393
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3393
	{
#line 3393
		const int lstatus = ncx_get_ulonglong_short(xp, tp);
#line 3393
		if(lstatus != ENOERR)
#line 3393
			status = lstatus;
#line 3393
	}
#line 3393

#line 3393
	*xpp = (const void *)xp;
#line 3393
	return status;
#line 3393
#  endif
#line 3393
}
#line 3393

int
#line 3394
ncx_getn_ulonglong_int(const void **xpp, size_t nelems, int *tp)
#line 3394
{
#line 3394
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3394

#line 3394
 /* basic algorithm is:
#line 3394
  *   - ensure sane alignment of input data
#line 3394
  *   - copy (conversion happens automatically) input data
#line 3394
  *     to output
#line 3394
  *   - update xpp to point at next unconverted input, and tp to point
#line 3394
  *     at next location for converted output
#line 3394
  */
#line 3394
  long i, j, ni;
#line 3394
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3394
  ulonglong *xp;
#line 3394
  int nrange = 0;         /* number of range errors */
#line 3394
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3394
  long cxp = (long) *((char**)xpp);
#line 3394

#line 3394
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3394
  /* sjl: manually stripmine so we can limit amount of
#line 3394
   * vector work space reserved to LOOPCNT elements. Also
#line 3394
   * makes vectorisation easy */
#line 3394
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3394
    ni=Min(nelems-j,LOOPCNT);
#line 3394
    if (realign) {
#line 3394
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3394
      xp = tmp;
#line 3394
    } else {
#line 3394
      xp = (ulonglong *) *xpp;
#line 3394
    }
#line 3394
   /* copy the next block */
#line 3394
#pragma cdir loopcnt=LOOPCNT
#line 3394
#pragma cdir shortloop
#line 3394
    for (i=0; i<ni; i++) {
#line 3394
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3394
     /* test for range errors (not always needed but do it anyway) */
#line 3394
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3394
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3394
      nrange += xp[i] > INT_MAX ;
#line 3394
    }
#line 3394
   /* update xpp and tp */
#line 3394
    if (realign) xp = (ulonglong *) *xpp;
#line 3394
    xp += ni;
#line 3394
    tp += ni;
#line 3394
    *xpp = (void*)xp;
#line 3394
  }
#line 3394
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3394

#line 3394
#else   /* not SX */
#line 3394
	const char *xp = (const char *) *xpp;
#line 3394
	int status = ENOERR;
#line 3394

#line 3394
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3394
	{
#line 3394
		const int lstatus = ncx_get_ulonglong_int(xp, tp);
#line 3394
		if(lstatus != ENOERR)
#line 3394
			status = lstatus;
#line 3394
	}
#line 3394

#line 3394
	*xpp = (const void *)xp;
#line 3394
	return status;
#line 3394
#  endif
#line 3394
}
#line 3394

int
#line 3395
ncx_getn_ulonglong_float(const void **xpp, size_t nelems, float *tp)
#line 3395
{
#line 3395
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3395

#line 3395
 /* basic algorithm is:
#line 3395
  *   - ensure sane alignment of input data
#line 3395
  *   - copy (conversion happens automatically) input data
#line 3395
  *     to output
#line 3395
  *   - update xpp to point at next unconverted input, and tp to point
#line 3395
  *     at next location for converted output
#line 3395
  */
#line 3395
  long i, j, ni;
#line 3395
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3395
  ulonglong *xp;
#line 3395
  int nrange = 0;         /* number of range errors */
#line 3395
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3395
  long cxp = (long) *((char**)xpp);
#line 3395

#line 3395
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3395
  /* sjl: manually stripmine so we can limit amount of
#line 3395
   * vector work space reserved to LOOPCNT elements. Also
#line 3395
   * makes vectorisation easy */
#line 3395
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3395
    ni=Min(nelems-j,LOOPCNT);
#line 3395
    if (realign) {
#line 3395
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3395
      xp = tmp;
#line 3395
    } else {
#line 3395
      xp = (ulonglong *) *xpp;
#line 3395
    }
#line 3395
   /* copy the next block */
#line 3395
#pragma cdir loopcnt=LOOPCNT
#line 3395
#pragma cdir shortloop
#line 3395
    for (i=0; i<ni; i++) {
#line 3395
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3395
     /* test for range errors (not always needed but do it anyway) */
#line 3395
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3395
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3395
      nrange += xp[i] > FLOAT_MAX ;
#line 3395
    }
#line 3395
   /* update xpp and tp */
#line 3395
    if (realign) xp = (ulonglong *) *xpp;
#line 3395
    xp += ni;
#line 3395
    tp += ni;
#line 3395
    *xpp = (void*)xp;
#line 3395
  }
#line 3395
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3395

#line 3395
#else   /* not SX */
#line 3395
	const char *xp = (const char *) *xpp;
#line 3395
	int status = ENOERR;
#line 3395

#line 3395
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3395
	{
#line 3395
		const int lstatus = ncx_get_ulonglong_float(xp, tp);
#line 3395
		if(lstatus != ENOERR)
#line 3395
			status = lstatus;
#line 3395
	}
#line 3395

#line 3395
	*xpp = (const void *)xp;
#line 3395
	return status;
#line 3395
#  endif
#line 3395
}
#line 3395

int
#line 3396
ncx_getn_ulonglong_double(const void **xpp, size_t nelems, double *tp)
#line 3396
{
#line 3396
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3396

#line 3396
 /* basic algorithm is:
#line 3396
  *   - ensure sane alignment of input data
#line 3396
  *   - copy (conversion happens automatically) input data
#line 3396
  *     to output
#line 3396
  *   - update xpp to point at next unconverted input, and tp to point
#line 3396
  *     at next location for converted output
#line 3396
  */
#line 3396
  long i, j, ni;
#line 3396
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3396
  ulonglong *xp;
#line 3396
  int nrange = 0;         /* number of range errors */
#line 3396
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3396
  long cxp = (long) *((char**)xpp);
#line 3396

#line 3396
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3396
  /* sjl: manually stripmine so we can limit amount of
#line 3396
   * vector work space reserved to LOOPCNT elements. Also
#line 3396
   * makes vectorisation easy */
#line 3396
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3396
    ni=Min(nelems-j,LOOPCNT);
#line 3396
    if (realign) {
#line 3396
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3396
      xp = tmp;
#line 3396
    } else {
#line 3396
      xp = (ulonglong *) *xpp;
#line 3396
    }
#line 3396
   /* copy the next block */
#line 3396
#pragma cdir loopcnt=LOOPCNT
#line 3396
#pragma cdir shortloop
#line 3396
    for (i=0; i<ni; i++) {
#line 3396
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3396
     /* test for range errors (not always needed but do it anyway) */
#line 3396
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3396
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3396
      nrange += xp[i] > DOUBLE_MAX ;
#line 3396
    }
#line 3396
   /* update xpp and tp */
#line 3396
    if (realign) xp = (ulonglong *) *xpp;
#line 3396
    xp += ni;
#line 3396
    tp += ni;
#line 3396
    *xpp = (void*)xp;
#line 3396
  }
#line 3396
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3396

#line 3396
#else   /* not SX */
#line 3396
	const char *xp = (const char *) *xpp;
#line 3396
	int status = ENOERR;
#line 3396

#line 3396
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3396
	{
#line 3396
		const int lstatus = ncx_get_ulonglong_double(xp, tp);
#line 3396
		if(lstatus != ENOERR)
#line 3396
			status = lstatus;
#line 3396
	}
#line 3396

#line 3396
	*xpp = (const void *)xp;
#line 3396
	return status;
#line 3396
#  endif
#line 3396
}
#line 3396

int
#line 3397
ncx_getn_ulonglong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3397
{
#line 3397
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3397

#line 3397
 /* basic algorithm is:
#line 3397
  *   - ensure sane alignment of input data
#line 3397
  *   - copy (conversion happens automatically) input data
#line 3397
  *     to output
#line 3397
  *   - update xpp to point at next unconverted input, and tp to point
#line 3397
  *     at next location for converted output
#line 3397
  */
#line 3397
  long i, j, ni;
#line 3397
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3397
  ulonglong *xp;
#line 3397
  int nrange = 0;         /* number of range errors */
#line 3397
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3397
  long cxp = (long) *((char**)xpp);
#line 3397

#line 3397
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3397
  /* sjl: manually stripmine so we can limit amount of
#line 3397
   * vector work space reserved to LOOPCNT elements. Also
#line 3397
   * makes vectorisation easy */
#line 3397
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3397
    ni=Min(nelems-j,LOOPCNT);
#line 3397
    if (realign) {
#line 3397
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3397
      xp = tmp;
#line 3397
    } else {
#line 3397
      xp = (ulonglong *) *xpp;
#line 3397
    }
#line 3397
   /* copy the next block */
#line 3397
#pragma cdir loopcnt=LOOPCNT
#line 3397
#pragma cdir shortloop
#line 3397
    for (i=0; i<ni; i++) {
#line 3397
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3397
     /* test for range errors (not always needed but do it anyway) */
#line 3397
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3397
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3397
      nrange += xp[i] > LONGLONG_MAX ;
#line 3397
    }
#line 3397
   /* update xpp and tp */
#line 3397
    if (realign) xp = (ulonglong *) *xpp;
#line 3397
    xp += ni;
#line 3397
    tp += ni;
#line 3397
    *xpp = (void*)xp;
#line 3397
  }
#line 3397
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3397

#line 3397
#else   /* not SX */
#line 3397
	const char *xp = (const char *) *xpp;
#line 3397
	int status = ENOERR;
#line 3397

#line 3397
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3397
	{
#line 3397
		const int lstatus = ncx_get_ulonglong_longlong(xp, tp);
#line 3397
		if(lstatus != ENOERR)
#line 3397
			status = lstatus;
#line 3397
	}
#line 3397

#line 3397
	*xpp = (const void *)xp;
#line 3397
	return status;
#line 3397
#  endif
#line 3397
}
#line 3397

int
#line 3398
ncx_getn_ulonglong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3398
{
#line 3398
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3398

#line 3398
 /* basic algorithm is:
#line 3398
  *   - ensure sane alignment of input data
#line 3398
  *   - copy (conversion happens automatically) input data
#line 3398
  *     to output
#line 3398
  *   - update xpp to point at next unconverted input, and tp to point
#line 3398
  *     at next location for converted output
#line 3398
  */
#line 3398
  long i, j, ni;
#line 3398
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3398
  ulonglong *xp;
#line 3398
  int nrange = 0;         /* number of range errors */
#line 3398
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3398
  long cxp = (long) *((char**)xpp);
#line 3398

#line 3398
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3398
  /* sjl: manually stripmine so we can limit amount of
#line 3398
   * vector work space reserved to LOOPCNT elements. Also
#line 3398
   * makes vectorisation easy */
#line 3398
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3398
    ni=Min(nelems-j,LOOPCNT);
#line 3398
    if (realign) {
#line 3398
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3398
      xp = tmp;
#line 3398
    } else {
#line 3398
      xp = (ulonglong *) *xpp;
#line 3398
    }
#line 3398
   /* copy the next block */
#line 3398
#pragma cdir loopcnt=LOOPCNT
#line 3398
#pragma cdir shortloop
#line 3398
    for (i=0; i<ni; i++) {
#line 3398
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3398
     /* test for range errors (not always needed but do it anyway) */
#line 3398
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3398
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3398
      nrange += xp[i] > UCHAR_MAX ;
#line 3398
    }
#line 3398
   /* update xpp and tp */
#line 3398
    if (realign) xp = (ulonglong *) *xpp;
#line 3398
    xp += ni;
#line 3398
    tp += ni;
#line 3398
    *xpp = (void*)xp;
#line 3398
  }
#line 3398
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3398

#line 3398
#else   /* not SX */
#line 3398
	const char *xp = (const char *) *xpp;
#line 3398
	int status = ENOERR;
#line 3398

#line 3398
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3398
	{
#line 3398
		const int lstatus = ncx_get_ulonglong_uchar(xp, tp);
#line 3398
		if(lstatus != ENOERR)
#line 3398
			status = lstatus;
#line 3398
	}
#line 3398

#line 3398
	*xpp = (const void *)xp;
#line 3398
	return status;
#line 3398
#  endif
#line 3398
}
#line 3398

int
#line 3399
ncx_getn_ulonglong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3399
{
#line 3399
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3399

#line 3399
 /* basic algorithm is:
#line 3399
  *   - ensure sane alignment of input data
#line 3399
  *   - copy (conversion happens automatically) input data
#line 3399
  *     to output
#line 3399
  *   - update xpp to point at next unconverted input, and tp to point
#line 3399
  *     at next location for converted output
#line 3399
  */
#line 3399
  long i, j, ni;
#line 3399
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3399
  ulonglong *xp;
#line 3399
  int nrange = 0;         /* number of range errors */
#line 3399
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3399
  long cxp = (long) *((char**)xpp);
#line 3399

#line 3399
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3399
  /* sjl: manually stripmine so we can limit amount of
#line 3399
   * vector work space reserved to LOOPCNT elements. Also
#line 3399
   * makes vectorisation easy */
#line 3399
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3399
    ni=Min(nelems-j,LOOPCNT);
#line 3399
    if (realign) {
#line 3399
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3399
      xp = tmp;
#line 3399
    } else {
#line 3399
      xp = (ulonglong *) *xpp;
#line 3399
    }
#line 3399
   /* copy the next block */
#line 3399
#pragma cdir loopcnt=LOOPCNT
#line 3399
#pragma cdir shortloop
#line 3399
    for (i=0; i<ni; i++) {
#line 3399
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3399
     /* test for range errors (not always needed but do it anyway) */
#line 3399
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3399
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3399
      nrange += xp[i] > USHORT_MAX ;
#line 3399
    }
#line 3399
   /* update xpp and tp */
#line 3399
    if (realign) xp = (ulonglong *) *xpp;
#line 3399
    xp += ni;
#line 3399
    tp += ni;
#line 3399
    *xpp = (void*)xp;
#line 3399
  }
#line 3399
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3399

#line 3399
#else   /* not SX */
#line 3399
	const char *xp = (const char *) *xpp;
#line 3399
	int status = ENOERR;
#line 3399

#line 3399
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3399
	{
#line 3399
		const int lstatus = ncx_get_ulonglong_ushort(xp, tp);
#line 3399
		if(lstatus != ENOERR)
#line 3399
			status = lstatus;
#line 3399
	}
#line 3399

#line 3399
	*xpp = (const void *)xp;
#line 3399
	return status;
#line 3399
#  endif
#line 3399
}
#line 3399

int
#line 3400
ncx_getn_ulonglong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3400
{
#line 3400
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3400

#line 3400
 /* basic algorithm is:
#line 3400
  *   - ensure sane alignment of input data
#line 3400
  *   - copy (conversion happens automatically) input data
#line 3400
  *     to output
#line 3400
  *   - update xpp to point at next unconverted input, and tp to point
#line 3400
  *     at next location for converted output
#line 3400
  */
#line 3400
  long i, j, ni;
#line 3400
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3400
  ulonglong *xp;
#line 3400
  int nrange = 0;         /* number of range errors */
#line 3400
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3400
  long cxp = (long) *((char**)xpp);
#line 3400

#line 3400
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3400
  /* sjl: manually stripmine so we can limit amount of
#line 3400
   * vector work space reserved to LOOPCNT elements. Also
#line 3400
   * makes vectorisation easy */
#line 3400
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3400
    ni=Min(nelems-j,LOOPCNT);
#line 3400
    if (realign) {
#line 3400
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3400
      xp = tmp;
#line 3400
    } else {
#line 3400
      xp = (ulonglong *) *xpp;
#line 3400
    }
#line 3400
   /* copy the next block */
#line 3400
#pragma cdir loopcnt=LOOPCNT
#line 3400
#pragma cdir shortloop
#line 3400
    for (i=0; i<ni; i++) {
#line 3400
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3400
     /* test for range errors (not always needed but do it anyway) */
#line 3400
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3400
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3400
      nrange += xp[i] > UINT_MAX ;
#line 3400
    }
#line 3400
   /* update xpp and tp */
#line 3400
    if (realign) xp = (ulonglong *) *xpp;
#line 3400
    xp += ni;
#line 3400
    tp += ni;
#line 3400
    *xpp = (void*)xp;
#line 3400
  }
#line 3400
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3400

#line 3400
#else   /* not SX */
#line 3400
	const char *xp = (const char *) *xpp;
#line 3400
	int status = ENOERR;
#line 3400

#line 3400
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3400
	{
#line 3400
		const int lstatus = ncx_get_ulonglong_uint(xp, tp);
#line 3400
		if(lstatus != ENOERR)
#line 3400
			status = lstatus;
#line 3400
	}
#line 3400

#line 3400
	*xpp = (const void *)xp;
#line 3400
	return status;
#line 3400
#  endif
#line 3400
}
#line 3400


#if X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const unsigned long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_ULONGLONG);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_ULONGLONG);
	return ENOERR;
}
#else
int
#line 3416
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3416
{
#line 3416
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3416

#line 3416
 /* basic algorithm is:
#line 3416
  *   - ensure sane alignment of output data
#line 3416
  *   - copy (conversion happens automatically) input data
#line 3416
  *     to output
#line 3416
  *   - update tp to point at next unconverted input, and xpp to point
#line 3416
  *     at next location for converted output
#line 3416
  */
#line 3416
  long i, j, ni;
#line 3416
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3416
  ulonglong *xp;
#line 3416
  int nrange = 0;         /* number of range errors */
#line 3416
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3416
  long cxp = (long) *((char**)xpp);
#line 3416

#line 3416
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3416
  /* sjl: manually stripmine so we can limit amount of
#line 3416
   * vector work space reserved to LOOPCNT elements. Also
#line 3416
   * makes vectorisation easy */
#line 3416
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3416
    ni=Min(nelems-j,LOOPCNT);
#line 3416
    if (realign) {
#line 3416
      xp = tmp;
#line 3416
    } else {
#line 3416
      xp = (ulonglong *) *xpp;
#line 3416
    }
#line 3416
   /* copy the next block */
#line 3416
#pragma cdir loopcnt=LOOPCNT
#line 3416
#pragma cdir shortloop
#line 3416
    for (i=0; i<ni; i++) {
#line 3416
      /* the normal case: */
#line 3416
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3416
     /* test for range errors (not always needed but do it anyway) */
#line 3416
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3416
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3416
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3416
    }
#line 3416
   /* copy workspace back if necessary */
#line 3416
    if (realign) {
#line 3416
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3416
      xp = (ulonglong *) *xpp;
#line 3416
    }
#line 3416
   /* update xpp and tp */
#line 3416
    xp += ni;
#line 3416
    tp += ni;
#line 3416
    *xpp = (void*)xp;
#line 3416
  }
#line 3416
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3416

#line 3416
#else   /* not SX */
#line 3416

#line 3416
	char *xp = (char *) *xpp;
#line 3416
	int status = ENOERR;
#line 3416

#line 3416
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3416
	{
#line 3416
		int lstatus = ncx_put_ulonglong_ulonglong(xp, tp);
#line 3416
		if(lstatus != ENOERR)
#line 3416
			status = lstatus;
#line 3416
	}
#line 3416

#line 3416
	*xpp = (void *)xp;
#line 3416
	return status;
#line 3416
#endif
#line 3416
}
#line 3416

#endif
int
#line 3418
ncx_putn_ulonglong_schar(void **xpp, size_t nelems, const schar *tp)
#line 3418
{
#line 3418
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3418

#line 3418
 /* basic algorithm is:
#line 3418
  *   - ensure sane alignment of output data
#line 3418
  *   - copy (conversion happens automatically) input data
#line 3418
  *     to output
#line 3418
  *   - update tp to point at next unconverted input, and xpp to point
#line 3418
  *     at next location for converted output
#line 3418
  */
#line 3418
  long i, j, ni;
#line 3418
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3418
  ulonglong *xp;
#line 3418
  int nrange = 0;         /* number of range errors */
#line 3418
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3418
  long cxp = (long) *((char**)xpp);
#line 3418

#line 3418
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3418
  /* sjl: manually stripmine so we can limit amount of
#line 3418
   * vector work space reserved to LOOPCNT elements. Also
#line 3418
   * makes vectorisation easy */
#line 3418
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3418
    ni=Min(nelems-j,LOOPCNT);
#line 3418
    if (realign) {
#line 3418
      xp = tmp;
#line 3418
    } else {
#line 3418
      xp = (ulonglong *) *xpp;
#line 3418
    }
#line 3418
   /* copy the next block */
#line 3418
#pragma cdir loopcnt=LOOPCNT
#line 3418
#pragma cdir shortloop
#line 3418
    for (i=0; i<ni; i++) {
#line 3418
      /* the normal case: */
#line 3418
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3418
     /* test for range errors (not always needed but do it anyway) */
#line 3418
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3418
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3418
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3418
    }
#line 3418
   /* copy workspace back if necessary */
#line 3418
    if (realign) {
#line 3418
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3418
      xp = (ulonglong *) *xpp;
#line 3418
    }
#line 3418
   /* update xpp and tp */
#line 3418
    xp += ni;
#line 3418
    tp += ni;
#line 3418
    *xpp = (void*)xp;
#line 3418
  }
#line 3418
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3418

#line 3418
#else   /* not SX */
#line 3418

#line 3418
	char *xp = (char *) *xpp;
#line 3418
	int status = ENOERR;
#line 3418

#line 3418
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3418
	{
#line 3418
		int lstatus = ncx_put_ulonglong_schar(xp, tp);
#line 3418
		if(lstatus != ENOERR)
#line 3418
			status = lstatus;
#line 3418
	}
#line 3418

#line 3418
	*xpp = (void *)xp;
#line 3418
	return status;
#line 3418
#endif
#line 3418
}
#line 3418

int
#line 3419
ncx_putn_ulonglong_short(void **xpp, size_t nelems, const short *tp)
#line 3419
{
#line 3419
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3419

#line 3419
 /* basic algorithm is:
#line 3419
  *   - ensure sane alignment of output data
#line 3419
  *   - copy (conversion happens automatically) input data
#line 3419
  *     to output
#line 3419
  *   - update tp to point at next unconverted input, and xpp to point
#line 3419
  *     at next location for converted output
#line 3419
  */
#line 3419
  long i, j, ni;
#line 3419
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3419
  ulonglong *xp;
#line 3419
  int nrange = 0;         /* number of range errors */
#line 3419
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3419
  long cxp = (long) *((char**)xpp);
#line 3419

#line 3419
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3419
  /* sjl: manually stripmine so we can limit amount of
#line 3419
   * vector work space reserved to LOOPCNT elements. Also
#line 3419
   * makes vectorisation easy */
#line 3419
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3419
    ni=Min(nelems-j,LOOPCNT);
#line 3419
    if (realign) {
#line 3419
      xp = tmp;
#line 3419
    } else {
#line 3419
      xp = (ulonglong *) *xpp;
#line 3419
    }
#line 3419
   /* copy the next block */
#line 3419
#pragma cdir loopcnt=LOOPCNT
#line 3419
#pragma cdir shortloop
#line 3419
    for (i=0; i<ni; i++) {
#line 3419
      /* the normal case: */
#line 3419
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3419
     /* test for range errors (not always needed but do it anyway) */
#line 3419
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3419
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3419
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3419
    }
#line 3419
   /* copy workspace back if necessary */
#line 3419
    if (realign) {
#line 3419
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3419
      xp = (ulonglong *) *xpp;
#line 3419
    }
#line 3419
   /* update xpp and tp */
#line 3419
    xp += ni;
#line 3419
    tp += ni;
#line 3419
    *xpp = (void*)xp;
#line 3419
  }
#line 3419
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3419

#line 3419
#else   /* not SX */
#line 3419

#line 3419
	char *xp = (char *) *xpp;
#line 3419
	int status = ENOERR;
#line 3419

#line 3419
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3419
	{
#line 3419
		int lstatus = ncx_put_ulonglong_short(xp, tp);
#line 3419
		if(lstatus != ENOERR)
#line 3419
			status = lstatus;
#line 3419
	}
#line 3419

#line 3419
	*xpp = (void *)xp;
#line 3419
	return status;
#line 3419
#endif
#line 3419
}
#line 3419

int
#line 3420
ncx_putn_ulonglong_int(void **xpp, size_t nelems, const int *tp)
#line 3420
{
#line 3420
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3420

#line 3420
 /* basic algorithm is:
#line 3420
  *   - ensure sane alignment of output data
#line 3420
  *   - copy (conversion happens automatically) input data
#line 3420
  *     to output
#line 3420
  *   - update tp to point at next unconverted input, and xpp to point
#line 3420
  *     at next location for converted output
#line 3420
  */
#line 3420
  long i, j, ni;
#line 3420
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3420
  ulonglong *xp;
#line 3420
  int nrange = 0;         /* number of range errors */
#line 3420
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3420
  long cxp = (long) *((char**)xpp);
#line 3420

#line 3420
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3420
  /* sjl: manually stripmine so we can limit amount of
#line 3420
   * vector work space reserved to LOOPCNT elements. Also
#line 3420
   * makes vectorisation easy */
#line 3420
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3420
    ni=Min(nelems-j,LOOPCNT);
#line 3420
    if (realign) {
#line 3420
      xp = tmp;
#line 3420
    } else {
#line 3420
      xp = (ulonglong *) *xpp;
#line 3420
    }
#line 3420
   /* copy the next block */
#line 3420
#pragma cdir loopcnt=LOOPCNT
#line 3420
#pragma cdir shortloop
#line 3420
    for (i=0; i<ni; i++) {
#line 3420
      /* the normal case: */
#line 3420
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3420
     /* test for range errors (not always needed but do it anyway) */
#line 3420
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3420
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3420
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3420
    }
#line 3420
   /* copy workspace back if necessary */
#line 3420
    if (realign) {
#line 3420
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3420
      xp = (ulonglong *) *xpp;
#line 3420
    }
#line 3420
   /* update xpp and tp */
#line 3420
    xp += ni;
#line 3420
    tp += ni;
#line 3420
    *xpp = (void*)xp;
#line 3420
  }
#line 3420
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3420

#line 3420
#else   /* not SX */
#line 3420

#line 3420
	char *xp = (char *) *xpp;
#line 3420
	int status = ENOERR;
#line 3420

#line 3420
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3420
	{
#line 3420
		int lstatus = ncx_put_ulonglong_int(xp, tp);
#line 3420
		if(lstatus != ENOERR)
#line 3420
			status = lstatus;
#line 3420
	}
#line 3420

#line 3420
	*xpp = (void *)xp;
#line 3420
	return status;
#line 3420
#endif
#line 3420
}
#line 3420

int
#line 3421
ncx_putn_ulonglong_float(void **xpp, size_t nelems, const float *tp)
#line 3421
{
#line 3421
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3421

#line 3421
 /* basic algorithm is:
#line 3421
  *   - ensure sane alignment of output data
#line 3421
  *   - copy (conversion happens automatically) input data
#line 3421
  *     to output
#line 3421
  *   - update tp to point at next unconverted input, and xpp to point
#line 3421
  *     at next location for converted output
#line 3421
  */
#line 3421
  long i, j, ni;
#line 3421
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3421
  ulonglong *xp;
#line 3421
  int nrange = 0;         /* number of range errors */
#line 3421
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3421
  long cxp = (long) *((char**)xpp);
#line 3421

#line 3421
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3421
  /* sjl: manually stripmine so we can limit amount of
#line 3421
   * vector work space reserved to LOOPCNT elements. Also
#line 3421
   * makes vectorisation easy */
#line 3421
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3421
    ni=Min(nelems-j,LOOPCNT);
#line 3421
    if (realign) {
#line 3421
      xp = tmp;
#line 3421
    } else {
#line 3421
      xp = (ulonglong *) *xpp;
#line 3421
    }
#line 3421
   /* copy the next block */
#line 3421
#pragma cdir loopcnt=LOOPCNT
#line 3421
#pragma cdir shortloop
#line 3421
    for (i=0; i<ni; i++) {
#line 3421
      /* the normal case: */
#line 3421
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3421
     /* test for range errors (not always needed but do it anyway) */
#line 3421
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3421
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3421
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3421
    }
#line 3421
   /* copy workspace back if necessary */
#line 3421
    if (realign) {
#line 3421
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3421
      xp = (ulonglong *) *xpp;
#line 3421
    }
#line 3421
   /* update xpp and tp */
#line 3421
    xp += ni;
#line 3421
    tp += ni;
#line 3421
    *xpp = (void*)xp;
#line 3421
  }
#line 3421
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3421

#line 3421
#else   /* not SX */
#line 3421

#line 3421
	char *xp = (char *) *xpp;
#line 3421
	int status = ENOERR;
#line 3421

#line 3421
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3421
	{
#line 3421
		int lstatus = ncx_put_ulonglong_float(xp, tp);
#line 3421
		if(lstatus != ENOERR)
#line 3421
			status = lstatus;
#line 3421
	}
#line 3421

#line 3421
	*xpp = (void *)xp;
#line 3421
	return status;
#line 3421
#endif
#line 3421
}
#line 3421

int
#line 3422
ncx_putn_ulonglong_double(void **xpp, size_t nelems, const double *tp)
#line 3422
{
#line 3422
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3422

#line 3422
 /* basic algorithm is:
#line 3422
  *   - ensure sane alignment of output data
#line 3422
  *   - copy (conversion happens automatically) input data
#line 3422
  *     to output
#line 3422
  *   - update tp to point at next unconverted input, and xpp to point
#line 3422
  *     at next location for converted output
#line 3422
  */
#line 3422
  long i, j, ni;
#line 3422
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3422
  ulonglong *xp;
#line 3422
  int nrange = 0;         /* number of range errors */
#line 3422
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3422
  long cxp = (long) *((char**)xpp);
#line 3422

#line 3422
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3422
  /* sjl: manually stripmine so we can limit amount of
#line 3422
   * vector work space reserved to LOOPCNT elements. Also
#line 3422
   * makes vectorisation easy */
#line 3422
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3422
    ni=Min(nelems-j,LOOPCNT);
#line 3422
    if (realign) {
#line 3422
      xp = tmp;
#line 3422
    } else {
#line 3422
      xp = (ulonglong *) *xpp;
#line 3422
    }
#line 3422
   /* copy the next block */
#line 3422
#pragma cdir loopcnt=LOOPCNT
#line 3422
#pragma cdir shortloop
#line 3422
    for (i=0; i<ni; i++) {
#line 3422
      /* the normal case: */
#line 3422
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3422
     /* test for range errors (not always needed but do it anyway) */
#line 3422
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3422
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3422
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3422
    }
#line 3422
   /* copy workspace back if necessary */
#line 3422
    if (realign) {
#line 3422
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3422
      xp = (ulonglong *) *xpp;
#line 3422
    }
#line 3422
   /* update xpp and tp */
#line 3422
    xp += ni;
#line 3422
    tp += ni;
#line 3422
    *xpp = (void*)xp;
#line 3422
  }
#line 3422
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3422

#line 3422
#else   /* not SX */
#line 3422

#line 3422
	char *xp = (char *) *xpp;
#line 3422
	int status = ENOERR;
#line 3422

#line 3422
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3422
	{
#line 3422
		int lstatus = ncx_put_ulonglong_double(xp, tp);
#line 3422
		if(lstatus != ENOERR)
#line 3422
			status = lstatus;
#line 3422
	}
#line 3422

#line 3422
	*xpp = (void *)xp;
#line 3422
	return status;
#line 3422
#endif
#line 3422
}
#line 3422

int
#line 3423
ncx_putn_ulonglong_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3423
{
#line 3423
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3423

#line 3423
 /* basic algorithm is:
#line 3423
  *   - ensure sane alignment of output data
#line 3423
  *   - copy (conversion happens automatically) input data
#line 3423
  *     to output
#line 3423
  *   - update tp to point at next unconverted input, and xpp to point
#line 3423
  *     at next location for converted output
#line 3423
  */
#line 3423
  long i, j, ni;
#line 3423
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3423
  ulonglong *xp;
#line 3423
  int nrange = 0;         /* number of range errors */
#line 3423
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3423
  long cxp = (long) *((char**)xpp);
#line 3423

#line 3423
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3423
  /* sjl: manually stripmine so we can limit amount of
#line 3423
   * vector work space reserved to LOOPCNT elements. Also
#line 3423
   * makes vectorisation easy */
#line 3423
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3423
    ni=Min(nelems-j,LOOPCNT);
#line 3423
    if (realign) {
#line 3423
      xp = tmp;
#line 3423
    } else {
#line 3423
      xp = (ulonglong *) *xpp;
#line 3423
    }
#line 3423
   /* copy the next block */
#line 3423
#pragma cdir loopcnt=LOOPCNT
#line 3423
#pragma cdir shortloop
#line 3423
    for (i=0; i<ni; i++) {
#line 3423
      /* the normal case: */
#line 3423
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3423
     /* test for range errors (not always needed but do it anyway) */
#line 3423
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3423
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3423
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3423
    }
#line 3423
   /* copy workspace back if necessary */
#line 3423
    if (realign) {
#line 3423
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3423
      xp = (ulonglong *) *xpp;
#line 3423
    }
#line 3423
   /* update xpp and tp */
#line 3423
    xp += ni;
#line 3423
    tp += ni;
#line 3423
    *xpp = (void*)xp;
#line 3423
  }
#line 3423
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3423

#line 3423
#else   /* not SX */
#line 3423

#line 3423
	char *xp = (char *) *xpp;
#line 3423
	int status = ENOERR;
#line 3423

#line 3423
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3423
	{
#line 3423
		int lstatus = ncx_put_ulonglong_longlong(xp, tp);
#line 3423
		if(lstatus != ENOERR)
#line 3423
			status = lstatus;
#line 3423
	}
#line 3423

#line 3423
	*xpp = (void *)xp;
#line 3423
	return status;
#line 3423
#endif
#line 3423
}
#line 3423

int
#line 3424
ncx_putn_ulonglong_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3424
{
#line 3424
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3424

#line 3424
 /* basic algorithm is:
#line 3424
  *   - ensure sane alignment of output data
#line 3424
  *   - copy (conversion happens automatically) input data
#line 3424
  *     to output
#line 3424
  *   - update tp to point at next unconverted input, and xpp to point
#line 3424
  *     at next location for converted output
#line 3424
  */
#line 3424
  long i, j, ni;
#line 3424
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3424
  ulonglong *xp;
#line 3424
  int nrange = 0;         /* number of range errors */
#line 3424
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3424
  long cxp = (long) *((char**)xpp);
#line 3424

#line 3424
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3424
  /* sjl: manually stripmine so we can limit amount of
#line 3424
   * vector work space reserved to LOOPCNT elements. Also
#line 3424
   * makes vectorisation easy */
#line 3424
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3424
    ni=Min(nelems-j,LOOPCNT);
#line 3424
    if (realign) {
#line 3424
      xp = tmp;
#line 3424
    } else {
#line 3424
      xp = (ulonglong *) *xpp;
#line 3424
    }
#line 3424
   /* copy the next block */
#line 3424
#pragma cdir loopcnt=LOOPCNT
#line 3424
#pragma cdir shortloop
#line 3424
    for (i=0; i<ni; i++) {
#line 3424
      /* the normal case: */
#line 3424
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3424
     /* test for range errors (not always needed but do it anyway) */
#line 3424
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3424
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3424
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3424
    }
#line 3424
   /* copy workspace back if necessary */
#line 3424
    if (realign) {
#line 3424
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3424
      xp = (ulonglong *) *xpp;
#line 3424
    }
#line 3424
   /* update xpp and tp */
#line 3424
    xp += ni;
#line 3424
    tp += ni;
#line 3424
    *xpp = (void*)xp;
#line 3424
  }
#line 3424
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3424

#line 3424
#else   /* not SX */
#line 3424

#line 3424
	char *xp = (char *) *xpp;
#line 3424
	int status = ENOERR;
#line 3424

#line 3424
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3424
	{
#line 3424
		int lstatus = ncx_put_ulonglong_uchar(xp, tp);
#line 3424
		if(lstatus != ENOERR)
#line 3424
			status = lstatus;
#line 3424
	}
#line 3424

#line 3424
	*xpp = (void *)xp;
#line 3424
	return status;
#line 3424
#endif
#line 3424
}
#line 3424

int
#line 3425
ncx_putn_ulonglong_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3425
{
#line 3425
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3425

#line 3425
 /* basic algorithm is:
#line 3425
  *   - ensure sane alignment of output data
#line 3425
  *   - copy (conversion happens automatically) input data
#line 3425
  *     to output
#line 3425
  *   - update tp to point at next unconverted input, and xpp to point
#line 3425
  *     at next location for converted output
#line 3425
  */
#line 3425
  long i, j, ni;
#line 3425
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3425
  ulonglong *xp;
#line 3425
  int nrange = 0;         /* number of range errors */
#line 3425
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3425
  long cxp = (long) *((char**)xpp);
#line 3425

#line 3425
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3425
  /* sjl: manually stripmine so we can limit amount of
#line 3425
   * vector work space reserved to LOOPCNT elements. Also
#line 3425
   * makes vectorisation easy */
#line 3425
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3425
    ni=Min(nelems-j,LOOPCNT);
#line 3425
    if (realign) {
#line 3425
      xp = tmp;
#line 3425
    } else {
#line 3425
      xp = (ulonglong *) *xpp;
#line 3425
    }
#line 3425
   /* copy the next block */
#line 3425
#pragma cdir loopcnt=LOOPCNT
#line 3425
#pragma cdir shortloop
#line 3425
    for (i=0; i<ni; i++) {
#line 3425
      /* the normal case: */
#line 3425
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3425
     /* test for range errors (not always needed but do it anyway) */
#line 3425
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3425
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3425
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3425
    }
#line 3425
   /* copy workspace back if necessary */
#line 3425
    if (realign) {
#line 3425
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3425
      xp = (ulonglong *) *xpp;
#line 3425
    }
#line 3425
   /* update xpp and tp */
#line 3425
    xp += ni;
#line 3425
    tp += ni;
#line 3425
    *xpp = (void*)xp;
#line 3425
  }
#line 3425
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3425

#line 3425
#else   /* not SX */
#line 3425

#line 3425
	char *xp = (char *) *xpp;
#line 3425
	int status = ENOERR;
#line 3425

#line 3425
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3425
	{
#line 3425
		int lstatus = ncx_put_ulonglong_ushort(xp, tp);
#line 3425
		if(lstatus != ENOERR)
#line 3425
			status = lstatus;
#line 3425
	}
#line 3425

#line 3425
	*xpp = (void *)xp;
#line 3425
	return status;
#line 3425
#endif
#line 3425
}
#line 3425

int
#line 3426
ncx_putn_ulonglong_uint(void **xpp, size_t nelems, const uint *tp)
#line 3426
{
#line 3426
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3426

#line 3426
 /* basic algorithm is:
#line 3426
  *   - ensure sane alignment of output data
#line 3426
  *   - copy (conversion happens automatically) input data
#line 3426
  *     to output
#line 3426
  *   - update tp to point at next unconverted input, and xpp to point
#line 3426
  *     at next location for converted output
#line 3426
  */
#line 3426
  long i, j, ni;
#line 3426
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3426
  ulonglong *xp;
#line 3426
  int nrange = 0;         /* number of range errors */
#line 3426
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3426
  long cxp = (long) *((char**)xpp);
#line 3426

#line 3426
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3426
  /* sjl: manually stripmine so we can limit amount of
#line 3426
   * vector work space reserved to LOOPCNT elements. Also
#line 3426
   * makes vectorisation easy */
#line 3426
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3426
    ni=Min(nelems-j,LOOPCNT);
#line 3426
    if (realign) {
#line 3426
      xp = tmp;
#line 3426
    } else {
#line 3426
      xp = (ulonglong *) *xpp;
#line 3426
    }
#line 3426
   /* copy the next block */
#line 3426
#pragma cdir loopcnt=LOOPCNT
#line 3426
#pragma cdir shortloop
#line 3426
    for (i=0; i<ni; i++) {
#line 3426
      /* the normal case: */
#line 3426
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3426
     /* test for range errors (not always needed but do it anyway) */
#line 3426
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3426
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3426
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3426
    }
#line 3426
   /* copy workspace back if necessary */
#line 3426
    if (realign) {
#line 3426
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3426
      xp = (ulonglong *) *xpp;
#line 3426
    }
#line 3426
   /* update xpp and tp */
#line 3426
    xp += ni;
#line 3426
    tp += ni;
#line 3426
    *xpp = (void*)xp;
#line 3426
  }
#line 3426
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3426

#line 3426
#else   /* not SX */
#line 3426

#line 3426
	char *xp = (char *) *xpp;
#line 3426
	int status = ENOERR;
#line 3426

#line 3426
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3426
	{
#line 3426
		int lstatus = ncx_put_ulonglong_uint(xp, tp);
#line 3426
		if(lstatus != ENOERR)
#line 3426
			status = lstatus;
#line 3426
	}
#line 3426

#line 3426
	*xpp = (void *)xp;
#line 3426
	return status;
#line 3426
#endif
#line 3426
}
#line 3426



/*
 * Other aggregate conversion functions.
 */

/* text */

int
ncx_getn_text(const void **xpp, size_t nelems, char *tp)
{
	(void) memcpy(tp, *xpp, nelems);
#line 3438
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3438
	return ENOERR;
#line 3438

}

int
ncx_pad_getn_text(const void **xpp, size_t nelems, char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3444

#line 3444
	if(rndup)
#line 3444
		rndup = X_ALIGN - rndup;
#line 3444

#line 3444
	(void) memcpy(tp, *xpp, nelems);
#line 3444
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3444

#line 3444
	return ENOERR;
#line 3444

}

int
ncx_putn_text(void **xpp, size_t nelems, const char *tp)
{
	(void) memcpy(*xpp, tp, nelems);
#line 3450
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3450

#line 3450
	return ENOERR;
#line 3450

}

int
ncx_pad_putn_text(void **xpp, size_t nelems, const char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3456

#line 3456
	if(rndup)
#line 3456
		rndup = X_ALIGN - rndup;
#line 3456

#line 3456
	(void) memcpy(*xpp, tp, nelems);
#line 3456
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3456

#line 3456
	if(rndup)
#line 3456
	{
#line 3456
		(void) memcpy(*xpp, nada, rndup);
#line 3456
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3456
	}
#line 3456

#line 3456
	return ENOERR;
#line 3456

}


/* opaque */

int
ncx_getn_void(const void **xpp, size_t nelems, void *tp)
{
	(void) memcpy(tp, *xpp, nelems);
#line 3465
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3465
	return ENOERR;
#line 3465

}

int
ncx_pad_getn_void(const void **xpp, size_t nelems, void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3471

#line 3471
	if(rndup)
#line 3471
		rndup = X_ALIGN - rndup;
#line 3471

#line 3471
	(void) memcpy(tp, *xpp, nelems);
#line 3471
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3471

#line 3471
	return ENOERR;
#line 3471

}

int
ncx_putn_void(void **xpp, size_t nelems, const void *tp)
{
	(void) memcpy(*xpp, tp, nelems);
#line 3477
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3477

#line 3477
	return ENOERR;
#line 3477

}

int
ncx_pad_putn_void(void **xpp, size_t nelems, const void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3483

#line 3483
	if(rndup)
#line 3483
		rndup = X_ALIGN - rndup;
#line 3483

#line 3483
	(void) memcpy(*xpp, tp, nelems);
#line 3483
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3483

#line 3483
	if(rndup)
#line 3483
	{
#line 3483
		(void) memcpy(*xpp, nada, rndup);
#line 3483
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3483
	}
#line 3483

#line 3483
	return ENOERR;
#line 3483

}
