#line 11 "ncx.m4"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 13
/*
 *	Copyright 1996, University Corporation for Atmospheric Research
 *	See netcdf/COPYRIGHT file for copying and redistribution conditions.
 * 	
 * 	This file contains some routines derived from code
 *	which is copyrighted by Sun Microsystems, Inc.
 *	The "#ifdef vax" versions of
 *		 ncx_put_float_float()
 *		 ncx_get_float_float()
 *		 ncx_put_double_double()
 *		 ncx_get_double_double()
 *		 ncx_putn_float_float()
 *		 ncx_getn_float_float()
 *		 ncx_putn_double_double()
 *		 ncx_getn_double_double()
 * 	are derived from xdr_float() and xdr_double() routines
 *	in the freely available, copyrighted Sun RPCSRC 3.9
 *	distribution, xdr_float.c.
 * 	Our "value added" is that these are always memory to memory,
 *	they handle IEEE subnormals properly, and their "n" versions
 *	operate speedily on arrays.
 */
/* $Id: ncx.m4 2795 2014-10-27 23:12:51Z wkliao $ */

/*
 * An external data representation interface.
 */

#include "ncx.h"
#include "nc3dispatch.h"
#include <string.h>
#include <limits.h>

/* alias poorly named limits.h macros */
#define  SHORT_MAX  SHRT_MAX
#define  SHORT_MIN  SHRT_MIN
#define USHORT_MAX USHRT_MAX
#ifndef LLONG_MAX
#   define LLONG_MAX	9223372036854775807LL
#   define LLONG_MIN	(-LLONG_MAX - 1LL)
#   define ULLONG_MAX	18446744073709551615ULL
#endif
#ifndef LONG_LONG_MAX
#define LONG_LONG_MAX LLONG_MAX
#endif
#ifndef LONGLONG_MAX
#define LONGLONG_MAX LONG_LONG_MAX
#endif
#ifndef LONG_LONG_MIN
#define LONG_LONG_MIN LLONG_MIN
#endif
#ifndef LONGLONG_MIN
#define LONGLONG_MIN LONG_LONG_MIN
#endif
#ifndef ULONG_LONG_MAX
#define ULONG_LONG_MAX ULLONG_MAX
#endif
#ifndef ULONGLONG_MAX
#define ULONGLONG_MAX ULONG_LONG_MAX
#endif
#include <float.h>
#ifndef FLT_MAX /* This POSIX macro missing on some systems */
# ifndef NO_IEEE_FLOAT
# define FLT_MAX 3.40282347e+38f
# else
# error "You will need to define FLT_MAX"
# endif
#endif
/* alias poorly named float.h macros */
#define FLOAT_MAX FLT_MAX
#define FLOAT_MIN (-FLT_MAX)
#define DOUBLE_MAX DBL_MAX
#define DOUBLE_MIN (-DBL_MAX)
#define FLOAT_MAX_EXP FLT_MAX_EXP
#define DOUBLE_MAX_EXP DBL_MAX_EXP
#include <assert.h>
#define UCHAR_MIN 0
#define Min(a,b) ((a) < (b) ? (a) : (b))
#define Max(a,b) ((a) > (b) ? (a) : (b))

#ifndef SIZEOF_USHORT
#define SIZEOF_USHORT SIZEOF_UNSIGNED_SHORT_INT
#endif
#ifndef SIZEOF_UINT
#define SIZEOF_UINT SIZEOF_UNSIGNED_INT
#endif
#ifndef SIZEOF_ULONG_LONG
#define SIZEOF_ULONG_LONG SIZEOF_UNSIGNED_LONG_LONG
#endif

/*
 * If the machine's float domain is "smaller" than the external one
 * use the machine domain
 */
#if defined(FLT_MAX_EXP) && FLT_MAX_EXP < 128 /* 128 is X_FLT_MAX_EXP */
#undef X_FLOAT_MAX
# define X_FLOAT_MAX FLT_MAX
#undef X_FLOAT_MIN
# define X_FLOAT_MIN (-X_FLOAT_MAX)
#endif

#if _SX /* NEC SUPER UX */
#define LOOPCNT 256    /* must be no longer than hardware vector length */
#if _INT64
#undef  INT_MAX /* workaround cpp bug */
#define INT_MAX  X_INT_MAX
#undef  INT_MIN /* workaround cpp bug */
#define INT_MIN  X_INT_MIN
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  X_INT_MAX
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN  X_INT_MIN
#elif _LONG64
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  4294967295L
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN -4294967295L
#endif
#if !_FLOAT0
#error "FLOAT1 and FLOAT2 not supported"
#endif
#endif /* _SX */

static const char nada[X_ALIGN] = {0, 0, 0, 0};

#ifndef WORDS_BIGENDIAN
/* LITTLE_ENDIAN: DEC and intel */
/*
 * Routines to convert to BIGENDIAN.
 * Optimize the swapn?b() and swap?b() routines aggressivly.
 */

#define SWAP2(a) ( (((a) & 0xff) << 8) | \
		(((a) >> 8) & 0xff) )

#define SWAP4(a) ( ((a) << 24) | \
		(((a) <<  8) & 0x00ff0000) | \
		(((a) >>  8) & 0x0000ff00) | \
		(((a) >> 24) & 0x000000ff) )


static void
swapn2b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *
 *	while(nn-- != 0)
 *	{
 *		*op++ = *(++ip);
 *		*op++ = *(ip++ -1);
 *	}                                       
 */
	while(nn > 3)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		nn -= 4;
	}
	while(nn-- != 0)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
	}
}

# ifndef vax
static void
swap4b(void *dst, const void *src)
{
	char *op = dst;
	const char *ip = src;
	op[0] = ip[3];
	op[1] = ip[2];
	op[2] = ip[1];
	op[3] = ip[0];
}
# endif /* !vax */

static void
swapn4b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while(nn-- != 0)
 *	{
 *		op[0] = ip[3];
 *		op[1] = ip[2];
 *		op[2] = ip[1];
 *		op[3] = ip[0];
 *		op += 4;
 *		ip += 4;
 *	}
 */
	while(nn > 3)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op[8] = ip[11];
		op[9] = ip[10];
		op[10] = ip[9];
		op[11] = ip[8];
		op[12] = ip[15];
		op[13] = ip[14];
		op[14] = ip[13];
		op[15] = ip[12];
		op += 16;
		ip += 16;
		nn -= 4;
	}
	while(nn-- != 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op += 4;
		ip += 4;
	}
}

# ifndef vax
static void
swap8b(void *dst, const void *src)
{
	char *op = dst;
	const char *ip = src;
#  ifndef FLOAT_WORDS_BIGENDIAN
	op[0] = ip[7];
	op[1] = ip[6];
	op[2] = ip[5];
	op[3] = ip[4];
	op[4] = ip[3];
	op[5] = ip[2];
	op[6] = ip[1];
	op[7] = ip[0];
#  else
	op[0] = ip[3];
	op[1] = ip[2];
	op[2] = ip[1];
	op[3] = ip[0];
	op[4] = ip[7];
	op[5] = ip[6];
	op[6] = ip[5];
	op[7] = ip[4];
#  endif
}
# endif /* !vax */

# ifndef vax
static void
swapn8b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while(nn-- != 0)
 *	{
 *		op[0] = ip[7];
 *		op[1] = ip[6];
 *		op[2] = ip[5];
 *		op[3] = ip[4];
 *		op[4] = ip[3];
 *		op[5] = ip[2];
 *		op[6] = ip[1];
 *		op[7] = ip[0];
 *		op += 8;
 *		ip += 8;
 *	}
 */
#  ifndef FLOAT_WORDS_BIGENDIAN
	while(nn > 1)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op[8] = ip[15];
		op[9] = ip[14];
		op[10] = ip[13];
		op[11] = ip[12];
		op[12] = ip[11];
		op[13] = ip[10];
		op[14] = ip[9];
		op[15] = ip[8];
		op += 16;
		ip += 16;
		nn -= 2;
	}
	while(nn-- != 0)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op += 8;
		ip += 8;
	}
#  else
	while(nn-- != 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op += 8;
		ip += 8;
	}
#  endif
}
# endif /* !vax */

#endif /* LITTLE_ENDIAN */

#line 379

#line 387

#line 395

#line 402


#line 410


#line 418


#line 426


/*
 * Primitive numeric conversion functions.
 */

#line 448

#line 474

#line 490

#line 515

/* x_schar */
/* x_uchar */

/* We don't implement any x_schar and x_uchar primitives. */


/* x_short -------------------------------------------------------------------*/

#if SHORT_MAX == X_SHORT_MAX
typedef short ix_short;
#define SIZEOF_IX_SHORT SIZEOF_SHORT
#define IX_SHORT_MAX SHORT_MAX
#elif INT_MAX >= X_SHORT_MAX
typedef int ix_short;
#define SIZEOF_IX_SHORT SIZEOF_INT
#define IX_SHORT_MAX INT_MAX
#elif LONG_MAX >= X_SHORT_MAX
typedef long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG
#define IX_SHORT_MAX LONG_MAX
#elif LLONG_MAX >= X_SHORT_MAX
typedef long long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG_LONG
#define IX_SHORT_MAX LLONG_MAX
#else
#error "ix_short implementation"
#endif

static void
get_ix_short(const void *xp, ix_short *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = *cp++ << 8;
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if(*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= *cp; 
}

static void
put_ix_short(void *xp, const ix_short *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (*ip) >> 8;
	*cp = (*ip) & 0xff;
}

static int
#line 567
ncx_get_short_schar(const void *xp, schar *ip)
#line 567
{
#line 567
	ix_short xx;
#line 567
	get_ix_short(xp, &xx);
#line 567
	*ip = (schar) xx;
#line 567
#if IX_SHORT_MAX > SCHAR_MAX
#line 567
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 567
#endif
#line 567

#line 567
	return ENOERR;
#line 567
}
#line 567

static int
#line 568
ncx_get_short_short(const void *xp, short *ip)
#line 568
{
#line 568
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 568
	get_ix_short(xp, (ix_short *)ip);
#line 568
	return ENOERR;
#line 568
#else
#line 568
	ix_short xx;
#line 568
	get_ix_short(xp, &xx);
#line 568
	*ip = (short) xx;
#line 568
#if IX_SHORT_MAX > SHORT_MAX
#line 568
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 568
#endif
#line 568

#line 568
#endif
#line 568
	return ENOERR;
#line 568
}
#line 568

static int
#line 569
ncx_get_short_int(const void *xp, int *ip)
#line 569
{
#line 569
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 569
	get_ix_short(xp, (ix_short *)ip);
#line 569
	return ENOERR;
#line 569
#else
#line 569
	ix_short xx;
#line 569
	get_ix_short(xp, &xx);
#line 569
	*ip = (int) xx;
#line 569
#if IX_SHORT_MAX > INT_MAX
#line 569
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 569
#endif
#line 569

#line 569
#endif
#line 569
	return ENOERR;
#line 569
}
#line 569

static int
#line 570
ncx_get_short_longlong(const void *xp, longlong *ip)
#line 570
{
#line 570
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 570
	get_ix_short(xp, (ix_short *)ip);
#line 570
	return ENOERR;
#line 570
#else
#line 570
	ix_short xx;
#line 570
	get_ix_short(xp, &xx);
#line 570
	*ip = (longlong) xx;
#line 570
#if IX_SHORT_MAX > LONGLONG_MAX
#line 570
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 570
#endif
#line 570

#line 570
#endif
#line 570
	return ENOERR;
#line 570
}
#line 570

static int
#line 571
ncx_get_short_ushort(const void *xp, ushort *ip)
#line 571
{
#line 571
	ix_short xx;
#line 571
	get_ix_short(xp, &xx);
#line 571
	*ip = (ushort) xx;
#line 571
#if IX_SHORT_MAX > USHORT_MAX
#line 571
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 571
#endif
#line 571
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 571
	return ENOERR;
#line 571
}
#line 571

static int
#line 572
ncx_get_short_uchar(const void *xp, uchar *ip)
#line 572
{
#line 572
	ix_short xx;
#line 572
	get_ix_short(xp, &xx);
#line 572
	*ip = (uchar) xx;
#line 572
#if IX_SHORT_MAX > UCHAR_MAX
#line 572
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 572
#endif
#line 572
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 572
	return ENOERR;
#line 572
}
#line 572

static int
#line 573
ncx_get_short_uint(const void *xp, uint *ip)
#line 573
{
#line 573
	ix_short xx;
#line 573
	get_ix_short(xp, &xx);
#line 573
	*ip = (uint) xx;
#line 573
#if IX_SHORT_MAX > UINT_MAX
#line 573
	if (xx > UINT_MAX) return NC_ERANGE;
#line 573
#endif
#line 573
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 573
	return ENOERR;
#line 573
}
#line 573

static int
#line 574
ncx_get_short_ulonglong(const void *xp, ulonglong *ip)
#line 574
{
#line 574
	ix_short xx;
#line 574
	get_ix_short(xp, &xx);
#line 574
	*ip = (ulonglong) xx;
#line 574
#if IX_SHORT_MAX > ULONGLONG_MAX
#line 574
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 574
#endif
#line 574
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 574
	return ENOERR;
#line 574
}
#line 574

static int
#line 575
ncx_get_short_float(const void *xp, float *ip)
#line 575
{
#line 575
	ix_short xx;
#line 575
	get_ix_short(xp, &xx);
#line 575
	*ip = (float) xx;
#line 575

#line 575
	return ENOERR;
#line 575
}
#line 575

static int
#line 576
ncx_get_short_double(const void *xp, double *ip)
#line 576
{
#line 576
	ix_short xx;
#line 576
	get_ix_short(xp, &xx);
#line 576
	*ip = (double) xx;
#line 576

#line 576
	return ENOERR;
#line 576
}
#line 576


static int
ncx_put_short_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
	return ENOERR;
}

static int
ncx_put_short_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return ENOERR;
}

static int
#line 599
ncx_put_short_short(void *xp, const short *ip)
#line 599
{
#line 599
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 599
	put_ix_short(xp, (const ix_short *)ip);
#line 599
	return ENOERR;
#line 599
#else
#line 599
	ix_short xx = (ix_short)*ip;
#line 599
	put_ix_short(xp, &xx);
#line 599
#if IX_SHORT_MAX < SHORT_MAX
#line 599
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 599
#endif
#line 599

#line 599
#endif
#line 599
	return ENOERR;
#line 599
}
#line 599

static int
#line 600
ncx_put_short_int(void *xp, const int *ip)
#line 600
{
#line 600
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 600
	put_ix_short(xp, (const ix_short *)ip);
#line 600
	return ENOERR;
#line 600
#else
#line 600
	ix_short xx = (ix_short)*ip;
#line 600
	put_ix_short(xp, &xx);
#line 600
#if IX_SHORT_MAX < INT_MAX
#line 600
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 600
#endif
#line 600

#line 600
#endif
#line 600
	return ENOERR;
#line 600
}
#line 600

static int
#line 601
ncx_put_short_longlong(void *xp, const longlong *ip)
#line 601
{
#line 601
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 601
	put_ix_short(xp, (const ix_short *)ip);
#line 601
	return ENOERR;
#line 601
#else
#line 601
	ix_short xx = (ix_short)*ip;
#line 601
	put_ix_short(xp, &xx);
#line 601
#if IX_SHORT_MAX < LONGLONG_MAX
#line 601
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 601
#endif
#line 601

#line 601
#endif
#line 601
	return ENOERR;
#line 601
}
#line 601

static int
#line 602
ncx_put_short_ushort(void *xp, const ushort *ip)
#line 602
{
#line 602
	ix_short xx = (ix_short)*ip;
#line 602
	put_ix_short(xp, &xx);
#line 602
#if IX_SHORT_MAX < USHORT_MAX
#line 602
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 602
#endif
#line 602

#line 602
	return ENOERR;
#line 602
}
#line 602

static int
#line 603
ncx_put_short_uint(void *xp, const uint *ip)
#line 603
{
#line 603
	ix_short xx = (ix_short)*ip;
#line 603
	put_ix_short(xp, &xx);
#line 603
#if IX_SHORT_MAX < UINT_MAX
#line 603
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 603
#endif
#line 603

#line 603
	return ENOERR;
#line 603
}
#line 603

static int
#line 604
ncx_put_short_ulonglong(void *xp, const ulonglong *ip)
#line 604
{
#line 604
	ix_short xx = (ix_short)*ip;
#line 604
	put_ix_short(xp, &xx);
#line 604
#if IX_SHORT_MAX < ULONGLONG_MAX
#line 604
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 604
#endif
#line 604

#line 604
	return ENOERR;
#line 604
}
#line 604

static int
#line 605
ncx_put_short_float(void *xp, const float *ip)
#line 605
{
#line 605
	ix_short xx = (ix_short)*ip;
#line 605
	put_ix_short(xp, &xx);
#line 605
	if(*ip > (double)X_SHORT_MAX || *ip < (double)X_SHORT_MIN) return NC_ERANGE;
#line 605
	return ENOERR;
#line 605
}
#line 605

static int
#line 606
ncx_put_short_double(void *xp, const double *ip)
#line 606
{
#line 606
	ix_short xx = (ix_short)*ip;
#line 606
	put_ix_short(xp, &xx);
#line 606
	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 606
	return ENOERR;
#line 606
}
#line 606


/* x_ushort ------------------------------------------------------------------*/

#if USHORT_MAX == X_USHORT_MAX
typedef unsigned short ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_USHORT
#define IX_USHORT_MAX USHORT_MAX
#elif UINT_MAX >= X_USHORT_MAX
typedef unsigned int ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_UINT
#define IX_USHORT_MAX UINT_MAX
#elif ULONG_MAX >= X_USHORT_MAX
typedef unsigned long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONG
#define IX_USHORT_MAX ULONG_MAX
#elif ULLONG_MAX >= X_USHORT_MAX
typedef unsigned long long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONG_LONG
#define IX_USHORT_MAX ULLONG_MAX
#else
#error "ix_ushort implementation"
#endif

static void
get_ix_ushort(const void *xp, ix_ushort *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = *cp++ << 8;
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if(*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= *cp; 
}

static void
put_ix_ushort(void *xp, const ix_ushort *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (*ip) >> 8;
	*cp = (*ip) & 0xff;
}

static int
#line 653
ncx_get_ushort_schar(const void *xp, schar *ip)
#line 653
{
#line 653
	ix_ushort xx;
#line 653
	get_ix_ushort(xp, &xx);
#line 653
	*ip = (schar) xx;
#line 653
#if IX_USHORT_MAX > SCHAR_MAX
#line 653
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 653
#endif
#line 653

#line 653
	return ENOERR;
#line 653
}
#line 653

static int
#line 654
ncx_get_ushort_short(const void *xp, short *ip)
#line 654
{
#line 654
	ix_ushort xx;
#line 654
	get_ix_ushort(xp, &xx);
#line 654
	*ip = (short) xx;
#line 654
#if IX_USHORT_MAX > SHORT_MAX
#line 654
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 654
#endif
#line 654

#line 654
	return ENOERR;
#line 654
}
#line 654

static int
#line 655
ncx_get_ushort_int(const void *xp, int *ip)
#line 655
{
#line 655
	ix_ushort xx;
#line 655
	get_ix_ushort(xp, &xx);
#line 655
	*ip = (int) xx;
#line 655
#if IX_USHORT_MAX > INT_MAX
#line 655
	if (xx > INT_MAX) return NC_ERANGE;
#line 655
#endif
#line 655

#line 655
	return ENOERR;
#line 655
}
#line 655

static int
#line 656
ncx_get_ushort_longlong(const void *xp, longlong *ip)
#line 656
{
#line 656
	ix_ushort xx;
#line 656
	get_ix_ushort(xp, &xx);
#line 656
	*ip = (longlong) xx;
#line 656
#if IX_USHORT_MAX > LONGLONG_MAX
#line 656
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 656
#endif
#line 656

#line 656
	return ENOERR;
#line 656
}
#line 656

static int
#line 657
ncx_get_ushort_ushort(const void *xp, ushort *ip)
#line 657
{
#line 657
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 657
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 657
	return ENOERR;
#line 657
#else
#line 657
	ix_ushort xx;
#line 657
	get_ix_ushort(xp, &xx);
#line 657
	*ip = (ushort) xx;
#line 657
#if IX_USHORT_MAX > USHORT_MAX
#line 657
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 657
#endif
#line 657

#line 657
#endif
#line 657
	return ENOERR;
#line 657
}
#line 657

static int
#line 658
ncx_get_ushort_uchar(const void *xp, uchar *ip)
#line 658
{
#line 658
#if SIZEOF_IX_USHORT == SIZEOF_UCHAR && IX_USHORT_MAX == UCHAR_MAX
#line 658
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 658
	return ENOERR;
#line 658
#else
#line 658
	ix_ushort xx;
#line 658
	get_ix_ushort(xp, &xx);
#line 658
	*ip = (uchar) xx;
#line 658
#if IX_USHORT_MAX > UCHAR_MAX
#line 658
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 658
#endif
#line 658

#line 658
#endif
#line 658
	return ENOERR;
#line 658
}
#line 658

static int
#line 659
ncx_get_ushort_uint(const void *xp, uint *ip)
#line 659
{
#line 659
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 659
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 659
	return ENOERR;
#line 659
#else
#line 659
	ix_ushort xx;
#line 659
	get_ix_ushort(xp, &xx);
#line 659
	*ip = (uint) xx;
#line 659
#if IX_USHORT_MAX > UINT_MAX
#line 659
	if (xx > UINT_MAX) return NC_ERANGE;
#line 659
#endif
#line 659

#line 659
#endif
#line 659
	return ENOERR;
#line 659
}
#line 659

static int
#line 660
ncx_get_ushort_ulonglong(const void *xp, ulonglong *ip)
#line 660
{
#line 660
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 660
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 660
	return ENOERR;
#line 660
#else
#line 660
	ix_ushort xx;
#line 660
	get_ix_ushort(xp, &xx);
#line 660
	*ip = (ulonglong) xx;
#line 660
#if IX_USHORT_MAX > ULONGLONG_MAX
#line 660
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 660
#endif
#line 660

#line 660
#endif
#line 660
	return ENOERR;
#line 660
}
#line 660

static int
#line 661
ncx_get_ushort_float(const void *xp, float *ip)
#line 661
{
#line 661
	ix_ushort xx;
#line 661
	get_ix_ushort(xp, &xx);
#line 661
	*ip = (float) xx;
#line 661

#line 661
	return ENOERR;
#line 661
}
#line 661

static int
#line 662
ncx_get_ushort_double(const void *xp, double *ip)
#line 662
{
#line 662
	ix_ushort xx;
#line 662
	get_ix_ushort(xp, &xx);
#line 662
	*ip = (double) xx;
#line 662

#line 662
	return ENOERR;
#line 662
}
#line 662


static int
ncx_put_ushort_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
        if (*ip < 0) return NC_ERANGE;

	return ENOERR;
}

static int
ncx_put_ushort_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return ENOERR;
}

static int
#line 687
ncx_put_ushort_short(void *xp, const short *ip)
#line 687
{
#line 687
	ix_ushort xx = (ix_ushort)*ip;
#line 687
	put_ix_ushort(xp, &xx);
#line 687
#if IX_USHORT_MAX < SHORT_MAX
#line 687
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 687
#endif
#line 687
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 687
	return ENOERR;
#line 687
}
#line 687

static int
#line 688
ncx_put_ushort_int(void *xp, const int *ip)
#line 688
{
#line 688
	ix_ushort xx = (ix_ushort)*ip;
#line 688
	put_ix_ushort(xp, &xx);
#line 688
#if IX_USHORT_MAX < INT_MAX
#line 688
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 688
#endif
#line 688
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 688
	return ENOERR;
#line 688
}
#line 688

static int
#line 689
ncx_put_ushort_longlong(void *xp, const longlong *ip)
#line 689
{
#line 689
	ix_ushort xx = (ix_ushort)*ip;
#line 689
	put_ix_ushort(xp, &xx);
#line 689
#if IX_USHORT_MAX < LONGLONG_MAX
#line 689
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 689
#endif
#line 689
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 689
	return ENOERR;
#line 689
}
#line 689

static int
#line 690
ncx_put_ushort_ushort(void *xp, const ushort *ip)
#line 690
{
#line 690
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 690
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 690
	return ENOERR;
#line 690
#else
#line 690
	ix_ushort xx = (ix_ushort)*ip;
#line 690
	put_ix_ushort(xp, &xx);
#line 690
#if IX_USHORT_MAX < USHORT_MAX
#line 690
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 690
#endif
#line 690

#line 690
#endif
#line 690
	return ENOERR;
#line 690
}
#line 690

static int
#line 691
ncx_put_ushort_uint(void *xp, const uint *ip)
#line 691
{
#line 691
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 691
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 691
	return ENOERR;
#line 691
#else
#line 691
	ix_ushort xx = (ix_ushort)*ip;
#line 691
	put_ix_ushort(xp, &xx);
#line 691
#if IX_USHORT_MAX < UINT_MAX
#line 691
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 691
#endif
#line 691

#line 691
#endif
#line 691
	return ENOERR;
#line 691
}
#line 691

static int
#line 692
ncx_put_ushort_ulonglong(void *xp, const ulonglong *ip)
#line 692
{
#line 692
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 692
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 692
	return ENOERR;
#line 692
#else
#line 692
	ix_ushort xx = (ix_ushort)*ip;
#line 692
	put_ix_ushort(xp, &xx);
#line 692
#if IX_USHORT_MAX < ULONGLONG_MAX
#line 692
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 692
#endif
#line 692

#line 692
#endif
#line 692
	return ENOERR;
#line 692
}
#line 692

static int
#line 693
ncx_put_ushort_float(void *xp, const float *ip)
#line 693
{
#line 693
	ix_ushort xx = (ix_ushort)*ip;
#line 693
	put_ix_ushort(xp, &xx);
#line 693
	if(*ip > (double)X_USHORT_MAX || *ip < 0) return NC_ERANGE;
#line 693
	return ENOERR;
#line 693
}
#line 693

static int
#line 694
ncx_put_ushort_double(void *xp, const double *ip)
#line 694
{
#line 694
	ix_ushort xx = (ix_ushort)*ip;
#line 694
	put_ix_ushort(xp, &xx);
#line 694
	if(*ip > X_USHORT_MAX || *ip < 0) return NC_ERANGE;
#line 694
	return ENOERR;
#line 694
}
#line 694


/* x_int ---------------------------------------------------------------------*/

#if SHORT_MAX == X_INT_MAX
typedef short ix_int;
#define SIZEOF_IX_INT SIZEOF_SHORT
#define IX_INT_MAX SHORT_MAX
#elif INT_MAX  >= X_INT_MAX
typedef int ix_int;
#define SIZEOF_IX_INT SIZEOF_INT
#define IX_INT_MAX INT_MAX
#elif LONG_MAX  >= X_INT_MAX
typedef long ix_int;
#define SIZEOF_IX_INT SIZEOF_LONG
#define IX_INT_MAX LONG_MAX
#else
#error "ix_int implementation"
#endif


static void
get_ix_int(const void *xp, ix_int *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = *cp++ << 24;
#if SIZEOF_IX_INT > X_SIZEOF_INT
	if(*ip & 0x80000000)
	{
		/* extern is negative */
		*ip |= (~(0xffffffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp; 
}

static void
put_ix_int(void *xp, const ix_int *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (*ip) >> 24;
	*cp++ = ((*ip) & 0x00ff0000) >> 16;
	*cp++ = ((*ip) & 0x0000ff00) >>  8;
	*cp   = ((*ip) & 0x000000ff);
}

static int
#line 744
ncx_get_int_schar(const void *xp, schar *ip)
#line 744
{
#line 744
	ix_int xx;
#line 744
	get_ix_int(xp, &xx);
#line 744
	*ip = (schar) xx;
#line 744
#if IX_INT_MAX > SCHAR_MAX
#line 744
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 744
#endif
#line 744

#line 744
	return ENOERR;
#line 744
}
#line 744

static int
#line 745
ncx_get_int_short(const void *xp, short *ip)
#line 745
{
#line 745
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 745
	get_ix_int(xp, (ix_int *)ip);
#line 745
	return ENOERR;
#line 745
#else
#line 745
	ix_int xx;
#line 745
	get_ix_int(xp, &xx);
#line 745
	*ip = (short) xx;
#line 745
#if IX_INT_MAX > SHORT_MAX
#line 745
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 745
#endif
#line 745

#line 745
#endif
#line 745
	return ENOERR;
#line 745
}
#line 745

       int
#line 746
ncx_get_int_int(const void *xp, int *ip)
#line 746
{
#line 746
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 746
	get_ix_int(xp, (ix_int *)ip);
#line 746
	return ENOERR;
#line 746
#else
#line 746
	ix_int xx;
#line 746
	get_ix_int(xp, &xx);
#line 746
	*ip = (int) xx;
#line 746
#if IX_INT_MAX > INT_MAX
#line 746
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 746
#endif
#line 746

#line 746
#endif
#line 746
	return ENOERR;
#line 746
}
#line 746

static int
#line 747
ncx_get_int_longlong(const void *xp, longlong *ip)
#line 747
{
#line 747
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 747
	get_ix_int(xp, (ix_int *)ip);
#line 747
	return ENOERR;
#line 747
#else
#line 747
	ix_int xx;
#line 747
	get_ix_int(xp, &xx);
#line 747
	*ip = (longlong) xx;
#line 747
#if IX_INT_MAX > LONGLONG_MAX
#line 747
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 747
#endif
#line 747

#line 747
#endif
#line 747
	return ENOERR;
#line 747
}
#line 747

static int
#line 748
ncx_get_int_ushort(const void *xp, ushort *ip)
#line 748
{
#line 748
	ix_int xx;
#line 748
	get_ix_int(xp, &xx);
#line 748
	*ip = (ushort) xx;
#line 748
#if IX_INT_MAX > USHORT_MAX
#line 748
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 748
#endif
#line 748
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 748
	return ENOERR;
#line 748
}
#line 748

static int
#line 749
ncx_get_int_uchar(const void *xp, uchar *ip)
#line 749
{
#line 749
	ix_int xx;
#line 749
	get_ix_int(xp, &xx);
#line 749
	*ip = (uchar) xx;
#line 749
#if IX_INT_MAX > UCHAR_MAX
#line 749
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 749
#endif
#line 749
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 749
	return ENOERR;
#line 749
}
#line 749

static int
#line 750
ncx_get_int_uint(const void *xp, uint *ip)
#line 750
{
#line 750
	ix_int xx;
#line 750
	get_ix_int(xp, &xx);
#line 750
	*ip = (uint) xx;
#line 750
#if IX_INT_MAX > UINT_MAX
#line 750
	if (xx > UINT_MAX) return NC_ERANGE;
#line 750
#endif
#line 750
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 750
	return ENOERR;
#line 750
}
#line 750

static int
#line 751
ncx_get_int_ulonglong(const void *xp, ulonglong *ip)
#line 751
{
#line 751
	ix_int xx;
#line 751
	get_ix_int(xp, &xx);
#line 751
	*ip = (ulonglong) xx;
#line 751
#if IX_INT_MAX > ULONGLONG_MAX
#line 751
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 751
#endif
#line 751
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 751
	return ENOERR;
#line 751
}
#line 751

static int
#line 752
ncx_get_int_float(const void *xp, float *ip)
#line 752
{
#line 752
	ix_int xx;
#line 752
	get_ix_int(xp, &xx);
#line 752
	*ip = (float) xx;
#line 752

#line 752
	return ENOERR;
#line 752
}
#line 752

static int
#line 753
ncx_get_int_double(const void *xp, double *ip)
#line 753
{
#line 753
	ix_int xx;
#line 753
	get_ix_int(xp, &xx);
#line 753
	*ip = (double) xx;
#line 753

#line 753
	return ENOERR;
#line 753
}
#line 753


static int
ncx_put_int_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
	{
		*cp++ = 0xff;
		*cp++ = 0xff;
		*cp++ = 0xff;
	}
	else
	{
		*cp++ = 0x00;
		*cp++ = 0x00;
		*cp++ = 0x00;
	}
	*cp = (uchar)*ip;
	return ENOERR;
}

static int
ncx_put_int_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return ENOERR;
}

static int
#line 786
ncx_put_int_short(void *xp, const short *ip)
#line 786
{
#line 786
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 786
	put_ix_int(xp, (const ix_int *)ip);
#line 786
	return ENOERR;
#line 786
#else
#line 786
	ix_int xx = (ix_int)*ip;
#line 786
	put_ix_int(xp, &xx);
#line 786
#if IX_INT_MAX < SHORT_MAX
#line 786
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 786
#endif
#line 786

#line 786
#endif
#line 786
	return ENOERR;
#line 786
}
#line 786

       int
#line 787
ncx_put_int_int(void *xp, const int *ip)
#line 787
{
#line 787
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 787
	put_ix_int(xp, (const ix_int *)ip);
#line 787
	return ENOERR;
#line 787
#else
#line 787
	ix_int xx = (ix_int)*ip;
#line 787
	put_ix_int(xp, &xx);
#line 787
#if IX_INT_MAX < INT_MAX
#line 787
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 787
#endif
#line 787

#line 787
#endif
#line 787
	return ENOERR;
#line 787
}
#line 787

static int
#line 788
ncx_put_int_longlong(void *xp, const longlong *ip)
#line 788
{
#line 788
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 788
	put_ix_int(xp, (const ix_int *)ip);
#line 788
	return ENOERR;
#line 788
#else
#line 788
	ix_int xx = (ix_int)*ip;
#line 788
	put_ix_int(xp, &xx);
#line 788
#if IX_INT_MAX < LONGLONG_MAX
#line 788
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 788
#endif
#line 788

#line 788
#endif
#line 788
	return ENOERR;
#line 788
}
#line 788

static int
#line 789
ncx_put_int_ushort(void *xp, const ushort *ip)
#line 789
{
#line 789
	ix_int xx = (ix_int)*ip;
#line 789
	put_ix_int(xp, &xx);
#line 789
#if IX_INT_MAX < USHORT_MAX
#line 789
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 789
#endif
#line 789

#line 789
	return ENOERR;
#line 789
}
#line 789

static int
#line 790
ncx_put_int_uint(void *xp, const uint *ip)
#line 790
{
#line 790
	ix_int xx = (ix_int)*ip;
#line 790
	put_ix_int(xp, &xx);
#line 790
#if IX_INT_MAX < UINT_MAX
#line 790
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 790
#endif
#line 790

#line 790
	return ENOERR;
#line 790
}
#line 790

static int
#line 791
ncx_put_int_ulonglong(void *xp, const ulonglong *ip)
#line 791
{
#line 791
	ix_int xx = (ix_int)*ip;
#line 791
	put_ix_int(xp, &xx);
#line 791
#if IX_INT_MAX < ULONGLONG_MAX
#line 791
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 791
#endif
#line 791

#line 791
	return ENOERR;
#line 791
}
#line 791

static int
#line 792
ncx_put_int_float(void *xp, const float *ip)
#line 792
{
#line 792
	ix_int xx = (ix_int)*ip;
#line 792
	put_ix_int(xp, &xx);
#line 792
	if(*ip > (double)X_INT_MAX || *ip < (double)X_INT_MIN) return NC_ERANGE;
#line 792
	return ENOERR;
#line 792
}
#line 792

static int
#line 793
ncx_put_int_double(void *xp, const double *ip)
#line 793
{
#line 793
	ix_int xx = (ix_int)*ip;
#line 793
	put_ix_int(xp, &xx);
#line 793
	if(*ip > X_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 793
	return ENOERR;
#line 793
}
#line 793



/* x_uint --------------------------------------------------------------------*/

#if USHORT_MAX == X_UINT_MAX
typedef ushort ix_uint;
#define SIZEOF_IX_UINT SIZEOF_USHORT
#define IX_UINT_MAX USHORT_MAX
#elif UINT_MAX  >= X_UINT_MAX
typedef uint ix_uint;
#define SIZEOF_IX_UINT SIZEOF_UINT
#define IX_UINT_MAX UINT_MAX
#elif ULONG_MAX  >= X_UINT_MAX
typedef ulong ix_uint;
#define SIZEOF_IX_UINT SIZEOF_ULONG
#define IX_UINT_MAX ULONG_MAX
#else
#error "ix_uint implementation"
#endif


static void
get_ix_uint(const void *xp, ix_uint *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = *cp++ << 24;
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp; 
}

static void
put_ix_uint(void *xp, const ix_uint *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (*ip) >> 24;
	*cp++ = ((*ip) & 0x00ff0000) >> 16;
	*cp++ = ((*ip) & 0x0000ff00) >>  8;
	*cp   = ((*ip) & 0x000000ff);
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 838
ncx_get_uint_uint(const void *xp, uint *ip)
#line 838
{
#line 838
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 838
	get_ix_uint(xp, (ix_uint *)ip);
#line 838
	return ENOERR;
#line 838
#else
#line 838
	ix_uint xx;
#line 838
	get_ix_uint(xp, &xx);
#line 838
	*ip = (uint) xx;
#line 838
#if IX_UINT_MAX > UINT_MAX
#line 838
	if (xx > UINT_MAX) return NC_ERANGE;
#line 838
#endif
#line 838

#line 838
#endif
#line 838
	return ENOERR;
#line 838
}
#line 838

#endif

static int
#line 841
ncx_get_uint_schar(const void *xp, schar *ip)
#line 841
{
#line 841
	ix_uint xx;
#line 841
	get_ix_uint(xp, &xx);
#line 841
	*ip = (schar) xx;
#line 841
#if IX_UINT_MAX > SCHAR_MAX
#line 841
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 841
#endif
#line 841

#line 841
	return ENOERR;
#line 841
}
#line 841

static int
#line 842
ncx_get_uint_short(const void *xp, short *ip)
#line 842
{
#line 842
	ix_uint xx;
#line 842
	get_ix_uint(xp, &xx);
#line 842
	*ip = (short) xx;
#line 842
#if IX_UINT_MAX > SHORT_MAX
#line 842
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 842
#endif
#line 842

#line 842
	return ENOERR;
#line 842
}
#line 842

static int
#line 843
ncx_get_uint_int(const void *xp, int *ip)
#line 843
{
#line 843
	ix_uint xx;
#line 843
	get_ix_uint(xp, &xx);
#line 843
	*ip = (int) xx;
#line 843
#if IX_UINT_MAX > INT_MAX
#line 843
	if (xx > INT_MAX) return NC_ERANGE;
#line 843
#endif
#line 843

#line 843
	return ENOERR;
#line 843
}
#line 843

static int
#line 844
ncx_get_uint_longlong(const void *xp, longlong *ip)
#line 844
{
#line 844
	ix_uint xx;
#line 844
	get_ix_uint(xp, &xx);
#line 844
	*ip = (longlong) xx;
#line 844
#if IX_UINT_MAX > LONGLONG_MAX
#line 844
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 844
#endif
#line 844

#line 844
	return ENOERR;
#line 844
}
#line 844

static int
#line 845
ncx_get_uint_ushort(const void *xp, ushort *ip)
#line 845
{
#line 845
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 845
	get_ix_uint(xp, (ix_uint *)ip);
#line 845
	return ENOERR;
#line 845
#else
#line 845
	ix_uint xx;
#line 845
	get_ix_uint(xp, &xx);
#line 845
	*ip = (ushort) xx;
#line 845
#if IX_UINT_MAX > USHORT_MAX
#line 845
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 845
#endif
#line 845

#line 845
#endif
#line 845
	return ENOERR;
#line 845
}
#line 845

static int
#line 846
ncx_get_uint_uchar(const void *xp, uchar *ip)
#line 846
{
#line 846
#if SIZEOF_IX_UINT == SIZEOF_UCHAR && IX_UINT_MAX == UCHAR_MAX
#line 846
	get_ix_uint(xp, (ix_uint *)ip);
#line 846
	return ENOERR;
#line 846
#else
#line 846
	ix_uint xx;
#line 846
	get_ix_uint(xp, &xx);
#line 846
	*ip = (uchar) xx;
#line 846
#if IX_UINT_MAX > UCHAR_MAX
#line 846
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 846
#endif
#line 846

#line 846
#endif
#line 846
	return ENOERR;
#line 846
}
#line 846

static int
#line 847
ncx_get_uint_ulonglong(const void *xp, ulonglong *ip)
#line 847
{
#line 847
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 847
	get_ix_uint(xp, (ix_uint *)ip);
#line 847
	return ENOERR;
#line 847
#else
#line 847
	ix_uint xx;
#line 847
	get_ix_uint(xp, &xx);
#line 847
	*ip = (ulonglong) xx;
#line 847
#if IX_UINT_MAX > ULONGLONG_MAX
#line 847
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 847
#endif
#line 847

#line 847
#endif
#line 847
	return ENOERR;
#line 847
}
#line 847

static int
#line 848
ncx_get_uint_float(const void *xp, float *ip)
#line 848
{
#line 848
	ix_uint xx;
#line 848
	get_ix_uint(xp, &xx);
#line 848
	*ip = (float) xx;
#line 848

#line 848
	return ENOERR;
#line 848
}
#line 848

static int
#line 849
ncx_get_uint_double(const void *xp, double *ip)
#line 849
{
#line 849
	ix_uint xx;
#line 849
	get_ix_uint(xp, &xx);
#line 849
	*ip = (double) xx;
#line 849

#line 849
	return ENOERR;
#line 849
}
#line 849


static int
ncx_put_uint_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp = (uchar)*ip;

	if (*ip < 0) return NC_ERANGE;

	return ENOERR;
}

static int
ncx_put_uint_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return ENOERR;
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 877
ncx_put_uint_uint(void *xp, const uint *ip)
#line 877
{
#line 877
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 877
	put_ix_uint(xp, (const ix_uint *)ip);
#line 877
	return ENOERR;
#line 877
#else
#line 877
	ix_uint xx = (ix_uint)*ip;
#line 877
	put_ix_uint(xp, &xx);
#line 877
#if IX_UINT_MAX < UINT_MAX
#line 877
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 877
#endif
#line 877

#line 877
#endif
#line 877
	return ENOERR;
#line 877
}
#line 877

#endif
#
static int
#line 880
ncx_put_uint_short(void *xp, const short *ip)
#line 880
{
#line 880
	ix_uint xx = (ix_uint)*ip;
#line 880
	put_ix_uint(xp, &xx);
#line 880
#if IX_UINT_MAX < SHORT_MAX
#line 880
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 880
#endif
#line 880
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 880
	return ENOERR;
#line 880
}
#line 880

static int
#line 881
ncx_put_uint_int(void *xp, const int *ip)
#line 881
{
#line 881
	ix_uint xx = (ix_uint)*ip;
#line 881
	put_ix_uint(xp, &xx);
#line 881
#if IX_UINT_MAX < INT_MAX
#line 881
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 881
#endif
#line 881
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 881
	return ENOERR;
#line 881
}
#line 881

static int
#line 882
ncx_put_uint_longlong(void *xp, const longlong *ip)
#line 882
{
#line 882
	ix_uint xx = (ix_uint)*ip;
#line 882
	put_ix_uint(xp, &xx);
#line 882
#if IX_UINT_MAX < LONGLONG_MAX
#line 882
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 882
#endif
#line 882
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 882
	return ENOERR;
#line 882
}
#line 882

static int
#line 883
ncx_put_uint_ushort(void *xp, const ushort *ip)
#line 883
{
#line 883
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 883
	put_ix_uint(xp, (const ix_uint *)ip);
#line 883
	return ENOERR;
#line 883
#else
#line 883
	ix_uint xx = (ix_uint)*ip;
#line 883
	put_ix_uint(xp, &xx);
#line 883
#if IX_UINT_MAX < USHORT_MAX
#line 883
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 883
#endif
#line 883

#line 883
#endif
#line 883
	return ENOERR;
#line 883
}
#line 883

static int
#line 884
ncx_put_uint_ulonglong(void *xp, const ulonglong *ip)
#line 884
{
#line 884
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 884
	put_ix_uint(xp, (const ix_uint *)ip);
#line 884
	return ENOERR;
#line 884
#else
#line 884
	ix_uint xx = (ix_uint)*ip;
#line 884
	put_ix_uint(xp, &xx);
#line 884
#if IX_UINT_MAX < ULONGLONG_MAX
#line 884
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 884
#endif
#line 884

#line 884
#endif
#line 884
	return ENOERR;
#line 884
}
#line 884

static int
#line 885
ncx_put_uint_float(void *xp, const float *ip)
#line 885
{
#line 885
	ix_uint xx = (ix_uint)*ip;
#line 885
	put_ix_uint(xp, &xx);
#line 885
	if(*ip > (double)X_UINT_MAX || *ip < 0) return NC_ERANGE;
#line 885
	return ENOERR;
#line 885
}
#line 885

static int
#line 886
ncx_put_uint_double(void *xp, const double *ip)
#line 886
{
#line 886
	ix_uint xx = (ix_uint)*ip;
#line 886
	put_ix_uint(xp, &xx);
#line 886
	if(*ip > X_UINT_MAX || *ip < 0) return NC_ERANGE;
#line 886
	return ENOERR;
#line 886
}
#line 886

 

/* x_float -------------------------------------------------------------------*/

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)

static void
get_ix_float(const void *xp, float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, sizeof(float));
#else
	swap4b(ip, xp);
#endif
}

static void
put_ix_float(void *xp, const float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_FLOAT);
#else
	swap4b(xp, ip);
#endif
}

#elif vax

/* What IEEE single precision floating point looks like on a Vax */
struct	ieee_single {
	unsigned int	exp_hi       : 7;
	unsigned int	sign         : 1;
	unsigned int 	mant_hi      : 7;
	unsigned int	exp_lo       : 1;
	unsigned int	mant_lo_hi   : 8;
	unsigned int	mant_lo_lo   : 8;
};

/* Vax single precision floating point */
struct	vax_single {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
};

#define VAX_SNG_BIAS	0x81
#define IEEE_SNG_BIAS	0x7f

static struct sgl_limits {
	struct vax_single s;
	struct ieee_single ieee;
} max = {
	{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0x1, 0x0, 0x0 }		/* Max IEEE */
};
static struct sgl_limits min = {
	{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }		/* Min IEEE */
};

#line 1000
static void
get_ix_float(const void *xp, float *ip)
{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 1003
		const struct ieee_single *const isp =
#line 1003
			 (const struct ieee_single *) xp;
#line 1003
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 1003

#line 1003
		switch(exp) {
#line 1003
		case 0 :
#line 1003
			/* ieee subnormal */
#line 1003
			if(isp->mant_hi == min.ieee.mant_hi
#line 1003
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 1003
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 1003
			{
#line 1003
				*vsp = min.s;
#line 1003
			}
#line 1003
			else
#line 1003
			{
#line 1003
				unsigned mantissa = (isp->mant_hi << 16)
#line 1003
					 | isp->mant_lo_hi << 8
#line 1003
					 | isp->mant_lo_lo;
#line 1003
				unsigned tmp = mantissa >> 20;
#line 1003
				if(tmp >= 4) {
#line 1003
					vsp->exp = 2;
#line 1003
				} else if (tmp >= 2) {
#line 1003
					vsp->exp = 1;
#line 1003
				} else {
#line 1003
					*vsp = min.s;
#line 1003
					break;
#line 1003
				} /* else */
#line 1003
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 1003
				tmp <<= 3 - vsp->exp;
#line 1003
				vsp->mantissa2 = tmp;
#line 1003
				vsp->mantissa1 = (tmp >> 16);
#line 1003
			}
#line 1003
			break;
#line 1003
		case 0xfe :
#line 1003
		case 0xff :
#line 1003
			*vsp = max.s;
#line 1003
			break;
#line 1003
		default :
#line 1003
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 1003
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 1003
			vsp->mantissa1 = isp->mant_hi;
#line 1003
		}
#line 1003

#line 1003
		vsp->sign = isp->sign;
#line 1003

}

#line 1057

static void
put_ix_float(void *xp, const float *ip)
{
		const struct vax_single *const vsp =
#line 1061
			 (const struct vax_single *)ip;
#line 1061
		struct ieee_single *const isp = (struct ieee_single *) xp;
#line 1061

#line 1061
		switch(vsp->exp){
#line 1061
		case 0 :
#line 1061
			/* all vax float with zero exponent map to zero */
#line 1061
			*isp = min.ieee;
#line 1061
			break;
#line 1061
		case 2 :
#line 1061
		case 1 :
#line 1061
		{
#line 1061
			/* These will map to subnormals */
#line 1061
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 1061
					 | vsp->mantissa2;
#line 1061
			mantissa >>= 3 - vsp->exp;
#line 1061
			mantissa += (1 << (20 + vsp->exp));
#line 1061
			isp->mant_lo_lo = mantissa;
#line 1061
			isp->mant_lo_hi = mantissa >> 8;
#line 1061
			isp->mant_hi = mantissa >> 16;
#line 1061
			isp->exp_lo = 0;
#line 1061
			isp->exp_hi = 0;
#line 1061
		}
#line 1061
			break;
#line 1061
		case 0xff : /* max.s.exp */
#line 1061
			if( vsp->mantissa2 == max.s.mantissa2
#line 1061
				&& vsp->mantissa1 == max.s.mantissa1)
#line 1061
			{
#line 1061
				/* map largest vax float to ieee infinity */
#line 1061
				*isp = max.ieee;
#line 1061
				break;
#line 1061
			} /* else, fall thru */
#line 1061
		default :
#line 1061
		{
#line 1061
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 1061
			isp->exp_hi = exp >> 1;
#line 1061
			isp->exp_lo = exp;
#line 1061
			isp->mant_lo_lo = vsp->mantissa2;
#line 1061
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 1061
			isp->mant_hi = vsp->mantissa1;
#line 1061
		}
#line 1061
		}
#line 1061

#line 1061
		isp->sign = vsp->sign;
#line 1061

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

/*
 * Return the number of bytes until the next "word" boundary
 * N.B. This is based on the very wierd YMP address structure,
 * which puts the address within a word in the leftmost 3 bits
 * of the address.
 */
static size_t
word_align(const void *vp)
{
	const size_t rem = ((size_t)vp >> (64 - 3)) & 0x7;
	return (rem != 0);
}

struct ieee_single_hi {
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
	unsigned int	pad	:32;
};
typedef struct ieee_single_hi ieee_single_hi;

struct ieee_single_lo {
	unsigned int	pad	:32;
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
};
typedef struct ieee_single_lo ieee_single_lo;

static const int ieee_single_bias = 0x7f;

struct ieee_double {
	unsigned int	sign	: 1;
	unsigned int	 exp	:11;
	unsigned int	mant	:52;
};
typedef struct ieee_double ieee_double;

static const int ieee_double_bias = 0x3ff;

#if defined(NO_IEEE_FLOAT)

struct cray_single {
	unsigned int	sign	: 1;
	unsigned int	 exp	:15;
	unsigned int	mant	:48;
};
typedef struct cray_single cray_single;

static const int cs_ieis_bias = 0x4000 - 0x7f;

static const int cs_id_bias = 0x4000 - 0x3ff;

#line 1196

static void
get_ix_float(const void *xp, float *ip)
{

	if(word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1204

#line 1204
		if(isp->exp == 0)
#line 1204
		{
#line 1204
			/* ieee subnormal */
#line 1204
			*ip = (double)isp->mant;
#line 1204
			if(isp->mant != 0)
#line 1204
			{
#line 1204
				csp->exp -= (ieee_single_bias + 22);
#line 1204
			}
#line 1204
		}
#line 1204
		else
#line 1204
		{
#line 1204
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1204
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1204
			csp->mant |= (1 << (48 - 1));
#line 1204
		}
#line 1204
		csp->sign = isp->sign;
#line 1204

#line 1204

	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1209

#line 1209
		if(isp->exp == 0)
#line 1209
		{
#line 1209
			/* ieee subnormal */
#line 1209
			*ip = (double)isp->mant;
#line 1209
			if(isp->mant != 0)
#line 1209
			{
#line 1209
				csp->exp -= (ieee_single_bias + 22);
#line 1209
			}
#line 1209
		}
#line 1209
		else
#line 1209
		{
#line 1209
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1209
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1209
			csp->mant |= (1 << (48 - 1));
#line 1209
		}
#line 1209
		csp->sign = isp->sign;
#line 1209

#line 1209

	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	if(word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1219
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1219

#line 1219
	isp->sign = csp->sign;
#line 1219

#line 1219
	if(ieee_exp >= 0xff)
#line 1219
	{
#line 1219
		/* NC_ERANGE => ieee Inf */
#line 1219
		isp->exp = 0xff;
#line 1219
		isp->mant = 0x0;
#line 1219
	}
#line 1219
	else if(ieee_exp > 0)
#line 1219
	{
#line 1219
		/* normal ieee representation */
#line 1219
		isp->exp  = ieee_exp;
#line 1219
		/* assumes cray rep is in normal form */
#line 1219
		assert(csp->mant & 0x800000000000);
#line 1219
		isp->mant = (((csp->mant << 1) &
#line 1219
				0xffffffffffff) >> (48 - 23));
#line 1219
	}
#line 1219
	else if(ieee_exp > -23)
#line 1219
	{
#line 1219
		/* ieee subnormal, right shift */
#line 1219
		const int rshift = (48 - 23 - ieee_exp);
#line 1219

#line 1219
		isp->mant = csp->mant >> rshift;
#line 1219

#line 1219
#if 0
#line 1219
		if(csp->mant & (1 << (rshift -1)))
#line 1219
		{
#line 1219
			/* round up */
#line 1219
			isp->mant++;
#line 1219
		}
#line 1219
#endif
#line 1219

#line 1219
		isp->exp  = 0;
#line 1219
	}
#line 1219
	else
#line 1219
	{
#line 1219
		/* smaller than ieee can represent */
#line 1219
		isp->exp = 0;
#line 1219
		isp->mant = 0;
#line 1219
	}
#line 1219

	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1224
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1224

#line 1224
	isp->sign = csp->sign;
#line 1224

#line 1224
	if(ieee_exp >= 0xff)
#line 1224
	{
#line 1224
		/* NC_ERANGE => ieee Inf */
#line 1224
		isp->exp = 0xff;
#line 1224
		isp->mant = 0x0;
#line 1224
	}
#line 1224
	else if(ieee_exp > 0)
#line 1224
	{
#line 1224
		/* normal ieee representation */
#line 1224
		isp->exp  = ieee_exp;
#line 1224
		/* assumes cray rep is in normal form */
#line 1224
		assert(csp->mant & 0x800000000000);
#line 1224
		isp->mant = (((csp->mant << 1) &
#line 1224
				0xffffffffffff) >> (48 - 23));
#line 1224
	}
#line 1224
	else if(ieee_exp > -23)
#line 1224
	{
#line 1224
		/* ieee subnormal, right shift */
#line 1224
		const int rshift = (48 - 23 - ieee_exp);
#line 1224

#line 1224
		isp->mant = csp->mant >> rshift;
#line 1224

#line 1224
#if 0
#line 1224
		if(csp->mant & (1 << (rshift -1)))
#line 1224
		{
#line 1224
			/* round up */
#line 1224
			isp->mant++;
#line 1224
		}
#line 1224
#endif
#line 1224

#line 1224
		isp->exp  = 0;
#line 1224
	}
#line 1224
	else
#line 1224
	{
#line 1224
		/* smaller than ieee can represent */
#line 1224
		isp->exp = 0;
#line 1224
		isp->mant = 0;
#line 1224
	}
#line 1224

	}
}

#else
	/* IEEE Cray with only doubles */
static void
get_ix_float(const void *xp, float *ip)
{

	ieee_double *idp = (ieee_double *) ip;

	if(word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		if(isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		if(isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	const ieee_double *idp = (const ieee_double *) ip;
	if(word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
		if(idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
		if(idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
}
#endif

#else
#error "ix_float implementation"
#endif

#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_get_float_float(const void *xp, float *ip)
{
	/* TODO */
	get_ix_float(xp, ip);
	return ENOERR;
}
#endif

#define ix_float float

static int
#line 1311
ncx_get_float_schar(const void *xp, schar *ip)
#line 1311
{
#line 1311
	ix_float xx;
#line 1311
	get_ix_float(xp, &xx);
#line 1311
	*ip = (schar) xx;
#line 1311
	if(xx > (double)SCHAR_MAX || xx < (double)SCHAR_MIN) return NC_ERANGE;
#line 1311
	return ENOERR;
#line 1311
}
#line 1311

static int
#line 1312
ncx_get_float_short(const void *xp, short *ip)
#line 1312
{
#line 1312
	ix_float xx;
#line 1312
	get_ix_float(xp, &xx);
#line 1312
	*ip = (short) xx;
#line 1312
	if(xx > (double)SHORT_MAX || xx < (double)SHORT_MIN) return NC_ERANGE;
#line 1312
	return ENOERR;
#line 1312
}
#line 1312

static int
#line 1313
ncx_get_float_int(const void *xp, int *ip)
#line 1313
{
#line 1313
	ix_float xx;
#line 1313
	get_ix_float(xp, &xx);
#line 1313
	*ip = (int) xx;
#line 1313
	if(xx > (double)INT_MAX || xx < (double)INT_MIN) return NC_ERANGE;
#line 1313
	return ENOERR;
#line 1313
}
#line 1313

static int
#line 1314
ncx_get_float_double(const void *xp, double *ip)
#line 1314
{
#line 1314
	ix_float xx;
#line 1314
	get_ix_float(xp, &xx);
#line 1314
	*ip = (double) xx;
#line 1314

#line 1314
	return ENOERR;
#line 1314
}
#line 1314

static int
#line 1315
ncx_get_float_longlong(const void *xp, longlong *ip)
#line 1315
{
#line 1315
	ix_float xx;
#line 1315
	get_ix_float(xp, &xx);
#line 1315
	*ip = (longlong) xx;
#line 1315
	if(xx > (double)LONGLONG_MAX || xx < (double)LONGLONG_MIN) return NC_ERANGE;
#line 1315
	return ENOERR;
#line 1315
}
#line 1315

static int
#line 1316
ncx_get_float_uchar(const void *xp, uchar *ip)
#line 1316
{
#line 1316
	ix_float xx;
#line 1316
	get_ix_float(xp, &xx);
#line 1316
	*ip = (uchar) xx;
#line 1316
	if(xx > (double)UCHAR_MAX || xx < 0) return NC_ERANGE;
#line 1316
	return ENOERR;
#line 1316
}
#line 1316

static int
#line 1317
ncx_get_float_ushort(const void *xp, ushort *ip)
#line 1317
{
#line 1317
	ix_float xx;
#line 1317
	get_ix_float(xp, &xx);
#line 1317
	*ip = (ushort) xx;
#line 1317
	if(xx > (double)USHORT_MAX || xx < 0) return NC_ERANGE;
#line 1317
	return ENOERR;
#line 1317
}
#line 1317

static int
#line 1318
ncx_get_float_uint(const void *xp, uint *ip)
#line 1318
{
#line 1318
	ix_float xx;
#line 1318
	get_ix_float(xp, &xx);
#line 1318
	*ip = (uint) xx;
#line 1318
	if(xx > (double)UINT_MAX || xx < 0) return NC_ERANGE;
#line 1318
	return ENOERR;
#line 1318
}
#line 1318

static int
#line 1319
ncx_get_float_ulonglong(const void *xp, ulonglong *ip)
#line 1319
{
#line 1319
	ix_float xx;
#line 1319
	get_ix_float(xp, &xx);
#line 1319
	*ip = (ulonglong) xx;
#line 1319
	if(xx > (double)ULONGLONG_MAX || xx < 0) return NC_ERANGE;
#line 1319
	return ENOERR;
#line 1319
}
#line 1319


#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_put_float_float(void *xp, const float *ip)
{
	put_ix_float(xp, ip);
#ifdef NO_IEEE_FLOAT
	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}
#endif

static int
#line 1334
ncx_put_float_schar(void *xp, const schar *ip)
#line 1334
{
#line 1334
	ix_float xx = (ix_float)*ip;
#line 1334
	put_ix_float(xp, &xx);
#line 1334

#line 1334
	return ENOERR;
#line 1334
}
#line 1334

static int
#line 1335
ncx_put_float_short(void *xp, const short *ip)
#line 1335
{
#line 1335
	ix_float xx = (ix_float)*ip;
#line 1335
	put_ix_float(xp, &xx);
#line 1335

#line 1335
	return ENOERR;
#line 1335
}
#line 1335

static int
#line 1336
ncx_put_float_int(void *xp, const int *ip)
#line 1336
{
#line 1336
	ix_float xx = (ix_float)*ip;
#line 1336
	put_ix_float(xp, &xx);
#line 1336

#line 1336
	return ENOERR;
#line 1336
}
#line 1336

static int
#line 1337
ncx_put_float_double(void *xp, const double *ip)
#line 1337
{
#line 1337
	ix_float xx = (ix_float)*ip;
#line 1337
	put_ix_float(xp, &xx);
#line 1337
	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN) return NC_ERANGE;
#line 1337
	return ENOERR;
#line 1337
}
#line 1337

static int
#line 1338
ncx_put_float_longlong(void *xp, const longlong *ip)
#line 1338
{
#line 1338
	ix_float xx = (ix_float)*ip;
#line 1338
	put_ix_float(xp, &xx);
#line 1338

#line 1338
	return ENOERR;
#line 1338
}
#line 1338

static int
#line 1339
ncx_put_float_uchar(void *xp, const uchar *ip)
#line 1339
{
#line 1339
	ix_float xx = (ix_float)*ip;
#line 1339
	put_ix_float(xp, &xx);
#line 1339

#line 1339
	return ENOERR;
#line 1339
}
#line 1339

static int
#line 1340
ncx_put_float_ushort(void *xp, const ushort *ip)
#line 1340
{
#line 1340
	ix_float xx = (ix_float)*ip;
#line 1340
	put_ix_float(xp, &xx);
#line 1340

#line 1340
	return ENOERR;
#line 1340
}
#line 1340

static int
#line 1341
ncx_put_float_uint(void *xp, const uint *ip)
#line 1341
{
#line 1341
	ix_float xx = (ix_float)*ip;
#line 1341
	put_ix_float(xp, &xx);
#line 1341

#line 1341
	return ENOERR;
#line 1341
}
#line 1341

static int
#line 1342
ncx_put_float_ulonglong(void *xp, const ulonglong *ip)
#line 1342
{
#line 1342
	ix_float xx = (ix_float)*ip;
#line 1342
	put_ix_float(xp, &xx);
#line 1342

#line 1342
	return ENOERR;
#line 1342
}
#line 1342



/* x_double ------------------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE  && !defined(NO_IEEE_FLOAT)

static void
get_ix_double(const void *xp, double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, sizeof(double));
#else
	swap8b(ip, xp);
#endif
}

static void
put_ix_double(void *xp, const double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_DOUBLE);
#else
	swap8b(xp, ip);
#endif
}

#elif vax

/* What IEEE double precision floating point looks like on a Vax */
struct	ieee_double {
	unsigned int	exp_hi   : 7;
	unsigned int	sign     : 1;
	unsigned int 	mant_6   : 4;
	unsigned int	exp_lo   : 4;
	unsigned int	mant_5   : 8;
	unsigned int	mant_4   : 8;

	unsigned int	mant_lo  : 32;
};

/* Vax double precision floating point */
struct  vax_double {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
	unsigned int	mantissa3 : 16;
	unsigned int	mantissa4 : 16;
};

#define VAX_DBL_BIAS	0x81
#define IEEE_DBL_BIAS	0x3ff
#define MASK(nbits)	((1 << nbits) - 1)

static const struct dbl_limits {
	struct	vax_double d;
	struct	ieee_double ieee;
} dbl_limits[2] = {
	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0}}, /* Max IEEE */
	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}, /* Min IEEE */
};


#line 1456
static void
get_ix_double(const void *xp, double *ip)
{
	struct vax_double *const vdp =
#line 1459
			 (struct vax_double *)ip;
#line 1459
	const struct ieee_double *const idp =
#line 1459
			 (const struct ieee_double *) xp;
#line 1459
	{
#line 1459
		const struct dbl_limits *lim;
#line 1459
		int ii;
#line 1459
		for (ii = 0, lim = dbl_limits;
#line 1459
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 1459
			ii++, lim++)
#line 1459
		{
#line 1459
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 1459
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 1459
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 1459
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 1459
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 1459
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 1459
				)
#line 1459
			{
#line 1459
				*vdp = lim->d;
#line 1459
				goto doneit;
#line 1459
			}
#line 1459
		}
#line 1459
	}
#line 1459
	{
#line 1459
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 1459
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 1459
	}
#line 1459
	{
#line 1459
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 1459
				 | (idp->mant_5 << 8)
#line 1459
				 | idp->mant_4);
#line 1459
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 1459
		vdp->mantissa1 = (mant_hi >> 13);
#line 1459
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 1459
				| (mant_lo >> 29);
#line 1459
		vdp->mantissa3 = (mant_lo >> 13);
#line 1459
		vdp->mantissa4 = (mant_lo << 3);
#line 1459
	}
#line 1459
	doneit:
#line 1459
		vdp->sign = idp->sign;
#line 1459

}


#line 1529
static void
put_ix_double(void *xp, const double *ip)
{
	const struct vax_double *const vdp = 
#line 1532
			(const struct vax_double *)ip;
#line 1532
	struct ieee_double *const idp =
#line 1532
			 (struct ieee_double *) xp;
#line 1532

#line 1532
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 1532
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 1532
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 1532
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 1532
		(vdp->exp == dbl_limits[0].d.exp))
#line 1532
	{
#line 1532
		*idp = dbl_limits[0].ieee;
#line 1532
		goto shipit;
#line 1532
	}
#line 1532
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 1532
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 1532
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 1532
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 1532
		(vdp->exp == dbl_limits[1].d.exp))
#line 1532
	{
#line 1532
		*idp = dbl_limits[1].ieee;
#line 1532
		goto shipit;
#line 1532
	}
#line 1532

#line 1532
	{
#line 1532
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 1532

#line 1532
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 1532
			(vdp->mantissa3 << 13) |
#line 1532
			((vdp->mantissa4 >> 3) & MASK(13));
#line 1532

#line 1532
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 1532
				 | (vdp->mantissa2 >> 3);
#line 1532

#line 1532
		if((vdp->mantissa4 & 7) > 4)
#line 1532
		{
#line 1532
			/* round up */
#line 1532
			mant_lo++;
#line 1532
			if(mant_lo == 0)
#line 1532
			{
#line 1532
				mant_hi++;
#line 1532
				if(mant_hi > 0xffffff)
#line 1532
				{
#line 1532
					mant_hi = 0;
#line 1532
					exp++;
#line 1532
				}
#line 1532
			}
#line 1532
		}
#line 1532

#line 1532
		idp->mant_lo = SWAP4(mant_lo);
#line 1532
		idp->mant_6 = mant_hi >> 16;
#line 1532
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 1532
		idp->mant_4 = mant_hi;
#line 1532
		idp->exp_hi = exp >> 4;
#line 1532
		idp->exp_lo = exp;
#line 1532
	}
#line 1532
		
#line 1532
	shipit:
#line 1532
		idp->sign = vdp->sign;
#line 1532

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

static void
get_ix_double(const void *xp, double *ip)
{
	const ieee_double *idp = (const ieee_double *) xp;
	cray_single *csp = (cray_single *) ip;

	if(idp->exp == 0)
	{
		/* ieee subnormal */
		*ip = (double)idp->mant;
		if(idp->mant != 0)
		{
			csp->exp -= (ieee_double_bias + 51);
		}
	}
	else
	{
		csp->exp  = idp->exp + cs_id_bias + 1;
		csp->mant = idp->mant >> (52 - 48 + 1);
		csp->mant |= (1 << (48 - 1));
	}
	csp->sign = idp->sign;
}

static void
put_ix_double(void *xp, const double *ip)
{
	ieee_double *idp = (ieee_double *) xp;
	const cray_single *csp = (const cray_single *) ip;

	int ieee_exp = csp->exp - cs_id_bias -1;

	idp->sign = csp->sign;

	if(ieee_exp >= 0x7ff)
	{
		/* NC_ERANGE => ieee Inf */
		idp->exp = 0x7ff;
		idp->mant = 0x0;
	}
	else if(ieee_exp > 0)
	{
		/* normal ieee representation */
		idp->exp  = ieee_exp;
		/* assumes cray rep is in normal form */
		assert(csp->mant & 0x800000000000);
		idp->mant = (((csp->mant << 1) &
				0xffffffffffff) << (52 - 48));
	}
	else if(ieee_exp >= (-(52 -48)))
	{
		/* ieee subnormal, left shift */
		const int lshift = (52 - 48) + ieee_exp;
		idp->mant = csp->mant << lshift;
		idp->exp  = 0;
	}
	else if(ieee_exp >= -52)
	{
		/* ieee subnormal, right shift */
		const int rshift = (- (52 - 48) - ieee_exp);

		idp->mant = csp->mant >> rshift;

#if 0
		if(csp->mant & (1 << (rshift -1)))
		{
			/* round up */
			idp->mant++;
		}
#endif

		idp->exp  = 0;
	}
	else
	{
		/* smaller than ieee can represent */
		idp->exp = 0;
		idp->mant = 0;
	}
}
#else
#error "ix_double implementation"
#endif

#define ix_double double

static int
#line 1624
ncx_get_double_schar(const void *xp, schar *ip)
#line 1624
{
#line 1624
	ix_double xx;
#line 1624
	get_ix_double(xp, &xx);
#line 1624
	*ip = (schar) xx;
#line 1624
	if(xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 1624
	return ENOERR;
#line 1624
}
#line 1624

static int
#line 1625
ncx_get_double_short(const void *xp, short *ip)
#line 1625
{
#line 1625
	ix_double xx;
#line 1625
	get_ix_double(xp, &xx);
#line 1625
	*ip = (short) xx;
#line 1625
	if(xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 1625
	return ENOERR;
#line 1625
}
#line 1625

static int
#line 1626
ncx_get_double_int(const void *xp, int *ip)
#line 1626
{
#line 1626
	ix_double xx;
#line 1626
	get_ix_double(xp, &xx);
#line 1626
	*ip = (int) xx;
#line 1626
	if(xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 1626
	return ENOERR;
#line 1626
}
#line 1626

static int
#line 1627
ncx_get_double_longlong(const void *xp, longlong *ip)
#line 1627
{
#line 1627
	ix_double xx;
#line 1627
	get_ix_double(xp, &xx);
#line 1627
	*ip = (longlong) xx;
#line 1627
	if(xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 1627
	return ENOERR;
#line 1627
}
#line 1627

static int
#line 1628
ncx_get_double_uchar(const void *xp, uchar *ip)
#line 1628
{
#line 1628
	ix_double xx;
#line 1628
	get_ix_double(xp, &xx);
#line 1628
	*ip = (uchar) xx;
#line 1628
	if(xx > UCHAR_MAX || xx < 0) return NC_ERANGE;
#line 1628
	return ENOERR;
#line 1628
}
#line 1628

static int
#line 1629
ncx_get_double_ushort(const void *xp, ushort *ip)
#line 1629
{
#line 1629
	ix_double xx;
#line 1629
	get_ix_double(xp, &xx);
#line 1629
	*ip = (ushort) xx;
#line 1629
	if(xx > USHORT_MAX || xx < 0) return NC_ERANGE;
#line 1629
	return ENOERR;
#line 1629
}
#line 1629

static int
#line 1630
ncx_get_double_uint(const void *xp, uint *ip)
#line 1630
{
#line 1630
	ix_double xx;
#line 1630
	get_ix_double(xp, &xx);
#line 1630
	*ip = (uint) xx;
#line 1630
	if(xx > UINT_MAX || xx < 0) return NC_ERANGE;
#line 1630
	return ENOERR;
#line 1630
}
#line 1630

static int
#line 1631
ncx_get_double_ulonglong(const void *xp, ulonglong *ip)
#line 1631
{
#line 1631
	ix_double xx;
#line 1631
	get_ix_double(xp, &xx);
#line 1631
	*ip = (ulonglong) xx;
#line 1631
	if(xx > ULONGLONG_MAX || xx < 0) return NC_ERANGE;
#line 1631
	return ENOERR;
#line 1631
}
#line 1631


static int
ncx_get_double_float(const void *xp, float *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	if(xx > FLT_MAX)
	{
		*ip = FLT_MAX;
		return NC_ERANGE;
	}
	if(xx < (-FLT_MAX))
	{
		*ip = (-FLT_MAX);
		return NC_ERANGE;
	}
	*ip = (float) xx;
	return ENOERR;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_get_double_double(const void *xp, double *ip)
{
	/* TODO */
	get_ix_double(xp, ip);
	return ENOERR;
}
#endif

static int
#line 1662
ncx_put_double_schar(void *xp, const schar *ip)
#line 1662
{
#line 1662
	ix_double xx = (ix_double)*ip;
#line 1662
	put_ix_double(xp, &xx);
#line 1662

#line 1662
	return ENOERR;
#line 1662
}
#line 1662

static int
#line 1663
ncx_put_double_uchar(void *xp, const uchar *ip)
#line 1663
{
#line 1663
	ix_double xx = (ix_double)*ip;
#line 1663
	put_ix_double(xp, &xx);
#line 1663

#line 1663
	return ENOERR;
#line 1663
}
#line 1663

static int
#line 1664
ncx_put_double_short(void *xp, const short *ip)
#line 1664
{
#line 1664
	ix_double xx = (ix_double)*ip;
#line 1664
	put_ix_double(xp, &xx);
#line 1664

#line 1664
	return ENOERR;
#line 1664
}
#line 1664

static int
#line 1665
ncx_put_double_ushort(void *xp, const ushort *ip)
#line 1665
{
#line 1665
	ix_double xx = (ix_double)*ip;
#line 1665
	put_ix_double(xp, &xx);
#line 1665

#line 1665
	return ENOERR;
#line 1665
}
#line 1665

static int
#line 1666
ncx_put_double_int(void *xp, const int *ip)
#line 1666
{
#line 1666
	ix_double xx = (ix_double)*ip;
#line 1666
	put_ix_double(xp, &xx);
#line 1666

#line 1666
	return ENOERR;
#line 1666
}
#line 1666

static int
#line 1667
ncx_put_double_uint(void *xp, const uint *ip)
#line 1667
{
#line 1667
	ix_double xx = (ix_double)*ip;
#line 1667
	put_ix_double(xp, &xx);
#line 1667

#line 1667
	return ENOERR;
#line 1667
}
#line 1667

static int
#line 1668
ncx_put_double_longlong(void *xp, const longlong *ip)
#line 1668
{
#line 1668
	ix_double xx = (ix_double)*ip;
#line 1668
	put_ix_double(xp, &xx);
#line 1668

#line 1668
	return ENOERR;
#line 1668
}
#line 1668

static int
#line 1669
ncx_put_double_ulonglong(void *xp, const ulonglong *ip)
#line 1669
{
#line 1669
	ix_double xx = (ix_double)*ip;
#line 1669
	put_ix_double(xp, &xx);
#line 1669

#line 1669
	return ENOERR;
#line 1669
}
#line 1669


static int
ncx_put_double_float(void *xp, const float *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 1	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_put_double_double(void *xp, const double *ip)
{
	put_ix_double(xp, ip);
#ifdef NO_IEEE_FLOAT
	if(*ip > X_DOUBLE_MAX || *ip < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}
#endif


/* x_longlong ---------------------------------------------------------------------*/

#if SHORT_MAX == X_LONGLONG_MAX
typedef short ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_SHORT
#define IX_LONGLONG_MAX SHORT_MAX
#elif LONG_LONG_MAX  >= X_LONGLONG_MAX
typedef longlong ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_LONGLONG
#define IX_LONGLONG_MAX LONG_LONG_MAX
#elif LONG_MAX  >= X_LONGLONG_MAX
typedef long ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_LONG
#define IX_LONGLONG_MAX LONG_MAX
#else
#error "ix_longlong implementation"
#endif


static void
get_ix_longlong(const void *xp, ix_longlong *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((long long)(*cp++) << 56);
    *ip |= ((long long)(*cp++) << 48);
    *ip |= ((long long)(*cp++) << 40);
    *ip |= ((long long)(*cp++) << 32);
    *ip |= ((long long)(*cp++) << 24);
    *ip |= ((long long)(*cp++) << 16);
    *ip |= ((long long)(*cp++) <<  8);
    *ip |=  (long long)*cp;
}

static void
put_ix_longlong(void *xp, const ix_longlong *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (*ip) >> 56;
    *cp++ = ((*ip) & 0x00ff000000000000LL) >> 48;
    *cp++ = ((*ip) & 0x0000ff0000000000LL) >> 40;
    *cp++ = ((*ip) & 0x000000ff00000000LL) >> 32;
    *cp++ = ((*ip) & 0x00000000ff000000LL) >> 24;
    *cp++ = ((*ip) & 0x0000000000ff0000LL) >> 16;
    *cp++ = ((*ip) & 0x000000000000ff00LL) >>  8;
    *cp   = ((*ip) & 0x00000000000000ffLL);
}

static int
#line 1746
ncx_get_longlong_schar(const void *xp, schar *ip)
#line 1746
{
#line 1746
	ix_longlong xx;
#line 1746
	get_ix_longlong(xp, &xx);
#line 1746
	*ip = (schar) xx;
#line 1746
#if IX_LONGLONG_MAX > SCHAR_MAX
#line 1746
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 1746
#endif
#line 1746

#line 1746
	return ENOERR;
#line 1746
}
#line 1746

static int
#line 1747
ncx_get_longlong_short(const void *xp, short *ip)
#line 1747
{
#line 1747
#if SIZEOF_IX_LONGLONG == SIZEOF_SHORT && IX_LONGLONG_MAX == SHORT_MAX
#line 1747
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1747
	return ENOERR;
#line 1747
#else
#line 1747
	ix_longlong xx;
#line 1747
	get_ix_longlong(xp, &xx);
#line 1747
	*ip = (short) xx;
#line 1747
#if IX_LONGLONG_MAX > SHORT_MAX
#line 1747
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 1747
#endif
#line 1747

#line 1747
#endif
#line 1747
	return ENOERR;
#line 1747
}
#line 1747

static int
#line 1748
ncx_get_longlong_int(const void *xp, int *ip)
#line 1748
{
#line 1748
#if SIZEOF_IX_LONGLONG == SIZEOF_INT && IX_LONGLONG_MAX == INT_MAX
#line 1748
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1748
	return ENOERR;
#line 1748
#else
#line 1748
	ix_longlong xx;
#line 1748
	get_ix_longlong(xp, &xx);
#line 1748
	*ip = (int) xx;
#line 1748
#if IX_LONGLONG_MAX > INT_MAX
#line 1748
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 1748
#endif
#line 1748

#line 1748
#endif
#line 1748
	return ENOERR;
#line 1748
}
#line 1748

static int
#line 1749
ncx_get_longlong_longlong(const void *xp, longlong *ip)
#line 1749
{
#line 1749
#if SIZEOF_IX_LONGLONG == SIZEOF_LONGLONG && IX_LONGLONG_MAX == LONGLONG_MAX
#line 1749
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1749
	return ENOERR;
#line 1749
#else
#line 1749
	ix_longlong xx;
#line 1749
	get_ix_longlong(xp, &xx);
#line 1749
	*ip = (longlong) xx;
#line 1749
#if IX_LONGLONG_MAX > LONGLONG_MAX
#line 1749
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 1749
#endif
#line 1749

#line 1749
#endif
#line 1749
	return ENOERR;
#line 1749
}
#line 1749

static int
#line 1750
ncx_get_longlong_ushort(const void *xp, ushort *ip)
#line 1750
{
#line 1750
	ix_longlong xx;
#line 1750
	get_ix_longlong(xp, &xx);
#line 1750
	*ip = (ushort) xx;
#line 1750
#if IX_LONGLONG_MAX > USHORT_MAX
#line 1750
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 1750
#endif
#line 1750
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1750
	return ENOERR;
#line 1750
}
#line 1750

static int
#line 1751
ncx_get_longlong_uchar(const void *xp, uchar *ip)
#line 1751
{
#line 1751
	ix_longlong xx;
#line 1751
	get_ix_longlong(xp, &xx);
#line 1751
	*ip = (uchar) xx;
#line 1751
#if IX_LONGLONG_MAX > UCHAR_MAX
#line 1751
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 1751
#endif
#line 1751
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1751
	return ENOERR;
#line 1751
}
#line 1751

static int
#line 1752
ncx_get_longlong_uint(const void *xp, uint *ip)
#line 1752
{
#line 1752
	ix_longlong xx;
#line 1752
	get_ix_longlong(xp, &xx);
#line 1752
	*ip = (uint) xx;
#line 1752
#if IX_LONGLONG_MAX > UINT_MAX
#line 1752
	if (xx > UINT_MAX) return NC_ERANGE;
#line 1752
#endif
#line 1752
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1752
	return ENOERR;
#line 1752
}
#line 1752

static int
#line 1753
ncx_get_longlong_ulonglong(const void *xp, ulonglong *ip)
#line 1753
{
#line 1753
	ix_longlong xx;
#line 1753
	get_ix_longlong(xp, &xx);
#line 1753
	*ip = (ulonglong) xx;
#line 1753
#if IX_LONGLONG_MAX > ULONGLONG_MAX
#line 1753
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 1753
#endif
#line 1753
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1753
	return ENOERR;
#line 1753
}
#line 1753

static int
#line 1754
ncx_get_longlong_float(const void *xp, float *ip)
#line 1754
{
#line 1754
	ix_longlong xx;
#line 1754
	get_ix_longlong(xp, &xx);
#line 1754
	*ip = (float) xx;
#line 1754

#line 1754
	return ENOERR;
#line 1754
}
#line 1754

static int
#line 1755
ncx_get_longlong_double(const void *xp, double *ip)
#line 1755
{
#line 1755
	ix_longlong xx;
#line 1755
	get_ix_longlong(xp, &xx);
#line 1755
	*ip = (double) xx;
#line 1755

#line 1755
	return ENOERR;
#line 1755
}
#line 1755


static int
#line 1757
ncx_put_longlong_schar(void *xp, const schar *ip)
#line 1757
{
#line 1757
	ix_longlong xx = (ix_longlong)*ip;
#line 1757
	put_ix_longlong(xp, &xx);
#line 1757
#if IX_LONGLONG_MAX < SCHAR_MAX
#line 1757
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1757
#endif
#line 1757

#line 1757
	return ENOERR;
#line 1757
}
#line 1757

static int
#line 1758
ncx_put_longlong_short(void *xp, const short *ip)
#line 1758
{
#line 1758
#if SIZEOF_IX_LONGLONG == SIZEOF_SHORT && IX_LONGLONG_MAX == SHORT_MAX
#line 1758
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1758
	return ENOERR;
#line 1758
#else
#line 1758
	ix_longlong xx = (ix_longlong)*ip;
#line 1758
	put_ix_longlong(xp, &xx);
#line 1758
#if IX_LONGLONG_MAX < SHORT_MAX
#line 1758
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1758
#endif
#line 1758

#line 1758
#endif
#line 1758
	return ENOERR;
#line 1758
}
#line 1758

static int
#line 1759
ncx_put_longlong_int(void *xp, const int *ip)
#line 1759
{
#line 1759
#if SIZEOF_IX_LONGLONG == SIZEOF_INT && IX_LONGLONG_MAX == INT_MAX
#line 1759
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1759
	return ENOERR;
#line 1759
#else
#line 1759
	ix_longlong xx = (ix_longlong)*ip;
#line 1759
	put_ix_longlong(xp, &xx);
#line 1759
#if IX_LONGLONG_MAX < INT_MAX
#line 1759
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1759
#endif
#line 1759

#line 1759
#endif
#line 1759
	return ENOERR;
#line 1759
}
#line 1759

static int
#line 1760
ncx_put_longlong_longlong(void *xp, const longlong *ip)
#line 1760
{
#line 1760
#if SIZEOF_IX_LONGLONG == SIZEOF_LONGLONG && IX_LONGLONG_MAX == LONGLONG_MAX
#line 1760
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1760
	return ENOERR;
#line 1760
#else
#line 1760
	ix_longlong xx = (ix_longlong)*ip;
#line 1760
	put_ix_longlong(xp, &xx);
#line 1760
#if IX_LONGLONG_MAX < LONGLONG_MAX
#line 1760
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1760
#endif
#line 1760

#line 1760
#endif
#line 1760
	return ENOERR;
#line 1760
}
#line 1760

static int
#line 1761
ncx_put_longlong_ushort(void *xp, const ushort *ip)
#line 1761
{
#line 1761
	ix_longlong xx = (ix_longlong)*ip;
#line 1761
	put_ix_longlong(xp, &xx);
#line 1761
#if IX_LONGLONG_MAX < USHORT_MAX
#line 1761
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1761
#endif
#line 1761

#line 1761
	return ENOERR;
#line 1761
}
#line 1761

static int
#line 1762
ncx_put_longlong_uchar(void *xp, const uchar *ip)
#line 1762
{
#line 1762
	ix_longlong xx = (ix_longlong)*ip;
#line 1762
	put_ix_longlong(xp, &xx);
#line 1762
#if IX_LONGLONG_MAX < UCHAR_MAX
#line 1762
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1762
#endif
#line 1762

#line 1762
	return ENOERR;
#line 1762
}
#line 1762

static int
#line 1763
ncx_put_longlong_uint(void *xp, const uint *ip)
#line 1763
{
#line 1763
	ix_longlong xx = (ix_longlong)*ip;
#line 1763
	put_ix_longlong(xp, &xx);
#line 1763
#if IX_LONGLONG_MAX < UINT_MAX
#line 1763
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1763
#endif
#line 1763

#line 1763
	return ENOERR;
#line 1763
}
#line 1763

static int
#line 1764
ncx_put_longlong_ulonglong(void *xp, const ulonglong *ip)
#line 1764
{
#line 1764
	ix_longlong xx = (ix_longlong)*ip;
#line 1764
	put_ix_longlong(xp, &xx);
#line 1764
#if IX_LONGLONG_MAX < ULONGLONG_MAX
#line 1764
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1764
#endif
#line 1764

#line 1764
	return ENOERR;
#line 1764
}
#line 1764

static int
#line 1765
ncx_put_longlong_float(void *xp, const float *ip)
#line 1765
{
#line 1765
	ix_longlong xx = (ix_longlong)*ip;
#line 1765
	put_ix_longlong(xp, &xx);
#line 1765
	if(*ip > (double)X_LONGLONG_MAX || *ip < (double)X_LONGLONG_MIN) return NC_ERANGE;
#line 1765
	return ENOERR;
#line 1765
}
#line 1765

static int
#line 1766
ncx_put_longlong_double(void *xp, const double *ip)
#line 1766
{
#line 1766
	ix_longlong xx = (ix_longlong)*ip;
#line 1766
	put_ix_longlong(xp, &xx);
#line 1766
	if(*ip > X_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1766
	return ENOERR;
#line 1766
}
#line 1766

 

/* x_ulonglong --------------------------------------------------------------------*/

#if USHORT_MAX == X_ULONGLONG_MAX
typedef ushort ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_USHORT
#define IX_ULONGLONG_MAX USHORT_MAX
#elif ULONG_LONG_MAX  >= X_ULONGLONG_MAX
typedef ulonglong ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_ULONGLONG
#define IX_ULONGLONG_MAX ULONG_LONG_MAX
#elif ULONG_MAX  >= X_ULONGLONG_MAX
typedef ulong ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_ULONG
#define IX_ULONGLONG_MAX ULONG_MAX
#else
#error "ix_ulonglong implementation"
#endif


static void
get_ix_ulonglong(const void *xp, ix_ulonglong *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((unsigned long long)(*cp++) << 56);
    *ip |= ((unsigned long long)(*cp++) << 48);
    *ip |= ((unsigned long long)(*cp++) << 40);
    *ip |= ((unsigned long long)(*cp++) << 32);
    *ip |= ((unsigned long long)(*cp++) << 24);
    *ip |= ((unsigned long long)(*cp++) << 16);
    *ip |= ((unsigned long long)(*cp++) <<  8);
    *ip |=  (unsigned long long)*cp;
}

static void
put_ix_ulonglong(void *xp, const ix_ulonglong *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (*ip) >> 56;
    *cp++ = ((*ip) & 0x00ff000000000000ULL) >> 48;
    *cp++ = ((*ip) & 0x0000ff0000000000ULL) >> 40;
    *cp++ = ((*ip) & 0x000000ff00000000ULL) >> 32;
    *cp++ = ((*ip) & 0x00000000ff000000ULL) >> 24;
    *cp++ = ((*ip) & 0x0000000000ff0000ULL) >> 16;
    *cp++ = ((*ip) & 0x000000000000ff00ULL) >>  8;
    *cp   = ((*ip) & 0x00000000000000ffULL);
}

static int
#line 1818
ncx_get_ulonglong_schar(const void *xp, schar *ip)
#line 1818
{
#line 1818
	ix_ulonglong xx;
#line 1818
	get_ix_ulonglong(xp, &xx);
#line 1818
	*ip = (schar) xx;
#line 1818
#if IX_ULONGLONG_MAX > SCHAR_MAX
#line 1818
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 1818
#endif
#line 1818

#line 1818
	return ENOERR;
#line 1818
}
#line 1818

static int
#line 1819
ncx_get_ulonglong_short(const void *xp, short *ip)
#line 1819
{
#line 1819
	ix_ulonglong xx;
#line 1819
	get_ix_ulonglong(xp, &xx);
#line 1819
	*ip = (short) xx;
#line 1819
#if IX_ULONGLONG_MAX > SHORT_MAX
#line 1819
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 1819
#endif
#line 1819

#line 1819
	return ENOERR;
#line 1819
}
#line 1819

static int
#line 1820
ncx_get_ulonglong_int(const void *xp, int *ip)
#line 1820
{
#line 1820
	ix_ulonglong xx;
#line 1820
	get_ix_ulonglong(xp, &xx);
#line 1820
	*ip = (int) xx;
#line 1820
#if IX_ULONGLONG_MAX > INT_MAX
#line 1820
	if (xx > INT_MAX) return NC_ERANGE;
#line 1820
#endif
#line 1820

#line 1820
	return ENOERR;
#line 1820
}
#line 1820

static int
#line 1821
ncx_get_ulonglong_longlong(const void *xp, longlong *ip)
#line 1821
{
#line 1821
	ix_ulonglong xx;
#line 1821
	get_ix_ulonglong(xp, &xx);
#line 1821
	*ip = (longlong) xx;
#line 1821
#if IX_ULONGLONG_MAX > LONGLONG_MAX
#line 1821
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 1821
#endif
#line 1821

#line 1821
	return ENOERR;
#line 1821
}
#line 1821

static int
#line 1822
ncx_get_ulonglong_ushort(const void *xp, ushort *ip)
#line 1822
{
#line 1822
#if SIZEOF_IX_ULONGLONG == SIZEOF_USHORT && IX_ULONGLONG_MAX == USHORT_MAX
#line 1822
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1822
	return ENOERR;
#line 1822
#else
#line 1822
	ix_ulonglong xx;
#line 1822
	get_ix_ulonglong(xp, &xx);
#line 1822
	*ip = (ushort) xx;
#line 1822
#if IX_ULONGLONG_MAX > USHORT_MAX
#line 1822
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 1822
#endif
#line 1822

#line 1822
#endif
#line 1822
	return ENOERR;
#line 1822
}
#line 1822

static int
#line 1823
ncx_get_ulonglong_uchar(const void *xp, uchar *ip)
#line 1823
{
#line 1823
#if SIZEOF_IX_ULONGLONG == SIZEOF_UCHAR && IX_ULONGLONG_MAX == UCHAR_MAX
#line 1823
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1823
	return ENOERR;
#line 1823
#else
#line 1823
	ix_ulonglong xx;
#line 1823
	get_ix_ulonglong(xp, &xx);
#line 1823
	*ip = (uchar) xx;
#line 1823
#if IX_ULONGLONG_MAX > UCHAR_MAX
#line 1823
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 1823
#endif
#line 1823

#line 1823
#endif
#line 1823
	return ENOERR;
#line 1823
}
#line 1823

static int
#line 1824
ncx_get_ulonglong_uint(const void *xp, uint *ip)
#line 1824
{
#line 1824
#if SIZEOF_IX_ULONGLONG == SIZEOF_UINT && IX_ULONGLONG_MAX == UINT_MAX
#line 1824
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1824
	return ENOERR;
#line 1824
#else
#line 1824
	ix_ulonglong xx;
#line 1824
	get_ix_ulonglong(xp, &xx);
#line 1824
	*ip = (uint) xx;
#line 1824
#if IX_ULONGLONG_MAX > UINT_MAX
#line 1824
	if (xx > UINT_MAX) return NC_ERANGE;
#line 1824
#endif
#line 1824

#line 1824
#endif
#line 1824
	return ENOERR;
#line 1824
}
#line 1824

static int
#line 1825
ncx_get_ulonglong_ulonglong(const void *xp, ulonglong *ip)
#line 1825
{
#line 1825
#if SIZEOF_IX_ULONGLONG == SIZEOF_ULONGLONG && IX_ULONGLONG_MAX == ULONGLONG_MAX
#line 1825
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1825
	return ENOERR;
#line 1825
#else
#line 1825
	ix_ulonglong xx;
#line 1825
	get_ix_ulonglong(xp, &xx);
#line 1825
	*ip = (ulonglong) xx;
#line 1825
#if IX_ULONGLONG_MAX > ULONGLONG_MAX
#line 1825
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 1825
#endif
#line 1825

#line 1825
#endif
#line 1825
	return ENOERR;
#line 1825
}
#line 1825

static int
#line 1826
ncx_get_ulonglong_float(const void *xp, float *ip)
#line 1826
{
#line 1826
	ix_ulonglong xx;
#line 1826
	get_ix_ulonglong(xp, &xx);
#line 1826
	*ip = (float) xx;
#line 1826

#line 1826
	return ENOERR;
#line 1826
}
#line 1826

static int
#line 1827
ncx_get_ulonglong_double(const void *xp, double *ip)
#line 1827
{
#line 1827
	ix_ulonglong xx;
#line 1827
	get_ix_ulonglong(xp, &xx);
#line 1827
	*ip = (double) xx;
#line 1827

#line 1827
	return ENOERR;
#line 1827
}
#line 1827


static int
#line 1829
ncx_put_ulonglong_schar(void *xp, const schar *ip)
#line 1829
{
#line 1829
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1829
	put_ix_ulonglong(xp, &xx);
#line 1829
#if IX_ULONGLONG_MAX < SCHAR_MAX
#line 1829
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1829
#endif
#line 1829
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1829
	return ENOERR;
#line 1829
}
#line 1829

static int
#line 1830
ncx_put_ulonglong_short(void *xp, const short *ip)
#line 1830
{
#line 1830
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1830
	put_ix_ulonglong(xp, &xx);
#line 1830
#if IX_ULONGLONG_MAX < SHORT_MAX
#line 1830
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1830
#endif
#line 1830
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1830
	return ENOERR;
#line 1830
}
#line 1830

static int
#line 1831
ncx_put_ulonglong_int(void *xp, const int *ip)
#line 1831
{
#line 1831
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1831
	put_ix_ulonglong(xp, &xx);
#line 1831
#if IX_ULONGLONG_MAX < INT_MAX
#line 1831
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1831
#endif
#line 1831
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1831
	return ENOERR;
#line 1831
}
#line 1831

static int
#line 1832
ncx_put_ulonglong_longlong(void *xp, const longlong *ip)
#line 1832
{
#line 1832
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1832
	put_ix_ulonglong(xp, &xx);
#line 1832
#if IX_ULONGLONG_MAX < LONGLONG_MAX
#line 1832
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1832
#endif
#line 1832
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1832
	return ENOERR;
#line 1832
}
#line 1832

static int
#line 1833
ncx_put_ulonglong_uchar(void *xp, const uchar *ip)
#line 1833
{
#line 1833
#if SIZEOF_IX_ULONGLONG == SIZEOF_UCHAR && IX_ULONGLONG_MAX == UCHAR_MAX
#line 1833
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1833
	return ENOERR;
#line 1833
#else
#line 1833
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1833
	put_ix_ulonglong(xp, &xx);
#line 1833
#if IX_ULONGLONG_MAX < UCHAR_MAX
#line 1833
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1833
#endif
#line 1833

#line 1833
#endif
#line 1833
	return ENOERR;
#line 1833
}
#line 1833

static int
#line 1834
ncx_put_ulonglong_ushort(void *xp, const ushort *ip)
#line 1834
{
#line 1834
#if SIZEOF_IX_ULONGLONG == SIZEOF_USHORT && IX_ULONGLONG_MAX == USHORT_MAX
#line 1834
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1834
	return ENOERR;
#line 1834
#else
#line 1834
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1834
	put_ix_ulonglong(xp, &xx);
#line 1834
#if IX_ULONGLONG_MAX < USHORT_MAX
#line 1834
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1834
#endif
#line 1834

#line 1834
#endif
#line 1834
	return ENOERR;
#line 1834
}
#line 1834

static int
#line 1835
ncx_put_ulonglong_uint(void *xp, const uint *ip)
#line 1835
{
#line 1835
#if SIZEOF_IX_ULONGLONG == SIZEOF_UINT && IX_ULONGLONG_MAX == UINT_MAX
#line 1835
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1835
	return ENOERR;
#line 1835
#else
#line 1835
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1835
	put_ix_ulonglong(xp, &xx);
#line 1835
#if IX_ULONGLONG_MAX < UINT_MAX
#line 1835
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1835
#endif
#line 1835

#line 1835
#endif
#line 1835
	return ENOERR;
#line 1835
}
#line 1835

static int
#line 1836
ncx_put_ulonglong_ulonglong(void *xp, const ulonglong *ip)
#line 1836
{
#line 1836
#if SIZEOF_IX_ULONGLONG == SIZEOF_ULONGLONG && IX_ULONGLONG_MAX == ULONGLONG_MAX
#line 1836
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1836
	return ENOERR;
#line 1836
#else
#line 1836
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1836
	put_ix_ulonglong(xp, &xx);
#line 1836
#if IX_ULONGLONG_MAX < ULONGLONG_MAX
#line 1836
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1836
#endif
#line 1836

#line 1836
#endif
#line 1836
	return ENOERR;
#line 1836
}
#line 1836

static int
#line 1837
ncx_put_ulonglong_float(void *xp, const float *ip)
#line 1837
{
#line 1837
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1837
	put_ix_ulonglong(xp, &xx);
#line 1837
	if(*ip > (double)X_ULONGLONG_MAX || *ip < 0) return NC_ERANGE;
#line 1837
	return ENOERR;
#line 1837
}
#line 1837

static int
#line 1838
ncx_put_ulonglong_double(void *xp, const double *ip)
#line 1838
{
#line 1838
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1838
	put_ix_ulonglong(xp, &xx);
#line 1838
	if(*ip > X_ULONGLONG_MAX || *ip < 0) return NC_ERANGE;
#line 1838
	return ENOERR;
#line 1838
}
#line 1838

 

/* x_size_t */

#if SIZEOF_SIZE_T < X_SIZEOF_SIZE_T
#error "x_size_t implementation"
/* netcdf requires size_t which can hold a values from 0 to 2^32 -1 */
#endif

int
ncx_put_size_t(void **xpp, const size_t *ulp)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
	assert(*ulp <= X_SIZE_MAX);

	*cp++ = (uchar)((*ulp) >> 24);
	*cp++ = (uchar)(((*ulp) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ulp) & 0x0000ff00) >>  8);
	*cp   = (uchar)((*ulp) & 0x000000ff);

	*xpp = (void *)((char *)(*xpp) + X_SIZEOF_SIZE_T);
	return ENOERR;
}

int
ncx_get_size_t(const void **xpp,  size_t *ulp)
{
	/* similar to get_ix_int */
	const uchar *cp = (const uchar *) *xpp;

	*ulp = (unsigned)(*cp++ << 24);
	*ulp |= (*cp++ << 16);
	*ulp |= (*cp++ << 8);
	*ulp |= *cp; 

	*xpp = (const void *)((const char *)(*xpp) + X_SIZEOF_SIZE_T);
	return ENOERR;
}

/* x_off_t */

int
ncx_put_off_t(void **xpp, const off_t *lp, size_t sizeof_off_t)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
		/* No negative offsets stored in netcdf */
	if (*lp < 0) {
	  /* Assume this is an overflow of a 32-bit int... */
	  return NC_ERANGE;
	}
	  
	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

	if (sizeof_off_t == 4) {
		*cp++ = (uchar) ((*lp)               >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
	} else {
#if SIZEOF_OFF_T == 4
/* Write a 64-bit offset on a system with only a 32-bit offset */
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;

		*cp++ = (uchar)(((*lp) & 0xff000000) >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
#else
		*cp++ = (uchar) ((*lp)                          >> 56);
		*cp++ = (uchar)(((*lp) & 0x00ff000000000000ULL) >> 48);
		*cp++ = (uchar)(((*lp) & 0x0000ff0000000000ULL) >> 40);
		*cp++ = (uchar)(((*lp) & 0x000000ff00000000ULL) >> 32);
		*cp++ = (uchar)(((*lp) & 0x00000000ff000000ULL) >> 24);
		*cp++ = (uchar)(((*lp) & 0x0000000000ff0000ULL) >> 16);
		*cp++ = (uchar)(((*lp) & 0x000000000000ff00ULL) >>  8);
		*cp   = (uchar)( (*lp) & 0x00000000000000ffULL);
#endif
	}
	*xpp = (void *)((char *)(*xpp) + sizeof_off_t);
	return ENOERR;
}

int
ncx_get_off_t(const void **xpp, off_t *lp, size_t sizeof_off_t)
{
	/* similar to get_ix_int() */
	const uchar *cp = (const uchar *) *xpp;
	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

 	if (sizeof_off_t == 4) {
		*lp =  (off_t)(*cp++ << 24);
		*lp |= (off_t)(*cp++ << 16);
		*lp |= (off_t)(*cp++ <<  8);
		*lp |= (off_t)*cp; 
	} else {
#if SIZEOF_OFF_T == 4
/* Read a 64-bit offset on a system with only a 32-bit offset */
/* If the offset overflows, set an error code and return */
		*lp =  ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |= ((off_t)(*cp++));
/*
 * lp now contains the upper 32-bits of the 64-bit offset.  if lp is
 * not zero, then the dataset is larger than can be represented
 * on this system.  Set an error code and return.
 */
		if (*lp != 0) {
		  return NC_ERANGE;
		}

		*lp  = ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;

		if (*lp < 0) {
		  /*
		   * If this fails, then the offset is >2^31, but less
		   * than 2^32 which is not allowed, but is not caught
		   * by the previous check
		   */
		  return NC_ERANGE;
		}
#else
		*lp =  ((off_t)(*cp++) << 56);
		*lp |= ((off_t)(*cp++) << 48);
		*lp |= ((off_t)(*cp++) << 40);
		*lp |= ((off_t)(*cp++) << 32);
		*lp |= ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;
#endif
	}
	*xpp = (const void *)((const char *)(*xpp) + sizeof_off_t);
	return ENOERR;
}

/*----< ncx_get_int32() >--------------------------------------------------*/
int
ncx_get_int32(const void **xpp,
              int         *ip)
{
    const uchar *cp = (const uchar *) *xpp;

    /* cannot call swap4b(), as lp is 8-byte */
    *ip  = (*cp++ << 24);
    *ip |= (*cp++ << 16);
    *ip |= (*cp++ <<  8);
    *ip |=  *cp;

    /* advance *xpp 4 bytes */
    *xpp = (void *)((const char *)(*xpp) + 4);

    return NC_NOERR;
}

/*----< ncx_get_int64() >-------------------------------------------------*/
int
ncx_get_int64(const void **xpp,
              long long   *llp)
{
    const uchar *cp = (const uchar *) *xpp;

    /* below is the same as calling swap8b(llp, *xpp) */
    *llp  = ((long long)(*cp++) << 56);
    *llp |= ((long long)(*cp++) << 48);
    *llp |= ((long long)(*cp++) << 40);
    *llp |= ((long long)(*cp++) << 32);
    *llp |= ((long long)(*cp++) << 24);
    *llp |= ((long long)(*cp++) << 16);
    *llp |= ((long long)(*cp++) <<  8);
    *llp |=  (long long)*cp;

    /* advance *xpp 8 bytes */
    *xpp = (void *)((const char *)(*xpp) + 8);

    return NC_NOERR;
}

/*---< ncx_put_int32() >-----------------------------------------------------*/
/* copy the contents of lp (a signed 32-bit integer) to xpp in Big Endian
 * form and advance *xpp 4 bytes
 */
int
ncx_put_int32(void      **xpp,
              const int   ip)
{
#ifdef WORDS_BIGENDIAN
    int *ptr = (int*) (*xpp); /* typecast to 4-byte integer */
    *ptr = ip;
#else
    /* bitwise shifts below are to produce an integer in Big Endian */
    /* cannot call swap4b(), as lp is 8-byte */
    uchar *cp = (uchar *) *xpp;
    *cp++ = (uchar)((ip & 0xff000000) >> 24);
    *cp++ = (uchar)((ip & 0x00ff0000) >> 16);
    *cp++ = (uchar)((ip & 0x0000ff00) >>  8);
    *cp   = (uchar)( ip & 0x000000ff);
#endif
    /* advance *xpp 4 bytes */
    *xpp  = (void *)((char *)(*xpp) + 4);

    return NC_NOERR;
}

/*---< ncx_put_int64() >-----------------------------------------------------*/
/* copy the contents of lp (a signed 64-bit integer) to xpp in Big Endian
 * form and advance *xpp 8 bytes
 */
int
ncx_put_int64(void             **xpp,
              const long long    ip)
{
#ifdef WORDS_BIGENDIAN
    long long *ptr = (long long*) (*xpp); /* typecast to 8-byte integer */
    *ptr = ip;
#else
    uchar *cp = (uchar *) *xpp;
    /* below is the same as calling swap8b(*xpp, &ip) */
    *cp++ = (uchar)((ip & 0xff00000000000000ULL) >> 56);
    *cp++ = (uchar)((ip & 0x00ff000000000000ULL) >> 48);
    *cp++ = (uchar)((ip & 0x0000ff0000000000ULL) >> 40);
    *cp++ = (uchar)((ip & 0x000000ff00000000ULL) >> 32);
    *cp++ = (uchar)((ip & 0x00000000ff000000ULL) >> 24);
    *cp++ = (uchar)((ip & 0x0000000000ff0000ULL) >> 16);
    *cp++ = (uchar)((ip & 0x000000000000ff00ULL) >>  8);
    *cp   = (uchar)( ip & 0x00000000000000ffULL);
#endif
    /* advance *xpp 8 bytes */
    *xpp  = (void *)((char *)(*xpp) + 8);

    return NC_NOERR;
}


/*
 * Aggregate numeric conversion functions.
 */
#line 2087

#line 2524

#line 2530

/* schar ---------------------------------------------------------------------*/

#line 2534
int
ncx_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2537
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2537
	return ENOERR;
#line 2537

}
#line 2540
int
ncx_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2543
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2543
	return ENOERR;
#line 2543

}
int
#line 2545
ncx_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2545
{
#line 2545
	int status = ENOERR;
#line 2545
	schar *xp = (schar *)(*xpp);
#line 2545

#line 2545
	while(nelems-- != 0)
#line 2545
	{
#line 2545

#line 2545
		*tp++ = *xp++;
#line 2545
	}
#line 2545

#line 2545
	*xpp = (const void *)xp;
#line 2545
	return status;
#line 2545
}
#line 2545

int
#line 2546
ncx_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2546
{
#line 2546
	int status = ENOERR;
#line 2546
	schar *xp = (schar *)(*xpp);
#line 2546

#line 2546
	while(nelems-- != 0)
#line 2546
	{
#line 2546

#line 2546
		*tp++ = *xp++;
#line 2546
	}
#line 2546

#line 2546
	*xpp = (const void *)xp;
#line 2546
	return status;
#line 2546
}
#line 2546

int
#line 2547
ncx_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2547
{
#line 2547
	int status = ENOERR;
#line 2547
	schar *xp = (schar *)(*xpp);
#line 2547

#line 2547
	while(nelems-- != 0)
#line 2547
	{
#line 2547

#line 2547
		*tp++ = *xp++;
#line 2547
	}
#line 2547

#line 2547
	*xpp = (const void *)xp;
#line 2547
	return status;
#line 2547
}
#line 2547

int
#line 2548
ncx_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2548
{
#line 2548
	int status = ENOERR;
#line 2548
	schar *xp = (schar *)(*xpp);
#line 2548

#line 2548
	while(nelems-- != 0)
#line 2548
	{
#line 2548

#line 2548
		*tp++ = *xp++;
#line 2548
	}
#line 2548

#line 2548
	*xpp = (const void *)xp;
#line 2548
	return status;
#line 2548
}
#line 2548

int
#line 2549
ncx_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2549
{
#line 2549
	int status = ENOERR;
#line 2549
	schar *xp = (schar *)(*xpp);
#line 2549

#line 2549
	while(nelems-- != 0)
#line 2549
	{
#line 2549

#line 2549
		*tp++ = *xp++;
#line 2549
	}
#line 2549

#line 2549
	*xpp = (const void *)xp;
#line 2549
	return status;
#line 2549
}
#line 2549

int
#line 2550
ncx_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2550
{
#line 2550
	int status = ENOERR;
#line 2550
	schar *xp = (schar *)(*xpp);
#line 2550

#line 2550
	while(nelems-- != 0)
#line 2550
	{
#line 2550
		if (*xp < 0) status = NC_ERANGE;
#line 2550
		*tp++ = *xp++;
#line 2550
	}
#line 2550

#line 2550
	*xpp = (const void *)xp;
#line 2550
	return status;
#line 2550
}
#line 2550

int
#line 2551
ncx_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2551
{
#line 2551
	int status = ENOERR;
#line 2551
	schar *xp = (schar *)(*xpp);
#line 2551

#line 2551
	while(nelems-- != 0)
#line 2551
	{
#line 2551
		if (*xp < 0) status = NC_ERANGE;
#line 2551
		*tp++ = *xp++;
#line 2551
	}
#line 2551

#line 2551
	*xpp = (const void *)xp;
#line 2551
	return status;
#line 2551
}
#line 2551

int
#line 2552
ncx_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2552
{
#line 2552
	int status = ENOERR;
#line 2552
	schar *xp = (schar *)(*xpp);
#line 2552

#line 2552
	while(nelems-- != 0)
#line 2552
	{
#line 2552
		if (*xp < 0) status = NC_ERANGE;
#line 2552
		*tp++ = *xp++;
#line 2552
	}
#line 2552

#line 2552
	*xpp = (const void *)xp;
#line 2552
	return status;
#line 2552
}
#line 2552


#line 2555
int
ncx_pad_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2558

#line 2558
	if(rndup)
#line 2558
		rndup = X_ALIGN - rndup;
#line 2558

#line 2558
	(void) memcpy(tp, *xpp, nelems);
#line 2558
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2558

#line 2558
	return ENOERR;
#line 2558

}
#line 2561
int
ncx_pad_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2564

#line 2564
	if(rndup)
#line 2564
		rndup = X_ALIGN - rndup;
#line 2564

#line 2564
	(void) memcpy(tp, *xpp, nelems);
#line 2564
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2564

#line 2564
	return ENOERR;
#line 2564

}
int
#line 2566
ncx_pad_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2566
{
#line 2566
	int status = ENOERR;
#line 2566
	size_t rndup = nelems % X_ALIGN;
#line 2566
	schar *xp = (schar *) *xpp;
#line 2566

#line 2566
	if(rndup)
#line 2566
		rndup = X_ALIGN - rndup;
#line 2566

#line 2566
	while(nelems-- != 0)
#line 2566
	{
#line 2566

#line 2566
		*tp++ = *xp++;
#line 2566
	}
#line 2566

#line 2566
	*xpp = (void *)(xp + rndup);
#line 2566
	return status;
#line 2566
}
#line 2566

int
#line 2567
ncx_pad_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2567
{
#line 2567
	int status = ENOERR;
#line 2567
	size_t rndup = nelems % X_ALIGN;
#line 2567
	schar *xp = (schar *) *xpp;
#line 2567

#line 2567
	if(rndup)
#line 2567
		rndup = X_ALIGN - rndup;
#line 2567

#line 2567
	while(nelems-- != 0)
#line 2567
	{
#line 2567

#line 2567
		*tp++ = *xp++;
#line 2567
	}
#line 2567

#line 2567
	*xpp = (void *)(xp + rndup);
#line 2567
	return status;
#line 2567
}
#line 2567

int
#line 2568
ncx_pad_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2568
{
#line 2568
	int status = ENOERR;
#line 2568
	size_t rndup = nelems % X_ALIGN;
#line 2568
	schar *xp = (schar *) *xpp;
#line 2568

#line 2568
	if(rndup)
#line 2568
		rndup = X_ALIGN - rndup;
#line 2568

#line 2568
	while(nelems-- != 0)
#line 2568
	{
#line 2568

#line 2568
		*tp++ = *xp++;
#line 2568
	}
#line 2568

#line 2568
	*xpp = (void *)(xp + rndup);
#line 2568
	return status;
#line 2568
}
#line 2568

int
#line 2569
ncx_pad_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2569
{
#line 2569
	int status = ENOERR;
#line 2569
	size_t rndup = nelems % X_ALIGN;
#line 2569
	schar *xp = (schar *) *xpp;
#line 2569

#line 2569
	if(rndup)
#line 2569
		rndup = X_ALIGN - rndup;
#line 2569

#line 2569
	while(nelems-- != 0)
#line 2569
	{
#line 2569

#line 2569
		*tp++ = *xp++;
#line 2569
	}
#line 2569

#line 2569
	*xpp = (void *)(xp + rndup);
#line 2569
	return status;
#line 2569
}
#line 2569

int
#line 2570
ncx_pad_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2570
{
#line 2570
	int status = ENOERR;
#line 2570
	size_t rndup = nelems % X_ALIGN;
#line 2570
	schar *xp = (schar *) *xpp;
#line 2570

#line 2570
	if(rndup)
#line 2570
		rndup = X_ALIGN - rndup;
#line 2570

#line 2570
	while(nelems-- != 0)
#line 2570
	{
#line 2570

#line 2570
		*tp++ = *xp++;
#line 2570
	}
#line 2570

#line 2570
	*xpp = (void *)(xp + rndup);
#line 2570
	return status;
#line 2570
}
#line 2570

int
#line 2571
ncx_pad_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2571
{
#line 2571
	int status = ENOERR;
#line 2571
	size_t rndup = nelems % X_ALIGN;
#line 2571
	schar *xp = (schar *) *xpp;
#line 2571

#line 2571
	if(rndup)
#line 2571
		rndup = X_ALIGN - rndup;
#line 2571

#line 2571
	while(nelems-- != 0)
#line 2571
	{
#line 2571
		if (*xp < 0) status = NC_ERANGE;
#line 2571
		*tp++ = *xp++;
#line 2571
	}
#line 2571

#line 2571
	*xpp = (void *)(xp + rndup);
#line 2571
	return status;
#line 2571
}
#line 2571

int
#line 2572
ncx_pad_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2572
{
#line 2572
	int status = ENOERR;
#line 2572
	size_t rndup = nelems % X_ALIGN;
#line 2572
	schar *xp = (schar *) *xpp;
#line 2572

#line 2572
	if(rndup)
#line 2572
		rndup = X_ALIGN - rndup;
#line 2572

#line 2572
	while(nelems-- != 0)
#line 2572
	{
#line 2572
		if (*xp < 0) status = NC_ERANGE;
#line 2572
		*tp++ = *xp++;
#line 2572
	}
#line 2572

#line 2572
	*xpp = (void *)(xp + rndup);
#line 2572
	return status;
#line 2572
}
#line 2572

int
#line 2573
ncx_pad_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2573
{
#line 2573
	int status = ENOERR;
#line 2573
	size_t rndup = nelems % X_ALIGN;
#line 2573
	schar *xp = (schar *) *xpp;
#line 2573

#line 2573
	if(rndup)
#line 2573
		rndup = X_ALIGN - rndup;
#line 2573

#line 2573
	while(nelems-- != 0)
#line 2573
	{
#line 2573
		if (*xp < 0) status = NC_ERANGE;
#line 2573
		*tp++ = *xp++;
#line 2573
	}
#line 2573

#line 2573
	*xpp = (void *)(xp + rndup);
#line 2573
	return status;
#line 2573
}
#line 2573


#line 2576
int
ncx_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2579
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2579

#line 2579
	return ENOERR;
#line 2579

}
#line 2582
int
ncx_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2585
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2585

#line 2585
	return ENOERR;
#line 2585

}
int
#line 2587
ncx_putn_schar_short(void **xpp, size_t nelems, const short *tp)
#line 2587
{
#line 2587
	int status = ENOERR;
#line 2587
	schar *xp = (schar *) *xpp;
#line 2587

#line 2587
	while(nelems-- != 0)
#line 2587
	{
#line 2587
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2587
			status = NC_ERANGE;
#line 2587
		*xp++ = (schar) *tp++;
#line 2587
	}
#line 2587

#line 2587
	*xpp = (void *)xp;
#line 2587
	return status;
#line 2587
}
#line 2587

int
#line 2588
ncx_putn_schar_int(void **xpp, size_t nelems, const int *tp)
#line 2588
{
#line 2588
	int status = ENOERR;
#line 2588
	schar *xp = (schar *) *xpp;
#line 2588

#line 2588
	while(nelems-- != 0)
#line 2588
	{
#line 2588
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2588
			status = NC_ERANGE;
#line 2588
		*xp++ = (schar) *tp++;
#line 2588
	}
#line 2588

#line 2588
	*xpp = (void *)xp;
#line 2588
	return status;
#line 2588
}
#line 2588

int
#line 2589
ncx_putn_schar_float(void **xpp, size_t nelems, const float *tp)
#line 2589
{
#line 2589
	int status = ENOERR;
#line 2589
	schar *xp = (schar *) *xpp;
#line 2589

#line 2589
	while(nelems-- != 0)
#line 2589
	{
#line 2589
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2589
			status = NC_ERANGE;
#line 2589
		*xp++ = (schar) *tp++;
#line 2589
	}
#line 2589

#line 2589
	*xpp = (void *)xp;
#line 2589
	return status;
#line 2589
}
#line 2589

int
#line 2590
ncx_putn_schar_double(void **xpp, size_t nelems, const double *tp)
#line 2590
{
#line 2590
	int status = ENOERR;
#line 2590
	schar *xp = (schar *) *xpp;
#line 2590

#line 2590
	while(nelems-- != 0)
#line 2590
	{
#line 2590
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2590
			status = NC_ERANGE;
#line 2590
		*xp++ = (schar) *tp++;
#line 2590
	}
#line 2590

#line 2590
	*xpp = (void *)xp;
#line 2590
	return status;
#line 2590
}
#line 2590

int
#line 2591
ncx_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2591
{
#line 2591
	int status = ENOERR;
#line 2591
	schar *xp = (schar *) *xpp;
#line 2591

#line 2591
	while(nelems-- != 0)
#line 2591
	{
#line 2591
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2591
			status = NC_ERANGE;
#line 2591
		*xp++ = (schar) *tp++;
#line 2591
	}
#line 2591

#line 2591
	*xpp = (void *)xp;
#line 2591
	return status;
#line 2591
}
#line 2591

int
#line 2592
ncx_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2592
{
#line 2592
	int status = ENOERR;
#line 2592
	schar *xp = (schar *) *xpp;
#line 2592

#line 2592
	while(nelems-- != 0)
#line 2592
	{
#line 2592
		if(*tp > X_SCHAR_MAX )
#line 2592
			status = NC_ERANGE;
#line 2592
		*xp++ = (schar) *tp++;
#line 2592
	}
#line 2592

#line 2592
	*xpp = (void *)xp;
#line 2592
	return status;
#line 2592
}
#line 2592

int
#line 2593
ncx_putn_schar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2593
{
#line 2593
	int status = ENOERR;
#line 2593
	schar *xp = (schar *) *xpp;
#line 2593

#line 2593
	while(nelems-- != 0)
#line 2593
	{
#line 2593
		if(*tp > X_SCHAR_MAX )
#line 2593
			status = NC_ERANGE;
#line 2593
		*xp++ = (schar) *tp++;
#line 2593
	}
#line 2593

#line 2593
	*xpp = (void *)xp;
#line 2593
	return status;
#line 2593
}
#line 2593

int
#line 2594
ncx_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2594
{
#line 2594
	int status = ENOERR;
#line 2594
	schar *xp = (schar *) *xpp;
#line 2594

#line 2594
	while(nelems-- != 0)
#line 2594
	{
#line 2594
		if(*tp > X_SCHAR_MAX )
#line 2594
			status = NC_ERANGE;
#line 2594
		*xp++ = (schar) *tp++;
#line 2594
	}
#line 2594

#line 2594
	*xpp = (void *)xp;
#line 2594
	return status;
#line 2594
}
#line 2594


#line 2597
int
ncx_pad_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2600

#line 2600
	if(rndup)
#line 2600
		rndup = X_ALIGN - rndup;
#line 2600

#line 2600
	(void) memcpy(*xpp, tp, nelems);
#line 2600
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2600

#line 2600
	if(rndup)
#line 2600
	{
#line 2600
		(void) memcpy(*xpp, nada, rndup);
#line 2600
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2600
	}
#line 2600
	
#line 2600
	return ENOERR;
#line 2600

}
#line 2603
int
ncx_pad_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2606

#line 2606
	if(rndup)
#line 2606
		rndup = X_ALIGN - rndup;
#line 2606

#line 2606
	(void) memcpy(*xpp, tp, nelems);
#line 2606
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2606

#line 2606
	if(rndup)
#line 2606
	{
#line 2606
		(void) memcpy(*xpp, nada, rndup);
#line 2606
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2606
	}
#line 2606
	
#line 2606
	return ENOERR;
#line 2606

}
int
#line 2608
ncx_pad_putn_schar_short(void **xpp, size_t nelems, const short *tp)
#line 2608
{
#line 2608
	int status = ENOERR;
#line 2608
	size_t rndup = nelems % X_ALIGN;
#line 2608
	schar *xp = (schar *) *xpp;
#line 2608

#line 2608
	if(rndup)
#line 2608
		rndup = X_ALIGN - rndup;
#line 2608

#line 2608
	while(nelems-- != 0)
#line 2608
	{
#line 2608
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2608
			status = NC_ERANGE;
#line 2608
		*xp++ = (schar) *tp++;
#line 2608
	}
#line 2608

#line 2608

#line 2608
	if(rndup)
#line 2608
	{
#line 2608
		(void) memcpy(xp, nada, rndup);
#line 2608
		xp += rndup;
#line 2608
	}
#line 2608

#line 2608
	*xpp = (void *)xp;
#line 2608
	return status;
#line 2608
}
#line 2608

int
#line 2609
ncx_pad_putn_schar_int(void **xpp, size_t nelems, const int *tp)
#line 2609
{
#line 2609
	int status = ENOERR;
#line 2609
	size_t rndup = nelems % X_ALIGN;
#line 2609
	schar *xp = (schar *) *xpp;
#line 2609

#line 2609
	if(rndup)
#line 2609
		rndup = X_ALIGN - rndup;
#line 2609

#line 2609
	while(nelems-- != 0)
#line 2609
	{
#line 2609
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2609
			status = NC_ERANGE;
#line 2609
		*xp++ = (schar) *tp++;
#line 2609
	}
#line 2609

#line 2609

#line 2609
	if(rndup)
#line 2609
	{
#line 2609
		(void) memcpy(xp, nada, rndup);
#line 2609
		xp += rndup;
#line 2609
	}
#line 2609

#line 2609
	*xpp = (void *)xp;
#line 2609
	return status;
#line 2609
}
#line 2609

int
#line 2610
ncx_pad_putn_schar_float(void **xpp, size_t nelems, const float *tp)
#line 2610
{
#line 2610
	int status = ENOERR;
#line 2610
	size_t rndup = nelems % X_ALIGN;
#line 2610
	schar *xp = (schar *) *xpp;
#line 2610

#line 2610
	if(rndup)
#line 2610
		rndup = X_ALIGN - rndup;
#line 2610

#line 2610
	while(nelems-- != 0)
#line 2610
	{
#line 2610
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2610
			status = NC_ERANGE;
#line 2610
		*xp++ = (schar) *tp++;
#line 2610
	}
#line 2610

#line 2610

#line 2610
	if(rndup)
#line 2610
	{
#line 2610
		(void) memcpy(xp, nada, rndup);
#line 2610
		xp += rndup;
#line 2610
	}
#line 2610

#line 2610
	*xpp = (void *)xp;
#line 2610
	return status;
#line 2610
}
#line 2610

int
#line 2611
ncx_pad_putn_schar_double(void **xpp, size_t nelems, const double *tp)
#line 2611
{
#line 2611
	int status = ENOERR;
#line 2611
	size_t rndup = nelems % X_ALIGN;
#line 2611
	schar *xp = (schar *) *xpp;
#line 2611

#line 2611
	if(rndup)
#line 2611
		rndup = X_ALIGN - rndup;
#line 2611

#line 2611
	while(nelems-- != 0)
#line 2611
	{
#line 2611
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2611
			status = NC_ERANGE;
#line 2611
		*xp++ = (schar) *tp++;
#line 2611
	}
#line 2611

#line 2611

#line 2611
	if(rndup)
#line 2611
	{
#line 2611
		(void) memcpy(xp, nada, rndup);
#line 2611
		xp += rndup;
#line 2611
	}
#line 2611

#line 2611
	*xpp = (void *)xp;
#line 2611
	return status;
#line 2611
}
#line 2611

int
#line 2612
ncx_pad_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2612
{
#line 2612
	int status = ENOERR;
#line 2612
	size_t rndup = nelems % X_ALIGN;
#line 2612
	schar *xp = (schar *) *xpp;
#line 2612

#line 2612
	if(rndup)
#line 2612
		rndup = X_ALIGN - rndup;
#line 2612

#line 2612
	while(nelems-- != 0)
#line 2612
	{
#line 2612
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2612
			status = NC_ERANGE;
#line 2612
		*xp++ = (schar) *tp++;
#line 2612
	}
#line 2612

#line 2612

#line 2612
	if(rndup)
#line 2612
	{
#line 2612
		(void) memcpy(xp, nada, rndup);
#line 2612
		xp += rndup;
#line 2612
	}
#line 2612

#line 2612
	*xpp = (void *)xp;
#line 2612
	return status;
#line 2612
}
#line 2612

int
#line 2613
ncx_pad_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2613
{
#line 2613
	int status = ENOERR;
#line 2613
	size_t rndup = nelems % X_ALIGN;
#line 2613
	schar *xp = (schar *) *xpp;
#line 2613

#line 2613
	if(rndup)
#line 2613
		rndup = X_ALIGN - rndup;
#line 2613

#line 2613
	while(nelems-- != 0)
#line 2613
	{
#line 2613
		if(*tp > X_SCHAR_MAX )
#line 2613
			status = NC_ERANGE;
#line 2613
		*xp++ = (schar) *tp++;
#line 2613
	}
#line 2613

#line 2613

#line 2613
	if(rndup)
#line 2613
	{
#line 2613
		(void) memcpy(xp, nada, rndup);
#line 2613
		xp += rndup;
#line 2613
	}
#line 2613

#line 2613
	*xpp = (void *)xp;
#line 2613
	return status;
#line 2613
}
#line 2613

int
#line 2614
ncx_pad_putn_schar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2614
{
#line 2614
	int status = ENOERR;
#line 2614
	size_t rndup = nelems % X_ALIGN;
#line 2614
	schar *xp = (schar *) *xpp;
#line 2614

#line 2614
	if(rndup)
#line 2614
		rndup = X_ALIGN - rndup;
#line 2614

#line 2614
	while(nelems-- != 0)
#line 2614
	{
#line 2614
		if(*tp > X_SCHAR_MAX )
#line 2614
			status = NC_ERANGE;
#line 2614
		*xp++ = (schar) *tp++;
#line 2614
	}
#line 2614

#line 2614

#line 2614
	if(rndup)
#line 2614
	{
#line 2614
		(void) memcpy(xp, nada, rndup);
#line 2614
		xp += rndup;
#line 2614
	}
#line 2614

#line 2614
	*xpp = (void *)xp;
#line 2614
	return status;
#line 2614
}
#line 2614

int
#line 2615
ncx_pad_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2615
{
#line 2615
	int status = ENOERR;
#line 2615
	size_t rndup = nelems % X_ALIGN;
#line 2615
	schar *xp = (schar *) *xpp;
#line 2615

#line 2615
	if(rndup)
#line 2615
		rndup = X_ALIGN - rndup;
#line 2615

#line 2615
	while(nelems-- != 0)
#line 2615
	{
#line 2615
		if(*tp > X_SCHAR_MAX )
#line 2615
			status = NC_ERANGE;
#line 2615
		*xp++ = (schar) *tp++;
#line 2615
	}
#line 2615

#line 2615

#line 2615
	if(rndup)
#line 2615
	{
#line 2615
		(void) memcpy(xp, nada, rndup);
#line 2615
		xp += rndup;
#line 2615
	}
#line 2615

#line 2615
	*xpp = (void *)xp;
#line 2615
	return status;
#line 2615
}
#line 2615



/* uchar ---------------------------------------------------------------------*/
#line 2621
int
ncx_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2624
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2624
	return ENOERR;
#line 2624

}
#line 2627
int
ncx_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2630
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2630
	return ENOERR;
#line 2630

}
int
#line 2632
ncx_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2632
{
#line 2632
	int status = ENOERR;
#line 2632
	uchar *xp = (uchar *)(*xpp);
#line 2632

#line 2632
	while(nelems-- != 0)
#line 2632
	{
#line 2632

#line 2632
		*tp++ = *xp++;
#line 2632
	}
#line 2632

#line 2632
	*xpp = (const void *)xp;
#line 2632
	return status;
#line 2632
}
#line 2632

int
#line 2633
ncx_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2633
{
#line 2633
	int status = ENOERR;
#line 2633
	uchar *xp = (uchar *)(*xpp);
#line 2633

#line 2633
	while(nelems-- != 0)
#line 2633
	{
#line 2633

#line 2633
		*tp++ = *xp++;
#line 2633
	}
#line 2633

#line 2633
	*xpp = (const void *)xp;
#line 2633
	return status;
#line 2633
}
#line 2633

int
#line 2634
ncx_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2634
{
#line 2634
	int status = ENOERR;
#line 2634
	uchar *xp = (uchar *)(*xpp);
#line 2634

#line 2634
	while(nelems-- != 0)
#line 2634
	{
#line 2634

#line 2634
		*tp++ = *xp++;
#line 2634
	}
#line 2634

#line 2634
	*xpp = (const void *)xp;
#line 2634
	return status;
#line 2634
}
#line 2634

int
#line 2635
ncx_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2635
{
#line 2635
	int status = ENOERR;
#line 2635
	uchar *xp = (uchar *)(*xpp);
#line 2635

#line 2635
	while(nelems-- != 0)
#line 2635
	{
#line 2635

#line 2635
		*tp++ = *xp++;
#line 2635
	}
#line 2635

#line 2635
	*xpp = (const void *)xp;
#line 2635
	return status;
#line 2635
}
#line 2635

int
#line 2636
ncx_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2636
{
#line 2636
	int status = ENOERR;
#line 2636
	uchar *xp = (uchar *)(*xpp);
#line 2636

#line 2636
	while(nelems-- != 0)
#line 2636
	{
#line 2636

#line 2636
		*tp++ = *xp++;
#line 2636
	}
#line 2636

#line 2636
	*xpp = (const void *)xp;
#line 2636
	return status;
#line 2636
}
#line 2636

int
#line 2637
ncx_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2637
{
#line 2637
	int status = ENOERR;
#line 2637
	uchar *xp = (uchar *)(*xpp);
#line 2637

#line 2637
	while(nelems-- != 0)
#line 2637
	{
#line 2637

#line 2637
		*tp++ = *xp++;
#line 2637
	}
#line 2637

#line 2637
	*xpp = (const void *)xp;
#line 2637
	return status;
#line 2637
}
#line 2637

int
#line 2638
ncx_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2638
{
#line 2638
	int status = ENOERR;
#line 2638
	uchar *xp = (uchar *)(*xpp);
#line 2638

#line 2638
	while(nelems-- != 0)
#line 2638
	{
#line 2638

#line 2638
		*tp++ = *xp++;
#line 2638
	}
#line 2638

#line 2638
	*xpp = (const void *)xp;
#line 2638
	return status;
#line 2638
}
#line 2638

int
#line 2639
ncx_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2639
{
#line 2639
	int status = ENOERR;
#line 2639
	uchar *xp = (uchar *)(*xpp);
#line 2639

#line 2639
	while(nelems-- != 0)
#line 2639
	{
#line 2639

#line 2639
		*tp++ = *xp++;
#line 2639
	}
#line 2639

#line 2639
	*xpp = (const void *)xp;
#line 2639
	return status;
#line 2639
}
#line 2639


#line 2642
int
ncx_pad_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2645

#line 2645
	if(rndup)
#line 2645
		rndup = X_ALIGN - rndup;
#line 2645

#line 2645
	(void) memcpy(tp, *xpp, nelems);
#line 2645
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2645

#line 2645
	return ENOERR;
#line 2645

}
#line 2648
int
ncx_pad_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2651

#line 2651
	if(rndup)
#line 2651
		rndup = X_ALIGN - rndup;
#line 2651

#line 2651
	(void) memcpy(tp, *xpp, nelems);
#line 2651
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2651

#line 2651
	return ENOERR;
#line 2651

}
int
#line 2653
ncx_pad_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2653
{
#line 2653
	int status = ENOERR;
#line 2653
	size_t rndup = nelems % X_ALIGN;
#line 2653
	uchar *xp = (uchar *) *xpp;
#line 2653

#line 2653
	if(rndup)
#line 2653
		rndup = X_ALIGN - rndup;
#line 2653

#line 2653
	while(nelems-- != 0)
#line 2653
	{
#line 2653

#line 2653
		*tp++ = *xp++;
#line 2653
	}
#line 2653

#line 2653
	*xpp = (void *)(xp + rndup);
#line 2653
	return status;
#line 2653
}
#line 2653

int
#line 2654
ncx_pad_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2654
{
#line 2654
	int status = ENOERR;
#line 2654
	size_t rndup = nelems % X_ALIGN;
#line 2654
	uchar *xp = (uchar *) *xpp;
#line 2654

#line 2654
	if(rndup)
#line 2654
		rndup = X_ALIGN - rndup;
#line 2654

#line 2654
	while(nelems-- != 0)
#line 2654
	{
#line 2654

#line 2654
		*tp++ = *xp++;
#line 2654
	}
#line 2654

#line 2654
	*xpp = (void *)(xp + rndup);
#line 2654
	return status;
#line 2654
}
#line 2654

int
#line 2655
ncx_pad_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2655
{
#line 2655
	int status = ENOERR;
#line 2655
	size_t rndup = nelems % X_ALIGN;
#line 2655
	uchar *xp = (uchar *) *xpp;
#line 2655

#line 2655
	if(rndup)
#line 2655
		rndup = X_ALIGN - rndup;
#line 2655

#line 2655
	while(nelems-- != 0)
#line 2655
	{
#line 2655

#line 2655
		*tp++ = *xp++;
#line 2655
	}
#line 2655

#line 2655
	*xpp = (void *)(xp + rndup);
#line 2655
	return status;
#line 2655
}
#line 2655

int
#line 2656
ncx_pad_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2656
{
#line 2656
	int status = ENOERR;
#line 2656
	size_t rndup = nelems % X_ALIGN;
#line 2656
	uchar *xp = (uchar *) *xpp;
#line 2656

#line 2656
	if(rndup)
#line 2656
		rndup = X_ALIGN - rndup;
#line 2656

#line 2656
	while(nelems-- != 0)
#line 2656
	{
#line 2656

#line 2656
		*tp++ = *xp++;
#line 2656
	}
#line 2656

#line 2656
	*xpp = (void *)(xp + rndup);
#line 2656
	return status;
#line 2656
}
#line 2656

int
#line 2657
ncx_pad_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2657
{
#line 2657
	int status = ENOERR;
#line 2657
	size_t rndup = nelems % X_ALIGN;
#line 2657
	uchar *xp = (uchar *) *xpp;
#line 2657

#line 2657
	if(rndup)
#line 2657
		rndup = X_ALIGN - rndup;
#line 2657

#line 2657
	while(nelems-- != 0)
#line 2657
	{
#line 2657

#line 2657
		*tp++ = *xp++;
#line 2657
	}
#line 2657

#line 2657
	*xpp = (void *)(xp + rndup);
#line 2657
	return status;
#line 2657
}
#line 2657

int
#line 2658
ncx_pad_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2658
{
#line 2658
	int status = ENOERR;
#line 2658
	size_t rndup = nelems % X_ALIGN;
#line 2658
	uchar *xp = (uchar *) *xpp;
#line 2658

#line 2658
	if(rndup)
#line 2658
		rndup = X_ALIGN - rndup;
#line 2658

#line 2658
	while(nelems-- != 0)
#line 2658
	{
#line 2658

#line 2658
		*tp++ = *xp++;
#line 2658
	}
#line 2658

#line 2658
	*xpp = (void *)(xp + rndup);
#line 2658
	return status;
#line 2658
}
#line 2658

int
#line 2659
ncx_pad_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2659
{
#line 2659
	int status = ENOERR;
#line 2659
	size_t rndup = nelems % X_ALIGN;
#line 2659
	uchar *xp = (uchar *) *xpp;
#line 2659

#line 2659
	if(rndup)
#line 2659
		rndup = X_ALIGN - rndup;
#line 2659

#line 2659
	while(nelems-- != 0)
#line 2659
	{
#line 2659

#line 2659
		*tp++ = *xp++;
#line 2659
	}
#line 2659

#line 2659
	*xpp = (void *)(xp + rndup);
#line 2659
	return status;
#line 2659
}
#line 2659

int
#line 2660
ncx_pad_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2660
{
#line 2660
	int status = ENOERR;
#line 2660
	size_t rndup = nelems % X_ALIGN;
#line 2660
	uchar *xp = (uchar *) *xpp;
#line 2660

#line 2660
	if(rndup)
#line 2660
		rndup = X_ALIGN - rndup;
#line 2660

#line 2660
	while(nelems-- != 0)
#line 2660
	{
#line 2660

#line 2660
		*tp++ = *xp++;
#line 2660
	}
#line 2660

#line 2660
	*xpp = (void *)(xp + rndup);
#line 2660
	return status;
#line 2660
}
#line 2660


#line 2663
int
ncx_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2666
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2666

#line 2666
	return ENOERR;
#line 2666

}
#line 2669
int
ncx_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2672
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2672

#line 2672
	return ENOERR;
#line 2672

}
int
#line 2674
ncx_putn_uchar_short(void **xpp, size_t nelems, const short *tp)
#line 2674
{
#line 2674
	int status = ENOERR;
#line 2674
	uchar *xp = (uchar *) *xpp;
#line 2674

#line 2674
	while(nelems-- != 0)
#line 2674
	{
#line 2674
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2674
			status = NC_ERANGE;
#line 2674
		*xp++ = (uchar) *tp++;
#line 2674
	}
#line 2674

#line 2674
	*xpp = (void *)xp;
#line 2674
	return status;
#line 2674
}
#line 2674

int
#line 2675
ncx_putn_uchar_int(void **xpp, size_t nelems, const int *tp)
#line 2675
{
#line 2675
	int status = ENOERR;
#line 2675
	uchar *xp = (uchar *) *xpp;
#line 2675

#line 2675
	while(nelems-- != 0)
#line 2675
	{
#line 2675
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2675
			status = NC_ERANGE;
#line 2675
		*xp++ = (uchar) *tp++;
#line 2675
	}
#line 2675

#line 2675
	*xpp = (void *)xp;
#line 2675
	return status;
#line 2675
}
#line 2675

int
#line 2676
ncx_putn_uchar_float(void **xpp, size_t nelems, const float *tp)
#line 2676
{
#line 2676
	int status = ENOERR;
#line 2676
	uchar *xp = (uchar *) *xpp;
#line 2676

#line 2676
	while(nelems-- != 0)
#line 2676
	{
#line 2676
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2676
			status = NC_ERANGE;
#line 2676
		*xp++ = (uchar) *tp++;
#line 2676
	}
#line 2676

#line 2676
	*xpp = (void *)xp;
#line 2676
	return status;
#line 2676
}
#line 2676

int
#line 2677
ncx_putn_uchar_double(void **xpp, size_t nelems, const double *tp)
#line 2677
{
#line 2677
	int status = ENOERR;
#line 2677
	uchar *xp = (uchar *) *xpp;
#line 2677

#line 2677
	while(nelems-- != 0)
#line 2677
	{
#line 2677
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2677
			status = NC_ERANGE;
#line 2677
		*xp++ = (uchar) *tp++;
#line 2677
	}
#line 2677

#line 2677
	*xpp = (void *)xp;
#line 2677
	return status;
#line 2677
}
#line 2677

int
#line 2678
ncx_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2678
{
#line 2678
	int status = ENOERR;
#line 2678
	uchar *xp = (uchar *) *xpp;
#line 2678

#line 2678
	while(nelems-- != 0)
#line 2678
	{
#line 2678
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2678
			status = NC_ERANGE;
#line 2678
		*xp++ = (uchar) *tp++;
#line 2678
	}
#line 2678

#line 2678
	*xpp = (void *)xp;
#line 2678
	return status;
#line 2678
}
#line 2678

int
#line 2679
ncx_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2679
{
#line 2679
	int status = ENOERR;
#line 2679
	uchar *xp = (uchar *) *xpp;
#line 2679

#line 2679
	while(nelems-- != 0)
#line 2679
	{
#line 2679
		if(*tp > X_UCHAR_MAX )
#line 2679
			status = NC_ERANGE;
#line 2679
		*xp++ = (uchar) *tp++;
#line 2679
	}
#line 2679

#line 2679
	*xpp = (void *)xp;
#line 2679
	return status;
#line 2679
}
#line 2679

int
#line 2680
ncx_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2680
{
#line 2680
	int status = ENOERR;
#line 2680
	uchar *xp = (uchar *) *xpp;
#line 2680

#line 2680
	while(nelems-- != 0)
#line 2680
	{
#line 2680
		if(*tp > X_UCHAR_MAX )
#line 2680
			status = NC_ERANGE;
#line 2680
		*xp++ = (uchar) *tp++;
#line 2680
	}
#line 2680

#line 2680
	*xpp = (void *)xp;
#line 2680
	return status;
#line 2680
}
#line 2680

int
#line 2681
ncx_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2681
{
#line 2681
	int status = ENOERR;
#line 2681
	uchar *xp = (uchar *) *xpp;
#line 2681

#line 2681
	while(nelems-- != 0)
#line 2681
	{
#line 2681
		if(*tp > X_UCHAR_MAX )
#line 2681
			status = NC_ERANGE;
#line 2681
		*xp++ = (uchar) *tp++;
#line 2681
	}
#line 2681

#line 2681
	*xpp = (void *)xp;
#line 2681
	return status;
#line 2681
}
#line 2681


#line 2684
int
ncx_pad_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2687

#line 2687
	if(rndup)
#line 2687
		rndup = X_ALIGN - rndup;
#line 2687

#line 2687
	(void) memcpy(*xpp, tp, nelems);
#line 2687
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2687

#line 2687
	if(rndup)
#line 2687
	{
#line 2687
		(void) memcpy(*xpp, nada, rndup);
#line 2687
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2687
	}
#line 2687
	
#line 2687
	return ENOERR;
#line 2687

}
#line 2690
int
ncx_pad_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2693

#line 2693
	if(rndup)
#line 2693
		rndup = X_ALIGN - rndup;
#line 2693

#line 2693
	(void) memcpy(*xpp, tp, nelems);
#line 2693
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2693

#line 2693
	if(rndup)
#line 2693
	{
#line 2693
		(void) memcpy(*xpp, nada, rndup);
#line 2693
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2693
	}
#line 2693
	
#line 2693
	return ENOERR;
#line 2693

}
int
#line 2695
ncx_pad_putn_uchar_short(void **xpp, size_t nelems, const short *tp)
#line 2695
{
#line 2695
	int status = ENOERR;
#line 2695
	size_t rndup = nelems % X_ALIGN;
#line 2695
	uchar *xp = (uchar *) *xpp;
#line 2695

#line 2695
	if(rndup)
#line 2695
		rndup = X_ALIGN - rndup;
#line 2695

#line 2695
	while(nelems-- != 0)
#line 2695
	{
#line 2695
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2695
			status = NC_ERANGE;
#line 2695
		*xp++ = (uchar) *tp++;
#line 2695
	}
#line 2695

#line 2695

#line 2695
	if(rndup)
#line 2695
	{
#line 2695
		(void) memcpy(xp, nada, rndup);
#line 2695
		xp += rndup;
#line 2695
	}
#line 2695

#line 2695
	*xpp = (void *)xp;
#line 2695
	return status;
#line 2695
}
#line 2695

int
#line 2696
ncx_pad_putn_uchar_int(void **xpp, size_t nelems, const int *tp)
#line 2696
{
#line 2696
	int status = ENOERR;
#line 2696
	size_t rndup = nelems % X_ALIGN;
#line 2696
	uchar *xp = (uchar *) *xpp;
#line 2696

#line 2696
	if(rndup)
#line 2696
		rndup = X_ALIGN - rndup;
#line 2696

#line 2696
	while(nelems-- != 0)
#line 2696
	{
#line 2696
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2696
			status = NC_ERANGE;
#line 2696
		*xp++ = (uchar) *tp++;
#line 2696
	}
#line 2696

#line 2696

#line 2696
	if(rndup)
#line 2696
	{
#line 2696
		(void) memcpy(xp, nada, rndup);
#line 2696
		xp += rndup;
#line 2696
	}
#line 2696

#line 2696
	*xpp = (void *)xp;
#line 2696
	return status;
#line 2696
}
#line 2696

int
#line 2697
ncx_pad_putn_uchar_float(void **xpp, size_t nelems, const float *tp)
#line 2697
{
#line 2697
	int status = ENOERR;
#line 2697
	size_t rndup = nelems % X_ALIGN;
#line 2697
	uchar *xp = (uchar *) *xpp;
#line 2697

#line 2697
	if(rndup)
#line 2697
		rndup = X_ALIGN - rndup;
#line 2697

#line 2697
	while(nelems-- != 0)
#line 2697
	{
#line 2697
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2697
			status = NC_ERANGE;
#line 2697
		*xp++ = (uchar) *tp++;
#line 2697
	}
#line 2697

#line 2697

#line 2697
	if(rndup)
#line 2697
	{
#line 2697
		(void) memcpy(xp, nada, rndup);
#line 2697
		xp += rndup;
#line 2697
	}
#line 2697

#line 2697
	*xpp = (void *)xp;
#line 2697
	return status;
#line 2697
}
#line 2697

int
#line 2698
ncx_pad_putn_uchar_double(void **xpp, size_t nelems, const double *tp)
#line 2698
{
#line 2698
	int status = ENOERR;
#line 2698
	size_t rndup = nelems % X_ALIGN;
#line 2698
	uchar *xp = (uchar *) *xpp;
#line 2698

#line 2698
	if(rndup)
#line 2698
		rndup = X_ALIGN - rndup;
#line 2698

#line 2698
	while(nelems-- != 0)
#line 2698
	{
#line 2698
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2698
			status = NC_ERANGE;
#line 2698
		*xp++ = (uchar) *tp++;
#line 2698
	}
#line 2698

#line 2698

#line 2698
	if(rndup)
#line 2698
	{
#line 2698
		(void) memcpy(xp, nada, rndup);
#line 2698
		xp += rndup;
#line 2698
	}
#line 2698

#line 2698
	*xpp = (void *)xp;
#line 2698
	return status;
#line 2698
}
#line 2698

int
#line 2699
ncx_pad_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2699
{
#line 2699
	int status = ENOERR;
#line 2699
	size_t rndup = nelems % X_ALIGN;
#line 2699
	uchar *xp = (uchar *) *xpp;
#line 2699

#line 2699
	if(rndup)
#line 2699
		rndup = X_ALIGN - rndup;
#line 2699

#line 2699
	while(nelems-- != 0)
#line 2699
	{
#line 2699
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2699
			status = NC_ERANGE;
#line 2699
		*xp++ = (uchar) *tp++;
#line 2699
	}
#line 2699

#line 2699

#line 2699
	if(rndup)
#line 2699
	{
#line 2699
		(void) memcpy(xp, nada, rndup);
#line 2699
		xp += rndup;
#line 2699
	}
#line 2699

#line 2699
	*xpp = (void *)xp;
#line 2699
	return status;
#line 2699
}
#line 2699

int
#line 2700
ncx_pad_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2700
{
#line 2700
	int status = ENOERR;
#line 2700
	size_t rndup = nelems % X_ALIGN;
#line 2700
	uchar *xp = (uchar *) *xpp;
#line 2700

#line 2700
	if(rndup)
#line 2700
		rndup = X_ALIGN - rndup;
#line 2700

#line 2700
	while(nelems-- != 0)
#line 2700
	{
#line 2700
		if(*tp > X_UCHAR_MAX )
#line 2700
			status = NC_ERANGE;
#line 2700
		*xp++ = (uchar) *tp++;
#line 2700
	}
#line 2700

#line 2700

#line 2700
	if(rndup)
#line 2700
	{
#line 2700
		(void) memcpy(xp, nada, rndup);
#line 2700
		xp += rndup;
#line 2700
	}
#line 2700

#line 2700
	*xpp = (void *)xp;
#line 2700
	return status;
#line 2700
}
#line 2700

int
#line 2701
ncx_pad_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2701
{
#line 2701
	int status = ENOERR;
#line 2701
	size_t rndup = nelems % X_ALIGN;
#line 2701
	uchar *xp = (uchar *) *xpp;
#line 2701

#line 2701
	if(rndup)
#line 2701
		rndup = X_ALIGN - rndup;
#line 2701

#line 2701
	while(nelems-- != 0)
#line 2701
	{
#line 2701
		if(*tp > X_UCHAR_MAX )
#line 2701
			status = NC_ERANGE;
#line 2701
		*xp++ = (uchar) *tp++;
#line 2701
	}
#line 2701

#line 2701

#line 2701
	if(rndup)
#line 2701
	{
#line 2701
		(void) memcpy(xp, nada, rndup);
#line 2701
		xp += rndup;
#line 2701
	}
#line 2701

#line 2701
	*xpp = (void *)xp;
#line 2701
	return status;
#line 2701
}
#line 2701

int
#line 2702
ncx_pad_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2702
{
#line 2702
	int status = ENOERR;
#line 2702
	size_t rndup = nelems % X_ALIGN;
#line 2702
	uchar *xp = (uchar *) *xpp;
#line 2702

#line 2702
	if(rndup)
#line 2702
		rndup = X_ALIGN - rndup;
#line 2702

#line 2702
	while(nelems-- != 0)
#line 2702
	{
#line 2702
		if(*tp > X_UCHAR_MAX )
#line 2702
			status = NC_ERANGE;
#line 2702
		*xp++ = (uchar) *tp++;
#line 2702
	}
#line 2702

#line 2702

#line 2702
	if(rndup)
#line 2702
	{
#line 2702
		(void) memcpy(xp, nada, rndup);
#line 2702
		xp += rndup;
#line 2702
	}
#line 2702

#line 2702
	*xpp = (void *)xp;
#line 2702
	return status;
#line 2702
}
#line 2702


/* short ---------------------------------------------------------------------*/

#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(short));
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return ENOERR;
}
#else
int
#line 2720
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 2720
{
#line 2720
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2720

#line 2720
 /* basic algorithm is:
#line 2720
  *   - ensure sane alignment of input data
#line 2720
  *   - copy (conversion happens automatically) input data
#line 2720
  *     to output
#line 2720
  *   - update xpp to point at next unconverted input, and tp to point
#line 2720
  *     at next location for converted output
#line 2720
  */
#line 2720
  long i, j, ni;
#line 2720
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2720
  short *xp;
#line 2720
  int nrange = 0;         /* number of range errors */
#line 2720
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2720
  long cxp = (long) *((char**)xpp);
#line 2720

#line 2720
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2720
  /* sjl: manually stripmine so we can limit amount of
#line 2720
   * vector work space reserved to LOOPCNT elements. Also
#line 2720
   * makes vectorisation easy */
#line 2720
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2720
    ni=Min(nelems-j,LOOPCNT);
#line 2720
    if (realign) {
#line 2720
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2720
      xp = tmp;
#line 2720
    } else {
#line 2720
      xp = (short *) *xpp;
#line 2720
    }
#line 2720
   /* copy the next block */
#line 2720
#pragma cdir loopcnt=LOOPCNT
#line 2720
#pragma cdir shortloop
#line 2720
    for (i=0; i<ni; i++) {
#line 2720
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2720
     /* test for range errors (not always needed but do it anyway) */
#line 2720
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2720
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2720
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 2720
    }
#line 2720
   /* update xpp and tp */
#line 2720
    if (realign) xp = (short *) *xpp;
#line 2720
    xp += ni;
#line 2720
    tp += ni;
#line 2720
    *xpp = (void*)xp;
#line 2720
  }
#line 2720
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2720

#line 2720
#else   /* not SX */
#line 2720
	const char *xp = (const char *) *xpp;
#line 2720
	int status = ENOERR;
#line 2720

#line 2720
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2720
	{
#line 2720
		const int lstatus = ncx_get_short_short(xp, tp);
#line 2720
		if(lstatus != ENOERR)
#line 2720
			status = lstatus;
#line 2720
	}
#line 2720

#line 2720
	*xpp = (const void *)xp;
#line 2720
	return status;
#line 2720
#  endif
#line 2720
}
#line 2720

#endif
int
#line 2722
ncx_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 2722
{
#line 2722
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2722

#line 2722
 /* basic algorithm is:
#line 2722
  *   - ensure sane alignment of input data
#line 2722
  *   - copy (conversion happens automatically) input data
#line 2722
  *     to output
#line 2722
  *   - update xpp to point at next unconverted input, and tp to point
#line 2722
  *     at next location for converted output
#line 2722
  */
#line 2722
  long i, j, ni;
#line 2722
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2722
  short *xp;
#line 2722
  int nrange = 0;         /* number of range errors */
#line 2722
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2722
  long cxp = (long) *((char**)xpp);
#line 2722

#line 2722
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2722
  /* sjl: manually stripmine so we can limit amount of
#line 2722
   * vector work space reserved to LOOPCNT elements. Also
#line 2722
   * makes vectorisation easy */
#line 2722
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2722
    ni=Min(nelems-j,LOOPCNT);
#line 2722
    if (realign) {
#line 2722
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2722
      xp = tmp;
#line 2722
    } else {
#line 2722
      xp = (short *) *xpp;
#line 2722
    }
#line 2722
   /* copy the next block */
#line 2722
#pragma cdir loopcnt=LOOPCNT
#line 2722
#pragma cdir shortloop
#line 2722
    for (i=0; i<ni; i++) {
#line 2722
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2722
     /* test for range errors (not always needed but do it anyway) */
#line 2722
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2722
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2722
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 2722
    }
#line 2722
   /* update xpp and tp */
#line 2722
    if (realign) xp = (short *) *xpp;
#line 2722
    xp += ni;
#line 2722
    tp += ni;
#line 2722
    *xpp = (void*)xp;
#line 2722
  }
#line 2722
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2722

#line 2722
#else   /* not SX */
#line 2722
	const char *xp = (const char *) *xpp;
#line 2722
	int status = ENOERR;
#line 2722

#line 2722
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2722
	{
#line 2722
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 2722
		if(lstatus != ENOERR)
#line 2722
			status = lstatus;
#line 2722
	}
#line 2722

#line 2722
	*xpp = (const void *)xp;
#line 2722
	return status;
#line 2722
#  endif
#line 2722
}
#line 2722

int
#line 2723
ncx_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 2723
{
#line 2723
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2723

#line 2723
 /* basic algorithm is:
#line 2723
  *   - ensure sane alignment of input data
#line 2723
  *   - copy (conversion happens automatically) input data
#line 2723
  *     to output
#line 2723
  *   - update xpp to point at next unconverted input, and tp to point
#line 2723
  *     at next location for converted output
#line 2723
  */
#line 2723
  long i, j, ni;
#line 2723
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2723
  short *xp;
#line 2723
  int nrange = 0;         /* number of range errors */
#line 2723
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2723
  long cxp = (long) *((char**)xpp);
#line 2723

#line 2723
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2723
  /* sjl: manually stripmine so we can limit amount of
#line 2723
   * vector work space reserved to LOOPCNT elements. Also
#line 2723
   * makes vectorisation easy */
#line 2723
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2723
    ni=Min(nelems-j,LOOPCNT);
#line 2723
    if (realign) {
#line 2723
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2723
      xp = tmp;
#line 2723
    } else {
#line 2723
      xp = (short *) *xpp;
#line 2723
    }
#line 2723
   /* copy the next block */
#line 2723
#pragma cdir loopcnt=LOOPCNT
#line 2723
#pragma cdir shortloop
#line 2723
    for (i=0; i<ni; i++) {
#line 2723
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2723
     /* test for range errors (not always needed but do it anyway) */
#line 2723
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2723
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2723
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 2723
    }
#line 2723
   /* update xpp and tp */
#line 2723
    if (realign) xp = (short *) *xpp;
#line 2723
    xp += ni;
#line 2723
    tp += ni;
#line 2723
    *xpp = (void*)xp;
#line 2723
  }
#line 2723
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2723

#line 2723
#else   /* not SX */
#line 2723
	const char *xp = (const char *) *xpp;
#line 2723
	int status = ENOERR;
#line 2723

#line 2723
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2723
	{
#line 2723
		const int lstatus = ncx_get_short_int(xp, tp);
#line 2723
		if(lstatus != ENOERR)
#line 2723
			status = lstatus;
#line 2723
	}
#line 2723

#line 2723
	*xpp = (const void *)xp;
#line 2723
	return status;
#line 2723
#  endif
#line 2723
}
#line 2723

int
#line 2724
ncx_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 2724
{
#line 2724
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2724

#line 2724
 /* basic algorithm is:
#line 2724
  *   - ensure sane alignment of input data
#line 2724
  *   - copy (conversion happens automatically) input data
#line 2724
  *     to output
#line 2724
  *   - update xpp to point at next unconverted input, and tp to point
#line 2724
  *     at next location for converted output
#line 2724
  */
#line 2724
  long i, j, ni;
#line 2724
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2724
  short *xp;
#line 2724
  int nrange = 0;         /* number of range errors */
#line 2724
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2724
  long cxp = (long) *((char**)xpp);
#line 2724

#line 2724
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2724
  /* sjl: manually stripmine so we can limit amount of
#line 2724
   * vector work space reserved to LOOPCNT elements. Also
#line 2724
   * makes vectorisation easy */
#line 2724
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2724
    ni=Min(nelems-j,LOOPCNT);
#line 2724
    if (realign) {
#line 2724
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2724
      xp = tmp;
#line 2724
    } else {
#line 2724
      xp = (short *) *xpp;
#line 2724
    }
#line 2724
   /* copy the next block */
#line 2724
#pragma cdir loopcnt=LOOPCNT
#line 2724
#pragma cdir shortloop
#line 2724
    for (i=0; i<ni; i++) {
#line 2724
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2724
     /* test for range errors (not always needed but do it anyway) */
#line 2724
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2724
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2724
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 2724
    }
#line 2724
   /* update xpp and tp */
#line 2724
    if (realign) xp = (short *) *xpp;
#line 2724
    xp += ni;
#line 2724
    tp += ni;
#line 2724
    *xpp = (void*)xp;
#line 2724
  }
#line 2724
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2724

#line 2724
#else   /* not SX */
#line 2724
	const char *xp = (const char *) *xpp;
#line 2724
	int status = ENOERR;
#line 2724

#line 2724
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2724
	{
#line 2724
		const int lstatus = ncx_get_short_float(xp, tp);
#line 2724
		if(lstatus != ENOERR)
#line 2724
			status = lstatus;
#line 2724
	}
#line 2724

#line 2724
	*xpp = (const void *)xp;
#line 2724
	return status;
#line 2724
#  endif
#line 2724
}
#line 2724

int
#line 2725
ncx_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 2725
{
#line 2725
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2725

#line 2725
 /* basic algorithm is:
#line 2725
  *   - ensure sane alignment of input data
#line 2725
  *   - copy (conversion happens automatically) input data
#line 2725
  *     to output
#line 2725
  *   - update xpp to point at next unconverted input, and tp to point
#line 2725
  *     at next location for converted output
#line 2725
  */
#line 2725
  long i, j, ni;
#line 2725
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2725
  short *xp;
#line 2725
  int nrange = 0;         /* number of range errors */
#line 2725
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2725
  long cxp = (long) *((char**)xpp);
#line 2725

#line 2725
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2725
  /* sjl: manually stripmine so we can limit amount of
#line 2725
   * vector work space reserved to LOOPCNT elements. Also
#line 2725
   * makes vectorisation easy */
#line 2725
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2725
    ni=Min(nelems-j,LOOPCNT);
#line 2725
    if (realign) {
#line 2725
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2725
      xp = tmp;
#line 2725
    } else {
#line 2725
      xp = (short *) *xpp;
#line 2725
    }
#line 2725
   /* copy the next block */
#line 2725
#pragma cdir loopcnt=LOOPCNT
#line 2725
#pragma cdir shortloop
#line 2725
    for (i=0; i<ni; i++) {
#line 2725
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2725
     /* test for range errors (not always needed but do it anyway) */
#line 2725
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2725
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2725
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 2725
    }
#line 2725
   /* update xpp and tp */
#line 2725
    if (realign) xp = (short *) *xpp;
#line 2725
    xp += ni;
#line 2725
    tp += ni;
#line 2725
    *xpp = (void*)xp;
#line 2725
  }
#line 2725
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2725

#line 2725
#else   /* not SX */
#line 2725
	const char *xp = (const char *) *xpp;
#line 2725
	int status = ENOERR;
#line 2725

#line 2725
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2725
	{
#line 2725
		const int lstatus = ncx_get_short_double(xp, tp);
#line 2725
		if(lstatus != ENOERR)
#line 2725
			status = lstatus;
#line 2725
	}
#line 2725

#line 2725
	*xpp = (const void *)xp;
#line 2725
	return status;
#line 2725
#  endif
#line 2725
}
#line 2725

int
#line 2726
ncx_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2726
{
#line 2726
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2726

#line 2726
 /* basic algorithm is:
#line 2726
  *   - ensure sane alignment of input data
#line 2726
  *   - copy (conversion happens automatically) input data
#line 2726
  *     to output
#line 2726
  *   - update xpp to point at next unconverted input, and tp to point
#line 2726
  *     at next location for converted output
#line 2726
  */
#line 2726
  long i, j, ni;
#line 2726
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2726
  short *xp;
#line 2726
  int nrange = 0;         /* number of range errors */
#line 2726
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2726
  long cxp = (long) *((char**)xpp);
#line 2726

#line 2726
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2726
  /* sjl: manually stripmine so we can limit amount of
#line 2726
   * vector work space reserved to LOOPCNT elements. Also
#line 2726
   * makes vectorisation easy */
#line 2726
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2726
    ni=Min(nelems-j,LOOPCNT);
#line 2726
    if (realign) {
#line 2726
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2726
      xp = tmp;
#line 2726
    } else {
#line 2726
      xp = (short *) *xpp;
#line 2726
    }
#line 2726
   /* copy the next block */
#line 2726
#pragma cdir loopcnt=LOOPCNT
#line 2726
#pragma cdir shortloop
#line 2726
    for (i=0; i<ni; i++) {
#line 2726
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2726
     /* test for range errors (not always needed but do it anyway) */
#line 2726
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2726
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2726
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 2726
    }
#line 2726
   /* update xpp and tp */
#line 2726
    if (realign) xp = (short *) *xpp;
#line 2726
    xp += ni;
#line 2726
    tp += ni;
#line 2726
    *xpp = (void*)xp;
#line 2726
  }
#line 2726
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2726

#line 2726
#else   /* not SX */
#line 2726
	const char *xp = (const char *) *xpp;
#line 2726
	int status = ENOERR;
#line 2726

#line 2726
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2726
	{
#line 2726
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 2726
		if(lstatus != ENOERR)
#line 2726
			status = lstatus;
#line 2726
	}
#line 2726

#line 2726
	*xpp = (const void *)xp;
#line 2726
	return status;
#line 2726
#  endif
#line 2726
}
#line 2726

int
#line 2727
ncx_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2727
{
#line 2727
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2727

#line 2727
 /* basic algorithm is:
#line 2727
  *   - ensure sane alignment of input data
#line 2727
  *   - copy (conversion happens automatically) input data
#line 2727
  *     to output
#line 2727
  *   - update xpp to point at next unconverted input, and tp to point
#line 2727
  *     at next location for converted output
#line 2727
  */
#line 2727
  long i, j, ni;
#line 2727
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2727
  short *xp;
#line 2727
  int nrange = 0;         /* number of range errors */
#line 2727
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2727
  long cxp = (long) *((char**)xpp);
#line 2727

#line 2727
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2727
  /* sjl: manually stripmine so we can limit amount of
#line 2727
   * vector work space reserved to LOOPCNT elements. Also
#line 2727
   * makes vectorisation easy */
#line 2727
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2727
    ni=Min(nelems-j,LOOPCNT);
#line 2727
    if (realign) {
#line 2727
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2727
      xp = tmp;
#line 2727
    } else {
#line 2727
      xp = (short *) *xpp;
#line 2727
    }
#line 2727
   /* copy the next block */
#line 2727
#pragma cdir loopcnt=LOOPCNT
#line 2727
#pragma cdir shortloop
#line 2727
    for (i=0; i<ni; i++) {
#line 2727
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2727
     /* test for range errors (not always needed but do it anyway) */
#line 2727
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2727
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2727
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 2727
    }
#line 2727
   /* update xpp and tp */
#line 2727
    if (realign) xp = (short *) *xpp;
#line 2727
    xp += ni;
#line 2727
    tp += ni;
#line 2727
    *xpp = (void*)xp;
#line 2727
  }
#line 2727
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2727

#line 2727
#else   /* not SX */
#line 2727
	const char *xp = (const char *) *xpp;
#line 2727
	int status = ENOERR;
#line 2727

#line 2727
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2727
	{
#line 2727
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 2727
		if(lstatus != ENOERR)
#line 2727
			status = lstatus;
#line 2727
	}
#line 2727

#line 2727
	*xpp = (const void *)xp;
#line 2727
	return status;
#line 2727
#  endif
#line 2727
}
#line 2727

int
#line 2728
ncx_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2728
{
#line 2728
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2728

#line 2728
 /* basic algorithm is:
#line 2728
  *   - ensure sane alignment of input data
#line 2728
  *   - copy (conversion happens automatically) input data
#line 2728
  *     to output
#line 2728
  *   - update xpp to point at next unconverted input, and tp to point
#line 2728
  *     at next location for converted output
#line 2728
  */
#line 2728
  long i, j, ni;
#line 2728
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2728
  short *xp;
#line 2728
  int nrange = 0;         /* number of range errors */
#line 2728
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2728
  long cxp = (long) *((char**)xpp);
#line 2728

#line 2728
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2728
  /* sjl: manually stripmine so we can limit amount of
#line 2728
   * vector work space reserved to LOOPCNT elements. Also
#line 2728
   * makes vectorisation easy */
#line 2728
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2728
    ni=Min(nelems-j,LOOPCNT);
#line 2728
    if (realign) {
#line 2728
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2728
      xp = tmp;
#line 2728
    } else {
#line 2728
      xp = (short *) *xpp;
#line 2728
    }
#line 2728
   /* copy the next block */
#line 2728
#pragma cdir loopcnt=LOOPCNT
#line 2728
#pragma cdir shortloop
#line 2728
    for (i=0; i<ni; i++) {
#line 2728
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2728
     /* test for range errors (not always needed but do it anyway) */
#line 2728
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2728
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2728
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 2728
    }
#line 2728
   /* update xpp and tp */
#line 2728
    if (realign) xp = (short *) *xpp;
#line 2728
    xp += ni;
#line 2728
    tp += ni;
#line 2728
    *xpp = (void*)xp;
#line 2728
  }
#line 2728
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2728

#line 2728
#else   /* not SX */
#line 2728
	const char *xp = (const char *) *xpp;
#line 2728
	int status = ENOERR;
#line 2728

#line 2728
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2728
	{
#line 2728
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 2728
		if(lstatus != ENOERR)
#line 2728
			status = lstatus;
#line 2728
	}
#line 2728

#line 2728
	*xpp = (const void *)xp;
#line 2728
	return status;
#line 2728
#  endif
#line 2728
}
#line 2728

int
#line 2729
ncx_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 2729
{
#line 2729
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2729

#line 2729
 /* basic algorithm is:
#line 2729
  *   - ensure sane alignment of input data
#line 2729
  *   - copy (conversion happens automatically) input data
#line 2729
  *     to output
#line 2729
  *   - update xpp to point at next unconverted input, and tp to point
#line 2729
  *     at next location for converted output
#line 2729
  */
#line 2729
  long i, j, ni;
#line 2729
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2729
  short *xp;
#line 2729
  int nrange = 0;         /* number of range errors */
#line 2729
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2729
  long cxp = (long) *((char**)xpp);
#line 2729

#line 2729
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2729
  /* sjl: manually stripmine so we can limit amount of
#line 2729
   * vector work space reserved to LOOPCNT elements. Also
#line 2729
   * makes vectorisation easy */
#line 2729
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2729
    ni=Min(nelems-j,LOOPCNT);
#line 2729
    if (realign) {
#line 2729
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2729
      xp = tmp;
#line 2729
    } else {
#line 2729
      xp = (short *) *xpp;
#line 2729
    }
#line 2729
   /* copy the next block */
#line 2729
#pragma cdir loopcnt=LOOPCNT
#line 2729
#pragma cdir shortloop
#line 2729
    for (i=0; i<ni; i++) {
#line 2729
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2729
     /* test for range errors (not always needed but do it anyway) */
#line 2729
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2729
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2729
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 2729
    }
#line 2729
   /* update xpp and tp */
#line 2729
    if (realign) xp = (short *) *xpp;
#line 2729
    xp += ni;
#line 2729
    tp += ni;
#line 2729
    *xpp = (void*)xp;
#line 2729
  }
#line 2729
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2729

#line 2729
#else   /* not SX */
#line 2729
	const char *xp = (const char *) *xpp;
#line 2729
	int status = ENOERR;
#line 2729

#line 2729
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2729
	{
#line 2729
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 2729
		if(lstatus != ENOERR)
#line 2729
			status = lstatus;
#line 2729
	}
#line 2729

#line 2729
	*xpp = (const void *)xp;
#line 2729
	return status;
#line 2729
#  endif
#line 2729
}
#line 2729

int
#line 2730
ncx_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2730
{
#line 2730
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2730

#line 2730
 /* basic algorithm is:
#line 2730
  *   - ensure sane alignment of input data
#line 2730
  *   - copy (conversion happens automatically) input data
#line 2730
  *     to output
#line 2730
  *   - update xpp to point at next unconverted input, and tp to point
#line 2730
  *     at next location for converted output
#line 2730
  */
#line 2730
  long i, j, ni;
#line 2730
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2730
  short *xp;
#line 2730
  int nrange = 0;         /* number of range errors */
#line 2730
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2730
  long cxp = (long) *((char**)xpp);
#line 2730

#line 2730
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2730
  /* sjl: manually stripmine so we can limit amount of
#line 2730
   * vector work space reserved to LOOPCNT elements. Also
#line 2730
   * makes vectorisation easy */
#line 2730
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2730
    ni=Min(nelems-j,LOOPCNT);
#line 2730
    if (realign) {
#line 2730
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2730
      xp = tmp;
#line 2730
    } else {
#line 2730
      xp = (short *) *xpp;
#line 2730
    }
#line 2730
   /* copy the next block */
#line 2730
#pragma cdir loopcnt=LOOPCNT
#line 2730
#pragma cdir shortloop
#line 2730
    for (i=0; i<ni; i++) {
#line 2730
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2730
     /* test for range errors (not always needed but do it anyway) */
#line 2730
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2730
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2730
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 2730
    }
#line 2730
   /* update xpp and tp */
#line 2730
    if (realign) xp = (short *) *xpp;
#line 2730
    xp += ni;
#line 2730
    tp += ni;
#line 2730
    *xpp = (void*)xp;
#line 2730
  }
#line 2730
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2730

#line 2730
#else   /* not SX */
#line 2730
	const char *xp = (const char *) *xpp;
#line 2730
	int status = ENOERR;
#line 2730

#line 2730
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2730
	{
#line 2730
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 2730
		if(lstatus != ENOERR)
#line 2730
			status = lstatus;
#line 2730
	}
#line 2730

#line 2730
	*xpp = (const void *)xp;
#line 2730
	return status;
#line 2730
#  endif
#line 2730
}
#line 2730


int
#line 2732
ncx_pad_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 2732
{
#line 2732
	const size_t rndup = nelems % 2;
#line 2732

#line 2732
	const char *xp = (const char *) *xpp;
#line 2732
	int status = ENOERR;
#line 2732

#line 2732
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2732
	{
#line 2732
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 2732
		if(lstatus != ENOERR)
#line 2732
			status = lstatus;
#line 2732
	}
#line 2732

#line 2732
	if(rndup != 0)
#line 2732
		xp += X_SIZEOF_SHORT;
#line 2732
		
#line 2732
	*xpp = (void *)xp;
#line 2732
	return status;
#line 2732
}
#line 2732

int
#line 2733
ncx_pad_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2733
{
#line 2733
	const size_t rndup = nelems % 2;
#line 2733

#line 2733
	const char *xp = (const char *) *xpp;
#line 2733
	int status = ENOERR;
#line 2733

#line 2733
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2733
	{
#line 2733
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 2733
		if(lstatus != ENOERR)
#line 2733
			status = lstatus;
#line 2733
	}
#line 2733

#line 2733
	if(rndup != 0)
#line 2733
		xp += X_SIZEOF_SHORT;
#line 2733
		
#line 2733
	*xpp = (void *)xp;
#line 2733
	return status;
#line 2733
}
#line 2733

int
#line 2734
ncx_pad_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 2734
{
#line 2734
	const size_t rndup = nelems % 2;
#line 2734

#line 2734
	const char *xp = (const char *) *xpp;
#line 2734
	int status = ENOERR;
#line 2734

#line 2734
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2734
	{
#line 2734
		const int lstatus = ncx_get_short_short(xp, tp);
#line 2734
		if(lstatus != ENOERR)
#line 2734
			status = lstatus;
#line 2734
	}
#line 2734

#line 2734
	if(rndup != 0)
#line 2734
		xp += X_SIZEOF_SHORT;
#line 2734
		
#line 2734
	*xpp = (void *)xp;
#line 2734
	return status;
#line 2734
}
#line 2734

int
#line 2735
ncx_pad_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 2735
{
#line 2735
	const size_t rndup = nelems % 2;
#line 2735

#line 2735
	const char *xp = (const char *) *xpp;
#line 2735
	int status = ENOERR;
#line 2735

#line 2735
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2735
	{
#line 2735
		const int lstatus = ncx_get_short_int(xp, tp);
#line 2735
		if(lstatus != ENOERR)
#line 2735
			status = lstatus;
#line 2735
	}
#line 2735

#line 2735
	if(rndup != 0)
#line 2735
		xp += X_SIZEOF_SHORT;
#line 2735
		
#line 2735
	*xpp = (void *)xp;
#line 2735
	return status;
#line 2735
}
#line 2735

int
#line 2736
ncx_pad_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 2736
{
#line 2736
	const size_t rndup = nelems % 2;
#line 2736

#line 2736
	const char *xp = (const char *) *xpp;
#line 2736
	int status = ENOERR;
#line 2736

#line 2736
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2736
	{
#line 2736
		const int lstatus = ncx_get_short_float(xp, tp);
#line 2736
		if(lstatus != ENOERR)
#line 2736
			status = lstatus;
#line 2736
	}
#line 2736

#line 2736
	if(rndup != 0)
#line 2736
		xp += X_SIZEOF_SHORT;
#line 2736
		
#line 2736
	*xpp = (void *)xp;
#line 2736
	return status;
#line 2736
}
#line 2736

int
#line 2737
ncx_pad_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 2737
{
#line 2737
	const size_t rndup = nelems % 2;
#line 2737

#line 2737
	const char *xp = (const char *) *xpp;
#line 2737
	int status = ENOERR;
#line 2737

#line 2737
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2737
	{
#line 2737
		const int lstatus = ncx_get_short_double(xp, tp);
#line 2737
		if(lstatus != ENOERR)
#line 2737
			status = lstatus;
#line 2737
	}
#line 2737

#line 2737
	if(rndup != 0)
#line 2737
		xp += X_SIZEOF_SHORT;
#line 2737
		
#line 2737
	*xpp = (void *)xp;
#line 2737
	return status;
#line 2737
}
#line 2737

int
#line 2738
ncx_pad_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 2738
{
#line 2738
	const size_t rndup = nelems % 2;
#line 2738

#line 2738
	const char *xp = (const char *) *xpp;
#line 2738
	int status = ENOERR;
#line 2738

#line 2738
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2738
	{
#line 2738
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 2738
		if(lstatus != ENOERR)
#line 2738
			status = lstatus;
#line 2738
	}
#line 2738

#line 2738
	if(rndup != 0)
#line 2738
		xp += X_SIZEOF_SHORT;
#line 2738
		
#line 2738
	*xpp = (void *)xp;
#line 2738
	return status;
#line 2738
}
#line 2738

int
#line 2739
ncx_pad_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2739
{
#line 2739
	const size_t rndup = nelems % 2;
#line 2739

#line 2739
	const char *xp = (const char *) *xpp;
#line 2739
	int status = ENOERR;
#line 2739

#line 2739
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2739
	{
#line 2739
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 2739
		if(lstatus != ENOERR)
#line 2739
			status = lstatus;
#line 2739
	}
#line 2739

#line 2739
	if(rndup != 0)
#line 2739
		xp += X_SIZEOF_SHORT;
#line 2739
		
#line 2739
	*xpp = (void *)xp;
#line 2739
	return status;
#line 2739
}
#line 2739

int
#line 2740
ncx_pad_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2740
{
#line 2740
	const size_t rndup = nelems % 2;
#line 2740

#line 2740
	const char *xp = (const char *) *xpp;
#line 2740
	int status = ENOERR;
#line 2740

#line 2740
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2740
	{
#line 2740
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 2740
		if(lstatus != ENOERR)
#line 2740
			status = lstatus;
#line 2740
	}
#line 2740

#line 2740
	if(rndup != 0)
#line 2740
		xp += X_SIZEOF_SHORT;
#line 2740
		
#line 2740
	*xpp = (void *)xp;
#line 2740
	return status;
#line 2740
}
#line 2740

int
#line 2741
ncx_pad_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2741
{
#line 2741
	const size_t rndup = nelems % 2;
#line 2741

#line 2741
	const char *xp = (const char *) *xpp;
#line 2741
	int status = ENOERR;
#line 2741

#line 2741
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2741
	{
#line 2741
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 2741
		if(lstatus != ENOERR)
#line 2741
			status = lstatus;
#line 2741
	}
#line 2741

#line 2741
	if(rndup != 0)
#line 2741
		xp += X_SIZEOF_SHORT;
#line 2741
		
#line 2741
	*xpp = (void *)xp;
#line 2741
	return status;
#line 2741
}
#line 2741


#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_SHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return ENOERR;
}
#else
int
#line 2757
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp)
#line 2757
{
#line 2757
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2757

#line 2757
 /* basic algorithm is:
#line 2757
  *   - ensure sane alignment of output data
#line 2757
  *   - copy (conversion happens automatically) input data
#line 2757
  *     to output
#line 2757
  *   - update tp to point at next unconverted input, and xpp to point
#line 2757
  *     at next location for converted output
#line 2757
  */
#line 2757
  long i, j, ni;
#line 2757
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2757
  short *xp;
#line 2757
  int nrange = 0;         /* number of range errors */
#line 2757
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2757
  long cxp = (long) *((char**)xpp);
#line 2757

#line 2757
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2757
  /* sjl: manually stripmine so we can limit amount of
#line 2757
   * vector work space reserved to LOOPCNT elements. Also
#line 2757
   * makes vectorisation easy */
#line 2757
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2757
    ni=Min(nelems-j,LOOPCNT);
#line 2757
    if (realign) {
#line 2757
      xp = tmp;
#line 2757
    } else {
#line 2757
      xp = (short *) *xpp;
#line 2757
    }
#line 2757
   /* copy the next block */
#line 2757
#pragma cdir loopcnt=LOOPCNT
#line 2757
#pragma cdir shortloop
#line 2757
    for (i=0; i<ni; i++) {
#line 2757
      /* the normal case: */
#line 2757
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2757
     /* test for range errors (not always needed but do it anyway) */
#line 2757
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2757
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2757
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2757
    }
#line 2757
   /* copy workspace back if necessary */ 
#line 2757
    if (realign) {
#line 2757
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2757
      xp = (short *) *xpp;
#line 2757
    }
#line 2757
   /* update xpp and tp */
#line 2757
    xp += ni;
#line 2757
    tp += ni;
#line 2757
    *xpp = (void*)xp;
#line 2757
  }
#line 2757
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2757

#line 2757
#else   /* not SX */
#line 2757

#line 2757
	char *xp = (char *) *xpp;
#line 2757
	int status = ENOERR;
#line 2757

#line 2757
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2757
	{
#line 2757
		int lstatus = ncx_put_short_short(xp, tp);
#line 2757
		if(lstatus != ENOERR)
#line 2757
			status = lstatus;
#line 2757
	}
#line 2757

#line 2757
	*xpp = (void *)xp;
#line 2757
	return status;
#line 2757
#endif
#line 2757
}
#line 2757

#endif
int
#line 2759
ncx_putn_short_schar(void **xpp, size_t nelems, const schar *tp)
#line 2759
{
#line 2759
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2759

#line 2759
 /* basic algorithm is:
#line 2759
  *   - ensure sane alignment of output data
#line 2759
  *   - copy (conversion happens automatically) input data
#line 2759
  *     to output
#line 2759
  *   - update tp to point at next unconverted input, and xpp to point
#line 2759
  *     at next location for converted output
#line 2759
  */
#line 2759
  long i, j, ni;
#line 2759
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2759
  short *xp;
#line 2759
  int nrange = 0;         /* number of range errors */
#line 2759
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2759
  long cxp = (long) *((char**)xpp);
#line 2759

#line 2759
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2759
  /* sjl: manually stripmine so we can limit amount of
#line 2759
   * vector work space reserved to LOOPCNT elements. Also
#line 2759
   * makes vectorisation easy */
#line 2759
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2759
    ni=Min(nelems-j,LOOPCNT);
#line 2759
    if (realign) {
#line 2759
      xp = tmp;
#line 2759
    } else {
#line 2759
      xp = (short *) *xpp;
#line 2759
    }
#line 2759
   /* copy the next block */
#line 2759
#pragma cdir loopcnt=LOOPCNT
#line 2759
#pragma cdir shortloop
#line 2759
    for (i=0; i<ni; i++) {
#line 2759
      /* the normal case: */
#line 2759
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2759
     /* test for range errors (not always needed but do it anyway) */
#line 2759
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2759
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2759
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2759
    }
#line 2759
   /* copy workspace back if necessary */ 
#line 2759
    if (realign) {
#line 2759
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2759
      xp = (short *) *xpp;
#line 2759
    }
#line 2759
   /* update xpp and tp */
#line 2759
    xp += ni;
#line 2759
    tp += ni;
#line 2759
    *xpp = (void*)xp;
#line 2759
  }
#line 2759
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2759

#line 2759
#else   /* not SX */
#line 2759

#line 2759
	char *xp = (char *) *xpp;
#line 2759
	int status = ENOERR;
#line 2759

#line 2759
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2759
	{
#line 2759
		int lstatus = ncx_put_short_schar(xp, tp);
#line 2759
		if(lstatus != ENOERR)
#line 2759
			status = lstatus;
#line 2759
	}
#line 2759

#line 2759
	*xpp = (void *)xp;
#line 2759
	return status;
#line 2759
#endif
#line 2759
}
#line 2759

int
#line 2760
ncx_putn_short_int(void **xpp, size_t nelems, const int *tp)
#line 2760
{
#line 2760
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2760

#line 2760
 /* basic algorithm is:
#line 2760
  *   - ensure sane alignment of output data
#line 2760
  *   - copy (conversion happens automatically) input data
#line 2760
  *     to output
#line 2760
  *   - update tp to point at next unconverted input, and xpp to point
#line 2760
  *     at next location for converted output
#line 2760
  */
#line 2760
  long i, j, ni;
#line 2760
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2760
  short *xp;
#line 2760
  int nrange = 0;         /* number of range errors */
#line 2760
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2760
  long cxp = (long) *((char**)xpp);
#line 2760

#line 2760
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2760
  /* sjl: manually stripmine so we can limit amount of
#line 2760
   * vector work space reserved to LOOPCNT elements. Also
#line 2760
   * makes vectorisation easy */
#line 2760
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2760
    ni=Min(nelems-j,LOOPCNT);
#line 2760
    if (realign) {
#line 2760
      xp = tmp;
#line 2760
    } else {
#line 2760
      xp = (short *) *xpp;
#line 2760
    }
#line 2760
   /* copy the next block */
#line 2760
#pragma cdir loopcnt=LOOPCNT
#line 2760
#pragma cdir shortloop
#line 2760
    for (i=0; i<ni; i++) {
#line 2760
      /* the normal case: */
#line 2760
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2760
     /* test for range errors (not always needed but do it anyway) */
#line 2760
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2760
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2760
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2760
    }
#line 2760
   /* copy workspace back if necessary */ 
#line 2760
    if (realign) {
#line 2760
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2760
      xp = (short *) *xpp;
#line 2760
    }
#line 2760
   /* update xpp and tp */
#line 2760
    xp += ni;
#line 2760
    tp += ni;
#line 2760
    *xpp = (void*)xp;
#line 2760
  }
#line 2760
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2760

#line 2760
#else   /* not SX */
#line 2760

#line 2760
	char *xp = (char *) *xpp;
#line 2760
	int status = ENOERR;
#line 2760

#line 2760
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2760
	{
#line 2760
		int lstatus = ncx_put_short_int(xp, tp);
#line 2760
		if(lstatus != ENOERR)
#line 2760
			status = lstatus;
#line 2760
	}
#line 2760

#line 2760
	*xpp = (void *)xp;
#line 2760
	return status;
#line 2760
#endif
#line 2760
}
#line 2760

int
#line 2761
ncx_putn_short_float(void **xpp, size_t nelems, const float *tp)
#line 2761
{
#line 2761
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2761

#line 2761
 /* basic algorithm is:
#line 2761
  *   - ensure sane alignment of output data
#line 2761
  *   - copy (conversion happens automatically) input data
#line 2761
  *     to output
#line 2761
  *   - update tp to point at next unconverted input, and xpp to point
#line 2761
  *     at next location for converted output
#line 2761
  */
#line 2761
  long i, j, ni;
#line 2761
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2761
  short *xp;
#line 2761
  int nrange = 0;         /* number of range errors */
#line 2761
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2761
  long cxp = (long) *((char**)xpp);
#line 2761

#line 2761
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2761
  /* sjl: manually stripmine so we can limit amount of
#line 2761
   * vector work space reserved to LOOPCNT elements. Also
#line 2761
   * makes vectorisation easy */
#line 2761
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2761
    ni=Min(nelems-j,LOOPCNT);
#line 2761
    if (realign) {
#line 2761
      xp = tmp;
#line 2761
    } else {
#line 2761
      xp = (short *) *xpp;
#line 2761
    }
#line 2761
   /* copy the next block */
#line 2761
#pragma cdir loopcnt=LOOPCNT
#line 2761
#pragma cdir shortloop
#line 2761
    for (i=0; i<ni; i++) {
#line 2761
      /* the normal case: */
#line 2761
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2761
     /* test for range errors (not always needed but do it anyway) */
#line 2761
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2761
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2761
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2761
    }
#line 2761
   /* copy workspace back if necessary */ 
#line 2761
    if (realign) {
#line 2761
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2761
      xp = (short *) *xpp;
#line 2761
    }
#line 2761
   /* update xpp and tp */
#line 2761
    xp += ni;
#line 2761
    tp += ni;
#line 2761
    *xpp = (void*)xp;
#line 2761
  }
#line 2761
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2761

#line 2761
#else   /* not SX */
#line 2761

#line 2761
	char *xp = (char *) *xpp;
#line 2761
	int status = ENOERR;
#line 2761

#line 2761
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2761
	{
#line 2761
		int lstatus = ncx_put_short_float(xp, tp);
#line 2761
		if(lstatus != ENOERR)
#line 2761
			status = lstatus;
#line 2761
	}
#line 2761

#line 2761
	*xpp = (void *)xp;
#line 2761
	return status;
#line 2761
#endif
#line 2761
}
#line 2761

int
#line 2762
ncx_putn_short_double(void **xpp, size_t nelems, const double *tp)
#line 2762
{
#line 2762
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2762

#line 2762
 /* basic algorithm is:
#line 2762
  *   - ensure sane alignment of output data
#line 2762
  *   - copy (conversion happens automatically) input data
#line 2762
  *     to output
#line 2762
  *   - update tp to point at next unconverted input, and xpp to point
#line 2762
  *     at next location for converted output
#line 2762
  */
#line 2762
  long i, j, ni;
#line 2762
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2762
  short *xp;
#line 2762
  int nrange = 0;         /* number of range errors */
#line 2762
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2762
  long cxp = (long) *((char**)xpp);
#line 2762

#line 2762
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2762
  /* sjl: manually stripmine so we can limit amount of
#line 2762
   * vector work space reserved to LOOPCNT elements. Also
#line 2762
   * makes vectorisation easy */
#line 2762
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2762
    ni=Min(nelems-j,LOOPCNT);
#line 2762
    if (realign) {
#line 2762
      xp = tmp;
#line 2762
    } else {
#line 2762
      xp = (short *) *xpp;
#line 2762
    }
#line 2762
   /* copy the next block */
#line 2762
#pragma cdir loopcnt=LOOPCNT
#line 2762
#pragma cdir shortloop
#line 2762
    for (i=0; i<ni; i++) {
#line 2762
      /* the normal case: */
#line 2762
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2762
     /* test for range errors (not always needed but do it anyway) */
#line 2762
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2762
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2762
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2762
    }
#line 2762
   /* copy workspace back if necessary */ 
#line 2762
    if (realign) {
#line 2762
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2762
      xp = (short *) *xpp;
#line 2762
    }
#line 2762
   /* update xpp and tp */
#line 2762
    xp += ni;
#line 2762
    tp += ni;
#line 2762
    *xpp = (void*)xp;
#line 2762
  }
#line 2762
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2762

#line 2762
#else   /* not SX */
#line 2762

#line 2762
	char *xp = (char *) *xpp;
#line 2762
	int status = ENOERR;
#line 2762

#line 2762
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2762
	{
#line 2762
		int lstatus = ncx_put_short_double(xp, tp);
#line 2762
		if(lstatus != ENOERR)
#line 2762
			status = lstatus;
#line 2762
	}
#line 2762

#line 2762
	*xpp = (void *)xp;
#line 2762
	return status;
#line 2762
#endif
#line 2762
}
#line 2762

int
#line 2763
ncx_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2763
{
#line 2763
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2763

#line 2763
 /* basic algorithm is:
#line 2763
  *   - ensure sane alignment of output data
#line 2763
  *   - copy (conversion happens automatically) input data
#line 2763
  *     to output
#line 2763
  *   - update tp to point at next unconverted input, and xpp to point
#line 2763
  *     at next location for converted output
#line 2763
  */
#line 2763
  long i, j, ni;
#line 2763
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2763
  short *xp;
#line 2763
  int nrange = 0;         /* number of range errors */
#line 2763
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2763
  long cxp = (long) *((char**)xpp);
#line 2763

#line 2763
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2763
  /* sjl: manually stripmine so we can limit amount of
#line 2763
   * vector work space reserved to LOOPCNT elements. Also
#line 2763
   * makes vectorisation easy */
#line 2763
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2763
    ni=Min(nelems-j,LOOPCNT);
#line 2763
    if (realign) {
#line 2763
      xp = tmp;
#line 2763
    } else {
#line 2763
      xp = (short *) *xpp;
#line 2763
    }
#line 2763
   /* copy the next block */
#line 2763
#pragma cdir loopcnt=LOOPCNT
#line 2763
#pragma cdir shortloop
#line 2763
    for (i=0; i<ni; i++) {
#line 2763
      /* the normal case: */
#line 2763
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2763
     /* test for range errors (not always needed but do it anyway) */
#line 2763
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2763
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2763
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2763
    }
#line 2763
   /* copy workspace back if necessary */ 
#line 2763
    if (realign) {
#line 2763
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2763
      xp = (short *) *xpp;
#line 2763
    }
#line 2763
   /* update xpp and tp */
#line 2763
    xp += ni;
#line 2763
    tp += ni;
#line 2763
    *xpp = (void*)xp;
#line 2763
  }
#line 2763
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2763

#line 2763
#else   /* not SX */
#line 2763

#line 2763
	char *xp = (char *) *xpp;
#line 2763
	int status = ENOERR;
#line 2763

#line 2763
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2763
	{
#line 2763
		int lstatus = ncx_put_short_longlong(xp, tp);
#line 2763
		if(lstatus != ENOERR)
#line 2763
			status = lstatus;
#line 2763
	}
#line 2763

#line 2763
	*xpp = (void *)xp;
#line 2763
	return status;
#line 2763
#endif
#line 2763
}
#line 2763

int
#line 2764
ncx_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2764
{
#line 2764
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2764

#line 2764
 /* basic algorithm is:
#line 2764
  *   - ensure sane alignment of output data
#line 2764
  *   - copy (conversion happens automatically) input data
#line 2764
  *     to output
#line 2764
  *   - update tp to point at next unconverted input, and xpp to point
#line 2764
  *     at next location for converted output
#line 2764
  */
#line 2764
  long i, j, ni;
#line 2764
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2764
  short *xp;
#line 2764
  int nrange = 0;         /* number of range errors */
#line 2764
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2764
  long cxp = (long) *((char**)xpp);
#line 2764

#line 2764
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2764
  /* sjl: manually stripmine so we can limit amount of
#line 2764
   * vector work space reserved to LOOPCNT elements. Also
#line 2764
   * makes vectorisation easy */
#line 2764
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2764
    ni=Min(nelems-j,LOOPCNT);
#line 2764
    if (realign) {
#line 2764
      xp = tmp;
#line 2764
    } else {
#line 2764
      xp = (short *) *xpp;
#line 2764
    }
#line 2764
   /* copy the next block */
#line 2764
#pragma cdir loopcnt=LOOPCNT
#line 2764
#pragma cdir shortloop
#line 2764
    for (i=0; i<ni; i++) {
#line 2764
      /* the normal case: */
#line 2764
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2764
     /* test for range errors (not always needed but do it anyway) */
#line 2764
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2764
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2764
      nrange += tp[i] > X_SHORT_MAX ;
#line 2764
    }
#line 2764
   /* copy workspace back if necessary */ 
#line 2764
    if (realign) {
#line 2764
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2764
      xp = (short *) *xpp;
#line 2764
    }
#line 2764
   /* update xpp and tp */
#line 2764
    xp += ni;
#line 2764
    tp += ni;
#line 2764
    *xpp = (void*)xp;
#line 2764
  }
#line 2764
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2764

#line 2764
#else   /* not SX */
#line 2764

#line 2764
	char *xp = (char *) *xpp;
#line 2764
	int status = ENOERR;
#line 2764

#line 2764
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2764
	{
#line 2764
		int lstatus = ncx_put_short_uchar(xp, tp);
#line 2764
		if(lstatus != ENOERR)
#line 2764
			status = lstatus;
#line 2764
	}
#line 2764

#line 2764
	*xpp = (void *)xp;
#line 2764
	return status;
#line 2764
#endif
#line 2764
}
#line 2764

int
#line 2765
ncx_putn_short_uint(void **xpp, size_t nelems, const uint *tp)
#line 2765
{
#line 2765
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2765

#line 2765
 /* basic algorithm is:
#line 2765
  *   - ensure sane alignment of output data
#line 2765
  *   - copy (conversion happens automatically) input data
#line 2765
  *     to output
#line 2765
  *   - update tp to point at next unconverted input, and xpp to point
#line 2765
  *     at next location for converted output
#line 2765
  */
#line 2765
  long i, j, ni;
#line 2765
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2765
  short *xp;
#line 2765
  int nrange = 0;         /* number of range errors */
#line 2765
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2765
  long cxp = (long) *((char**)xpp);
#line 2765

#line 2765
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2765
  /* sjl: manually stripmine so we can limit amount of
#line 2765
   * vector work space reserved to LOOPCNT elements. Also
#line 2765
   * makes vectorisation easy */
#line 2765
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2765
    ni=Min(nelems-j,LOOPCNT);
#line 2765
    if (realign) {
#line 2765
      xp = tmp;
#line 2765
    } else {
#line 2765
      xp = (short *) *xpp;
#line 2765
    }
#line 2765
   /* copy the next block */
#line 2765
#pragma cdir loopcnt=LOOPCNT
#line 2765
#pragma cdir shortloop
#line 2765
    for (i=0; i<ni; i++) {
#line 2765
      /* the normal case: */
#line 2765
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2765
     /* test for range errors (not always needed but do it anyway) */
#line 2765
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2765
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2765
      nrange += tp[i] > X_SHORT_MAX ;
#line 2765
    }
#line 2765
   /* copy workspace back if necessary */ 
#line 2765
    if (realign) {
#line 2765
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2765
      xp = (short *) *xpp;
#line 2765
    }
#line 2765
   /* update xpp and tp */
#line 2765
    xp += ni;
#line 2765
    tp += ni;
#line 2765
    *xpp = (void*)xp;
#line 2765
  }
#line 2765
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2765

#line 2765
#else   /* not SX */
#line 2765

#line 2765
	char *xp = (char *) *xpp;
#line 2765
	int status = ENOERR;
#line 2765

#line 2765
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2765
	{
#line 2765
		int lstatus = ncx_put_short_uint(xp, tp);
#line 2765
		if(lstatus != ENOERR)
#line 2765
			status = lstatus;
#line 2765
	}
#line 2765

#line 2765
	*xpp = (void *)xp;
#line 2765
	return status;
#line 2765
#endif
#line 2765
}
#line 2765

int
#line 2766
ncx_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2766
{
#line 2766
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2766

#line 2766
 /* basic algorithm is:
#line 2766
  *   - ensure sane alignment of output data
#line 2766
  *   - copy (conversion happens automatically) input data
#line 2766
  *     to output
#line 2766
  *   - update tp to point at next unconverted input, and xpp to point
#line 2766
  *     at next location for converted output
#line 2766
  */
#line 2766
  long i, j, ni;
#line 2766
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2766
  short *xp;
#line 2766
  int nrange = 0;         /* number of range errors */
#line 2766
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2766
  long cxp = (long) *((char**)xpp);
#line 2766

#line 2766
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2766
  /* sjl: manually stripmine so we can limit amount of
#line 2766
   * vector work space reserved to LOOPCNT elements. Also
#line 2766
   * makes vectorisation easy */
#line 2766
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2766
    ni=Min(nelems-j,LOOPCNT);
#line 2766
    if (realign) {
#line 2766
      xp = tmp;
#line 2766
    } else {
#line 2766
      xp = (short *) *xpp;
#line 2766
    }
#line 2766
   /* copy the next block */
#line 2766
#pragma cdir loopcnt=LOOPCNT
#line 2766
#pragma cdir shortloop
#line 2766
    for (i=0; i<ni; i++) {
#line 2766
      /* the normal case: */
#line 2766
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2766
     /* test for range errors (not always needed but do it anyway) */
#line 2766
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2766
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2766
      nrange += tp[i] > X_SHORT_MAX ;
#line 2766
    }
#line 2766
   /* copy workspace back if necessary */ 
#line 2766
    if (realign) {
#line 2766
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2766
      xp = (short *) *xpp;
#line 2766
    }
#line 2766
   /* update xpp and tp */
#line 2766
    xp += ni;
#line 2766
    tp += ni;
#line 2766
    *xpp = (void*)xp;
#line 2766
  }
#line 2766
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2766

#line 2766
#else   /* not SX */
#line 2766

#line 2766
	char *xp = (char *) *xpp;
#line 2766
	int status = ENOERR;
#line 2766

#line 2766
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2766
	{
#line 2766
		int lstatus = ncx_put_short_ulonglong(xp, tp);
#line 2766
		if(lstatus != ENOERR)
#line 2766
			status = lstatus;
#line 2766
	}
#line 2766

#line 2766
	*xpp = (void *)xp;
#line 2766
	return status;
#line 2766
#endif
#line 2766
}
#line 2766

int
#line 2767
ncx_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2767
{
#line 2767
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2767

#line 2767
 /* basic algorithm is:
#line 2767
  *   - ensure sane alignment of output data
#line 2767
  *   - copy (conversion happens automatically) input data
#line 2767
  *     to output
#line 2767
  *   - update tp to point at next unconverted input, and xpp to point
#line 2767
  *     at next location for converted output
#line 2767
  */
#line 2767
  long i, j, ni;
#line 2767
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2767
  short *xp;
#line 2767
  int nrange = 0;         /* number of range errors */
#line 2767
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2767
  long cxp = (long) *((char**)xpp);
#line 2767

#line 2767
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2767
  /* sjl: manually stripmine so we can limit amount of
#line 2767
   * vector work space reserved to LOOPCNT elements. Also
#line 2767
   * makes vectorisation easy */
#line 2767
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2767
    ni=Min(nelems-j,LOOPCNT);
#line 2767
    if (realign) {
#line 2767
      xp = tmp;
#line 2767
    } else {
#line 2767
      xp = (short *) *xpp;
#line 2767
    }
#line 2767
   /* copy the next block */
#line 2767
#pragma cdir loopcnt=LOOPCNT
#line 2767
#pragma cdir shortloop
#line 2767
    for (i=0; i<ni; i++) {
#line 2767
      /* the normal case: */
#line 2767
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2767
     /* test for range errors (not always needed but do it anyway) */
#line 2767
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2767
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2767
      nrange += tp[i] > X_SHORT_MAX ;
#line 2767
    }
#line 2767
   /* copy workspace back if necessary */ 
#line 2767
    if (realign) {
#line 2767
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2767
      xp = (short *) *xpp;
#line 2767
    }
#line 2767
   /* update xpp and tp */
#line 2767
    xp += ni;
#line 2767
    tp += ni;
#line 2767
    *xpp = (void*)xp;
#line 2767
  }
#line 2767
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2767

#line 2767
#else   /* not SX */
#line 2767

#line 2767
	char *xp = (char *) *xpp;
#line 2767
	int status = ENOERR;
#line 2767

#line 2767
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2767
	{
#line 2767
		int lstatus = ncx_put_short_ushort(xp, tp);
#line 2767
		if(lstatus != ENOERR)
#line 2767
			status = lstatus;
#line 2767
	}
#line 2767

#line 2767
	*xpp = (void *)xp;
#line 2767
	return status;
#line 2767
#endif
#line 2767
}
#line 2767


int
#line 2769
ncx_pad_putn_short_schar(void **xpp, size_t nelems, const schar *tp)
#line 2769
{
#line 2769
	const size_t rndup = nelems % 2;
#line 2769

#line 2769
	char *xp = (char *) *xpp;
#line 2769
	int status = ENOERR;
#line 2769

#line 2769
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2769
	{
#line 2769
		int lstatus = ncx_put_short_schar(xp, tp);
#line 2769
		if(lstatus != ENOERR)
#line 2769
			status = lstatus;
#line 2769
	}
#line 2769

#line 2769
	if(rndup != 0)
#line 2769
	{
#line 2769
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2769
		xp += X_SIZEOF_SHORT;	
#line 2769
	}
#line 2769
		
#line 2769
	*xpp = (void *)xp;
#line 2769
	return status;
#line 2769
}
#line 2769

int
#line 2770
ncx_pad_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2770
{
#line 2770
	const size_t rndup = nelems % 2;
#line 2770

#line 2770
	char *xp = (char *) *xpp;
#line 2770
	int status = ENOERR;
#line 2770

#line 2770
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2770
	{
#line 2770
		int lstatus = ncx_put_short_uchar(xp, tp);
#line 2770
		if(lstatus != ENOERR)
#line 2770
			status = lstatus;
#line 2770
	}
#line 2770

#line 2770
	if(rndup != 0)
#line 2770
	{
#line 2770
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2770
		xp += X_SIZEOF_SHORT;	
#line 2770
	}
#line 2770
		
#line 2770
	*xpp = (void *)xp;
#line 2770
	return status;
#line 2770
}
#line 2770

int
#line 2771
ncx_pad_putn_short_short(void **xpp, size_t nelems, const short *tp)
#line 2771
{
#line 2771
	const size_t rndup = nelems % 2;
#line 2771

#line 2771
	char *xp = (char *) *xpp;
#line 2771
	int status = ENOERR;
#line 2771

#line 2771
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2771
	{
#line 2771
		int lstatus = ncx_put_short_short(xp, tp);
#line 2771
		if(lstatus != ENOERR)
#line 2771
			status = lstatus;
#line 2771
	}
#line 2771

#line 2771
	if(rndup != 0)
#line 2771
	{
#line 2771
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2771
		xp += X_SIZEOF_SHORT;	
#line 2771
	}
#line 2771
		
#line 2771
	*xpp = (void *)xp;
#line 2771
	return status;
#line 2771
}
#line 2771

int
#line 2772
ncx_pad_putn_short_int(void **xpp, size_t nelems, const int *tp)
#line 2772
{
#line 2772
	const size_t rndup = nelems % 2;
#line 2772

#line 2772
	char *xp = (char *) *xpp;
#line 2772
	int status = ENOERR;
#line 2772

#line 2772
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2772
	{
#line 2772
		int lstatus = ncx_put_short_int(xp, tp);
#line 2772
		if(lstatus != ENOERR)
#line 2772
			status = lstatus;
#line 2772
	}
#line 2772

#line 2772
	if(rndup != 0)
#line 2772
	{
#line 2772
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2772
		xp += X_SIZEOF_SHORT;	
#line 2772
	}
#line 2772
		
#line 2772
	*xpp = (void *)xp;
#line 2772
	return status;
#line 2772
}
#line 2772

int
#line 2773
ncx_pad_putn_short_float(void **xpp, size_t nelems, const float *tp)
#line 2773
{
#line 2773
	const size_t rndup = nelems % 2;
#line 2773

#line 2773
	char *xp = (char *) *xpp;
#line 2773
	int status = ENOERR;
#line 2773

#line 2773
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2773
	{
#line 2773
		int lstatus = ncx_put_short_float(xp, tp);
#line 2773
		if(lstatus != ENOERR)
#line 2773
			status = lstatus;
#line 2773
	}
#line 2773

#line 2773
	if(rndup != 0)
#line 2773
	{
#line 2773
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2773
		xp += X_SIZEOF_SHORT;	
#line 2773
	}
#line 2773
		
#line 2773
	*xpp = (void *)xp;
#line 2773
	return status;
#line 2773
}
#line 2773

int
#line 2774
ncx_pad_putn_short_double(void **xpp, size_t nelems, const double *tp)
#line 2774
{
#line 2774
	const size_t rndup = nelems % 2;
#line 2774

#line 2774
	char *xp = (char *) *xpp;
#line 2774
	int status = ENOERR;
#line 2774

#line 2774
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2774
	{
#line 2774
		int lstatus = ncx_put_short_double(xp, tp);
#line 2774
		if(lstatus != ENOERR)
#line 2774
			status = lstatus;
#line 2774
	}
#line 2774

#line 2774
	if(rndup != 0)
#line 2774
	{
#line 2774
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2774
		xp += X_SIZEOF_SHORT;	
#line 2774
	}
#line 2774
		
#line 2774
	*xpp = (void *)xp;
#line 2774
	return status;
#line 2774
}
#line 2774

int
#line 2775
ncx_pad_putn_short_uint(void **xpp, size_t nelems, const uint *tp)
#line 2775
{
#line 2775
	const size_t rndup = nelems % 2;
#line 2775

#line 2775
	char *xp = (char *) *xpp;
#line 2775
	int status = ENOERR;
#line 2775

#line 2775
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2775
	{
#line 2775
		int lstatus = ncx_put_short_uint(xp, tp);
#line 2775
		if(lstatus != ENOERR)
#line 2775
			status = lstatus;
#line 2775
	}
#line 2775

#line 2775
	if(rndup != 0)
#line 2775
	{
#line 2775
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2775
		xp += X_SIZEOF_SHORT;	
#line 2775
	}
#line 2775
		
#line 2775
	*xpp = (void *)xp;
#line 2775
	return status;
#line 2775
}
#line 2775

int
#line 2776
ncx_pad_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2776
{
#line 2776
	const size_t rndup = nelems % 2;
#line 2776

#line 2776
	char *xp = (char *) *xpp;
#line 2776
	int status = ENOERR;
#line 2776

#line 2776
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2776
	{
#line 2776
		int lstatus = ncx_put_short_longlong(xp, tp);
#line 2776
		if(lstatus != ENOERR)
#line 2776
			status = lstatus;
#line 2776
	}
#line 2776

#line 2776
	if(rndup != 0)
#line 2776
	{
#line 2776
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2776
		xp += X_SIZEOF_SHORT;	
#line 2776
	}
#line 2776
		
#line 2776
	*xpp = (void *)xp;
#line 2776
	return status;
#line 2776
}
#line 2776

int
#line 2777
ncx_pad_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2777
{
#line 2777
	const size_t rndup = nelems % 2;
#line 2777

#line 2777
	char *xp = (char *) *xpp;
#line 2777
	int status = ENOERR;
#line 2777

#line 2777
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2777
	{
#line 2777
		int lstatus = ncx_put_short_ulonglong(xp, tp);
#line 2777
		if(lstatus != ENOERR)
#line 2777
			status = lstatus;
#line 2777
	}
#line 2777

#line 2777
	if(rndup != 0)
#line 2777
	{
#line 2777
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2777
		xp += X_SIZEOF_SHORT;	
#line 2777
	}
#line 2777
		
#line 2777
	*xpp = (void *)xp;
#line 2777
	return status;
#line 2777
}
#line 2777

int
#line 2778
ncx_pad_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2778
{
#line 2778
	const size_t rndup = nelems % 2;
#line 2778

#line 2778
	char *xp = (char *) *xpp;
#line 2778
	int status = ENOERR;
#line 2778

#line 2778
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2778
	{
#line 2778
		int lstatus = ncx_put_short_ushort(xp, tp);
#line 2778
		if(lstatus != ENOERR)
#line 2778
			status = lstatus;
#line 2778
	}
#line 2778

#line 2778
	if(rndup != 0)
#line 2778
	{
#line 2778
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2778
		xp += X_SIZEOF_SHORT;	
#line 2778
	}
#line 2778
		
#line 2778
	*xpp = (void *)xp;
#line 2778
	return status;
#line 2778
}
#line 2778



/* ushort --------------------------------------------------------------------*/

#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, unsigned short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(unsigned short));
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return ENOERR;
}
#else
int
#line 2797
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2797
{
#line 2797
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2797

#line 2797
 /* basic algorithm is:
#line 2797
  *   - ensure sane alignment of input data
#line 2797
  *   - copy (conversion happens automatically) input data
#line 2797
  *     to output
#line 2797
  *   - update xpp to point at next unconverted input, and tp to point
#line 2797
  *     at next location for converted output
#line 2797
  */
#line 2797
  long i, j, ni;
#line 2797
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2797
  ushort *xp;
#line 2797
  int nrange = 0;         /* number of range errors */
#line 2797
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2797
  long cxp = (long) *((char**)xpp);
#line 2797

#line 2797
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2797
  /* sjl: manually stripmine so we can limit amount of
#line 2797
   * vector work space reserved to LOOPCNT elements. Also
#line 2797
   * makes vectorisation easy */
#line 2797
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2797
    ni=Min(nelems-j,LOOPCNT);
#line 2797
    if (realign) {
#line 2797
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2797
      xp = tmp;
#line 2797
    } else {
#line 2797
      xp = (ushort *) *xpp;
#line 2797
    }
#line 2797
   /* copy the next block */
#line 2797
#pragma cdir loopcnt=LOOPCNT
#line 2797
#pragma cdir shortloop
#line 2797
    for (i=0; i<ni; i++) {
#line 2797
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2797
     /* test for range errors (not always needed but do it anyway) */
#line 2797
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2797
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2797
      nrange += xp[i] > USHORT_MAX ;
#line 2797
    }
#line 2797
   /* update xpp and tp */
#line 2797
    if (realign) xp = (ushort *) *xpp;
#line 2797
    xp += ni;
#line 2797
    tp += ni;
#line 2797
    *xpp = (void*)xp;
#line 2797
  }
#line 2797
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2797

#line 2797
#else   /* not SX */
#line 2797
	const char *xp = (const char *) *xpp;
#line 2797
	int status = ENOERR;
#line 2797

#line 2797
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2797
	{
#line 2797
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 2797
		if(lstatus != ENOERR)
#line 2797
			status = lstatus;
#line 2797
	}
#line 2797

#line 2797
	*xpp = (const void *)xp;
#line 2797
	return status;
#line 2797
#  endif
#line 2797
}
#line 2797

#endif
int
#line 2799
ncx_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 2799
{
#line 2799
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2799

#line 2799
 /* basic algorithm is:
#line 2799
  *   - ensure sane alignment of input data
#line 2799
  *   - copy (conversion happens automatically) input data
#line 2799
  *     to output
#line 2799
  *   - update xpp to point at next unconverted input, and tp to point
#line 2799
  *     at next location for converted output
#line 2799
  */
#line 2799
  long i, j, ni;
#line 2799
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2799
  ushort *xp;
#line 2799
  int nrange = 0;         /* number of range errors */
#line 2799
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2799
  long cxp = (long) *((char**)xpp);
#line 2799

#line 2799
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2799
  /* sjl: manually stripmine so we can limit amount of
#line 2799
   * vector work space reserved to LOOPCNT elements. Also
#line 2799
   * makes vectorisation easy */
#line 2799
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2799
    ni=Min(nelems-j,LOOPCNT);
#line 2799
    if (realign) {
#line 2799
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2799
      xp = tmp;
#line 2799
    } else {
#line 2799
      xp = (ushort *) *xpp;
#line 2799
    }
#line 2799
   /* copy the next block */
#line 2799
#pragma cdir loopcnt=LOOPCNT
#line 2799
#pragma cdir shortloop
#line 2799
    for (i=0; i<ni; i++) {
#line 2799
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2799
     /* test for range errors (not always needed but do it anyway) */
#line 2799
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2799
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2799
      nrange += xp[i] > SCHAR_MAX ;
#line 2799
    }
#line 2799
   /* update xpp and tp */
#line 2799
    if (realign) xp = (ushort *) *xpp;
#line 2799
    xp += ni;
#line 2799
    tp += ni;
#line 2799
    *xpp = (void*)xp;
#line 2799
  }
#line 2799
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2799

#line 2799
#else   /* not SX */
#line 2799
	const char *xp = (const char *) *xpp;
#line 2799
	int status = ENOERR;
#line 2799

#line 2799
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2799
	{
#line 2799
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 2799
		if(lstatus != ENOERR)
#line 2799
			status = lstatus;
#line 2799
	}
#line 2799

#line 2799
	*xpp = (const void *)xp;
#line 2799
	return status;
#line 2799
#  endif
#line 2799
}
#line 2799

int
#line 2800
ncx_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 2800
{
#line 2800
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2800

#line 2800
 /* basic algorithm is:
#line 2800
  *   - ensure sane alignment of input data
#line 2800
  *   - copy (conversion happens automatically) input data
#line 2800
  *     to output
#line 2800
  *   - update xpp to point at next unconverted input, and tp to point
#line 2800
  *     at next location for converted output
#line 2800
  */
#line 2800
  long i, j, ni;
#line 2800
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2800
  ushort *xp;
#line 2800
  int nrange = 0;         /* number of range errors */
#line 2800
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2800
  long cxp = (long) *((char**)xpp);
#line 2800

#line 2800
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2800
  /* sjl: manually stripmine so we can limit amount of
#line 2800
   * vector work space reserved to LOOPCNT elements. Also
#line 2800
   * makes vectorisation easy */
#line 2800
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2800
    ni=Min(nelems-j,LOOPCNT);
#line 2800
    if (realign) {
#line 2800
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2800
      xp = tmp;
#line 2800
    } else {
#line 2800
      xp = (ushort *) *xpp;
#line 2800
    }
#line 2800
   /* copy the next block */
#line 2800
#pragma cdir loopcnt=LOOPCNT
#line 2800
#pragma cdir shortloop
#line 2800
    for (i=0; i<ni; i++) {
#line 2800
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2800
     /* test for range errors (not always needed but do it anyway) */
#line 2800
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2800
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2800
      nrange += xp[i] > SHORT_MAX ;
#line 2800
    }
#line 2800
   /* update xpp and tp */
#line 2800
    if (realign) xp = (ushort *) *xpp;
#line 2800
    xp += ni;
#line 2800
    tp += ni;
#line 2800
    *xpp = (void*)xp;
#line 2800
  }
#line 2800
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2800

#line 2800
#else   /* not SX */
#line 2800
	const char *xp = (const char *) *xpp;
#line 2800
	int status = ENOERR;
#line 2800

#line 2800
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2800
	{
#line 2800
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 2800
		if(lstatus != ENOERR)
#line 2800
			status = lstatus;
#line 2800
	}
#line 2800

#line 2800
	*xpp = (const void *)xp;
#line 2800
	return status;
#line 2800
#  endif
#line 2800
}
#line 2800

int
#line 2801
ncx_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 2801
{
#line 2801
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2801

#line 2801
 /* basic algorithm is:
#line 2801
  *   - ensure sane alignment of input data
#line 2801
  *   - copy (conversion happens automatically) input data
#line 2801
  *     to output
#line 2801
  *   - update xpp to point at next unconverted input, and tp to point
#line 2801
  *     at next location for converted output
#line 2801
  */
#line 2801
  long i, j, ni;
#line 2801
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2801
  ushort *xp;
#line 2801
  int nrange = 0;         /* number of range errors */
#line 2801
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2801
  long cxp = (long) *((char**)xpp);
#line 2801

#line 2801
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2801
  /* sjl: manually stripmine so we can limit amount of
#line 2801
   * vector work space reserved to LOOPCNT elements. Also
#line 2801
   * makes vectorisation easy */
#line 2801
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2801
    ni=Min(nelems-j,LOOPCNT);
#line 2801
    if (realign) {
#line 2801
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2801
      xp = tmp;
#line 2801
    } else {
#line 2801
      xp = (ushort *) *xpp;
#line 2801
    }
#line 2801
   /* copy the next block */
#line 2801
#pragma cdir loopcnt=LOOPCNT
#line 2801
#pragma cdir shortloop
#line 2801
    for (i=0; i<ni; i++) {
#line 2801
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2801
     /* test for range errors (not always needed but do it anyway) */
#line 2801
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2801
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2801
      nrange += xp[i] > INT_MAX ;
#line 2801
    }
#line 2801
   /* update xpp and tp */
#line 2801
    if (realign) xp = (ushort *) *xpp;
#line 2801
    xp += ni;
#line 2801
    tp += ni;
#line 2801
    *xpp = (void*)xp;
#line 2801
  }
#line 2801
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2801

#line 2801
#else   /* not SX */
#line 2801
	const char *xp = (const char *) *xpp;
#line 2801
	int status = ENOERR;
#line 2801

#line 2801
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2801
	{
#line 2801
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 2801
		if(lstatus != ENOERR)
#line 2801
			status = lstatus;
#line 2801
	}
#line 2801

#line 2801
	*xpp = (const void *)xp;
#line 2801
	return status;
#line 2801
#  endif
#line 2801
}
#line 2801

int
#line 2802
ncx_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 2802
{
#line 2802
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2802

#line 2802
 /* basic algorithm is:
#line 2802
  *   - ensure sane alignment of input data
#line 2802
  *   - copy (conversion happens automatically) input data
#line 2802
  *     to output
#line 2802
  *   - update xpp to point at next unconverted input, and tp to point
#line 2802
  *     at next location for converted output
#line 2802
  */
#line 2802
  long i, j, ni;
#line 2802
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2802
  ushort *xp;
#line 2802
  int nrange = 0;         /* number of range errors */
#line 2802
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2802
  long cxp = (long) *((char**)xpp);
#line 2802

#line 2802
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2802
  /* sjl: manually stripmine so we can limit amount of
#line 2802
   * vector work space reserved to LOOPCNT elements. Also
#line 2802
   * makes vectorisation easy */
#line 2802
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2802
    ni=Min(nelems-j,LOOPCNT);
#line 2802
    if (realign) {
#line 2802
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2802
      xp = tmp;
#line 2802
    } else {
#line 2802
      xp = (ushort *) *xpp;
#line 2802
    }
#line 2802
   /* copy the next block */
#line 2802
#pragma cdir loopcnt=LOOPCNT
#line 2802
#pragma cdir shortloop
#line 2802
    for (i=0; i<ni; i++) {
#line 2802
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2802
     /* test for range errors (not always needed but do it anyway) */
#line 2802
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2802
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2802
      nrange += xp[i] > FLOAT_MAX ;
#line 2802
    }
#line 2802
   /* update xpp and tp */
#line 2802
    if (realign) xp = (ushort *) *xpp;
#line 2802
    xp += ni;
#line 2802
    tp += ni;
#line 2802
    *xpp = (void*)xp;
#line 2802
  }
#line 2802
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2802

#line 2802
#else   /* not SX */
#line 2802
	const char *xp = (const char *) *xpp;
#line 2802
	int status = ENOERR;
#line 2802

#line 2802
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2802
	{
#line 2802
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 2802
		if(lstatus != ENOERR)
#line 2802
			status = lstatus;
#line 2802
	}
#line 2802

#line 2802
	*xpp = (const void *)xp;
#line 2802
	return status;
#line 2802
#  endif
#line 2802
}
#line 2802

int
#line 2803
ncx_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 2803
{
#line 2803
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2803

#line 2803
 /* basic algorithm is:
#line 2803
  *   - ensure sane alignment of input data
#line 2803
  *   - copy (conversion happens automatically) input data
#line 2803
  *     to output
#line 2803
  *   - update xpp to point at next unconverted input, and tp to point
#line 2803
  *     at next location for converted output
#line 2803
  */
#line 2803
  long i, j, ni;
#line 2803
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2803
  ushort *xp;
#line 2803
  int nrange = 0;         /* number of range errors */
#line 2803
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2803
  long cxp = (long) *((char**)xpp);
#line 2803

#line 2803
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2803
  /* sjl: manually stripmine so we can limit amount of
#line 2803
   * vector work space reserved to LOOPCNT elements. Also
#line 2803
   * makes vectorisation easy */
#line 2803
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2803
    ni=Min(nelems-j,LOOPCNT);
#line 2803
    if (realign) {
#line 2803
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2803
      xp = tmp;
#line 2803
    } else {
#line 2803
      xp = (ushort *) *xpp;
#line 2803
    }
#line 2803
   /* copy the next block */
#line 2803
#pragma cdir loopcnt=LOOPCNT
#line 2803
#pragma cdir shortloop
#line 2803
    for (i=0; i<ni; i++) {
#line 2803
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2803
     /* test for range errors (not always needed but do it anyway) */
#line 2803
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2803
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2803
      nrange += xp[i] > DOUBLE_MAX ;
#line 2803
    }
#line 2803
   /* update xpp and tp */
#line 2803
    if (realign) xp = (ushort *) *xpp;
#line 2803
    xp += ni;
#line 2803
    tp += ni;
#line 2803
    *xpp = (void*)xp;
#line 2803
  }
#line 2803
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2803

#line 2803
#else   /* not SX */
#line 2803
	const char *xp = (const char *) *xpp;
#line 2803
	int status = ENOERR;
#line 2803

#line 2803
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2803
	{
#line 2803
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 2803
		if(lstatus != ENOERR)
#line 2803
			status = lstatus;
#line 2803
	}
#line 2803

#line 2803
	*xpp = (const void *)xp;
#line 2803
	return status;
#line 2803
#  endif
#line 2803
}
#line 2803

int
#line 2804
ncx_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2804
{
#line 2804
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2804

#line 2804
 /* basic algorithm is:
#line 2804
  *   - ensure sane alignment of input data
#line 2804
  *   - copy (conversion happens automatically) input data
#line 2804
  *     to output
#line 2804
  *   - update xpp to point at next unconverted input, and tp to point
#line 2804
  *     at next location for converted output
#line 2804
  */
#line 2804
  long i, j, ni;
#line 2804
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2804
  ushort *xp;
#line 2804
  int nrange = 0;         /* number of range errors */
#line 2804
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2804
  long cxp = (long) *((char**)xpp);
#line 2804

#line 2804
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2804
  /* sjl: manually stripmine so we can limit amount of
#line 2804
   * vector work space reserved to LOOPCNT elements. Also
#line 2804
   * makes vectorisation easy */
#line 2804
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2804
    ni=Min(nelems-j,LOOPCNT);
#line 2804
    if (realign) {
#line 2804
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2804
      xp = tmp;
#line 2804
    } else {
#line 2804
      xp = (ushort *) *xpp;
#line 2804
    }
#line 2804
   /* copy the next block */
#line 2804
#pragma cdir loopcnt=LOOPCNT
#line 2804
#pragma cdir shortloop
#line 2804
    for (i=0; i<ni; i++) {
#line 2804
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2804
     /* test for range errors (not always needed but do it anyway) */
#line 2804
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2804
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2804
      nrange += xp[i] > LONGLONG_MAX ;
#line 2804
    }
#line 2804
   /* update xpp and tp */
#line 2804
    if (realign) xp = (ushort *) *xpp;
#line 2804
    xp += ni;
#line 2804
    tp += ni;
#line 2804
    *xpp = (void*)xp;
#line 2804
  }
#line 2804
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2804

#line 2804
#else   /* not SX */
#line 2804
	const char *xp = (const char *) *xpp;
#line 2804
	int status = ENOERR;
#line 2804

#line 2804
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2804
	{
#line 2804
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 2804
		if(lstatus != ENOERR)
#line 2804
			status = lstatus;
#line 2804
	}
#line 2804

#line 2804
	*xpp = (const void *)xp;
#line 2804
	return status;
#line 2804
#  endif
#line 2804
}
#line 2804

int
#line 2805
ncx_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2805
{
#line 2805
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2805

#line 2805
 /* basic algorithm is:
#line 2805
  *   - ensure sane alignment of input data
#line 2805
  *   - copy (conversion happens automatically) input data
#line 2805
  *     to output
#line 2805
  *   - update xpp to point at next unconverted input, and tp to point
#line 2805
  *     at next location for converted output
#line 2805
  */
#line 2805
  long i, j, ni;
#line 2805
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2805
  ushort *xp;
#line 2805
  int nrange = 0;         /* number of range errors */
#line 2805
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2805
  long cxp = (long) *((char**)xpp);
#line 2805

#line 2805
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2805
  /* sjl: manually stripmine so we can limit amount of
#line 2805
   * vector work space reserved to LOOPCNT elements. Also
#line 2805
   * makes vectorisation easy */
#line 2805
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2805
    ni=Min(nelems-j,LOOPCNT);
#line 2805
    if (realign) {
#line 2805
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2805
      xp = tmp;
#line 2805
    } else {
#line 2805
      xp = (ushort *) *xpp;
#line 2805
    }
#line 2805
   /* copy the next block */
#line 2805
#pragma cdir loopcnt=LOOPCNT
#line 2805
#pragma cdir shortloop
#line 2805
    for (i=0; i<ni; i++) {
#line 2805
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2805
     /* test for range errors (not always needed but do it anyway) */
#line 2805
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2805
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2805
      nrange += xp[i] > UCHAR_MAX ;
#line 2805
    }
#line 2805
   /* update xpp and tp */
#line 2805
    if (realign) xp = (ushort *) *xpp;
#line 2805
    xp += ni;
#line 2805
    tp += ni;
#line 2805
    *xpp = (void*)xp;
#line 2805
  }
#line 2805
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2805

#line 2805
#else   /* not SX */
#line 2805
	const char *xp = (const char *) *xpp;
#line 2805
	int status = ENOERR;
#line 2805

#line 2805
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2805
	{
#line 2805
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 2805
		if(lstatus != ENOERR)
#line 2805
			status = lstatus;
#line 2805
	}
#line 2805

#line 2805
	*xpp = (const void *)xp;
#line 2805
	return status;
#line 2805
#  endif
#line 2805
}
#line 2805

int
#line 2806
ncx_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 2806
{
#line 2806
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2806

#line 2806
 /* basic algorithm is:
#line 2806
  *   - ensure sane alignment of input data
#line 2806
  *   - copy (conversion happens automatically) input data
#line 2806
  *     to output
#line 2806
  *   - update xpp to point at next unconverted input, and tp to point
#line 2806
  *     at next location for converted output
#line 2806
  */
#line 2806
  long i, j, ni;
#line 2806
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2806
  ushort *xp;
#line 2806
  int nrange = 0;         /* number of range errors */
#line 2806
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2806
  long cxp = (long) *((char**)xpp);
#line 2806

#line 2806
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2806
  /* sjl: manually stripmine so we can limit amount of
#line 2806
   * vector work space reserved to LOOPCNT elements. Also
#line 2806
   * makes vectorisation easy */
#line 2806
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2806
    ni=Min(nelems-j,LOOPCNT);
#line 2806
    if (realign) {
#line 2806
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2806
      xp = tmp;
#line 2806
    } else {
#line 2806
      xp = (ushort *) *xpp;
#line 2806
    }
#line 2806
   /* copy the next block */
#line 2806
#pragma cdir loopcnt=LOOPCNT
#line 2806
#pragma cdir shortloop
#line 2806
    for (i=0; i<ni; i++) {
#line 2806
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2806
     /* test for range errors (not always needed but do it anyway) */
#line 2806
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2806
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2806
      nrange += xp[i] > UINT_MAX ;
#line 2806
    }
#line 2806
   /* update xpp and tp */
#line 2806
    if (realign) xp = (ushort *) *xpp;
#line 2806
    xp += ni;
#line 2806
    tp += ni;
#line 2806
    *xpp = (void*)xp;
#line 2806
  }
#line 2806
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2806

#line 2806
#else   /* not SX */
#line 2806
	const char *xp = (const char *) *xpp;
#line 2806
	int status = ENOERR;
#line 2806

#line 2806
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2806
	{
#line 2806
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 2806
		if(lstatus != ENOERR)
#line 2806
			status = lstatus;
#line 2806
	}
#line 2806

#line 2806
	*xpp = (const void *)xp;
#line 2806
	return status;
#line 2806
#  endif
#line 2806
}
#line 2806

int
#line 2807
ncx_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2807
{
#line 2807
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2807

#line 2807
 /* basic algorithm is:
#line 2807
  *   - ensure sane alignment of input data
#line 2807
  *   - copy (conversion happens automatically) input data
#line 2807
  *     to output
#line 2807
  *   - update xpp to point at next unconverted input, and tp to point
#line 2807
  *     at next location for converted output
#line 2807
  */
#line 2807
  long i, j, ni;
#line 2807
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2807
  ushort *xp;
#line 2807
  int nrange = 0;         /* number of range errors */
#line 2807
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2807
  long cxp = (long) *((char**)xpp);
#line 2807

#line 2807
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2807
  /* sjl: manually stripmine so we can limit amount of
#line 2807
   * vector work space reserved to LOOPCNT elements. Also
#line 2807
   * makes vectorisation easy */
#line 2807
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2807
    ni=Min(nelems-j,LOOPCNT);
#line 2807
    if (realign) {
#line 2807
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2807
      xp = tmp;
#line 2807
    } else {
#line 2807
      xp = (ushort *) *xpp;
#line 2807
    }
#line 2807
   /* copy the next block */
#line 2807
#pragma cdir loopcnt=LOOPCNT
#line 2807
#pragma cdir shortloop
#line 2807
    for (i=0; i<ni; i++) {
#line 2807
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2807
     /* test for range errors (not always needed but do it anyway) */
#line 2807
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2807
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2807
      nrange += xp[i] > ULONGLONG_MAX ;
#line 2807
    }
#line 2807
   /* update xpp and tp */
#line 2807
    if (realign) xp = (ushort *) *xpp;
#line 2807
    xp += ni;
#line 2807
    tp += ni;
#line 2807
    *xpp = (void*)xp;
#line 2807
  }
#line 2807
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2807

#line 2807
#else   /* not SX */
#line 2807
	const char *xp = (const char *) *xpp;
#line 2807
	int status = ENOERR;
#line 2807

#line 2807
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2807
	{
#line 2807
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 2807
		if(lstatus != ENOERR)
#line 2807
			status = lstatus;
#line 2807
	}
#line 2807

#line 2807
	*xpp = (const void *)xp;
#line 2807
	return status;
#line 2807
#  endif
#line 2807
}
#line 2807


int
#line 2809
ncx_pad_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 2809
{
#line 2809
	const size_t rndup = nelems % 2;
#line 2809

#line 2809
	const char *xp = (const char *) *xpp;
#line 2809
	int status = ENOERR;
#line 2809

#line 2809
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2809
	{
#line 2809
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 2809
		if(lstatus != ENOERR)
#line 2809
			status = lstatus;
#line 2809
	}
#line 2809

#line 2809
	if(rndup != 0)
#line 2809
		xp += X_SIZEOF_USHORT;
#line 2809
		
#line 2809
	*xpp = (void *)xp;
#line 2809
	return status;
#line 2809
}
#line 2809

int
#line 2810
ncx_pad_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2810
{
#line 2810
	const size_t rndup = nelems % 2;
#line 2810

#line 2810
	const char *xp = (const char *) *xpp;
#line 2810
	int status = ENOERR;
#line 2810

#line 2810
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2810
	{
#line 2810
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 2810
		if(lstatus != ENOERR)
#line 2810
			status = lstatus;
#line 2810
	}
#line 2810

#line 2810
	if(rndup != 0)
#line 2810
		xp += X_SIZEOF_USHORT;
#line 2810
		
#line 2810
	*xpp = (void *)xp;
#line 2810
	return status;
#line 2810
}
#line 2810

int
#line 2811
ncx_pad_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 2811
{
#line 2811
	const size_t rndup = nelems % 2;
#line 2811

#line 2811
	const char *xp = (const char *) *xpp;
#line 2811
	int status = ENOERR;
#line 2811

#line 2811
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2811
	{
#line 2811
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 2811
		if(lstatus != ENOERR)
#line 2811
			status = lstatus;
#line 2811
	}
#line 2811

#line 2811
	if(rndup != 0)
#line 2811
		xp += X_SIZEOF_USHORT;
#line 2811
		
#line 2811
	*xpp = (void *)xp;
#line 2811
	return status;
#line 2811
}
#line 2811

int
#line 2812
ncx_pad_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2812
{
#line 2812
	const size_t rndup = nelems % 2;
#line 2812

#line 2812
	const char *xp = (const char *) *xpp;
#line 2812
	int status = ENOERR;
#line 2812

#line 2812
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2812
	{
#line 2812
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 2812
		if(lstatus != ENOERR)
#line 2812
			status = lstatus;
#line 2812
	}
#line 2812

#line 2812
	if(rndup != 0)
#line 2812
		xp += X_SIZEOF_USHORT;
#line 2812
		
#line 2812
	*xpp = (void *)xp;
#line 2812
	return status;
#line 2812
}
#line 2812

int
#line 2813
ncx_pad_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 2813
{
#line 2813
	const size_t rndup = nelems % 2;
#line 2813

#line 2813
	const char *xp = (const char *) *xpp;
#line 2813
	int status = ENOERR;
#line 2813

#line 2813
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2813
	{
#line 2813
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 2813
		if(lstatus != ENOERR)
#line 2813
			status = lstatus;
#line 2813
	}
#line 2813

#line 2813
	if(rndup != 0)
#line 2813
		xp += X_SIZEOF_USHORT;
#line 2813
		
#line 2813
	*xpp = (void *)xp;
#line 2813
	return status;
#line 2813
}
#line 2813

int
#line 2814
ncx_pad_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 2814
{
#line 2814
	const size_t rndup = nelems % 2;
#line 2814

#line 2814
	const char *xp = (const char *) *xpp;
#line 2814
	int status = ENOERR;
#line 2814

#line 2814
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2814
	{
#line 2814
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 2814
		if(lstatus != ENOERR)
#line 2814
			status = lstatus;
#line 2814
	}
#line 2814

#line 2814
	if(rndup != 0)
#line 2814
		xp += X_SIZEOF_USHORT;
#line 2814
		
#line 2814
	*xpp = (void *)xp;
#line 2814
	return status;
#line 2814
}
#line 2814

int
#line 2815
ncx_pad_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 2815
{
#line 2815
	const size_t rndup = nelems % 2;
#line 2815

#line 2815
	const char *xp = (const char *) *xpp;
#line 2815
	int status = ENOERR;
#line 2815

#line 2815
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2815
	{
#line 2815
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 2815
		if(lstatus != ENOERR)
#line 2815
			status = lstatus;
#line 2815
	}
#line 2815

#line 2815
	if(rndup != 0)
#line 2815
		xp += X_SIZEOF_USHORT;
#line 2815
		
#line 2815
	*xpp = (void *)xp;
#line 2815
	return status;
#line 2815
}
#line 2815

int
#line 2816
ncx_pad_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 2816
{
#line 2816
	const size_t rndup = nelems % 2;
#line 2816

#line 2816
	const char *xp = (const char *) *xpp;
#line 2816
	int status = ENOERR;
#line 2816

#line 2816
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2816
	{
#line 2816
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 2816
		if(lstatus != ENOERR)
#line 2816
			status = lstatus;
#line 2816
	}
#line 2816

#line 2816
	if(rndup != 0)
#line 2816
		xp += X_SIZEOF_USHORT;
#line 2816
		
#line 2816
	*xpp = (void *)xp;
#line 2816
	return status;
#line 2816
}
#line 2816

int
#line 2817
ncx_pad_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2817
{
#line 2817
	const size_t rndup = nelems % 2;
#line 2817

#line 2817
	const char *xp = (const char *) *xpp;
#line 2817
	int status = ENOERR;
#line 2817

#line 2817
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2817
	{
#line 2817
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 2817
		if(lstatus != ENOERR)
#line 2817
			status = lstatus;
#line 2817
	}
#line 2817

#line 2817
	if(rndup != 0)
#line 2817
		xp += X_SIZEOF_USHORT;
#line 2817
		
#line 2817
	*xpp = (void *)xp;
#line 2817
	return status;
#line 2817
}
#line 2817

int
#line 2818
ncx_pad_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2818
{
#line 2818
	const size_t rndup = nelems % 2;
#line 2818

#line 2818
	const char *xp = (const char *) *xpp;
#line 2818
	int status = ENOERR;
#line 2818

#line 2818
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2818
	{
#line 2818
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 2818
		if(lstatus != ENOERR)
#line 2818
			status = lstatus;
#line 2818
	}
#line 2818

#line 2818
	if(rndup != 0)
#line 2818
		xp += X_SIZEOF_USHORT;
#line 2818
		
#line 2818
	*xpp = (void *)xp;
#line 2818
	return status;
#line 2818
}
#line 2818


#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const unsigned short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_USHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return ENOERR;
}
#else
int
#line 2834
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2834
{
#line 2834
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2834

#line 2834
 /* basic algorithm is:
#line 2834
  *   - ensure sane alignment of output data
#line 2834
  *   - copy (conversion happens automatically) input data
#line 2834
  *     to output
#line 2834
  *   - update tp to point at next unconverted input, and xpp to point
#line 2834
  *     at next location for converted output
#line 2834
  */
#line 2834
  long i, j, ni;
#line 2834
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2834
  ushort *xp;
#line 2834
  int nrange = 0;         /* number of range errors */
#line 2834
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2834
  long cxp = (long) *((char**)xpp);
#line 2834

#line 2834
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2834
  /* sjl: manually stripmine so we can limit amount of
#line 2834
   * vector work space reserved to LOOPCNT elements. Also
#line 2834
   * makes vectorisation easy */
#line 2834
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2834
    ni=Min(nelems-j,LOOPCNT);
#line 2834
    if (realign) {
#line 2834
      xp = tmp;
#line 2834
    } else {
#line 2834
      xp = (ushort *) *xpp;
#line 2834
    }
#line 2834
   /* copy the next block */
#line 2834
#pragma cdir loopcnt=LOOPCNT
#line 2834
#pragma cdir shortloop
#line 2834
    for (i=0; i<ni; i++) {
#line 2834
      /* the normal case: */
#line 2834
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2834
     /* test for range errors (not always needed but do it anyway) */
#line 2834
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2834
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2834
      nrange += tp[i] > X_USHORT_MAX ;
#line 2834
    }
#line 2834
   /* copy workspace back if necessary */ 
#line 2834
    if (realign) {
#line 2834
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2834
      xp = (ushort *) *xpp;
#line 2834
    }
#line 2834
   /* update xpp and tp */
#line 2834
    xp += ni;
#line 2834
    tp += ni;
#line 2834
    *xpp = (void*)xp;
#line 2834
  }
#line 2834
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2834

#line 2834
#else   /* not SX */
#line 2834

#line 2834
	char *xp = (char *) *xpp;
#line 2834
	int status = ENOERR;
#line 2834

#line 2834
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2834
	{
#line 2834
		int lstatus = ncx_put_ushort_ushort(xp, tp);
#line 2834
		if(lstatus != ENOERR)
#line 2834
			status = lstatus;
#line 2834
	}
#line 2834

#line 2834
	*xpp = (void *)xp;
#line 2834
	return status;
#line 2834
#endif
#line 2834
}
#line 2834

#endif
int
#line 2836
ncx_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp)
#line 2836
{
#line 2836
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2836

#line 2836
 /* basic algorithm is:
#line 2836
  *   - ensure sane alignment of output data
#line 2836
  *   - copy (conversion happens automatically) input data
#line 2836
  *     to output
#line 2836
  *   - update tp to point at next unconverted input, and xpp to point
#line 2836
  *     at next location for converted output
#line 2836
  */
#line 2836
  long i, j, ni;
#line 2836
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2836
  ushort *xp;
#line 2836
  int nrange = 0;         /* number of range errors */
#line 2836
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2836
  long cxp = (long) *((char**)xpp);
#line 2836

#line 2836
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2836
  /* sjl: manually stripmine so we can limit amount of
#line 2836
   * vector work space reserved to LOOPCNT elements. Also
#line 2836
   * makes vectorisation easy */
#line 2836
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2836
    ni=Min(nelems-j,LOOPCNT);
#line 2836
    if (realign) {
#line 2836
      xp = tmp;
#line 2836
    } else {
#line 2836
      xp = (ushort *) *xpp;
#line 2836
    }
#line 2836
   /* copy the next block */
#line 2836
#pragma cdir loopcnt=LOOPCNT
#line 2836
#pragma cdir shortloop
#line 2836
    for (i=0; i<ni; i++) {
#line 2836
      /* the normal case: */
#line 2836
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2836
     /* test for range errors (not always needed but do it anyway) */
#line 2836
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2836
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2836
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2836
    }
#line 2836
   /* copy workspace back if necessary */ 
#line 2836
    if (realign) {
#line 2836
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2836
      xp = (ushort *) *xpp;
#line 2836
    }
#line 2836
   /* update xpp and tp */
#line 2836
    xp += ni;
#line 2836
    tp += ni;
#line 2836
    *xpp = (void*)xp;
#line 2836
  }
#line 2836
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2836

#line 2836
#else   /* not SX */
#line 2836

#line 2836
	char *xp = (char *) *xpp;
#line 2836
	int status = ENOERR;
#line 2836

#line 2836
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2836
	{
#line 2836
		int lstatus = ncx_put_ushort_schar(xp, tp);
#line 2836
		if(lstatus != ENOERR)
#line 2836
			status = lstatus;
#line 2836
	}
#line 2836

#line 2836
	*xpp = (void *)xp;
#line 2836
	return status;
#line 2836
#endif
#line 2836
}
#line 2836

int
#line 2837
ncx_putn_ushort_short(void **xpp, size_t nelems, const short *tp)
#line 2837
{
#line 2837
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2837

#line 2837
 /* basic algorithm is:
#line 2837
  *   - ensure sane alignment of output data
#line 2837
  *   - copy (conversion happens automatically) input data
#line 2837
  *     to output
#line 2837
  *   - update tp to point at next unconverted input, and xpp to point
#line 2837
  *     at next location for converted output
#line 2837
  */
#line 2837
  long i, j, ni;
#line 2837
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2837
  ushort *xp;
#line 2837
  int nrange = 0;         /* number of range errors */
#line 2837
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2837
  long cxp = (long) *((char**)xpp);
#line 2837

#line 2837
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2837
  /* sjl: manually stripmine so we can limit amount of
#line 2837
   * vector work space reserved to LOOPCNT elements. Also
#line 2837
   * makes vectorisation easy */
#line 2837
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2837
    ni=Min(nelems-j,LOOPCNT);
#line 2837
    if (realign) {
#line 2837
      xp = tmp;
#line 2837
    } else {
#line 2837
      xp = (ushort *) *xpp;
#line 2837
    }
#line 2837
   /* copy the next block */
#line 2837
#pragma cdir loopcnt=LOOPCNT
#line 2837
#pragma cdir shortloop
#line 2837
    for (i=0; i<ni; i++) {
#line 2837
      /* the normal case: */
#line 2837
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2837
     /* test for range errors (not always needed but do it anyway) */
#line 2837
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2837
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2837
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2837
    }
#line 2837
   /* copy workspace back if necessary */ 
#line 2837
    if (realign) {
#line 2837
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2837
      xp = (ushort *) *xpp;
#line 2837
    }
#line 2837
   /* update xpp and tp */
#line 2837
    xp += ni;
#line 2837
    tp += ni;
#line 2837
    *xpp = (void*)xp;
#line 2837
  }
#line 2837
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2837

#line 2837
#else   /* not SX */
#line 2837

#line 2837
	char *xp = (char *) *xpp;
#line 2837
	int status = ENOERR;
#line 2837

#line 2837
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2837
	{
#line 2837
		int lstatus = ncx_put_ushort_short(xp, tp);
#line 2837
		if(lstatus != ENOERR)
#line 2837
			status = lstatus;
#line 2837
	}
#line 2837

#line 2837
	*xpp = (void *)xp;
#line 2837
	return status;
#line 2837
#endif
#line 2837
}
#line 2837

int
#line 2838
ncx_putn_ushort_int(void **xpp, size_t nelems, const int *tp)
#line 2838
{
#line 2838
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2838

#line 2838
 /* basic algorithm is:
#line 2838
  *   - ensure sane alignment of output data
#line 2838
  *   - copy (conversion happens automatically) input data
#line 2838
  *     to output
#line 2838
  *   - update tp to point at next unconverted input, and xpp to point
#line 2838
  *     at next location for converted output
#line 2838
  */
#line 2838
  long i, j, ni;
#line 2838
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2838
  ushort *xp;
#line 2838
  int nrange = 0;         /* number of range errors */
#line 2838
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2838
  long cxp = (long) *((char**)xpp);
#line 2838

#line 2838
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2838
  /* sjl: manually stripmine so we can limit amount of
#line 2838
   * vector work space reserved to LOOPCNT elements. Also
#line 2838
   * makes vectorisation easy */
#line 2838
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2838
    ni=Min(nelems-j,LOOPCNT);
#line 2838
    if (realign) {
#line 2838
      xp = tmp;
#line 2838
    } else {
#line 2838
      xp = (ushort *) *xpp;
#line 2838
    }
#line 2838
   /* copy the next block */
#line 2838
#pragma cdir loopcnt=LOOPCNT
#line 2838
#pragma cdir shortloop
#line 2838
    for (i=0; i<ni; i++) {
#line 2838
      /* the normal case: */
#line 2838
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2838
     /* test for range errors (not always needed but do it anyway) */
#line 2838
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2838
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2838
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2838
    }
#line 2838
   /* copy workspace back if necessary */ 
#line 2838
    if (realign) {
#line 2838
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2838
      xp = (ushort *) *xpp;
#line 2838
    }
#line 2838
   /* update xpp and tp */
#line 2838
    xp += ni;
#line 2838
    tp += ni;
#line 2838
    *xpp = (void*)xp;
#line 2838
  }
#line 2838
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2838

#line 2838
#else   /* not SX */
#line 2838

#line 2838
	char *xp = (char *) *xpp;
#line 2838
	int status = ENOERR;
#line 2838

#line 2838
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2838
	{
#line 2838
		int lstatus = ncx_put_ushort_int(xp, tp);
#line 2838
		if(lstatus != ENOERR)
#line 2838
			status = lstatus;
#line 2838
	}
#line 2838

#line 2838
	*xpp = (void *)xp;
#line 2838
	return status;
#line 2838
#endif
#line 2838
}
#line 2838

int
#line 2839
ncx_putn_ushort_float(void **xpp, size_t nelems, const float *tp)
#line 2839
{
#line 2839
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2839

#line 2839
 /* basic algorithm is:
#line 2839
  *   - ensure sane alignment of output data
#line 2839
  *   - copy (conversion happens automatically) input data
#line 2839
  *     to output
#line 2839
  *   - update tp to point at next unconverted input, and xpp to point
#line 2839
  *     at next location for converted output
#line 2839
  */
#line 2839
  long i, j, ni;
#line 2839
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2839
  ushort *xp;
#line 2839
  int nrange = 0;         /* number of range errors */
#line 2839
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2839
  long cxp = (long) *((char**)xpp);
#line 2839

#line 2839
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2839
  /* sjl: manually stripmine so we can limit amount of
#line 2839
   * vector work space reserved to LOOPCNT elements. Also
#line 2839
   * makes vectorisation easy */
#line 2839
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2839
    ni=Min(nelems-j,LOOPCNT);
#line 2839
    if (realign) {
#line 2839
      xp = tmp;
#line 2839
    } else {
#line 2839
      xp = (ushort *) *xpp;
#line 2839
    }
#line 2839
   /* copy the next block */
#line 2839
#pragma cdir loopcnt=LOOPCNT
#line 2839
#pragma cdir shortloop
#line 2839
    for (i=0; i<ni; i++) {
#line 2839
      /* the normal case: */
#line 2839
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2839
     /* test for range errors (not always needed but do it anyway) */
#line 2839
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2839
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2839
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2839
    }
#line 2839
   /* copy workspace back if necessary */ 
#line 2839
    if (realign) {
#line 2839
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2839
      xp = (ushort *) *xpp;
#line 2839
    }
#line 2839
   /* update xpp and tp */
#line 2839
    xp += ni;
#line 2839
    tp += ni;
#line 2839
    *xpp = (void*)xp;
#line 2839
  }
#line 2839
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2839

#line 2839
#else   /* not SX */
#line 2839

#line 2839
	char *xp = (char *) *xpp;
#line 2839
	int status = ENOERR;
#line 2839

#line 2839
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2839
	{
#line 2839
		int lstatus = ncx_put_ushort_float(xp, tp);
#line 2839
		if(lstatus != ENOERR)
#line 2839
			status = lstatus;
#line 2839
	}
#line 2839

#line 2839
	*xpp = (void *)xp;
#line 2839
	return status;
#line 2839
#endif
#line 2839
}
#line 2839

int
#line 2840
ncx_putn_ushort_double(void **xpp, size_t nelems, const double *tp)
#line 2840
{
#line 2840
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2840

#line 2840
 /* basic algorithm is:
#line 2840
  *   - ensure sane alignment of output data
#line 2840
  *   - copy (conversion happens automatically) input data
#line 2840
  *     to output
#line 2840
  *   - update tp to point at next unconverted input, and xpp to point
#line 2840
  *     at next location for converted output
#line 2840
  */
#line 2840
  long i, j, ni;
#line 2840
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2840
  ushort *xp;
#line 2840
  int nrange = 0;         /* number of range errors */
#line 2840
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2840
  long cxp = (long) *((char**)xpp);
#line 2840

#line 2840
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2840
  /* sjl: manually stripmine so we can limit amount of
#line 2840
   * vector work space reserved to LOOPCNT elements. Also
#line 2840
   * makes vectorisation easy */
#line 2840
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2840
    ni=Min(nelems-j,LOOPCNT);
#line 2840
    if (realign) {
#line 2840
      xp = tmp;
#line 2840
    } else {
#line 2840
      xp = (ushort *) *xpp;
#line 2840
    }
#line 2840
   /* copy the next block */
#line 2840
#pragma cdir loopcnt=LOOPCNT
#line 2840
#pragma cdir shortloop
#line 2840
    for (i=0; i<ni; i++) {
#line 2840
      /* the normal case: */
#line 2840
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2840
     /* test for range errors (not always needed but do it anyway) */
#line 2840
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2840
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2840
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2840
    }
#line 2840
   /* copy workspace back if necessary */ 
#line 2840
    if (realign) {
#line 2840
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2840
      xp = (ushort *) *xpp;
#line 2840
    }
#line 2840
   /* update xpp and tp */
#line 2840
    xp += ni;
#line 2840
    tp += ni;
#line 2840
    *xpp = (void*)xp;
#line 2840
  }
#line 2840
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2840

#line 2840
#else   /* not SX */
#line 2840

#line 2840
	char *xp = (char *) *xpp;
#line 2840
	int status = ENOERR;
#line 2840

#line 2840
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2840
	{
#line 2840
		int lstatus = ncx_put_ushort_double(xp, tp);
#line 2840
		if(lstatus != ENOERR)
#line 2840
			status = lstatus;
#line 2840
	}
#line 2840

#line 2840
	*xpp = (void *)xp;
#line 2840
	return status;
#line 2840
#endif
#line 2840
}
#line 2840

int
#line 2841
ncx_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2841
{
#line 2841
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2841

#line 2841
 /* basic algorithm is:
#line 2841
  *   - ensure sane alignment of output data
#line 2841
  *   - copy (conversion happens automatically) input data
#line 2841
  *     to output
#line 2841
  *   - update tp to point at next unconverted input, and xpp to point
#line 2841
  *     at next location for converted output
#line 2841
  */
#line 2841
  long i, j, ni;
#line 2841
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2841
  ushort *xp;
#line 2841
  int nrange = 0;         /* number of range errors */
#line 2841
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2841
  long cxp = (long) *((char**)xpp);
#line 2841

#line 2841
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2841
  /* sjl: manually stripmine so we can limit amount of
#line 2841
   * vector work space reserved to LOOPCNT elements. Also
#line 2841
   * makes vectorisation easy */
#line 2841
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2841
    ni=Min(nelems-j,LOOPCNT);
#line 2841
    if (realign) {
#line 2841
      xp = tmp;
#line 2841
    } else {
#line 2841
      xp = (ushort *) *xpp;
#line 2841
    }
#line 2841
   /* copy the next block */
#line 2841
#pragma cdir loopcnt=LOOPCNT
#line 2841
#pragma cdir shortloop
#line 2841
    for (i=0; i<ni; i++) {
#line 2841
      /* the normal case: */
#line 2841
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2841
     /* test for range errors (not always needed but do it anyway) */
#line 2841
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2841
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2841
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2841
    }
#line 2841
   /* copy workspace back if necessary */ 
#line 2841
    if (realign) {
#line 2841
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2841
      xp = (ushort *) *xpp;
#line 2841
    }
#line 2841
   /* update xpp and tp */
#line 2841
    xp += ni;
#line 2841
    tp += ni;
#line 2841
    *xpp = (void*)xp;
#line 2841
  }
#line 2841
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2841

#line 2841
#else   /* not SX */
#line 2841

#line 2841
	char *xp = (char *) *xpp;
#line 2841
	int status = ENOERR;
#line 2841

#line 2841
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2841
	{
#line 2841
		int lstatus = ncx_put_ushort_longlong(xp, tp);
#line 2841
		if(lstatus != ENOERR)
#line 2841
			status = lstatus;
#line 2841
	}
#line 2841

#line 2841
	*xpp = (void *)xp;
#line 2841
	return status;
#line 2841
#endif
#line 2841
}
#line 2841

int
#line 2842
ncx_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2842
{
#line 2842
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2842

#line 2842
 /* basic algorithm is:
#line 2842
  *   - ensure sane alignment of output data
#line 2842
  *   - copy (conversion happens automatically) input data
#line 2842
  *     to output
#line 2842
  *   - update tp to point at next unconverted input, and xpp to point
#line 2842
  *     at next location for converted output
#line 2842
  */
#line 2842
  long i, j, ni;
#line 2842
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2842
  ushort *xp;
#line 2842
  int nrange = 0;         /* number of range errors */
#line 2842
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2842
  long cxp = (long) *((char**)xpp);
#line 2842

#line 2842
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2842
  /* sjl: manually stripmine so we can limit amount of
#line 2842
   * vector work space reserved to LOOPCNT elements. Also
#line 2842
   * makes vectorisation easy */
#line 2842
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2842
    ni=Min(nelems-j,LOOPCNT);
#line 2842
    if (realign) {
#line 2842
      xp = tmp;
#line 2842
    } else {
#line 2842
      xp = (ushort *) *xpp;
#line 2842
    }
#line 2842
   /* copy the next block */
#line 2842
#pragma cdir loopcnt=LOOPCNT
#line 2842
#pragma cdir shortloop
#line 2842
    for (i=0; i<ni; i++) {
#line 2842
      /* the normal case: */
#line 2842
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2842
     /* test for range errors (not always needed but do it anyway) */
#line 2842
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2842
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2842
      nrange += tp[i] > X_USHORT_MAX ;
#line 2842
    }
#line 2842
   /* copy workspace back if necessary */ 
#line 2842
    if (realign) {
#line 2842
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2842
      xp = (ushort *) *xpp;
#line 2842
    }
#line 2842
   /* update xpp and tp */
#line 2842
    xp += ni;
#line 2842
    tp += ni;
#line 2842
    *xpp = (void*)xp;
#line 2842
  }
#line 2842
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2842

#line 2842
#else   /* not SX */
#line 2842

#line 2842
	char *xp = (char *) *xpp;
#line 2842
	int status = ENOERR;
#line 2842

#line 2842
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2842
	{
#line 2842
		int lstatus = ncx_put_ushort_uchar(xp, tp);
#line 2842
		if(lstatus != ENOERR)
#line 2842
			status = lstatus;
#line 2842
	}
#line 2842

#line 2842
	*xpp = (void *)xp;
#line 2842
	return status;
#line 2842
#endif
#line 2842
}
#line 2842

int
#line 2843
ncx_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp)
#line 2843
{
#line 2843
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2843

#line 2843
 /* basic algorithm is:
#line 2843
  *   - ensure sane alignment of output data
#line 2843
  *   - copy (conversion happens automatically) input data
#line 2843
  *     to output
#line 2843
  *   - update tp to point at next unconverted input, and xpp to point
#line 2843
  *     at next location for converted output
#line 2843
  */
#line 2843
  long i, j, ni;
#line 2843
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2843
  ushort *xp;
#line 2843
  int nrange = 0;         /* number of range errors */
#line 2843
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2843
  long cxp = (long) *((char**)xpp);
#line 2843

#line 2843
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2843
  /* sjl: manually stripmine so we can limit amount of
#line 2843
   * vector work space reserved to LOOPCNT elements. Also
#line 2843
   * makes vectorisation easy */
#line 2843
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2843
    ni=Min(nelems-j,LOOPCNT);
#line 2843
    if (realign) {
#line 2843
      xp = tmp;
#line 2843
    } else {
#line 2843
      xp = (ushort *) *xpp;
#line 2843
    }
#line 2843
   /* copy the next block */
#line 2843
#pragma cdir loopcnt=LOOPCNT
#line 2843
#pragma cdir shortloop
#line 2843
    for (i=0; i<ni; i++) {
#line 2843
      /* the normal case: */
#line 2843
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2843
     /* test for range errors (not always needed but do it anyway) */
#line 2843
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2843
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2843
      nrange += tp[i] > X_USHORT_MAX ;
#line 2843
    }
#line 2843
   /* copy workspace back if necessary */ 
#line 2843
    if (realign) {
#line 2843
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2843
      xp = (ushort *) *xpp;
#line 2843
    }
#line 2843
   /* update xpp and tp */
#line 2843
    xp += ni;
#line 2843
    tp += ni;
#line 2843
    *xpp = (void*)xp;
#line 2843
  }
#line 2843
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2843

#line 2843
#else   /* not SX */
#line 2843

#line 2843
	char *xp = (char *) *xpp;
#line 2843
	int status = ENOERR;
#line 2843

#line 2843
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2843
	{
#line 2843
		int lstatus = ncx_put_ushort_uint(xp, tp);
#line 2843
		if(lstatus != ENOERR)
#line 2843
			status = lstatus;
#line 2843
	}
#line 2843

#line 2843
	*xpp = (void *)xp;
#line 2843
	return status;
#line 2843
#endif
#line 2843
}
#line 2843

int
#line 2844
ncx_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2844
{
#line 2844
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2844

#line 2844
 /* basic algorithm is:
#line 2844
  *   - ensure sane alignment of output data
#line 2844
  *   - copy (conversion happens automatically) input data
#line 2844
  *     to output
#line 2844
  *   - update tp to point at next unconverted input, and xpp to point
#line 2844
  *     at next location for converted output
#line 2844
  */
#line 2844
  long i, j, ni;
#line 2844
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2844
  ushort *xp;
#line 2844
  int nrange = 0;         /* number of range errors */
#line 2844
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2844
  long cxp = (long) *((char**)xpp);
#line 2844

#line 2844
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2844
  /* sjl: manually stripmine so we can limit amount of
#line 2844
   * vector work space reserved to LOOPCNT elements. Also
#line 2844
   * makes vectorisation easy */
#line 2844
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2844
    ni=Min(nelems-j,LOOPCNT);
#line 2844
    if (realign) {
#line 2844
      xp = tmp;
#line 2844
    } else {
#line 2844
      xp = (ushort *) *xpp;
#line 2844
    }
#line 2844
   /* copy the next block */
#line 2844
#pragma cdir loopcnt=LOOPCNT
#line 2844
#pragma cdir shortloop
#line 2844
    for (i=0; i<ni; i++) {
#line 2844
      /* the normal case: */
#line 2844
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2844
     /* test for range errors (not always needed but do it anyway) */
#line 2844
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2844
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2844
      nrange += tp[i] > X_USHORT_MAX ;
#line 2844
    }
#line 2844
   /* copy workspace back if necessary */ 
#line 2844
    if (realign) {
#line 2844
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2844
      xp = (ushort *) *xpp;
#line 2844
    }
#line 2844
   /* update xpp and tp */
#line 2844
    xp += ni;
#line 2844
    tp += ni;
#line 2844
    *xpp = (void*)xp;
#line 2844
  }
#line 2844
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2844

#line 2844
#else   /* not SX */
#line 2844

#line 2844
	char *xp = (char *) *xpp;
#line 2844
	int status = ENOERR;
#line 2844

#line 2844
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2844
	{
#line 2844
		int lstatus = ncx_put_ushort_ulonglong(xp, tp);
#line 2844
		if(lstatus != ENOERR)
#line 2844
			status = lstatus;
#line 2844
	}
#line 2844

#line 2844
	*xpp = (void *)xp;
#line 2844
	return status;
#line 2844
#endif
#line 2844
}
#line 2844


int
#line 2846
ncx_pad_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp)
#line 2846
{
#line 2846
	const size_t rndup = nelems % 2;
#line 2846

#line 2846
	char *xp = (char *) *xpp;
#line 2846
	int status = ENOERR;
#line 2846

#line 2846
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2846
	{
#line 2846
		int lstatus = ncx_put_ushort_schar(xp, tp);
#line 2846
		if(lstatus != ENOERR)
#line 2846
			status = lstatus;
#line 2846
	}
#line 2846

#line 2846
	if(rndup != 0)
#line 2846
	{
#line 2846
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2846
		xp += X_SIZEOF_USHORT;	
#line 2846
	}
#line 2846
		
#line 2846
	*xpp = (void *)xp;
#line 2846
	return status;
#line 2846
}
#line 2846

int
#line 2847
ncx_pad_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2847
{
#line 2847
	const size_t rndup = nelems % 2;
#line 2847

#line 2847
	char *xp = (char *) *xpp;
#line 2847
	int status = ENOERR;
#line 2847

#line 2847
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2847
	{
#line 2847
		int lstatus = ncx_put_ushort_uchar(xp, tp);
#line 2847
		if(lstatus != ENOERR)
#line 2847
			status = lstatus;
#line 2847
	}
#line 2847

#line 2847
	if(rndup != 0)
#line 2847
	{
#line 2847
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2847
		xp += X_SIZEOF_USHORT;	
#line 2847
	}
#line 2847
		
#line 2847
	*xpp = (void *)xp;
#line 2847
	return status;
#line 2847
}
#line 2847

int
#line 2848
ncx_pad_putn_ushort_short(void **xpp, size_t nelems, const short *tp)
#line 2848
{
#line 2848
	const size_t rndup = nelems % 2;
#line 2848

#line 2848
	char *xp = (char *) *xpp;
#line 2848
	int status = ENOERR;
#line 2848

#line 2848
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2848
	{
#line 2848
		int lstatus = ncx_put_ushort_short(xp, tp);
#line 2848
		if(lstatus != ENOERR)
#line 2848
			status = lstatus;
#line 2848
	}
#line 2848

#line 2848
	if(rndup != 0)
#line 2848
	{
#line 2848
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2848
		xp += X_SIZEOF_USHORT;	
#line 2848
	}
#line 2848
		
#line 2848
	*xpp = (void *)xp;
#line 2848
	return status;
#line 2848
}
#line 2848

int
#line 2849
ncx_pad_putn_ushort_int(void **xpp, size_t nelems, const int *tp)
#line 2849
{
#line 2849
	const size_t rndup = nelems % 2;
#line 2849

#line 2849
	char *xp = (char *) *xpp;
#line 2849
	int status = ENOERR;
#line 2849

#line 2849
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2849
	{
#line 2849
		int lstatus = ncx_put_ushort_int(xp, tp);
#line 2849
		if(lstatus != ENOERR)
#line 2849
			status = lstatus;
#line 2849
	}
#line 2849

#line 2849
	if(rndup != 0)
#line 2849
	{
#line 2849
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2849
		xp += X_SIZEOF_USHORT;	
#line 2849
	}
#line 2849
		
#line 2849
	*xpp = (void *)xp;
#line 2849
	return status;
#line 2849
}
#line 2849

int
#line 2850
ncx_pad_putn_ushort_float(void **xpp, size_t nelems, const float *tp)
#line 2850
{
#line 2850
	const size_t rndup = nelems % 2;
#line 2850

#line 2850
	char *xp = (char *) *xpp;
#line 2850
	int status = ENOERR;
#line 2850

#line 2850
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2850
	{
#line 2850
		int lstatus = ncx_put_ushort_float(xp, tp);
#line 2850
		if(lstatus != ENOERR)
#line 2850
			status = lstatus;
#line 2850
	}
#line 2850

#line 2850
	if(rndup != 0)
#line 2850
	{
#line 2850
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2850
		xp += X_SIZEOF_USHORT;	
#line 2850
	}
#line 2850
		
#line 2850
	*xpp = (void *)xp;
#line 2850
	return status;
#line 2850
}
#line 2850

int
#line 2851
ncx_pad_putn_ushort_double(void **xpp, size_t nelems, const double *tp)
#line 2851
{
#line 2851
	const size_t rndup = nelems % 2;
#line 2851

#line 2851
	char *xp = (char *) *xpp;
#line 2851
	int status = ENOERR;
#line 2851

#line 2851
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2851
	{
#line 2851
		int lstatus = ncx_put_ushort_double(xp, tp);
#line 2851
		if(lstatus != ENOERR)
#line 2851
			status = lstatus;
#line 2851
	}
#line 2851

#line 2851
	if(rndup != 0)
#line 2851
	{
#line 2851
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2851
		xp += X_SIZEOF_USHORT;	
#line 2851
	}
#line 2851
		
#line 2851
	*xpp = (void *)xp;
#line 2851
	return status;
#line 2851
}
#line 2851

int
#line 2852
ncx_pad_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp)
#line 2852
{
#line 2852
	const size_t rndup = nelems % 2;
#line 2852

#line 2852
	char *xp = (char *) *xpp;
#line 2852
	int status = ENOERR;
#line 2852

#line 2852
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2852
	{
#line 2852
		int lstatus = ncx_put_ushort_uint(xp, tp);
#line 2852
		if(lstatus != ENOERR)
#line 2852
			status = lstatus;
#line 2852
	}
#line 2852

#line 2852
	if(rndup != 0)
#line 2852
	{
#line 2852
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2852
		xp += X_SIZEOF_USHORT;	
#line 2852
	}
#line 2852
		
#line 2852
	*xpp = (void *)xp;
#line 2852
	return status;
#line 2852
}
#line 2852

int
#line 2853
ncx_pad_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2853
{
#line 2853
	const size_t rndup = nelems % 2;
#line 2853

#line 2853
	char *xp = (char *) *xpp;
#line 2853
	int status = ENOERR;
#line 2853

#line 2853
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2853
	{
#line 2853
		int lstatus = ncx_put_ushort_longlong(xp, tp);
#line 2853
		if(lstatus != ENOERR)
#line 2853
			status = lstatus;
#line 2853
	}
#line 2853

#line 2853
	if(rndup != 0)
#line 2853
	{
#line 2853
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2853
		xp += X_SIZEOF_USHORT;	
#line 2853
	}
#line 2853
		
#line 2853
	*xpp = (void *)xp;
#line 2853
	return status;
#line 2853
}
#line 2853

int
#line 2854
ncx_pad_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2854
{
#line 2854
	const size_t rndup = nelems % 2;
#line 2854

#line 2854
	char *xp = (char *) *xpp;
#line 2854
	int status = ENOERR;
#line 2854

#line 2854
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2854
	{
#line 2854
		int lstatus = ncx_put_ushort_ulonglong(xp, tp);
#line 2854
		if(lstatus != ENOERR)
#line 2854
			status = lstatus;
#line 2854
	}
#line 2854

#line 2854
	if(rndup != 0)
#line 2854
	{
#line 2854
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2854
		xp += X_SIZEOF_USHORT;	
#line 2854
	}
#line 2854
		
#line 2854
	*xpp = (void *)xp;
#line 2854
	return status;
#line 2854
}
#line 2854

int
#line 2855
ncx_pad_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2855
{
#line 2855
	const size_t rndup = nelems % 2;
#line 2855

#line 2855
	char *xp = (char *) *xpp;
#line 2855
	int status = ENOERR;
#line 2855

#line 2855
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2855
	{
#line 2855
		int lstatus = ncx_put_ushort_ushort(xp, tp);
#line 2855
		if(lstatus != ENOERR)
#line 2855
			status = lstatus;
#line 2855
	}
#line 2855

#line 2855
	if(rndup != 0)
#line 2855
	{
#line 2855
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2855
		xp += X_SIZEOF_USHORT;	
#line 2855
	}
#line 2855
		
#line 2855
	*xpp = (void *)xp;
#line 2855
	return status;
#line 2855
}
#line 2855



/* int -----------------------------------------------------------------------*/

#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(int));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
#else
int
#line 2874
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
#line 2874
{
#line 2874
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2874

#line 2874
 /* basic algorithm is:
#line 2874
  *   - ensure sane alignment of input data
#line 2874
  *   - copy (conversion happens automatically) input data
#line 2874
  *     to output
#line 2874
  *   - update xpp to point at next unconverted input, and tp to point
#line 2874
  *     at next location for converted output
#line 2874
  */
#line 2874
  long i, j, ni;
#line 2874
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2874
  int *xp;
#line 2874
  int nrange = 0;         /* number of range errors */
#line 2874
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2874
  long cxp = (long) *((char**)xpp);
#line 2874

#line 2874
  realign = (cxp & 7) % SIZEOF_INT;
#line 2874
  /* sjl: manually stripmine so we can limit amount of
#line 2874
   * vector work space reserved to LOOPCNT elements. Also
#line 2874
   * makes vectorisation easy */
#line 2874
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2874
    ni=Min(nelems-j,LOOPCNT);
#line 2874
    if (realign) {
#line 2874
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2874
      xp = tmp;
#line 2874
    } else {
#line 2874
      xp = (int *) *xpp;
#line 2874
    }
#line 2874
   /* copy the next block */
#line 2874
#pragma cdir loopcnt=LOOPCNT
#line 2874
#pragma cdir shortloop
#line 2874
    for (i=0; i<ni; i++) {
#line 2874
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2874
     /* test for range errors (not always needed but do it anyway) */
#line 2874
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2874
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2874
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 2874
    }
#line 2874
   /* update xpp and tp */
#line 2874
    if (realign) xp = (int *) *xpp;
#line 2874
    xp += ni;
#line 2874
    tp += ni;
#line 2874
    *xpp = (void*)xp;
#line 2874
  }
#line 2874
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2874

#line 2874
#else   /* not SX */
#line 2874
	const char *xp = (const char *) *xpp;
#line 2874
	int status = ENOERR;
#line 2874

#line 2874
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2874
	{
#line 2874
		const int lstatus = ncx_get_int_int(xp, tp);
#line 2874
		if(lstatus != ENOERR)
#line 2874
			status = lstatus;
#line 2874
	}
#line 2874

#line 2874
	*xpp = (const void *)xp;
#line 2874
	return status;
#line 2874
#  endif
#line 2874
}
#line 2874

#endif
int
#line 2876
ncx_getn_int_schar(const void **xpp, size_t nelems, schar *tp)
#line 2876
{
#line 2876
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2876

#line 2876
 /* basic algorithm is:
#line 2876
  *   - ensure sane alignment of input data
#line 2876
  *   - copy (conversion happens automatically) input data
#line 2876
  *     to output
#line 2876
  *   - update xpp to point at next unconverted input, and tp to point
#line 2876
  *     at next location for converted output
#line 2876
  */
#line 2876
  long i, j, ni;
#line 2876
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2876
  int *xp;
#line 2876
  int nrange = 0;         /* number of range errors */
#line 2876
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2876
  long cxp = (long) *((char**)xpp);
#line 2876

#line 2876
  realign = (cxp & 7) % SIZEOF_INT;
#line 2876
  /* sjl: manually stripmine so we can limit amount of
#line 2876
   * vector work space reserved to LOOPCNT elements. Also
#line 2876
   * makes vectorisation easy */
#line 2876
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2876
    ni=Min(nelems-j,LOOPCNT);
#line 2876
    if (realign) {
#line 2876
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2876
      xp = tmp;
#line 2876
    } else {
#line 2876
      xp = (int *) *xpp;
#line 2876
    }
#line 2876
   /* copy the next block */
#line 2876
#pragma cdir loopcnt=LOOPCNT
#line 2876
#pragma cdir shortloop
#line 2876
    for (i=0; i<ni; i++) {
#line 2876
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2876
     /* test for range errors (not always needed but do it anyway) */
#line 2876
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2876
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2876
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 2876
    }
#line 2876
   /* update xpp and tp */
#line 2876
    if (realign) xp = (int *) *xpp;
#line 2876
    xp += ni;
#line 2876
    tp += ni;
#line 2876
    *xpp = (void*)xp;
#line 2876
  }
#line 2876
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2876

#line 2876
#else   /* not SX */
#line 2876
	const char *xp = (const char *) *xpp;
#line 2876
	int status = ENOERR;
#line 2876

#line 2876
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2876
	{
#line 2876
		const int lstatus = ncx_get_int_schar(xp, tp);
#line 2876
		if(lstatus != ENOERR)
#line 2876
			status = lstatus;
#line 2876
	}
#line 2876

#line 2876
	*xpp = (const void *)xp;
#line 2876
	return status;
#line 2876
#  endif
#line 2876
}
#line 2876

int
#line 2877
ncx_getn_int_short(const void **xpp, size_t nelems, short *tp)
#line 2877
{
#line 2877
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2877

#line 2877
 /* basic algorithm is:
#line 2877
  *   - ensure sane alignment of input data
#line 2877
  *   - copy (conversion happens automatically) input data
#line 2877
  *     to output
#line 2877
  *   - update xpp to point at next unconverted input, and tp to point
#line 2877
  *     at next location for converted output
#line 2877
  */
#line 2877
  long i, j, ni;
#line 2877
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2877
  int *xp;
#line 2877
  int nrange = 0;         /* number of range errors */
#line 2877
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2877
  long cxp = (long) *((char**)xpp);
#line 2877

#line 2877
  realign = (cxp & 7) % SIZEOF_INT;
#line 2877
  /* sjl: manually stripmine so we can limit amount of
#line 2877
   * vector work space reserved to LOOPCNT elements. Also
#line 2877
   * makes vectorisation easy */
#line 2877
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2877
    ni=Min(nelems-j,LOOPCNT);
#line 2877
    if (realign) {
#line 2877
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2877
      xp = tmp;
#line 2877
    } else {
#line 2877
      xp = (int *) *xpp;
#line 2877
    }
#line 2877
   /* copy the next block */
#line 2877
#pragma cdir loopcnt=LOOPCNT
#line 2877
#pragma cdir shortloop
#line 2877
    for (i=0; i<ni; i++) {
#line 2877
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2877
     /* test for range errors (not always needed but do it anyway) */
#line 2877
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2877
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2877
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 2877
    }
#line 2877
   /* update xpp and tp */
#line 2877
    if (realign) xp = (int *) *xpp;
#line 2877
    xp += ni;
#line 2877
    tp += ni;
#line 2877
    *xpp = (void*)xp;
#line 2877
  }
#line 2877
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2877

#line 2877
#else   /* not SX */
#line 2877
	const char *xp = (const char *) *xpp;
#line 2877
	int status = ENOERR;
#line 2877

#line 2877
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2877
	{
#line 2877
		const int lstatus = ncx_get_int_short(xp, tp);
#line 2877
		if(lstatus != ENOERR)
#line 2877
			status = lstatus;
#line 2877
	}
#line 2877

#line 2877
	*xpp = (const void *)xp;
#line 2877
	return status;
#line 2877
#  endif
#line 2877
}
#line 2877

int
#line 2878
ncx_getn_int_float(const void **xpp, size_t nelems, float *tp)
#line 2878
{
#line 2878
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2878

#line 2878
 /* basic algorithm is:
#line 2878
  *   - ensure sane alignment of input data
#line 2878
  *   - copy (conversion happens automatically) input data
#line 2878
  *     to output
#line 2878
  *   - update xpp to point at next unconverted input, and tp to point
#line 2878
  *     at next location for converted output
#line 2878
  */
#line 2878
  long i, j, ni;
#line 2878
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2878
  int *xp;
#line 2878
  int nrange = 0;         /* number of range errors */
#line 2878
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2878
  long cxp = (long) *((char**)xpp);
#line 2878

#line 2878
  realign = (cxp & 7) % SIZEOF_INT;
#line 2878
  /* sjl: manually stripmine so we can limit amount of
#line 2878
   * vector work space reserved to LOOPCNT elements. Also
#line 2878
   * makes vectorisation easy */
#line 2878
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2878
    ni=Min(nelems-j,LOOPCNT);
#line 2878
    if (realign) {
#line 2878
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2878
      xp = tmp;
#line 2878
    } else {
#line 2878
      xp = (int *) *xpp;
#line 2878
    }
#line 2878
   /* copy the next block */
#line 2878
#pragma cdir loopcnt=LOOPCNT
#line 2878
#pragma cdir shortloop
#line 2878
    for (i=0; i<ni; i++) {
#line 2878
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2878
     /* test for range errors (not always needed but do it anyway) */
#line 2878
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2878
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2878
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 2878
    }
#line 2878
   /* update xpp and tp */
#line 2878
    if (realign) xp = (int *) *xpp;
#line 2878
    xp += ni;
#line 2878
    tp += ni;
#line 2878
    *xpp = (void*)xp;
#line 2878
  }
#line 2878
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2878

#line 2878
#else   /* not SX */
#line 2878
	const char *xp = (const char *) *xpp;
#line 2878
	int status = ENOERR;
#line 2878

#line 2878
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2878
	{
#line 2878
		const int lstatus = ncx_get_int_float(xp, tp);
#line 2878
		if(lstatus != ENOERR)
#line 2878
			status = lstatus;
#line 2878
	}
#line 2878

#line 2878
	*xpp = (const void *)xp;
#line 2878
	return status;
#line 2878
#  endif
#line 2878
}
#line 2878

int
#line 2879
ncx_getn_int_double(const void **xpp, size_t nelems, double *tp)
#line 2879
{
#line 2879
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2879

#line 2879
 /* basic algorithm is:
#line 2879
  *   - ensure sane alignment of input data
#line 2879
  *   - copy (conversion happens automatically) input data
#line 2879
  *     to output
#line 2879
  *   - update xpp to point at next unconverted input, and tp to point
#line 2879
  *     at next location for converted output
#line 2879
  */
#line 2879
  long i, j, ni;
#line 2879
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2879
  int *xp;
#line 2879
  int nrange = 0;         /* number of range errors */
#line 2879
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2879
  long cxp = (long) *((char**)xpp);
#line 2879

#line 2879
  realign = (cxp & 7) % SIZEOF_INT;
#line 2879
  /* sjl: manually stripmine so we can limit amount of
#line 2879
   * vector work space reserved to LOOPCNT elements. Also
#line 2879
   * makes vectorisation easy */
#line 2879
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2879
    ni=Min(nelems-j,LOOPCNT);
#line 2879
    if (realign) {
#line 2879
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2879
      xp = tmp;
#line 2879
    } else {
#line 2879
      xp = (int *) *xpp;
#line 2879
    }
#line 2879
   /* copy the next block */
#line 2879
#pragma cdir loopcnt=LOOPCNT
#line 2879
#pragma cdir shortloop
#line 2879
    for (i=0; i<ni; i++) {
#line 2879
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2879
     /* test for range errors (not always needed but do it anyway) */
#line 2879
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2879
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2879
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 2879
    }
#line 2879
   /* update xpp and tp */
#line 2879
    if (realign) xp = (int *) *xpp;
#line 2879
    xp += ni;
#line 2879
    tp += ni;
#line 2879
    *xpp = (void*)xp;
#line 2879
  }
#line 2879
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2879

#line 2879
#else   /* not SX */
#line 2879
	const char *xp = (const char *) *xpp;
#line 2879
	int status = ENOERR;
#line 2879

#line 2879
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2879
	{
#line 2879
		const int lstatus = ncx_get_int_double(xp, tp);
#line 2879
		if(lstatus != ENOERR)
#line 2879
			status = lstatus;
#line 2879
	}
#line 2879

#line 2879
	*xpp = (const void *)xp;
#line 2879
	return status;
#line 2879
#  endif
#line 2879
}
#line 2879

int
#line 2880
ncx_getn_int_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2880
{
#line 2880
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2880

#line 2880
 /* basic algorithm is:
#line 2880
  *   - ensure sane alignment of input data
#line 2880
  *   - copy (conversion happens automatically) input data
#line 2880
  *     to output
#line 2880
  *   - update xpp to point at next unconverted input, and tp to point
#line 2880
  *     at next location for converted output
#line 2880
  */
#line 2880
  long i, j, ni;
#line 2880
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2880
  int *xp;
#line 2880
  int nrange = 0;         /* number of range errors */
#line 2880
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2880
  long cxp = (long) *((char**)xpp);
#line 2880

#line 2880
  realign = (cxp & 7) % SIZEOF_INT;
#line 2880
  /* sjl: manually stripmine so we can limit amount of
#line 2880
   * vector work space reserved to LOOPCNT elements. Also
#line 2880
   * makes vectorisation easy */
#line 2880
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2880
    ni=Min(nelems-j,LOOPCNT);
#line 2880
    if (realign) {
#line 2880
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2880
      xp = tmp;
#line 2880
    } else {
#line 2880
      xp = (int *) *xpp;
#line 2880
    }
#line 2880
   /* copy the next block */
#line 2880
#pragma cdir loopcnt=LOOPCNT
#line 2880
#pragma cdir shortloop
#line 2880
    for (i=0; i<ni; i++) {
#line 2880
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2880
     /* test for range errors (not always needed but do it anyway) */
#line 2880
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2880
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2880
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 2880
    }
#line 2880
   /* update xpp and tp */
#line 2880
    if (realign) xp = (int *) *xpp;
#line 2880
    xp += ni;
#line 2880
    tp += ni;
#line 2880
    *xpp = (void*)xp;
#line 2880
  }
#line 2880
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2880

#line 2880
#else   /* not SX */
#line 2880
	const char *xp = (const char *) *xpp;
#line 2880
	int status = ENOERR;
#line 2880

#line 2880
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2880
	{
#line 2880
		const int lstatus = ncx_get_int_longlong(xp, tp);
#line 2880
		if(lstatus != ENOERR)
#line 2880
			status = lstatus;
#line 2880
	}
#line 2880

#line 2880
	*xpp = (const void *)xp;
#line 2880
	return status;
#line 2880
#  endif
#line 2880
}
#line 2880

int
#line 2881
ncx_getn_int_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2881
{
#line 2881
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2881

#line 2881
 /* basic algorithm is:
#line 2881
  *   - ensure sane alignment of input data
#line 2881
  *   - copy (conversion happens automatically) input data
#line 2881
  *     to output
#line 2881
  *   - update xpp to point at next unconverted input, and tp to point
#line 2881
  *     at next location for converted output
#line 2881
  */
#line 2881
  long i, j, ni;
#line 2881
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2881
  int *xp;
#line 2881
  int nrange = 0;         /* number of range errors */
#line 2881
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2881
  long cxp = (long) *((char**)xpp);
#line 2881

#line 2881
  realign = (cxp & 7) % SIZEOF_INT;
#line 2881
  /* sjl: manually stripmine so we can limit amount of
#line 2881
   * vector work space reserved to LOOPCNT elements. Also
#line 2881
   * makes vectorisation easy */
#line 2881
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2881
    ni=Min(nelems-j,LOOPCNT);
#line 2881
    if (realign) {
#line 2881
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2881
      xp = tmp;
#line 2881
    } else {
#line 2881
      xp = (int *) *xpp;
#line 2881
    }
#line 2881
   /* copy the next block */
#line 2881
#pragma cdir loopcnt=LOOPCNT
#line 2881
#pragma cdir shortloop
#line 2881
    for (i=0; i<ni; i++) {
#line 2881
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2881
     /* test for range errors (not always needed but do it anyway) */
#line 2881
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2881
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2881
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 2881
    }
#line 2881
   /* update xpp and tp */
#line 2881
    if (realign) xp = (int *) *xpp;
#line 2881
    xp += ni;
#line 2881
    tp += ni;
#line 2881
    *xpp = (void*)xp;
#line 2881
  }
#line 2881
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2881

#line 2881
#else   /* not SX */
#line 2881
	const char *xp = (const char *) *xpp;
#line 2881
	int status = ENOERR;
#line 2881

#line 2881
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2881
	{
#line 2881
		const int lstatus = ncx_get_int_uchar(xp, tp);
#line 2881
		if(lstatus != ENOERR)
#line 2881
			status = lstatus;
#line 2881
	}
#line 2881

#line 2881
	*xpp = (const void *)xp;
#line 2881
	return status;
#line 2881
#  endif
#line 2881
}
#line 2881

int
#line 2882
ncx_getn_int_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2882
{
#line 2882
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2882

#line 2882
 /* basic algorithm is:
#line 2882
  *   - ensure sane alignment of input data
#line 2882
  *   - copy (conversion happens automatically) input data
#line 2882
  *     to output
#line 2882
  *   - update xpp to point at next unconverted input, and tp to point
#line 2882
  *     at next location for converted output
#line 2882
  */
#line 2882
  long i, j, ni;
#line 2882
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2882
  int *xp;
#line 2882
  int nrange = 0;         /* number of range errors */
#line 2882
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2882
  long cxp = (long) *((char**)xpp);
#line 2882

#line 2882
  realign = (cxp & 7) % SIZEOF_INT;
#line 2882
  /* sjl: manually stripmine so we can limit amount of
#line 2882
   * vector work space reserved to LOOPCNT elements. Also
#line 2882
   * makes vectorisation easy */
#line 2882
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2882
    ni=Min(nelems-j,LOOPCNT);
#line 2882
    if (realign) {
#line 2882
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2882
      xp = tmp;
#line 2882
    } else {
#line 2882
      xp = (int *) *xpp;
#line 2882
    }
#line 2882
   /* copy the next block */
#line 2882
#pragma cdir loopcnt=LOOPCNT
#line 2882
#pragma cdir shortloop
#line 2882
    for (i=0; i<ni; i++) {
#line 2882
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2882
     /* test for range errors (not always needed but do it anyway) */
#line 2882
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2882
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2882
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 2882
    }
#line 2882
   /* update xpp and tp */
#line 2882
    if (realign) xp = (int *) *xpp;
#line 2882
    xp += ni;
#line 2882
    tp += ni;
#line 2882
    *xpp = (void*)xp;
#line 2882
  }
#line 2882
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2882

#line 2882
#else   /* not SX */
#line 2882
	const char *xp = (const char *) *xpp;
#line 2882
	int status = ENOERR;
#line 2882

#line 2882
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2882
	{
#line 2882
		const int lstatus = ncx_get_int_ushort(xp, tp);
#line 2882
		if(lstatus != ENOERR)
#line 2882
			status = lstatus;
#line 2882
	}
#line 2882

#line 2882
	*xpp = (const void *)xp;
#line 2882
	return status;
#line 2882
#  endif
#line 2882
}
#line 2882

int
#line 2883
ncx_getn_int_uint(const void **xpp, size_t nelems, uint *tp)
#line 2883
{
#line 2883
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2883

#line 2883
 /* basic algorithm is:
#line 2883
  *   - ensure sane alignment of input data
#line 2883
  *   - copy (conversion happens automatically) input data
#line 2883
  *     to output
#line 2883
  *   - update xpp to point at next unconverted input, and tp to point
#line 2883
  *     at next location for converted output
#line 2883
  */
#line 2883
  long i, j, ni;
#line 2883
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2883
  int *xp;
#line 2883
  int nrange = 0;         /* number of range errors */
#line 2883
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2883
  long cxp = (long) *((char**)xpp);
#line 2883

#line 2883
  realign = (cxp & 7) % SIZEOF_INT;
#line 2883
  /* sjl: manually stripmine so we can limit amount of
#line 2883
   * vector work space reserved to LOOPCNT elements. Also
#line 2883
   * makes vectorisation easy */
#line 2883
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2883
    ni=Min(nelems-j,LOOPCNT);
#line 2883
    if (realign) {
#line 2883
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2883
      xp = tmp;
#line 2883
    } else {
#line 2883
      xp = (int *) *xpp;
#line 2883
    }
#line 2883
   /* copy the next block */
#line 2883
#pragma cdir loopcnt=LOOPCNT
#line 2883
#pragma cdir shortloop
#line 2883
    for (i=0; i<ni; i++) {
#line 2883
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2883
     /* test for range errors (not always needed but do it anyway) */
#line 2883
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2883
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2883
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 2883
    }
#line 2883
   /* update xpp and tp */
#line 2883
    if (realign) xp = (int *) *xpp;
#line 2883
    xp += ni;
#line 2883
    tp += ni;
#line 2883
    *xpp = (void*)xp;
#line 2883
  }
#line 2883
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2883

#line 2883
#else   /* not SX */
#line 2883
	const char *xp = (const char *) *xpp;
#line 2883
	int status = ENOERR;
#line 2883

#line 2883
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2883
	{
#line 2883
		const int lstatus = ncx_get_int_uint(xp, tp);
#line 2883
		if(lstatus != ENOERR)
#line 2883
			status = lstatus;
#line 2883
	}
#line 2883

#line 2883
	*xpp = (const void *)xp;
#line 2883
	return status;
#line 2883
#  endif
#line 2883
}
#line 2883

int
#line 2884
ncx_getn_int_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2884
{
#line 2884
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2884

#line 2884
 /* basic algorithm is:
#line 2884
  *   - ensure sane alignment of input data
#line 2884
  *   - copy (conversion happens automatically) input data
#line 2884
  *     to output
#line 2884
  *   - update xpp to point at next unconverted input, and tp to point
#line 2884
  *     at next location for converted output
#line 2884
  */
#line 2884
  long i, j, ni;
#line 2884
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2884
  int *xp;
#line 2884
  int nrange = 0;         /* number of range errors */
#line 2884
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2884
  long cxp = (long) *((char**)xpp);
#line 2884

#line 2884
  realign = (cxp & 7) % SIZEOF_INT;
#line 2884
  /* sjl: manually stripmine so we can limit amount of
#line 2884
   * vector work space reserved to LOOPCNT elements. Also
#line 2884
   * makes vectorisation easy */
#line 2884
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2884
    ni=Min(nelems-j,LOOPCNT);
#line 2884
    if (realign) {
#line 2884
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2884
      xp = tmp;
#line 2884
    } else {
#line 2884
      xp = (int *) *xpp;
#line 2884
    }
#line 2884
   /* copy the next block */
#line 2884
#pragma cdir loopcnt=LOOPCNT
#line 2884
#pragma cdir shortloop
#line 2884
    for (i=0; i<ni; i++) {
#line 2884
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2884
     /* test for range errors (not always needed but do it anyway) */
#line 2884
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2884
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2884
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 2884
    }
#line 2884
   /* update xpp and tp */
#line 2884
    if (realign) xp = (int *) *xpp;
#line 2884
    xp += ni;
#line 2884
    tp += ni;
#line 2884
    *xpp = (void*)xp;
#line 2884
  }
#line 2884
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2884

#line 2884
#else   /* not SX */
#line 2884
	const char *xp = (const char *) *xpp;
#line 2884
	int status = ENOERR;
#line 2884

#line 2884
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2884
	{
#line 2884
		const int lstatus = ncx_get_int_ulonglong(xp, tp);
#line 2884
		if(lstatus != ENOERR)
#line 2884
			status = lstatus;
#line 2884
	}
#line 2884

#line 2884
	*xpp = (const void *)xp;
#line 2884
	return status;
#line 2884
#  endif
#line 2884
}
#line 2884


#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_INT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
#else
int
#line 2900
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp)
#line 2900
{
#line 2900
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2900

#line 2900
 /* basic algorithm is:
#line 2900
  *   - ensure sane alignment of output data
#line 2900
  *   - copy (conversion happens automatically) input data
#line 2900
  *     to output
#line 2900
  *   - update tp to point at next unconverted input, and xpp to point
#line 2900
  *     at next location for converted output
#line 2900
  */
#line 2900
  long i, j, ni;
#line 2900
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2900
  int *xp;
#line 2900
  int nrange = 0;         /* number of range errors */
#line 2900
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2900
  long cxp = (long) *((char**)xpp);
#line 2900

#line 2900
  realign = (cxp & 7) % SIZEOF_INT;
#line 2900
  /* sjl: manually stripmine so we can limit amount of
#line 2900
   * vector work space reserved to LOOPCNT elements. Also
#line 2900
   * makes vectorisation easy */
#line 2900
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2900
    ni=Min(nelems-j,LOOPCNT);
#line 2900
    if (realign) {
#line 2900
      xp = tmp;
#line 2900
    } else {
#line 2900
      xp = (int *) *xpp;
#line 2900
    }
#line 2900
   /* copy the next block */
#line 2900
#pragma cdir loopcnt=LOOPCNT
#line 2900
#pragma cdir shortloop
#line 2900
    for (i=0; i<ni; i++) {
#line 2900
      /* the normal case: */
#line 2900
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2900
     /* test for range errors (not always needed but do it anyway) */
#line 2900
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2900
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2900
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2900
    }
#line 2900
   /* copy workspace back if necessary */ 
#line 2900
    if (realign) {
#line 2900
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2900
      xp = (int *) *xpp;
#line 2900
    }
#line 2900
   /* update xpp and tp */
#line 2900
    xp += ni;
#line 2900
    tp += ni;
#line 2900
    *xpp = (void*)xp;
#line 2900
  }
#line 2900
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2900

#line 2900
#else   /* not SX */
#line 2900

#line 2900
	char *xp = (char *) *xpp;
#line 2900
	int status = ENOERR;
#line 2900

#line 2900
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2900
	{
#line 2900
		int lstatus = ncx_put_int_int(xp, tp);
#line 2900
		if(lstatus != ENOERR)
#line 2900
			status = lstatus;
#line 2900
	}
#line 2900

#line 2900
	*xpp = (void *)xp;
#line 2900
	return status;
#line 2900
#endif
#line 2900
}
#line 2900

#endif
int
#line 2902
ncx_putn_int_schar(void **xpp, size_t nelems, const schar *tp)
#line 2902
{
#line 2902
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2902

#line 2902
 /* basic algorithm is:
#line 2902
  *   - ensure sane alignment of output data
#line 2902
  *   - copy (conversion happens automatically) input data
#line 2902
  *     to output
#line 2902
  *   - update tp to point at next unconverted input, and xpp to point
#line 2902
  *     at next location for converted output
#line 2902
  */
#line 2902
  long i, j, ni;
#line 2902
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2902
  int *xp;
#line 2902
  int nrange = 0;         /* number of range errors */
#line 2902
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2902
  long cxp = (long) *((char**)xpp);
#line 2902

#line 2902
  realign = (cxp & 7) % SIZEOF_INT;
#line 2902
  /* sjl: manually stripmine so we can limit amount of
#line 2902
   * vector work space reserved to LOOPCNT elements. Also
#line 2902
   * makes vectorisation easy */
#line 2902
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2902
    ni=Min(nelems-j,LOOPCNT);
#line 2902
    if (realign) {
#line 2902
      xp = tmp;
#line 2902
    } else {
#line 2902
      xp = (int *) *xpp;
#line 2902
    }
#line 2902
   /* copy the next block */
#line 2902
#pragma cdir loopcnt=LOOPCNT
#line 2902
#pragma cdir shortloop
#line 2902
    for (i=0; i<ni; i++) {
#line 2902
      /* the normal case: */
#line 2902
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2902
     /* test for range errors (not always needed but do it anyway) */
#line 2902
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2902
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2902
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2902
    }
#line 2902
   /* copy workspace back if necessary */ 
#line 2902
    if (realign) {
#line 2902
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2902
      xp = (int *) *xpp;
#line 2902
    }
#line 2902
   /* update xpp and tp */
#line 2902
    xp += ni;
#line 2902
    tp += ni;
#line 2902
    *xpp = (void*)xp;
#line 2902
  }
#line 2902
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2902

#line 2902
#else   /* not SX */
#line 2902

#line 2902
	char *xp = (char *) *xpp;
#line 2902
	int status = ENOERR;
#line 2902

#line 2902
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2902
	{
#line 2902
		int lstatus = ncx_put_int_schar(xp, tp);
#line 2902
		if(lstatus != ENOERR)
#line 2902
			status = lstatus;
#line 2902
	}
#line 2902

#line 2902
	*xpp = (void *)xp;
#line 2902
	return status;
#line 2902
#endif
#line 2902
}
#line 2902

int
#line 2903
ncx_putn_int_short(void **xpp, size_t nelems, const short *tp)
#line 2903
{
#line 2903
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2903

#line 2903
 /* basic algorithm is:
#line 2903
  *   - ensure sane alignment of output data
#line 2903
  *   - copy (conversion happens automatically) input data
#line 2903
  *     to output
#line 2903
  *   - update tp to point at next unconverted input, and xpp to point
#line 2903
  *     at next location for converted output
#line 2903
  */
#line 2903
  long i, j, ni;
#line 2903
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2903
  int *xp;
#line 2903
  int nrange = 0;         /* number of range errors */
#line 2903
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2903
  long cxp = (long) *((char**)xpp);
#line 2903

#line 2903
  realign = (cxp & 7) % SIZEOF_INT;
#line 2903
  /* sjl: manually stripmine so we can limit amount of
#line 2903
   * vector work space reserved to LOOPCNT elements. Also
#line 2903
   * makes vectorisation easy */
#line 2903
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2903
    ni=Min(nelems-j,LOOPCNT);
#line 2903
    if (realign) {
#line 2903
      xp = tmp;
#line 2903
    } else {
#line 2903
      xp = (int *) *xpp;
#line 2903
    }
#line 2903
   /* copy the next block */
#line 2903
#pragma cdir loopcnt=LOOPCNT
#line 2903
#pragma cdir shortloop
#line 2903
    for (i=0; i<ni; i++) {
#line 2903
      /* the normal case: */
#line 2903
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2903
     /* test for range errors (not always needed but do it anyway) */
#line 2903
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2903
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2903
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2903
    }
#line 2903
   /* copy workspace back if necessary */ 
#line 2903
    if (realign) {
#line 2903
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2903
      xp = (int *) *xpp;
#line 2903
    }
#line 2903
   /* update xpp and tp */
#line 2903
    xp += ni;
#line 2903
    tp += ni;
#line 2903
    *xpp = (void*)xp;
#line 2903
  }
#line 2903
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2903

#line 2903
#else   /* not SX */
#line 2903

#line 2903
	char *xp = (char *) *xpp;
#line 2903
	int status = ENOERR;
#line 2903

#line 2903
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2903
	{
#line 2903
		int lstatus = ncx_put_int_short(xp, tp);
#line 2903
		if(lstatus != ENOERR)
#line 2903
			status = lstatus;
#line 2903
	}
#line 2903

#line 2903
	*xpp = (void *)xp;
#line 2903
	return status;
#line 2903
#endif
#line 2903
}
#line 2903

int
#line 2904
ncx_putn_int_float(void **xpp, size_t nelems, const float *tp)
#line 2904
{
#line 2904
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2904

#line 2904
 /* basic algorithm is:
#line 2904
  *   - ensure sane alignment of output data
#line 2904
  *   - copy (conversion happens automatically) input data
#line 2904
  *     to output
#line 2904
  *   - update tp to point at next unconverted input, and xpp to point
#line 2904
  *     at next location for converted output
#line 2904
  */
#line 2904
  long i, j, ni;
#line 2904
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2904
  int *xp;
#line 2904
  double d;               /* special case for ncx_putn_int_float */
#line 2904
  int nrange = 0;         /* number of range errors */
#line 2904
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2904
  long cxp = (long) *((char**)xpp);
#line 2904

#line 2904
  realign = (cxp & 7) % SIZEOF_INT;
#line 2904
  /* sjl: manually stripmine so we can limit amount of
#line 2904
   * vector work space reserved to LOOPCNT elements. Also
#line 2904
   * makes vectorisation easy */
#line 2904
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2904
    ni=Min(nelems-j,LOOPCNT);
#line 2904
    if (realign) {
#line 2904
      xp = tmp;
#line 2904
    } else {
#line 2904
      xp = (int *) *xpp;
#line 2904
    }
#line 2904
   /* copy the next block */
#line 2904
#pragma cdir loopcnt=LOOPCNT
#line 2904
#pragma cdir shortloop
#line 2904
    for (i=0; i<ni; i++) {
#line 2904
      /* for some reason int to float, for putn, requires a special case */ 
#line 2904
      d = tp[i];
#line 2904
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) d));
#line 2904
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2904
    }
#line 2904
   /* copy workspace back if necessary */ 
#line 2904
    if (realign) {
#line 2904
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2904
      xp = (int *) *xpp;
#line 2904
    }
#line 2904
   /* update xpp and tp */
#line 2904
    xp += ni;
#line 2904
    tp += ni;
#line 2904
    *xpp = (void*)xp;
#line 2904
  }
#line 2904
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2904

#line 2904
#else   /* not SX */
#line 2904

#line 2904
	char *xp = (char *) *xpp;
#line 2904
	int status = ENOERR;
#line 2904

#line 2904
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2904
	{
#line 2904
		int lstatus = ncx_put_int_float(xp, tp);
#line 2904
		if(lstatus != ENOERR)
#line 2904
			status = lstatus;
#line 2904
	}
#line 2904

#line 2904
	*xpp = (void *)xp;
#line 2904
	return status;
#line 2904
#endif
#line 2904
}
#line 2904

int
#line 2905
ncx_putn_int_double(void **xpp, size_t nelems, const double *tp)
#line 2905
{
#line 2905
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2905

#line 2905
 /* basic algorithm is:
#line 2905
  *   - ensure sane alignment of output data
#line 2905
  *   - copy (conversion happens automatically) input data
#line 2905
  *     to output
#line 2905
  *   - update tp to point at next unconverted input, and xpp to point
#line 2905
  *     at next location for converted output
#line 2905
  */
#line 2905
  long i, j, ni;
#line 2905
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2905
  int *xp;
#line 2905
  int nrange = 0;         /* number of range errors */
#line 2905
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2905
  long cxp = (long) *((char**)xpp);
#line 2905

#line 2905
  realign = (cxp & 7) % SIZEOF_INT;
#line 2905
  /* sjl: manually stripmine so we can limit amount of
#line 2905
   * vector work space reserved to LOOPCNT elements. Also
#line 2905
   * makes vectorisation easy */
#line 2905
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2905
    ni=Min(nelems-j,LOOPCNT);
#line 2905
    if (realign) {
#line 2905
      xp = tmp;
#line 2905
    } else {
#line 2905
      xp = (int *) *xpp;
#line 2905
    }
#line 2905
   /* copy the next block */
#line 2905
#pragma cdir loopcnt=LOOPCNT
#line 2905
#pragma cdir shortloop
#line 2905
    for (i=0; i<ni; i++) {
#line 2905
      /* the normal case: */
#line 2905
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2905
     /* test for range errors (not always needed but do it anyway) */
#line 2905
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2905
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2905
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2905
    }
#line 2905
   /* copy workspace back if necessary */ 
#line 2905
    if (realign) {
#line 2905
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2905
      xp = (int *) *xpp;
#line 2905
    }
#line 2905
   /* update xpp and tp */
#line 2905
    xp += ni;
#line 2905
    tp += ni;
#line 2905
    *xpp = (void*)xp;
#line 2905
  }
#line 2905
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2905

#line 2905
#else   /* not SX */
#line 2905

#line 2905
	char *xp = (char *) *xpp;
#line 2905
	int status = ENOERR;
#line 2905

#line 2905
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2905
	{
#line 2905
		int lstatus = ncx_put_int_double(xp, tp);
#line 2905
		if(lstatus != ENOERR)
#line 2905
			status = lstatus;
#line 2905
	}
#line 2905

#line 2905
	*xpp = (void *)xp;
#line 2905
	return status;
#line 2905
#endif
#line 2905
}
#line 2905

int
#line 2906
ncx_putn_int_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2906
{
#line 2906
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2906

#line 2906
 /* basic algorithm is:
#line 2906
  *   - ensure sane alignment of output data
#line 2906
  *   - copy (conversion happens automatically) input data
#line 2906
  *     to output
#line 2906
  *   - update tp to point at next unconverted input, and xpp to point
#line 2906
  *     at next location for converted output
#line 2906
  */
#line 2906
  long i, j, ni;
#line 2906
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2906
  int *xp;
#line 2906
  int nrange = 0;         /* number of range errors */
#line 2906
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2906
  long cxp = (long) *((char**)xpp);
#line 2906

#line 2906
  realign = (cxp & 7) % SIZEOF_INT;
#line 2906
  /* sjl: manually stripmine so we can limit amount of
#line 2906
   * vector work space reserved to LOOPCNT elements. Also
#line 2906
   * makes vectorisation easy */
#line 2906
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2906
    ni=Min(nelems-j,LOOPCNT);
#line 2906
    if (realign) {
#line 2906
      xp = tmp;
#line 2906
    } else {
#line 2906
      xp = (int *) *xpp;
#line 2906
    }
#line 2906
   /* copy the next block */
#line 2906
#pragma cdir loopcnt=LOOPCNT
#line 2906
#pragma cdir shortloop
#line 2906
    for (i=0; i<ni; i++) {
#line 2906
      /* the normal case: */
#line 2906
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2906
     /* test for range errors (not always needed but do it anyway) */
#line 2906
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2906
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2906
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2906
    }
#line 2906
   /* copy workspace back if necessary */ 
#line 2906
    if (realign) {
#line 2906
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2906
      xp = (int *) *xpp;
#line 2906
    }
#line 2906
   /* update xpp and tp */
#line 2906
    xp += ni;
#line 2906
    tp += ni;
#line 2906
    *xpp = (void*)xp;
#line 2906
  }
#line 2906
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2906

#line 2906
#else   /* not SX */
#line 2906

#line 2906
	char *xp = (char *) *xpp;
#line 2906
	int status = ENOERR;
#line 2906

#line 2906
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2906
	{
#line 2906
		int lstatus = ncx_put_int_longlong(xp, tp);
#line 2906
		if(lstatus != ENOERR)
#line 2906
			status = lstatus;
#line 2906
	}
#line 2906

#line 2906
	*xpp = (void *)xp;
#line 2906
	return status;
#line 2906
#endif
#line 2906
}
#line 2906

int
#line 2907
ncx_putn_int_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2907
{
#line 2907
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2907

#line 2907
 /* basic algorithm is:
#line 2907
  *   - ensure sane alignment of output data
#line 2907
  *   - copy (conversion happens automatically) input data
#line 2907
  *     to output
#line 2907
  *   - update tp to point at next unconverted input, and xpp to point
#line 2907
  *     at next location for converted output
#line 2907
  */
#line 2907
  long i, j, ni;
#line 2907
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2907
  int *xp;
#line 2907
  int nrange = 0;         /* number of range errors */
#line 2907
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2907
  long cxp = (long) *((char**)xpp);
#line 2907

#line 2907
  realign = (cxp & 7) % SIZEOF_INT;
#line 2907
  /* sjl: manually stripmine so we can limit amount of
#line 2907
   * vector work space reserved to LOOPCNT elements. Also
#line 2907
   * makes vectorisation easy */
#line 2907
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2907
    ni=Min(nelems-j,LOOPCNT);
#line 2907
    if (realign) {
#line 2907
      xp = tmp;
#line 2907
    } else {
#line 2907
      xp = (int *) *xpp;
#line 2907
    }
#line 2907
   /* copy the next block */
#line 2907
#pragma cdir loopcnt=LOOPCNT
#line 2907
#pragma cdir shortloop
#line 2907
    for (i=0; i<ni; i++) {
#line 2907
      /* the normal case: */
#line 2907
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2907
     /* test for range errors (not always needed but do it anyway) */
#line 2907
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2907
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2907
      nrange += tp[i] > X_INT_MAX ;
#line 2907
    }
#line 2907
   /* copy workspace back if necessary */ 
#line 2907
    if (realign) {
#line 2907
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2907
      xp = (int *) *xpp;
#line 2907
    }
#line 2907
   /* update xpp and tp */
#line 2907
    xp += ni;
#line 2907
    tp += ni;
#line 2907
    *xpp = (void*)xp;
#line 2907
  }
#line 2907
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2907

#line 2907
#else   /* not SX */
#line 2907

#line 2907
	char *xp = (char *) *xpp;
#line 2907
	int status = ENOERR;
#line 2907

#line 2907
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2907
	{
#line 2907
		int lstatus = ncx_put_int_uchar(xp, tp);
#line 2907
		if(lstatus != ENOERR)
#line 2907
			status = lstatus;
#line 2907
	}
#line 2907

#line 2907
	*xpp = (void *)xp;
#line 2907
	return status;
#line 2907
#endif
#line 2907
}
#line 2907

int
#line 2908
ncx_putn_int_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2908
{
#line 2908
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2908

#line 2908
 /* basic algorithm is:
#line 2908
  *   - ensure sane alignment of output data
#line 2908
  *   - copy (conversion happens automatically) input data
#line 2908
  *     to output
#line 2908
  *   - update tp to point at next unconverted input, and xpp to point
#line 2908
  *     at next location for converted output
#line 2908
  */
#line 2908
  long i, j, ni;
#line 2908
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2908
  int *xp;
#line 2908
  int nrange = 0;         /* number of range errors */
#line 2908
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2908
  long cxp = (long) *((char**)xpp);
#line 2908

#line 2908
  realign = (cxp & 7) % SIZEOF_INT;
#line 2908
  /* sjl: manually stripmine so we can limit amount of
#line 2908
   * vector work space reserved to LOOPCNT elements. Also
#line 2908
   * makes vectorisation easy */
#line 2908
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2908
    ni=Min(nelems-j,LOOPCNT);
#line 2908
    if (realign) {
#line 2908
      xp = tmp;
#line 2908
    } else {
#line 2908
      xp = (int *) *xpp;
#line 2908
    }
#line 2908
   /* copy the next block */
#line 2908
#pragma cdir loopcnt=LOOPCNT
#line 2908
#pragma cdir shortloop
#line 2908
    for (i=0; i<ni; i++) {
#line 2908
      /* the normal case: */
#line 2908
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2908
     /* test for range errors (not always needed but do it anyway) */
#line 2908
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2908
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2908
      nrange += tp[i] > X_INT_MAX ;
#line 2908
    }
#line 2908
   /* copy workspace back if necessary */ 
#line 2908
    if (realign) {
#line 2908
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2908
      xp = (int *) *xpp;
#line 2908
    }
#line 2908
   /* update xpp and tp */
#line 2908
    xp += ni;
#line 2908
    tp += ni;
#line 2908
    *xpp = (void*)xp;
#line 2908
  }
#line 2908
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2908

#line 2908
#else   /* not SX */
#line 2908

#line 2908
	char *xp = (char *) *xpp;
#line 2908
	int status = ENOERR;
#line 2908

#line 2908
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2908
	{
#line 2908
		int lstatus = ncx_put_int_ushort(xp, tp);
#line 2908
		if(lstatus != ENOERR)
#line 2908
			status = lstatus;
#line 2908
	}
#line 2908

#line 2908
	*xpp = (void *)xp;
#line 2908
	return status;
#line 2908
#endif
#line 2908
}
#line 2908

int
#line 2909
ncx_putn_int_uint(void **xpp, size_t nelems, const uint *tp)
#line 2909
{
#line 2909
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2909

#line 2909
 /* basic algorithm is:
#line 2909
  *   - ensure sane alignment of output data
#line 2909
  *   - copy (conversion happens automatically) input data
#line 2909
  *     to output
#line 2909
  *   - update tp to point at next unconverted input, and xpp to point
#line 2909
  *     at next location for converted output
#line 2909
  */
#line 2909
  long i, j, ni;
#line 2909
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2909
  int *xp;
#line 2909
  int nrange = 0;         /* number of range errors */
#line 2909
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2909
  long cxp = (long) *((char**)xpp);
#line 2909

#line 2909
  realign = (cxp & 7) % SIZEOF_INT;
#line 2909
  /* sjl: manually stripmine so we can limit amount of
#line 2909
   * vector work space reserved to LOOPCNT elements. Also
#line 2909
   * makes vectorisation easy */
#line 2909
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2909
    ni=Min(nelems-j,LOOPCNT);
#line 2909
    if (realign) {
#line 2909
      xp = tmp;
#line 2909
    } else {
#line 2909
      xp = (int *) *xpp;
#line 2909
    }
#line 2909
   /* copy the next block */
#line 2909
#pragma cdir loopcnt=LOOPCNT
#line 2909
#pragma cdir shortloop
#line 2909
    for (i=0; i<ni; i++) {
#line 2909
      /* the normal case: */
#line 2909
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2909
     /* test for range errors (not always needed but do it anyway) */
#line 2909
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2909
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2909
      nrange += tp[i] > X_INT_MAX ;
#line 2909
    }
#line 2909
   /* copy workspace back if necessary */ 
#line 2909
    if (realign) {
#line 2909
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2909
      xp = (int *) *xpp;
#line 2909
    }
#line 2909
   /* update xpp and tp */
#line 2909
    xp += ni;
#line 2909
    tp += ni;
#line 2909
    *xpp = (void*)xp;
#line 2909
  }
#line 2909
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2909

#line 2909
#else   /* not SX */
#line 2909

#line 2909
	char *xp = (char *) *xpp;
#line 2909
	int status = ENOERR;
#line 2909

#line 2909
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2909
	{
#line 2909
		int lstatus = ncx_put_int_uint(xp, tp);
#line 2909
		if(lstatus != ENOERR)
#line 2909
			status = lstatus;
#line 2909
	}
#line 2909

#line 2909
	*xpp = (void *)xp;
#line 2909
	return status;
#line 2909
#endif
#line 2909
}
#line 2909

int
#line 2910
ncx_putn_int_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2910
{
#line 2910
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2910

#line 2910
 /* basic algorithm is:
#line 2910
  *   - ensure sane alignment of output data
#line 2910
  *   - copy (conversion happens automatically) input data
#line 2910
  *     to output
#line 2910
  *   - update tp to point at next unconverted input, and xpp to point
#line 2910
  *     at next location for converted output
#line 2910
  */
#line 2910
  long i, j, ni;
#line 2910
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2910
  int *xp;
#line 2910
  int nrange = 0;         /* number of range errors */
#line 2910
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2910
  long cxp = (long) *((char**)xpp);
#line 2910

#line 2910
  realign = (cxp & 7) % SIZEOF_INT;
#line 2910
  /* sjl: manually stripmine so we can limit amount of
#line 2910
   * vector work space reserved to LOOPCNT elements. Also
#line 2910
   * makes vectorisation easy */
#line 2910
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2910
    ni=Min(nelems-j,LOOPCNT);
#line 2910
    if (realign) {
#line 2910
      xp = tmp;
#line 2910
    } else {
#line 2910
      xp = (int *) *xpp;
#line 2910
    }
#line 2910
   /* copy the next block */
#line 2910
#pragma cdir loopcnt=LOOPCNT
#line 2910
#pragma cdir shortloop
#line 2910
    for (i=0; i<ni; i++) {
#line 2910
      /* the normal case: */
#line 2910
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2910
     /* test for range errors (not always needed but do it anyway) */
#line 2910
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2910
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2910
      nrange += tp[i] > X_INT_MAX ;
#line 2910
    }
#line 2910
   /* copy workspace back if necessary */ 
#line 2910
    if (realign) {
#line 2910
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2910
      xp = (int *) *xpp;
#line 2910
    }
#line 2910
   /* update xpp and tp */
#line 2910
    xp += ni;
#line 2910
    tp += ni;
#line 2910
    *xpp = (void*)xp;
#line 2910
  }
#line 2910
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2910

#line 2910
#else   /* not SX */
#line 2910

#line 2910
	char *xp = (char *) *xpp;
#line 2910
	int status = ENOERR;
#line 2910

#line 2910
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2910
	{
#line 2910
		int lstatus = ncx_put_int_ulonglong(xp, tp);
#line 2910
		if(lstatus != ENOERR)
#line 2910
			status = lstatus;
#line 2910
	}
#line 2910

#line 2910
	*xpp = (void *)xp;
#line 2910
	return status;
#line 2910
#endif
#line 2910
}
#line 2910


/* uint ----------------------------------------------------------------------*/

#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_getn_uint_uint(const void **xpp, size_t nelems, unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(uint));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return ENOERR;
}
#else
int
#line 2928
ncx_getn_uint_uint(const void **xpp, size_t nelems, uint *tp)
#line 2928
{
#line 2928
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2928

#line 2928
 /* basic algorithm is:
#line 2928
  *   - ensure sane alignment of input data
#line 2928
  *   - copy (conversion happens automatically) input data
#line 2928
  *     to output
#line 2928
  *   - update xpp to point at next unconverted input, and tp to point
#line 2928
  *     at next location for converted output
#line 2928
  */
#line 2928
  long i, j, ni;
#line 2928
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2928
  uint *xp;
#line 2928
  int nrange = 0;         /* number of range errors */
#line 2928
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2928
  long cxp = (long) *((char**)xpp);
#line 2928

#line 2928
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2928
  /* sjl: manually stripmine so we can limit amount of
#line 2928
   * vector work space reserved to LOOPCNT elements. Also
#line 2928
   * makes vectorisation easy */
#line 2928
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2928
    ni=Min(nelems-j,LOOPCNT);
#line 2928
    if (realign) {
#line 2928
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2928
      xp = tmp;
#line 2928
    } else {
#line 2928
      xp = (uint *) *xpp;
#line 2928
    }
#line 2928
   /* copy the next block */
#line 2928
#pragma cdir loopcnt=LOOPCNT
#line 2928
#pragma cdir shortloop
#line 2928
    for (i=0; i<ni; i++) {
#line 2928
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2928
     /* test for range errors (not always needed but do it anyway) */
#line 2928
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2928
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2928
      nrange += xp[i] > UINT_MAX ;
#line 2928
    }
#line 2928
   /* update xpp and tp */
#line 2928
    if (realign) xp = (uint *) *xpp;
#line 2928
    xp += ni;
#line 2928
    tp += ni;
#line 2928
    *xpp = (void*)xp;
#line 2928
  }
#line 2928
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2928

#line 2928
#else   /* not SX */
#line 2928
	const char *xp = (const char *) *xpp;
#line 2928
	int status = ENOERR;
#line 2928

#line 2928
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2928
	{
#line 2928
		const int lstatus = ncx_get_uint_uint(xp, tp);
#line 2928
		if(lstatus != ENOERR)
#line 2928
			status = lstatus;
#line 2928
	}
#line 2928

#line 2928
	*xpp = (const void *)xp;
#line 2928
	return status;
#line 2928
#  endif
#line 2928
}
#line 2928

#endif
int
#line 2930
ncx_getn_uint_schar(const void **xpp, size_t nelems, schar *tp)
#line 2930
{
#line 2930
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2930

#line 2930
 /* basic algorithm is:
#line 2930
  *   - ensure sane alignment of input data
#line 2930
  *   - copy (conversion happens automatically) input data
#line 2930
  *     to output
#line 2930
  *   - update xpp to point at next unconverted input, and tp to point
#line 2930
  *     at next location for converted output
#line 2930
  */
#line 2930
  long i, j, ni;
#line 2930
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2930
  uint *xp;
#line 2930
  int nrange = 0;         /* number of range errors */
#line 2930
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2930
  long cxp = (long) *((char**)xpp);
#line 2930

#line 2930
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2930
  /* sjl: manually stripmine so we can limit amount of
#line 2930
   * vector work space reserved to LOOPCNT elements. Also
#line 2930
   * makes vectorisation easy */
#line 2930
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2930
    ni=Min(nelems-j,LOOPCNT);
#line 2930
    if (realign) {
#line 2930
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2930
      xp = tmp;
#line 2930
    } else {
#line 2930
      xp = (uint *) *xpp;
#line 2930
    }
#line 2930
   /* copy the next block */
#line 2930
#pragma cdir loopcnt=LOOPCNT
#line 2930
#pragma cdir shortloop
#line 2930
    for (i=0; i<ni; i++) {
#line 2930
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2930
     /* test for range errors (not always needed but do it anyway) */
#line 2930
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2930
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2930
      nrange += xp[i] > SCHAR_MAX ;
#line 2930
    }
#line 2930
   /* update xpp and tp */
#line 2930
    if (realign) xp = (uint *) *xpp;
#line 2930
    xp += ni;
#line 2930
    tp += ni;
#line 2930
    *xpp = (void*)xp;
#line 2930
  }
#line 2930
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2930

#line 2930
#else   /* not SX */
#line 2930
	const char *xp = (const char *) *xpp;
#line 2930
	int status = ENOERR;
#line 2930

#line 2930
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2930
	{
#line 2930
		const int lstatus = ncx_get_uint_schar(xp, tp);
#line 2930
		if(lstatus != ENOERR)
#line 2930
			status = lstatus;
#line 2930
	}
#line 2930

#line 2930
	*xpp = (const void *)xp;
#line 2930
	return status;
#line 2930
#  endif
#line 2930
}
#line 2930

int
#line 2931
ncx_getn_uint_short(const void **xpp, size_t nelems, short *tp)
#line 2931
{
#line 2931
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2931

#line 2931
 /* basic algorithm is:
#line 2931
  *   - ensure sane alignment of input data
#line 2931
  *   - copy (conversion happens automatically) input data
#line 2931
  *     to output
#line 2931
  *   - update xpp to point at next unconverted input, and tp to point
#line 2931
  *     at next location for converted output
#line 2931
  */
#line 2931
  long i, j, ni;
#line 2931
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2931
  uint *xp;
#line 2931
  int nrange = 0;         /* number of range errors */
#line 2931
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2931
  long cxp = (long) *((char**)xpp);
#line 2931

#line 2931
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2931
  /* sjl: manually stripmine so we can limit amount of
#line 2931
   * vector work space reserved to LOOPCNT elements. Also
#line 2931
   * makes vectorisation easy */
#line 2931
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2931
    ni=Min(nelems-j,LOOPCNT);
#line 2931
    if (realign) {
#line 2931
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2931
      xp = tmp;
#line 2931
    } else {
#line 2931
      xp = (uint *) *xpp;
#line 2931
    }
#line 2931
   /* copy the next block */
#line 2931
#pragma cdir loopcnt=LOOPCNT
#line 2931
#pragma cdir shortloop
#line 2931
    for (i=0; i<ni; i++) {
#line 2931
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2931
     /* test for range errors (not always needed but do it anyway) */
#line 2931
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2931
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2931
      nrange += xp[i] > SHORT_MAX ;
#line 2931
    }
#line 2931
   /* update xpp and tp */
#line 2931
    if (realign) xp = (uint *) *xpp;
#line 2931
    xp += ni;
#line 2931
    tp += ni;
#line 2931
    *xpp = (void*)xp;
#line 2931
  }
#line 2931
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2931

#line 2931
#else   /* not SX */
#line 2931
	const char *xp = (const char *) *xpp;
#line 2931
	int status = ENOERR;
#line 2931

#line 2931
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2931
	{
#line 2931
		const int lstatus = ncx_get_uint_short(xp, tp);
#line 2931
		if(lstatus != ENOERR)
#line 2931
			status = lstatus;
#line 2931
	}
#line 2931

#line 2931
	*xpp = (const void *)xp;
#line 2931
	return status;
#line 2931
#  endif
#line 2931
}
#line 2931

int
#line 2932
ncx_getn_uint_int(const void **xpp, size_t nelems, int *tp)
#line 2932
{
#line 2932
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2932

#line 2932
 /* basic algorithm is:
#line 2932
  *   - ensure sane alignment of input data
#line 2932
  *   - copy (conversion happens automatically) input data
#line 2932
  *     to output
#line 2932
  *   - update xpp to point at next unconverted input, and tp to point
#line 2932
  *     at next location for converted output
#line 2932
  */
#line 2932
  long i, j, ni;
#line 2932
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2932
  uint *xp;
#line 2932
  int nrange = 0;         /* number of range errors */
#line 2932
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2932
  long cxp = (long) *((char**)xpp);
#line 2932

#line 2932
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2932
  /* sjl: manually stripmine so we can limit amount of
#line 2932
   * vector work space reserved to LOOPCNT elements. Also
#line 2932
   * makes vectorisation easy */
#line 2932
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2932
    ni=Min(nelems-j,LOOPCNT);
#line 2932
    if (realign) {
#line 2932
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2932
      xp = tmp;
#line 2932
    } else {
#line 2932
      xp = (uint *) *xpp;
#line 2932
    }
#line 2932
   /* copy the next block */
#line 2932
#pragma cdir loopcnt=LOOPCNT
#line 2932
#pragma cdir shortloop
#line 2932
    for (i=0; i<ni; i++) {
#line 2932
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2932
     /* test for range errors (not always needed but do it anyway) */
#line 2932
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2932
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2932
      nrange += xp[i] > INT_MAX ;
#line 2932
    }
#line 2932
   /* update xpp and tp */
#line 2932
    if (realign) xp = (uint *) *xpp;
#line 2932
    xp += ni;
#line 2932
    tp += ni;
#line 2932
    *xpp = (void*)xp;
#line 2932
  }
#line 2932
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2932

#line 2932
#else   /* not SX */
#line 2932
	const char *xp = (const char *) *xpp;
#line 2932
	int status = ENOERR;
#line 2932

#line 2932
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2932
	{
#line 2932
		const int lstatus = ncx_get_uint_int(xp, tp);
#line 2932
		if(lstatus != ENOERR)
#line 2932
			status = lstatus;
#line 2932
	}
#line 2932

#line 2932
	*xpp = (const void *)xp;
#line 2932
	return status;
#line 2932
#  endif
#line 2932
}
#line 2932

int
#line 2933
ncx_getn_uint_float(const void **xpp, size_t nelems, float *tp)
#line 2933
{
#line 2933
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2933

#line 2933
 /* basic algorithm is:
#line 2933
  *   - ensure sane alignment of input data
#line 2933
  *   - copy (conversion happens automatically) input data
#line 2933
  *     to output
#line 2933
  *   - update xpp to point at next unconverted input, and tp to point
#line 2933
  *     at next location for converted output
#line 2933
  */
#line 2933
  long i, j, ni;
#line 2933
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2933
  uint *xp;
#line 2933
  int nrange = 0;         /* number of range errors */
#line 2933
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2933
  long cxp = (long) *((char**)xpp);
#line 2933

#line 2933
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2933
  /* sjl: manually stripmine so we can limit amount of
#line 2933
   * vector work space reserved to LOOPCNT elements. Also
#line 2933
   * makes vectorisation easy */
#line 2933
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2933
    ni=Min(nelems-j,LOOPCNT);
#line 2933
    if (realign) {
#line 2933
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2933
      xp = tmp;
#line 2933
    } else {
#line 2933
      xp = (uint *) *xpp;
#line 2933
    }
#line 2933
   /* copy the next block */
#line 2933
#pragma cdir loopcnt=LOOPCNT
#line 2933
#pragma cdir shortloop
#line 2933
    for (i=0; i<ni; i++) {
#line 2933
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2933
     /* test for range errors (not always needed but do it anyway) */
#line 2933
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2933
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2933
      nrange += xp[i] > FLOAT_MAX ;
#line 2933
    }
#line 2933
   /* update xpp and tp */
#line 2933
    if (realign) xp = (uint *) *xpp;
#line 2933
    xp += ni;
#line 2933
    tp += ni;
#line 2933
    *xpp = (void*)xp;
#line 2933
  }
#line 2933
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2933

#line 2933
#else   /* not SX */
#line 2933
	const char *xp = (const char *) *xpp;
#line 2933
	int status = ENOERR;
#line 2933

#line 2933
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2933
	{
#line 2933
		const int lstatus = ncx_get_uint_float(xp, tp);
#line 2933
		if(lstatus != ENOERR)
#line 2933
			status = lstatus;
#line 2933
	}
#line 2933

#line 2933
	*xpp = (const void *)xp;
#line 2933
	return status;
#line 2933
#  endif
#line 2933
}
#line 2933

int
#line 2934
ncx_getn_uint_double(const void **xpp, size_t nelems, double *tp)
#line 2934
{
#line 2934
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2934

#line 2934
 /* basic algorithm is:
#line 2934
  *   - ensure sane alignment of input data
#line 2934
  *   - copy (conversion happens automatically) input data
#line 2934
  *     to output
#line 2934
  *   - update xpp to point at next unconverted input, and tp to point
#line 2934
  *     at next location for converted output
#line 2934
  */
#line 2934
  long i, j, ni;
#line 2934
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2934
  uint *xp;
#line 2934
  int nrange = 0;         /* number of range errors */
#line 2934
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2934
  long cxp = (long) *((char**)xpp);
#line 2934

#line 2934
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2934
  /* sjl: manually stripmine so we can limit amount of
#line 2934
   * vector work space reserved to LOOPCNT elements. Also
#line 2934
   * makes vectorisation easy */
#line 2934
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2934
    ni=Min(nelems-j,LOOPCNT);
#line 2934
    if (realign) {
#line 2934
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2934
      xp = tmp;
#line 2934
    } else {
#line 2934
      xp = (uint *) *xpp;
#line 2934
    }
#line 2934
   /* copy the next block */
#line 2934
#pragma cdir loopcnt=LOOPCNT
#line 2934
#pragma cdir shortloop
#line 2934
    for (i=0; i<ni; i++) {
#line 2934
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2934
     /* test for range errors (not always needed but do it anyway) */
#line 2934
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2934
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2934
      nrange += xp[i] > DOUBLE_MAX ;
#line 2934
    }
#line 2934
   /* update xpp and tp */
#line 2934
    if (realign) xp = (uint *) *xpp;
#line 2934
    xp += ni;
#line 2934
    tp += ni;
#line 2934
    *xpp = (void*)xp;
#line 2934
  }
#line 2934
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2934

#line 2934
#else   /* not SX */
#line 2934
	const char *xp = (const char *) *xpp;
#line 2934
	int status = ENOERR;
#line 2934

#line 2934
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2934
	{
#line 2934
		const int lstatus = ncx_get_uint_double(xp, tp);
#line 2934
		if(lstatus != ENOERR)
#line 2934
			status = lstatus;
#line 2934
	}
#line 2934

#line 2934
	*xpp = (const void *)xp;
#line 2934
	return status;
#line 2934
#  endif
#line 2934
}
#line 2934

int
#line 2935
ncx_getn_uint_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2935
{
#line 2935
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2935

#line 2935
 /* basic algorithm is:
#line 2935
  *   - ensure sane alignment of input data
#line 2935
  *   - copy (conversion happens automatically) input data
#line 2935
  *     to output
#line 2935
  *   - update xpp to point at next unconverted input, and tp to point
#line 2935
  *     at next location for converted output
#line 2935
  */
#line 2935
  long i, j, ni;
#line 2935
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2935
  uint *xp;
#line 2935
  int nrange = 0;         /* number of range errors */
#line 2935
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2935
  long cxp = (long) *((char**)xpp);
#line 2935

#line 2935
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2935
  /* sjl: manually stripmine so we can limit amount of
#line 2935
   * vector work space reserved to LOOPCNT elements. Also
#line 2935
   * makes vectorisation easy */
#line 2935
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2935
    ni=Min(nelems-j,LOOPCNT);
#line 2935
    if (realign) {
#line 2935
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2935
      xp = tmp;
#line 2935
    } else {
#line 2935
      xp = (uint *) *xpp;
#line 2935
    }
#line 2935
   /* copy the next block */
#line 2935
#pragma cdir loopcnt=LOOPCNT
#line 2935
#pragma cdir shortloop
#line 2935
    for (i=0; i<ni; i++) {
#line 2935
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2935
     /* test for range errors (not always needed but do it anyway) */
#line 2935
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2935
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2935
      nrange += xp[i] > LONGLONG_MAX ;
#line 2935
    }
#line 2935
   /* update xpp and tp */
#line 2935
    if (realign) xp = (uint *) *xpp;
#line 2935
    xp += ni;
#line 2935
    tp += ni;
#line 2935
    *xpp = (void*)xp;
#line 2935
  }
#line 2935
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2935

#line 2935
#else   /* not SX */
#line 2935
	const char *xp = (const char *) *xpp;
#line 2935
	int status = ENOERR;
#line 2935

#line 2935
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2935
	{
#line 2935
		const int lstatus = ncx_get_uint_longlong(xp, tp);
#line 2935
		if(lstatus != ENOERR)
#line 2935
			status = lstatus;
#line 2935
	}
#line 2935

#line 2935
	*xpp = (const void *)xp;
#line 2935
	return status;
#line 2935
#  endif
#line 2935
}
#line 2935

int
#line 2936
ncx_getn_uint_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2936
{
#line 2936
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2936

#line 2936
 /* basic algorithm is:
#line 2936
  *   - ensure sane alignment of input data
#line 2936
  *   - copy (conversion happens automatically) input data
#line 2936
  *     to output
#line 2936
  *   - update xpp to point at next unconverted input, and tp to point
#line 2936
  *     at next location for converted output
#line 2936
  */
#line 2936
  long i, j, ni;
#line 2936
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2936
  uint *xp;
#line 2936
  int nrange = 0;         /* number of range errors */
#line 2936
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2936
  long cxp = (long) *((char**)xpp);
#line 2936

#line 2936
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2936
  /* sjl: manually stripmine so we can limit amount of
#line 2936
   * vector work space reserved to LOOPCNT elements. Also
#line 2936
   * makes vectorisation easy */
#line 2936
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2936
    ni=Min(nelems-j,LOOPCNT);
#line 2936
    if (realign) {
#line 2936
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2936
      xp = tmp;
#line 2936
    } else {
#line 2936
      xp = (uint *) *xpp;
#line 2936
    }
#line 2936
   /* copy the next block */
#line 2936
#pragma cdir loopcnt=LOOPCNT
#line 2936
#pragma cdir shortloop
#line 2936
    for (i=0; i<ni; i++) {
#line 2936
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2936
     /* test for range errors (not always needed but do it anyway) */
#line 2936
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2936
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2936
      nrange += xp[i] > UCHAR_MAX ;
#line 2936
    }
#line 2936
   /* update xpp and tp */
#line 2936
    if (realign) xp = (uint *) *xpp;
#line 2936
    xp += ni;
#line 2936
    tp += ni;
#line 2936
    *xpp = (void*)xp;
#line 2936
  }
#line 2936
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2936

#line 2936
#else   /* not SX */
#line 2936
	const char *xp = (const char *) *xpp;
#line 2936
	int status = ENOERR;
#line 2936

#line 2936
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2936
	{
#line 2936
		const int lstatus = ncx_get_uint_uchar(xp, tp);
#line 2936
		if(lstatus != ENOERR)
#line 2936
			status = lstatus;
#line 2936
	}
#line 2936

#line 2936
	*xpp = (const void *)xp;
#line 2936
	return status;
#line 2936
#  endif
#line 2936
}
#line 2936

int
#line 2937
ncx_getn_uint_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2937
{
#line 2937
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2937

#line 2937
 /* basic algorithm is:
#line 2937
  *   - ensure sane alignment of input data
#line 2937
  *   - copy (conversion happens automatically) input data
#line 2937
  *     to output
#line 2937
  *   - update xpp to point at next unconverted input, and tp to point
#line 2937
  *     at next location for converted output
#line 2937
  */
#line 2937
  long i, j, ni;
#line 2937
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2937
  uint *xp;
#line 2937
  int nrange = 0;         /* number of range errors */
#line 2937
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2937
  long cxp = (long) *((char**)xpp);
#line 2937

#line 2937
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2937
  /* sjl: manually stripmine so we can limit amount of
#line 2937
   * vector work space reserved to LOOPCNT elements. Also
#line 2937
   * makes vectorisation easy */
#line 2937
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2937
    ni=Min(nelems-j,LOOPCNT);
#line 2937
    if (realign) {
#line 2937
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2937
      xp = tmp;
#line 2937
    } else {
#line 2937
      xp = (uint *) *xpp;
#line 2937
    }
#line 2937
   /* copy the next block */
#line 2937
#pragma cdir loopcnt=LOOPCNT
#line 2937
#pragma cdir shortloop
#line 2937
    for (i=0; i<ni; i++) {
#line 2937
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2937
     /* test for range errors (not always needed but do it anyway) */
#line 2937
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2937
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2937
      nrange += xp[i] > USHORT_MAX ;
#line 2937
    }
#line 2937
   /* update xpp and tp */
#line 2937
    if (realign) xp = (uint *) *xpp;
#line 2937
    xp += ni;
#line 2937
    tp += ni;
#line 2937
    *xpp = (void*)xp;
#line 2937
  }
#line 2937
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2937

#line 2937
#else   /* not SX */
#line 2937
	const char *xp = (const char *) *xpp;
#line 2937
	int status = ENOERR;
#line 2937

#line 2937
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2937
	{
#line 2937
		const int lstatus = ncx_get_uint_ushort(xp, tp);
#line 2937
		if(lstatus != ENOERR)
#line 2937
			status = lstatus;
#line 2937
	}
#line 2937

#line 2937
	*xpp = (const void *)xp;
#line 2937
	return status;
#line 2937
#  endif
#line 2937
}
#line 2937

int
#line 2938
ncx_getn_uint_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2938
{
#line 2938
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2938

#line 2938
 /* basic algorithm is:
#line 2938
  *   - ensure sane alignment of input data
#line 2938
  *   - copy (conversion happens automatically) input data
#line 2938
  *     to output
#line 2938
  *   - update xpp to point at next unconverted input, and tp to point
#line 2938
  *     at next location for converted output
#line 2938
  */
#line 2938
  long i, j, ni;
#line 2938
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2938
  uint *xp;
#line 2938
  int nrange = 0;         /* number of range errors */
#line 2938
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2938
  long cxp = (long) *((char**)xpp);
#line 2938

#line 2938
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2938
  /* sjl: manually stripmine so we can limit amount of
#line 2938
   * vector work space reserved to LOOPCNT elements. Also
#line 2938
   * makes vectorisation easy */
#line 2938
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2938
    ni=Min(nelems-j,LOOPCNT);
#line 2938
    if (realign) {
#line 2938
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2938
      xp = tmp;
#line 2938
    } else {
#line 2938
      xp = (uint *) *xpp;
#line 2938
    }
#line 2938
   /* copy the next block */
#line 2938
#pragma cdir loopcnt=LOOPCNT
#line 2938
#pragma cdir shortloop
#line 2938
    for (i=0; i<ni; i++) {
#line 2938
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2938
     /* test for range errors (not always needed but do it anyway) */
#line 2938
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2938
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2938
      nrange += xp[i] > ULONGLONG_MAX ;
#line 2938
    }
#line 2938
   /* update xpp and tp */
#line 2938
    if (realign) xp = (uint *) *xpp;
#line 2938
    xp += ni;
#line 2938
    tp += ni;
#line 2938
    *xpp = (void*)xp;
#line 2938
  }
#line 2938
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2938

#line 2938
#else   /* not SX */
#line 2938
	const char *xp = (const char *) *xpp;
#line 2938
	int status = ENOERR;
#line 2938

#line 2938
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2938
	{
#line 2938
		const int lstatus = ncx_get_uint_ulonglong(xp, tp);
#line 2938
		if(lstatus != ENOERR)
#line 2938
			status = lstatus;
#line 2938
	}
#line 2938

#line 2938
	*xpp = (const void *)xp;
#line 2938
	return status;
#line 2938
#  endif
#line 2938
}
#line 2938


#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_putn_uint_uint(void **xpp, size_t nelems, const unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_UINT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return ENOERR;
}
#else
int
#line 2954
ncx_putn_uint_uint(void **xpp, size_t nelems, const uint *tp)
#line 2954
{
#line 2954
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2954

#line 2954
 /* basic algorithm is:
#line 2954
  *   - ensure sane alignment of output data
#line 2954
  *   - copy (conversion happens automatically) input data
#line 2954
  *     to output
#line 2954
  *   - update tp to point at next unconverted input, and xpp to point
#line 2954
  *     at next location for converted output
#line 2954
  */
#line 2954
  long i, j, ni;
#line 2954
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2954
  uint *xp;
#line 2954
  int nrange = 0;         /* number of range errors */
#line 2954
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2954
  long cxp = (long) *((char**)xpp);
#line 2954

#line 2954
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2954
  /* sjl: manually stripmine so we can limit amount of
#line 2954
   * vector work space reserved to LOOPCNT elements. Also
#line 2954
   * makes vectorisation easy */
#line 2954
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2954
    ni=Min(nelems-j,LOOPCNT);
#line 2954
    if (realign) {
#line 2954
      xp = tmp;
#line 2954
    } else {
#line 2954
      xp = (uint *) *xpp;
#line 2954
    }
#line 2954
   /* copy the next block */
#line 2954
#pragma cdir loopcnt=LOOPCNT
#line 2954
#pragma cdir shortloop
#line 2954
    for (i=0; i<ni; i++) {
#line 2954
      /* the normal case: */
#line 2954
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2954
     /* test for range errors (not always needed but do it anyway) */
#line 2954
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2954
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2954
      nrange += tp[i] > X_UINT_MAX ;
#line 2954
    }
#line 2954
   /* copy workspace back if necessary */ 
#line 2954
    if (realign) {
#line 2954
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2954
      xp = (uint *) *xpp;
#line 2954
    }
#line 2954
   /* update xpp and tp */
#line 2954
    xp += ni;
#line 2954
    tp += ni;
#line 2954
    *xpp = (void*)xp;
#line 2954
  }
#line 2954
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2954

#line 2954
#else   /* not SX */
#line 2954

#line 2954
	char *xp = (char *) *xpp;
#line 2954
	int status = ENOERR;
#line 2954

#line 2954
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2954
	{
#line 2954
		int lstatus = ncx_put_uint_uint(xp, tp);
#line 2954
		if(lstatus != ENOERR)
#line 2954
			status = lstatus;
#line 2954
	}
#line 2954

#line 2954
	*xpp = (void *)xp;
#line 2954
	return status;
#line 2954
#endif
#line 2954
}
#line 2954

#endif
int
#line 2956
ncx_putn_uint_schar(void **xpp, size_t nelems, const schar *tp)
#line 2956
{
#line 2956
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2956

#line 2956
 /* basic algorithm is:
#line 2956
  *   - ensure sane alignment of output data
#line 2956
  *   - copy (conversion happens automatically) input data
#line 2956
  *     to output
#line 2956
  *   - update tp to point at next unconverted input, and xpp to point
#line 2956
  *     at next location for converted output
#line 2956
  */
#line 2956
  long i, j, ni;
#line 2956
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2956
  uint *xp;
#line 2956
  int nrange = 0;         /* number of range errors */
#line 2956
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2956
  long cxp = (long) *((char**)xpp);
#line 2956

#line 2956
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2956
  /* sjl: manually stripmine so we can limit amount of
#line 2956
   * vector work space reserved to LOOPCNT elements. Also
#line 2956
   * makes vectorisation easy */
#line 2956
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2956
    ni=Min(nelems-j,LOOPCNT);
#line 2956
    if (realign) {
#line 2956
      xp = tmp;
#line 2956
    } else {
#line 2956
      xp = (uint *) *xpp;
#line 2956
    }
#line 2956
   /* copy the next block */
#line 2956
#pragma cdir loopcnt=LOOPCNT
#line 2956
#pragma cdir shortloop
#line 2956
    for (i=0; i<ni; i++) {
#line 2956
      /* the normal case: */
#line 2956
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2956
     /* test for range errors (not always needed but do it anyway) */
#line 2956
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2956
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2956
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2956
    }
#line 2956
   /* copy workspace back if necessary */ 
#line 2956
    if (realign) {
#line 2956
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2956
      xp = (uint *) *xpp;
#line 2956
    }
#line 2956
   /* update xpp and tp */
#line 2956
    xp += ni;
#line 2956
    tp += ni;
#line 2956
    *xpp = (void*)xp;
#line 2956
  }
#line 2956
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2956

#line 2956
#else   /* not SX */
#line 2956

#line 2956
	char *xp = (char *) *xpp;
#line 2956
	int status = ENOERR;
#line 2956

#line 2956
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2956
	{
#line 2956
		int lstatus = ncx_put_uint_schar(xp, tp);
#line 2956
		if(lstatus != ENOERR)
#line 2956
			status = lstatus;
#line 2956
	}
#line 2956

#line 2956
	*xpp = (void *)xp;
#line 2956
	return status;
#line 2956
#endif
#line 2956
}
#line 2956

int
#line 2957
ncx_putn_uint_short(void **xpp, size_t nelems, const short *tp)
#line 2957
{
#line 2957
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2957

#line 2957
 /* basic algorithm is:
#line 2957
  *   - ensure sane alignment of output data
#line 2957
  *   - copy (conversion happens automatically) input data
#line 2957
  *     to output
#line 2957
  *   - update tp to point at next unconverted input, and xpp to point
#line 2957
  *     at next location for converted output
#line 2957
  */
#line 2957
  long i, j, ni;
#line 2957
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2957
  uint *xp;
#line 2957
  int nrange = 0;         /* number of range errors */
#line 2957
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2957
  long cxp = (long) *((char**)xpp);
#line 2957

#line 2957
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2957
  /* sjl: manually stripmine so we can limit amount of
#line 2957
   * vector work space reserved to LOOPCNT elements. Also
#line 2957
   * makes vectorisation easy */
#line 2957
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2957
    ni=Min(nelems-j,LOOPCNT);
#line 2957
    if (realign) {
#line 2957
      xp = tmp;
#line 2957
    } else {
#line 2957
      xp = (uint *) *xpp;
#line 2957
    }
#line 2957
   /* copy the next block */
#line 2957
#pragma cdir loopcnt=LOOPCNT
#line 2957
#pragma cdir shortloop
#line 2957
    for (i=0; i<ni; i++) {
#line 2957
      /* the normal case: */
#line 2957
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2957
     /* test for range errors (not always needed but do it anyway) */
#line 2957
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2957
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2957
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2957
    }
#line 2957
   /* copy workspace back if necessary */ 
#line 2957
    if (realign) {
#line 2957
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2957
      xp = (uint *) *xpp;
#line 2957
    }
#line 2957
   /* update xpp and tp */
#line 2957
    xp += ni;
#line 2957
    tp += ni;
#line 2957
    *xpp = (void*)xp;
#line 2957
  }
#line 2957
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2957

#line 2957
#else   /* not SX */
#line 2957

#line 2957
	char *xp = (char *) *xpp;
#line 2957
	int status = ENOERR;
#line 2957

#line 2957
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2957
	{
#line 2957
		int lstatus = ncx_put_uint_short(xp, tp);
#line 2957
		if(lstatus != ENOERR)
#line 2957
			status = lstatus;
#line 2957
	}
#line 2957

#line 2957
	*xpp = (void *)xp;
#line 2957
	return status;
#line 2957
#endif
#line 2957
}
#line 2957

int
#line 2958
ncx_putn_uint_int(void **xpp, size_t nelems, const int *tp)
#line 2958
{
#line 2958
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2958

#line 2958
 /* basic algorithm is:
#line 2958
  *   - ensure sane alignment of output data
#line 2958
  *   - copy (conversion happens automatically) input data
#line 2958
  *     to output
#line 2958
  *   - update tp to point at next unconverted input, and xpp to point
#line 2958
  *     at next location for converted output
#line 2958
  */
#line 2958
  long i, j, ni;
#line 2958
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2958
  uint *xp;
#line 2958
  int nrange = 0;         /* number of range errors */
#line 2958
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2958
  long cxp = (long) *((char**)xpp);
#line 2958

#line 2958
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2958
  /* sjl: manually stripmine so we can limit amount of
#line 2958
   * vector work space reserved to LOOPCNT elements. Also
#line 2958
   * makes vectorisation easy */
#line 2958
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2958
    ni=Min(nelems-j,LOOPCNT);
#line 2958
    if (realign) {
#line 2958
      xp = tmp;
#line 2958
    } else {
#line 2958
      xp = (uint *) *xpp;
#line 2958
    }
#line 2958
   /* copy the next block */
#line 2958
#pragma cdir loopcnt=LOOPCNT
#line 2958
#pragma cdir shortloop
#line 2958
    for (i=0; i<ni; i++) {
#line 2958
      /* the normal case: */
#line 2958
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2958
     /* test for range errors (not always needed but do it anyway) */
#line 2958
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2958
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2958
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2958
    }
#line 2958
   /* copy workspace back if necessary */ 
#line 2958
    if (realign) {
#line 2958
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2958
      xp = (uint *) *xpp;
#line 2958
    }
#line 2958
   /* update xpp and tp */
#line 2958
    xp += ni;
#line 2958
    tp += ni;
#line 2958
    *xpp = (void*)xp;
#line 2958
  }
#line 2958
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2958

#line 2958
#else   /* not SX */
#line 2958

#line 2958
	char *xp = (char *) *xpp;
#line 2958
	int status = ENOERR;
#line 2958

#line 2958
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2958
	{
#line 2958
		int lstatus = ncx_put_uint_int(xp, tp);
#line 2958
		if(lstatus != ENOERR)
#line 2958
			status = lstatus;
#line 2958
	}
#line 2958

#line 2958
	*xpp = (void *)xp;
#line 2958
	return status;
#line 2958
#endif
#line 2958
}
#line 2958

int
#line 2959
ncx_putn_uint_float(void **xpp, size_t nelems, const float *tp)
#line 2959
{
#line 2959
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2959

#line 2959
 /* basic algorithm is:
#line 2959
  *   - ensure sane alignment of output data
#line 2959
  *   - copy (conversion happens automatically) input data
#line 2959
  *     to output
#line 2959
  *   - update tp to point at next unconverted input, and xpp to point
#line 2959
  *     at next location for converted output
#line 2959
  */
#line 2959
  long i, j, ni;
#line 2959
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2959
  uint *xp;
#line 2959
  int nrange = 0;         /* number of range errors */
#line 2959
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2959
  long cxp = (long) *((char**)xpp);
#line 2959

#line 2959
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2959
  /* sjl: manually stripmine so we can limit amount of
#line 2959
   * vector work space reserved to LOOPCNT elements. Also
#line 2959
   * makes vectorisation easy */
#line 2959
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2959
    ni=Min(nelems-j,LOOPCNT);
#line 2959
    if (realign) {
#line 2959
      xp = tmp;
#line 2959
    } else {
#line 2959
      xp = (uint *) *xpp;
#line 2959
    }
#line 2959
   /* copy the next block */
#line 2959
#pragma cdir loopcnt=LOOPCNT
#line 2959
#pragma cdir shortloop
#line 2959
    for (i=0; i<ni; i++) {
#line 2959
      /* the normal case: */
#line 2959
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2959
     /* test for range errors (not always needed but do it anyway) */
#line 2959
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2959
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2959
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2959
    }
#line 2959
   /* copy workspace back if necessary */ 
#line 2959
    if (realign) {
#line 2959
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2959
      xp = (uint *) *xpp;
#line 2959
    }
#line 2959
   /* update xpp and tp */
#line 2959
    xp += ni;
#line 2959
    tp += ni;
#line 2959
    *xpp = (void*)xp;
#line 2959
  }
#line 2959
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2959

#line 2959
#else   /* not SX */
#line 2959

#line 2959
	char *xp = (char *) *xpp;
#line 2959
	int status = ENOERR;
#line 2959

#line 2959
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2959
	{
#line 2959
		int lstatus = ncx_put_uint_float(xp, tp);
#line 2959
		if(lstatus != ENOERR)
#line 2959
			status = lstatus;
#line 2959
	}
#line 2959

#line 2959
	*xpp = (void *)xp;
#line 2959
	return status;
#line 2959
#endif
#line 2959
}
#line 2959

int
#line 2960
ncx_putn_uint_double(void **xpp, size_t nelems, const double *tp)
#line 2960
{
#line 2960
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2960

#line 2960
 /* basic algorithm is:
#line 2960
  *   - ensure sane alignment of output data
#line 2960
  *   - copy (conversion happens automatically) input data
#line 2960
  *     to output
#line 2960
  *   - update tp to point at next unconverted input, and xpp to point
#line 2960
  *     at next location for converted output
#line 2960
  */
#line 2960
  long i, j, ni;
#line 2960
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2960
  uint *xp;
#line 2960
  int nrange = 0;         /* number of range errors */
#line 2960
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2960
  long cxp = (long) *((char**)xpp);
#line 2960

#line 2960
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2960
  /* sjl: manually stripmine so we can limit amount of
#line 2960
   * vector work space reserved to LOOPCNT elements. Also
#line 2960
   * makes vectorisation easy */
#line 2960
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2960
    ni=Min(nelems-j,LOOPCNT);
#line 2960
    if (realign) {
#line 2960
      xp = tmp;
#line 2960
    } else {
#line 2960
      xp = (uint *) *xpp;
#line 2960
    }
#line 2960
   /* copy the next block */
#line 2960
#pragma cdir loopcnt=LOOPCNT
#line 2960
#pragma cdir shortloop
#line 2960
    for (i=0; i<ni; i++) {
#line 2960
      /* the normal case: */
#line 2960
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2960
     /* test for range errors (not always needed but do it anyway) */
#line 2960
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2960
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2960
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2960
    }
#line 2960
   /* copy workspace back if necessary */ 
#line 2960
    if (realign) {
#line 2960
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2960
      xp = (uint *) *xpp;
#line 2960
    }
#line 2960
   /* update xpp and tp */
#line 2960
    xp += ni;
#line 2960
    tp += ni;
#line 2960
    *xpp = (void*)xp;
#line 2960
  }
#line 2960
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2960

#line 2960
#else   /* not SX */
#line 2960

#line 2960
	char *xp = (char *) *xpp;
#line 2960
	int status = ENOERR;
#line 2960

#line 2960
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2960
	{
#line 2960
		int lstatus = ncx_put_uint_double(xp, tp);
#line 2960
		if(lstatus != ENOERR)
#line 2960
			status = lstatus;
#line 2960
	}
#line 2960

#line 2960
	*xpp = (void *)xp;
#line 2960
	return status;
#line 2960
#endif
#line 2960
}
#line 2960

int
#line 2961
ncx_putn_uint_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2961
{
#line 2961
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2961

#line 2961
 /* basic algorithm is:
#line 2961
  *   - ensure sane alignment of output data
#line 2961
  *   - copy (conversion happens automatically) input data
#line 2961
  *     to output
#line 2961
  *   - update tp to point at next unconverted input, and xpp to point
#line 2961
  *     at next location for converted output
#line 2961
  */
#line 2961
  long i, j, ni;
#line 2961
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2961
  uint *xp;
#line 2961
  int nrange = 0;         /* number of range errors */
#line 2961
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2961
  long cxp = (long) *((char**)xpp);
#line 2961

#line 2961
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2961
  /* sjl: manually stripmine so we can limit amount of
#line 2961
   * vector work space reserved to LOOPCNT elements. Also
#line 2961
   * makes vectorisation easy */
#line 2961
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2961
    ni=Min(nelems-j,LOOPCNT);
#line 2961
    if (realign) {
#line 2961
      xp = tmp;
#line 2961
    } else {
#line 2961
      xp = (uint *) *xpp;
#line 2961
    }
#line 2961
   /* copy the next block */
#line 2961
#pragma cdir loopcnt=LOOPCNT
#line 2961
#pragma cdir shortloop
#line 2961
    for (i=0; i<ni; i++) {
#line 2961
      /* the normal case: */
#line 2961
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2961
     /* test for range errors (not always needed but do it anyway) */
#line 2961
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2961
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2961
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2961
    }
#line 2961
   /* copy workspace back if necessary */ 
#line 2961
    if (realign) {
#line 2961
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2961
      xp = (uint *) *xpp;
#line 2961
    }
#line 2961
   /* update xpp and tp */
#line 2961
    xp += ni;
#line 2961
    tp += ni;
#line 2961
    *xpp = (void*)xp;
#line 2961
  }
#line 2961
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2961

#line 2961
#else   /* not SX */
#line 2961

#line 2961
	char *xp = (char *) *xpp;
#line 2961
	int status = ENOERR;
#line 2961

#line 2961
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2961
	{
#line 2961
		int lstatus = ncx_put_uint_longlong(xp, tp);
#line 2961
		if(lstatus != ENOERR)
#line 2961
			status = lstatus;
#line 2961
	}
#line 2961

#line 2961
	*xpp = (void *)xp;
#line 2961
	return status;
#line 2961
#endif
#line 2961
}
#line 2961

int
#line 2962
ncx_putn_uint_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2962
{
#line 2962
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2962

#line 2962
 /* basic algorithm is:
#line 2962
  *   - ensure sane alignment of output data
#line 2962
  *   - copy (conversion happens automatically) input data
#line 2962
  *     to output
#line 2962
  *   - update tp to point at next unconverted input, and xpp to point
#line 2962
  *     at next location for converted output
#line 2962
  */
#line 2962
  long i, j, ni;
#line 2962
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2962
  uint *xp;
#line 2962
  int nrange = 0;         /* number of range errors */
#line 2962
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2962
  long cxp = (long) *((char**)xpp);
#line 2962

#line 2962
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2962
  /* sjl: manually stripmine so we can limit amount of
#line 2962
   * vector work space reserved to LOOPCNT elements. Also
#line 2962
   * makes vectorisation easy */
#line 2962
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2962
    ni=Min(nelems-j,LOOPCNT);
#line 2962
    if (realign) {
#line 2962
      xp = tmp;
#line 2962
    } else {
#line 2962
      xp = (uint *) *xpp;
#line 2962
    }
#line 2962
   /* copy the next block */
#line 2962
#pragma cdir loopcnt=LOOPCNT
#line 2962
#pragma cdir shortloop
#line 2962
    for (i=0; i<ni; i++) {
#line 2962
      /* the normal case: */
#line 2962
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2962
     /* test for range errors (not always needed but do it anyway) */
#line 2962
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2962
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2962
      nrange += tp[i] > X_UINT_MAX ;
#line 2962
    }
#line 2962
   /* copy workspace back if necessary */ 
#line 2962
    if (realign) {
#line 2962
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2962
      xp = (uint *) *xpp;
#line 2962
    }
#line 2962
   /* update xpp and tp */
#line 2962
    xp += ni;
#line 2962
    tp += ni;
#line 2962
    *xpp = (void*)xp;
#line 2962
  }
#line 2962
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2962

#line 2962
#else   /* not SX */
#line 2962

#line 2962
	char *xp = (char *) *xpp;
#line 2962
	int status = ENOERR;
#line 2962

#line 2962
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2962
	{
#line 2962
		int lstatus = ncx_put_uint_uchar(xp, tp);
#line 2962
		if(lstatus != ENOERR)
#line 2962
			status = lstatus;
#line 2962
	}
#line 2962

#line 2962
	*xpp = (void *)xp;
#line 2962
	return status;
#line 2962
#endif
#line 2962
}
#line 2962

int
#line 2963
ncx_putn_uint_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2963
{
#line 2963
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2963

#line 2963
 /* basic algorithm is:
#line 2963
  *   - ensure sane alignment of output data
#line 2963
  *   - copy (conversion happens automatically) input data
#line 2963
  *     to output
#line 2963
  *   - update tp to point at next unconverted input, and xpp to point
#line 2963
  *     at next location for converted output
#line 2963
  */
#line 2963
  long i, j, ni;
#line 2963
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2963
  uint *xp;
#line 2963
  int nrange = 0;         /* number of range errors */
#line 2963
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2963
  long cxp = (long) *((char**)xpp);
#line 2963

#line 2963
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2963
  /* sjl: manually stripmine so we can limit amount of
#line 2963
   * vector work space reserved to LOOPCNT elements. Also
#line 2963
   * makes vectorisation easy */
#line 2963
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2963
    ni=Min(nelems-j,LOOPCNT);
#line 2963
    if (realign) {
#line 2963
      xp = tmp;
#line 2963
    } else {
#line 2963
      xp = (uint *) *xpp;
#line 2963
    }
#line 2963
   /* copy the next block */
#line 2963
#pragma cdir loopcnt=LOOPCNT
#line 2963
#pragma cdir shortloop
#line 2963
    for (i=0; i<ni; i++) {
#line 2963
      /* the normal case: */
#line 2963
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2963
     /* test for range errors (not always needed but do it anyway) */
#line 2963
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2963
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2963
      nrange += tp[i] > X_UINT_MAX ;
#line 2963
    }
#line 2963
   /* copy workspace back if necessary */ 
#line 2963
    if (realign) {
#line 2963
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2963
      xp = (uint *) *xpp;
#line 2963
    }
#line 2963
   /* update xpp and tp */
#line 2963
    xp += ni;
#line 2963
    tp += ni;
#line 2963
    *xpp = (void*)xp;
#line 2963
  }
#line 2963
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2963

#line 2963
#else   /* not SX */
#line 2963

#line 2963
	char *xp = (char *) *xpp;
#line 2963
	int status = ENOERR;
#line 2963

#line 2963
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2963
	{
#line 2963
		int lstatus = ncx_put_uint_ushort(xp, tp);
#line 2963
		if(lstatus != ENOERR)
#line 2963
			status = lstatus;
#line 2963
	}
#line 2963

#line 2963
	*xpp = (void *)xp;
#line 2963
	return status;
#line 2963
#endif
#line 2963
}
#line 2963

int
#line 2964
ncx_putn_uint_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2964
{
#line 2964
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2964

#line 2964
 /* basic algorithm is:
#line 2964
  *   - ensure sane alignment of output data
#line 2964
  *   - copy (conversion happens automatically) input data
#line 2964
  *     to output
#line 2964
  *   - update tp to point at next unconverted input, and xpp to point
#line 2964
  *     at next location for converted output
#line 2964
  */
#line 2964
  long i, j, ni;
#line 2964
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2964
  uint *xp;
#line 2964
  int nrange = 0;         /* number of range errors */
#line 2964
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2964
  long cxp = (long) *((char**)xpp);
#line 2964

#line 2964
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2964
  /* sjl: manually stripmine so we can limit amount of
#line 2964
   * vector work space reserved to LOOPCNT elements. Also
#line 2964
   * makes vectorisation easy */
#line 2964
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2964
    ni=Min(nelems-j,LOOPCNT);
#line 2964
    if (realign) {
#line 2964
      xp = tmp;
#line 2964
    } else {
#line 2964
      xp = (uint *) *xpp;
#line 2964
    }
#line 2964
   /* copy the next block */
#line 2964
#pragma cdir loopcnt=LOOPCNT
#line 2964
#pragma cdir shortloop
#line 2964
    for (i=0; i<ni; i++) {
#line 2964
      /* the normal case: */
#line 2964
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2964
     /* test for range errors (not always needed but do it anyway) */
#line 2964
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2964
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2964
      nrange += tp[i] > X_UINT_MAX ;
#line 2964
    }
#line 2964
   /* copy workspace back if necessary */ 
#line 2964
    if (realign) {
#line 2964
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2964
      xp = (uint *) *xpp;
#line 2964
    }
#line 2964
   /* update xpp and tp */
#line 2964
    xp += ni;
#line 2964
    tp += ni;
#line 2964
    *xpp = (void*)xp;
#line 2964
  }
#line 2964
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2964

#line 2964
#else   /* not SX */
#line 2964

#line 2964
	char *xp = (char *) *xpp;
#line 2964
	int status = ENOERR;
#line 2964

#line 2964
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2964
	{
#line 2964
		int lstatus = ncx_put_uint_ulonglong(xp, tp);
#line 2964
		if(lstatus != ENOERR)
#line 2964
			status = lstatus;
#line 2964
	}
#line 2964

#line 2964
	*xpp = (void *)xp;
#line 2964
	return status;
#line 2964
#endif
#line 2964
}
#line 2964



/* float ---------------------------------------------------------------------*/

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(float));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return ENOERR;
}
#elif vax
int
ncx_getn_float_float(const void **xpp, size_t nfloats, float *ip)
{
	float *const end = ip + nfloats;

	while(ip < end)
	{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 2990
		const struct ieee_single *const isp =
#line 2990
			 (const struct ieee_single *) (*xpp);
#line 2990
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 2990

#line 2990
		switch(exp) {
#line 2990
		case 0 :
#line 2990
			/* ieee subnormal */
#line 2990
			if(isp->mant_hi == min.ieee.mant_hi
#line 2990
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 2990
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 2990
			{
#line 2990
				*vsp = min.s;
#line 2990
			}
#line 2990
			else
#line 2990
			{
#line 2990
				unsigned mantissa = (isp->mant_hi << 16)
#line 2990
					 | isp->mant_lo_hi << 8
#line 2990
					 | isp->mant_lo_lo;
#line 2990
				unsigned tmp = mantissa >> 20;
#line 2990
				if(tmp >= 4) {
#line 2990
					vsp->exp = 2;
#line 2990
				} else if (tmp >= 2) {
#line 2990
					vsp->exp = 1;
#line 2990
				} else {
#line 2990
					*vsp = min.s;
#line 2990
					break;
#line 2990
				} /* else */
#line 2990
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 2990
				tmp <<= 3 - vsp->exp;
#line 2990
				vsp->mantissa2 = tmp;
#line 2990
				vsp->mantissa1 = (tmp >> 16);
#line 2990
			}
#line 2990
			break;
#line 2990
		case 0xfe :
#line 2990
		case 0xff :
#line 2990
			*vsp = max.s;
#line 2990
			break;
#line 2990
		default :
#line 2990
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 2990
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 2990
			vsp->mantissa1 = isp->mant_hi;
#line 2990
		}
#line 2990

#line 2990
		vsp->sign = isp->sign;
#line 2990


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return ENOERR;
}
#else
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
	const char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		const int lstatus = ncx_get_float_float(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}

#endif
int
#line 3016
ncx_getn_float_schar(const void **xpp, size_t nelems, schar *tp)
#line 3016
{
#line 3016
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3016

#line 3016
 /* basic algorithm is:
#line 3016
  *   - ensure sane alignment of input data
#line 3016
  *   - copy (conversion happens automatically) input data
#line 3016
  *     to output
#line 3016
  *   - update xpp to point at next unconverted input, and tp to point
#line 3016
  *     at next location for converted output
#line 3016
  */
#line 3016
  long i, j, ni;
#line 3016
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3016
  float *xp;
#line 3016
  int nrange = 0;         /* number of range errors */
#line 3016
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3016
  long cxp = (long) *((char**)xpp);
#line 3016

#line 3016
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3016
  /* sjl: manually stripmine so we can limit amount of
#line 3016
   * vector work space reserved to LOOPCNT elements. Also
#line 3016
   * makes vectorisation easy */
#line 3016
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3016
    ni=Min(nelems-j,LOOPCNT);
#line 3016
    if (realign) {
#line 3016
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3016
      xp = tmp;
#line 3016
    } else {
#line 3016
      xp = (float *) *xpp;
#line 3016
    }
#line 3016
   /* copy the next block */
#line 3016
#pragma cdir loopcnt=LOOPCNT
#line 3016
#pragma cdir shortloop
#line 3016
    for (i=0; i<ni; i++) {
#line 3016
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3016
     /* test for range errors (not always needed but do it anyway) */
#line 3016
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3016
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3016
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3016
    }
#line 3016
   /* update xpp and tp */
#line 3016
    if (realign) xp = (float *) *xpp;
#line 3016
    xp += ni;
#line 3016
    tp += ni;
#line 3016
    *xpp = (void*)xp;
#line 3016
  }
#line 3016
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3016

#line 3016
#else   /* not SX */
#line 3016
	const char *xp = (const char *) *xpp;
#line 3016
	int status = ENOERR;
#line 3016

#line 3016
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3016
	{
#line 3016
		const int lstatus = ncx_get_float_schar(xp, tp);
#line 3016
		if(lstatus != ENOERR)
#line 3016
			status = lstatus;
#line 3016
	}
#line 3016

#line 3016
	*xpp = (const void *)xp;
#line 3016
	return status;
#line 3016
#  endif
#line 3016
}
#line 3016

int
#line 3017
ncx_getn_float_short(const void **xpp, size_t nelems, short *tp)
#line 3017
{
#line 3017
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3017

#line 3017
 /* basic algorithm is:
#line 3017
  *   - ensure sane alignment of input data
#line 3017
  *   - copy (conversion happens automatically) input data
#line 3017
  *     to output
#line 3017
  *   - update xpp to point at next unconverted input, and tp to point
#line 3017
  *     at next location for converted output
#line 3017
  */
#line 3017
  long i, j, ni;
#line 3017
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3017
  float *xp;
#line 3017
  int nrange = 0;         /* number of range errors */
#line 3017
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3017
  long cxp = (long) *((char**)xpp);
#line 3017

#line 3017
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3017
  /* sjl: manually stripmine so we can limit amount of
#line 3017
   * vector work space reserved to LOOPCNT elements. Also
#line 3017
   * makes vectorisation easy */
#line 3017
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3017
    ni=Min(nelems-j,LOOPCNT);
#line 3017
    if (realign) {
#line 3017
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3017
      xp = tmp;
#line 3017
    } else {
#line 3017
      xp = (float *) *xpp;
#line 3017
    }
#line 3017
   /* copy the next block */
#line 3017
#pragma cdir loopcnt=LOOPCNT
#line 3017
#pragma cdir shortloop
#line 3017
    for (i=0; i<ni; i++) {
#line 3017
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3017
     /* test for range errors (not always needed but do it anyway) */
#line 3017
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3017
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3017
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3017
    }
#line 3017
   /* update xpp and tp */
#line 3017
    if (realign) xp = (float *) *xpp;
#line 3017
    xp += ni;
#line 3017
    tp += ni;
#line 3017
    *xpp = (void*)xp;
#line 3017
  }
#line 3017
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3017

#line 3017
#else   /* not SX */
#line 3017
	const char *xp = (const char *) *xpp;
#line 3017
	int status = ENOERR;
#line 3017

#line 3017
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3017
	{
#line 3017
		const int lstatus = ncx_get_float_short(xp, tp);
#line 3017
		if(lstatus != ENOERR)
#line 3017
			status = lstatus;
#line 3017
	}
#line 3017

#line 3017
	*xpp = (const void *)xp;
#line 3017
	return status;
#line 3017
#  endif
#line 3017
}
#line 3017

int
#line 3018
ncx_getn_float_int(const void **xpp, size_t nelems, int *tp)
#line 3018
{
#line 3018
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3018

#line 3018
 /* basic algorithm is:
#line 3018
  *   - ensure sane alignment of input data
#line 3018
  *   - copy (conversion happens automatically) input data
#line 3018
  *     to output
#line 3018
  *   - update xpp to point at next unconverted input, and tp to point
#line 3018
  *     at next location for converted output
#line 3018
  */
#line 3018
  long i, j, ni;
#line 3018
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3018
  float *xp;
#line 3018
  int nrange = 0;         /* number of range errors */
#line 3018
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3018
  long cxp = (long) *((char**)xpp);
#line 3018

#line 3018
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3018
  /* sjl: manually stripmine so we can limit amount of
#line 3018
   * vector work space reserved to LOOPCNT elements. Also
#line 3018
   * makes vectorisation easy */
#line 3018
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3018
    ni=Min(nelems-j,LOOPCNT);
#line 3018
    if (realign) {
#line 3018
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3018
      xp = tmp;
#line 3018
    } else {
#line 3018
      xp = (float *) *xpp;
#line 3018
    }
#line 3018
   /* copy the next block */
#line 3018
#pragma cdir loopcnt=LOOPCNT
#line 3018
#pragma cdir shortloop
#line 3018
    for (i=0; i<ni; i++) {
#line 3018
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3018
     /* test for range errors (not always needed but do it anyway) */
#line 3018
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3018
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3018
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3018
    }
#line 3018
   /* update xpp and tp */
#line 3018
    if (realign) xp = (float *) *xpp;
#line 3018
    xp += ni;
#line 3018
    tp += ni;
#line 3018
    *xpp = (void*)xp;
#line 3018
  }
#line 3018
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3018

#line 3018
#else   /* not SX */
#line 3018
	const char *xp = (const char *) *xpp;
#line 3018
	int status = ENOERR;
#line 3018

#line 3018
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3018
	{
#line 3018
		const int lstatus = ncx_get_float_int(xp, tp);
#line 3018
		if(lstatus != ENOERR)
#line 3018
			status = lstatus;
#line 3018
	}
#line 3018

#line 3018
	*xpp = (const void *)xp;
#line 3018
	return status;
#line 3018
#  endif
#line 3018
}
#line 3018

int
#line 3019
ncx_getn_float_double(const void **xpp, size_t nelems, double *tp)
#line 3019
{
#line 3019
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3019

#line 3019
 /* basic algorithm is:
#line 3019
  *   - ensure sane alignment of input data
#line 3019
  *   - copy (conversion happens automatically) input data
#line 3019
  *     to output
#line 3019
  *   - update xpp to point at next unconverted input, and tp to point
#line 3019
  *     at next location for converted output
#line 3019
  */
#line 3019
  long i, j, ni;
#line 3019
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3019
  float *xp;
#line 3019
  int nrange = 0;         /* number of range errors */
#line 3019
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3019
  long cxp = (long) *((char**)xpp);
#line 3019

#line 3019
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3019
  /* sjl: manually stripmine so we can limit amount of
#line 3019
   * vector work space reserved to LOOPCNT elements. Also
#line 3019
   * makes vectorisation easy */
#line 3019
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3019
    ni=Min(nelems-j,LOOPCNT);
#line 3019
    if (realign) {
#line 3019
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3019
      xp = tmp;
#line 3019
    } else {
#line 3019
      xp = (float *) *xpp;
#line 3019
    }
#line 3019
   /* copy the next block */
#line 3019
#pragma cdir loopcnt=LOOPCNT
#line 3019
#pragma cdir shortloop
#line 3019
    for (i=0; i<ni; i++) {
#line 3019
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3019
     /* test for range errors (not always needed but do it anyway) */
#line 3019
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3019
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3019
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3019
    }
#line 3019
   /* update xpp and tp */
#line 3019
    if (realign) xp = (float *) *xpp;
#line 3019
    xp += ni;
#line 3019
    tp += ni;
#line 3019
    *xpp = (void*)xp;
#line 3019
  }
#line 3019
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3019

#line 3019
#else   /* not SX */
#line 3019
	const char *xp = (const char *) *xpp;
#line 3019
	int status = ENOERR;
#line 3019

#line 3019
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3019
	{
#line 3019
		const int lstatus = ncx_get_float_double(xp, tp);
#line 3019
		if(lstatus != ENOERR)
#line 3019
			status = lstatus;
#line 3019
	}
#line 3019

#line 3019
	*xpp = (const void *)xp;
#line 3019
	return status;
#line 3019
#  endif
#line 3019
}
#line 3019

int
#line 3020
ncx_getn_float_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3020
{
#line 3020
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3020

#line 3020
 /* basic algorithm is:
#line 3020
  *   - ensure sane alignment of input data
#line 3020
  *   - copy (conversion happens automatically) input data
#line 3020
  *     to output
#line 3020
  *   - update xpp to point at next unconverted input, and tp to point
#line 3020
  *     at next location for converted output
#line 3020
  */
#line 3020
  long i, j, ni;
#line 3020
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3020
  float *xp;
#line 3020
  int nrange = 0;         /* number of range errors */
#line 3020
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3020
  long cxp = (long) *((char**)xpp);
#line 3020

#line 3020
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3020
  /* sjl: manually stripmine so we can limit amount of
#line 3020
   * vector work space reserved to LOOPCNT elements. Also
#line 3020
   * makes vectorisation easy */
#line 3020
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3020
    ni=Min(nelems-j,LOOPCNT);
#line 3020
    if (realign) {
#line 3020
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3020
      xp = tmp;
#line 3020
    } else {
#line 3020
      xp = (float *) *xpp;
#line 3020
    }
#line 3020
   /* copy the next block */
#line 3020
#pragma cdir loopcnt=LOOPCNT
#line 3020
#pragma cdir shortloop
#line 3020
    for (i=0; i<ni; i++) {
#line 3020
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3020
     /* test for range errors (not always needed but do it anyway) */
#line 3020
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3020
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3020
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3020
    }
#line 3020
   /* update xpp and tp */
#line 3020
    if (realign) xp = (float *) *xpp;
#line 3020
    xp += ni;
#line 3020
    tp += ni;
#line 3020
    *xpp = (void*)xp;
#line 3020
  }
#line 3020
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3020

#line 3020
#else   /* not SX */
#line 3020
	const char *xp = (const char *) *xpp;
#line 3020
	int status = ENOERR;
#line 3020

#line 3020
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3020
	{
#line 3020
		const int lstatus = ncx_get_float_longlong(xp, tp);
#line 3020
		if(lstatus != ENOERR)
#line 3020
			status = lstatus;
#line 3020
	}
#line 3020

#line 3020
	*xpp = (const void *)xp;
#line 3020
	return status;
#line 3020
#  endif
#line 3020
}
#line 3020

int
#line 3021
ncx_getn_float_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3021
{
#line 3021
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3021

#line 3021
 /* basic algorithm is:
#line 3021
  *   - ensure sane alignment of input data
#line 3021
  *   - copy (conversion happens automatically) input data
#line 3021
  *     to output
#line 3021
  *   - update xpp to point at next unconverted input, and tp to point
#line 3021
  *     at next location for converted output
#line 3021
  */
#line 3021
  long i, j, ni;
#line 3021
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3021
  float *xp;
#line 3021
  int nrange = 0;         /* number of range errors */
#line 3021
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3021
  long cxp = (long) *((char**)xpp);
#line 3021

#line 3021
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3021
  /* sjl: manually stripmine so we can limit amount of
#line 3021
   * vector work space reserved to LOOPCNT elements. Also
#line 3021
   * makes vectorisation easy */
#line 3021
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3021
    ni=Min(nelems-j,LOOPCNT);
#line 3021
    if (realign) {
#line 3021
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3021
      xp = tmp;
#line 3021
    } else {
#line 3021
      xp = (float *) *xpp;
#line 3021
    }
#line 3021
   /* copy the next block */
#line 3021
#pragma cdir loopcnt=LOOPCNT
#line 3021
#pragma cdir shortloop
#line 3021
    for (i=0; i<ni; i++) {
#line 3021
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3021
     /* test for range errors (not always needed but do it anyway) */
#line 3021
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3021
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3021
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3021
    }
#line 3021
   /* update xpp and tp */
#line 3021
    if (realign) xp = (float *) *xpp;
#line 3021
    xp += ni;
#line 3021
    tp += ni;
#line 3021
    *xpp = (void*)xp;
#line 3021
  }
#line 3021
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3021

#line 3021
#else   /* not SX */
#line 3021
	const char *xp = (const char *) *xpp;
#line 3021
	int status = ENOERR;
#line 3021

#line 3021
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3021
	{
#line 3021
		const int lstatus = ncx_get_float_ushort(xp, tp);
#line 3021
		if(lstatus != ENOERR)
#line 3021
			status = lstatus;
#line 3021
	}
#line 3021

#line 3021
	*xpp = (const void *)xp;
#line 3021
	return status;
#line 3021
#  endif
#line 3021
}
#line 3021

int
#line 3022
ncx_getn_float_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3022
{
#line 3022
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3022

#line 3022
 /* basic algorithm is:
#line 3022
  *   - ensure sane alignment of input data
#line 3022
  *   - copy (conversion happens automatically) input data
#line 3022
  *     to output
#line 3022
  *   - update xpp to point at next unconverted input, and tp to point
#line 3022
  *     at next location for converted output
#line 3022
  */
#line 3022
  long i, j, ni;
#line 3022
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3022
  float *xp;
#line 3022
  int nrange = 0;         /* number of range errors */
#line 3022
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3022
  long cxp = (long) *((char**)xpp);
#line 3022

#line 3022
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3022
  /* sjl: manually stripmine so we can limit amount of
#line 3022
   * vector work space reserved to LOOPCNT elements. Also
#line 3022
   * makes vectorisation easy */
#line 3022
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3022
    ni=Min(nelems-j,LOOPCNT);
#line 3022
    if (realign) {
#line 3022
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3022
      xp = tmp;
#line 3022
    } else {
#line 3022
      xp = (float *) *xpp;
#line 3022
    }
#line 3022
   /* copy the next block */
#line 3022
#pragma cdir loopcnt=LOOPCNT
#line 3022
#pragma cdir shortloop
#line 3022
    for (i=0; i<ni; i++) {
#line 3022
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3022
     /* test for range errors (not always needed but do it anyway) */
#line 3022
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3022
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3022
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3022
    }
#line 3022
   /* update xpp and tp */
#line 3022
    if (realign) xp = (float *) *xpp;
#line 3022
    xp += ni;
#line 3022
    tp += ni;
#line 3022
    *xpp = (void*)xp;
#line 3022
  }
#line 3022
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3022

#line 3022
#else   /* not SX */
#line 3022
	const char *xp = (const char *) *xpp;
#line 3022
	int status = ENOERR;
#line 3022

#line 3022
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3022
	{
#line 3022
		const int lstatus = ncx_get_float_uchar(xp, tp);
#line 3022
		if(lstatus != ENOERR)
#line 3022
			status = lstatus;
#line 3022
	}
#line 3022

#line 3022
	*xpp = (const void *)xp;
#line 3022
	return status;
#line 3022
#  endif
#line 3022
}
#line 3022

int
#line 3023
ncx_getn_float_uint(const void **xpp, size_t nelems, uint *tp)
#line 3023
{
#line 3023
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3023

#line 3023
 /* basic algorithm is:
#line 3023
  *   - ensure sane alignment of input data
#line 3023
  *   - copy (conversion happens automatically) input data
#line 3023
  *     to output
#line 3023
  *   - update xpp to point at next unconverted input, and tp to point
#line 3023
  *     at next location for converted output
#line 3023
  */
#line 3023
  long i, j, ni;
#line 3023
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3023
  float *xp;
#line 3023
  int nrange = 0;         /* number of range errors */
#line 3023
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3023
  long cxp = (long) *((char**)xpp);
#line 3023

#line 3023
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3023
  /* sjl: manually stripmine so we can limit amount of
#line 3023
   * vector work space reserved to LOOPCNT elements. Also
#line 3023
   * makes vectorisation easy */
#line 3023
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3023
    ni=Min(nelems-j,LOOPCNT);
#line 3023
    if (realign) {
#line 3023
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3023
      xp = tmp;
#line 3023
    } else {
#line 3023
      xp = (float *) *xpp;
#line 3023
    }
#line 3023
   /* copy the next block */
#line 3023
#pragma cdir loopcnt=LOOPCNT
#line 3023
#pragma cdir shortloop
#line 3023
    for (i=0; i<ni; i++) {
#line 3023
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3023
     /* test for range errors (not always needed but do it anyway) */
#line 3023
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3023
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3023
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3023
    }
#line 3023
   /* update xpp and tp */
#line 3023
    if (realign) xp = (float *) *xpp;
#line 3023
    xp += ni;
#line 3023
    tp += ni;
#line 3023
    *xpp = (void*)xp;
#line 3023
  }
#line 3023
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3023

#line 3023
#else   /* not SX */
#line 3023
	const char *xp = (const char *) *xpp;
#line 3023
	int status = ENOERR;
#line 3023

#line 3023
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3023
	{
#line 3023
		const int lstatus = ncx_get_float_uint(xp, tp);
#line 3023
		if(lstatus != ENOERR)
#line 3023
			status = lstatus;
#line 3023
	}
#line 3023

#line 3023
	*xpp = (const void *)xp;
#line 3023
	return status;
#line 3023
#  endif
#line 3023
}
#line 3023

int
#line 3024
ncx_getn_float_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3024
{
#line 3024
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3024

#line 3024
 /* basic algorithm is:
#line 3024
  *   - ensure sane alignment of input data
#line 3024
  *   - copy (conversion happens automatically) input data
#line 3024
  *     to output
#line 3024
  *   - update xpp to point at next unconverted input, and tp to point
#line 3024
  *     at next location for converted output
#line 3024
  */
#line 3024
  long i, j, ni;
#line 3024
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3024
  float *xp;
#line 3024
  int nrange = 0;         /* number of range errors */
#line 3024
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3024
  long cxp = (long) *((char**)xpp);
#line 3024

#line 3024
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3024
  /* sjl: manually stripmine so we can limit amount of
#line 3024
   * vector work space reserved to LOOPCNT elements. Also
#line 3024
   * makes vectorisation easy */
#line 3024
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3024
    ni=Min(nelems-j,LOOPCNT);
#line 3024
    if (realign) {
#line 3024
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3024
      xp = tmp;
#line 3024
    } else {
#line 3024
      xp = (float *) *xpp;
#line 3024
    }
#line 3024
   /* copy the next block */
#line 3024
#pragma cdir loopcnt=LOOPCNT
#line 3024
#pragma cdir shortloop
#line 3024
    for (i=0; i<ni; i++) {
#line 3024
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3024
     /* test for range errors (not always needed but do it anyway) */
#line 3024
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3024
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3024
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3024
    }
#line 3024
   /* update xpp and tp */
#line 3024
    if (realign) xp = (float *) *xpp;
#line 3024
    xp += ni;
#line 3024
    tp += ni;
#line 3024
    *xpp = (void*)xp;
#line 3024
  }
#line 3024
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3024

#line 3024
#else   /* not SX */
#line 3024
	const char *xp = (const char *) *xpp;
#line 3024
	int status = ENOERR;
#line 3024

#line 3024
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3024
	{
#line 3024
		const int lstatus = ncx_get_float_ulonglong(xp, tp);
#line 3024
		if(lstatus != ENOERR)
#line 3024
			status = lstatus;
#line 3024
	}
#line 3024

#line 3024
	*xpp = (const void *)xp;
#line 3024
	return status;
#line 3024
#  endif
#line 3024
}
#line 3024


#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_FLOAT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return ENOERR;
}
#elif vax
int
ncx_putn_float_float(void **xpp, size_t nfloats, const float *ip)
{
	const float *const end = ip + nfloats;

	while(ip < end)
	{
		const struct vax_single *const vsp =
#line 3047
			 (const struct vax_single *)ip;
#line 3047
		struct ieee_single *const isp = (struct ieee_single *) (*xpp);
#line 3047

#line 3047
		switch(vsp->exp){
#line 3047
		case 0 :
#line 3047
			/* all vax float with zero exponent map to zero */
#line 3047
			*isp = min.ieee;
#line 3047
			break;
#line 3047
		case 2 :
#line 3047
		case 1 :
#line 3047
		{
#line 3047
			/* These will map to subnormals */
#line 3047
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 3047
					 | vsp->mantissa2;
#line 3047
			mantissa >>= 3 - vsp->exp;
#line 3047
			mantissa += (1 << (20 + vsp->exp));
#line 3047
			isp->mant_lo_lo = mantissa;
#line 3047
			isp->mant_lo_hi = mantissa >> 8;
#line 3047
			isp->mant_hi = mantissa >> 16;
#line 3047
			isp->exp_lo = 0;
#line 3047
			isp->exp_hi = 0;
#line 3047
		}
#line 3047
			break;
#line 3047
		case 0xff : /* max.s.exp */
#line 3047
			if( vsp->mantissa2 == max.s.mantissa2
#line 3047
				&& vsp->mantissa1 == max.s.mantissa1)
#line 3047
			{
#line 3047
				/* map largest vax float to ieee infinity */
#line 3047
				*isp = max.ieee;
#line 3047
				break;
#line 3047
			} /* else, fall thru */
#line 3047
		default :
#line 3047
		{
#line 3047
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 3047
			isp->exp_hi = exp >> 1;
#line 3047
			isp->exp_lo = exp;
#line 3047
			isp->mant_lo_lo = vsp->mantissa2;
#line 3047
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 3047
			isp->mant_hi = vsp->mantissa1;
#line 3047
		}
#line 3047
		}
#line 3047

#line 3047
		isp->sign = vsp->sign;
#line 3047

	
		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return ENOERR;
}
#else
int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp)
{
	char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		int lstatus = ncx_put_float_float(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3072
ncx_putn_float_schar(void **xpp, size_t nelems, const schar *tp)
#line 3072
{
#line 3072
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3072

#line 3072
 /* basic algorithm is:
#line 3072
  *   - ensure sane alignment of output data
#line 3072
  *   - copy (conversion happens automatically) input data
#line 3072
  *     to output
#line 3072
  *   - update tp to point at next unconverted input, and xpp to point
#line 3072
  *     at next location for converted output
#line 3072
  */
#line 3072
  long i, j, ni;
#line 3072
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3072
  float *xp;
#line 3072
  int nrange = 0;         /* number of range errors */
#line 3072
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3072
  long cxp = (long) *((char**)xpp);
#line 3072

#line 3072
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3072
  /* sjl: manually stripmine so we can limit amount of
#line 3072
   * vector work space reserved to LOOPCNT elements. Also
#line 3072
   * makes vectorisation easy */
#line 3072
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3072
    ni=Min(nelems-j,LOOPCNT);
#line 3072
    if (realign) {
#line 3072
      xp = tmp;
#line 3072
    } else {
#line 3072
      xp = (float *) *xpp;
#line 3072
    }
#line 3072
   /* copy the next block */
#line 3072
#pragma cdir loopcnt=LOOPCNT
#line 3072
#pragma cdir shortloop
#line 3072
    for (i=0; i<ni; i++) {
#line 3072
      /* the normal case: */
#line 3072
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3072
     /* test for range errors (not always needed but do it anyway) */
#line 3072
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3072
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3072
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3072
    }
#line 3072
   /* copy workspace back if necessary */ 
#line 3072
    if (realign) {
#line 3072
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3072
      xp = (float *) *xpp;
#line 3072
    }
#line 3072
   /* update xpp and tp */
#line 3072
    xp += ni;
#line 3072
    tp += ni;
#line 3072
    *xpp = (void*)xp;
#line 3072
  }
#line 3072
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3072

#line 3072
#else   /* not SX */
#line 3072

#line 3072
	char *xp = (char *) *xpp;
#line 3072
	int status = ENOERR;
#line 3072

#line 3072
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3072
	{
#line 3072
		int lstatus = ncx_put_float_schar(xp, tp);
#line 3072
		if(lstatus != ENOERR)
#line 3072
			status = lstatus;
#line 3072
	}
#line 3072

#line 3072
	*xpp = (void *)xp;
#line 3072
	return status;
#line 3072
#endif
#line 3072
}
#line 3072

int
#line 3073
ncx_putn_float_short(void **xpp, size_t nelems, const short *tp)
#line 3073
{
#line 3073
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3073

#line 3073
 /* basic algorithm is:
#line 3073
  *   - ensure sane alignment of output data
#line 3073
  *   - copy (conversion happens automatically) input data
#line 3073
  *     to output
#line 3073
  *   - update tp to point at next unconverted input, and xpp to point
#line 3073
  *     at next location for converted output
#line 3073
  */
#line 3073
  long i, j, ni;
#line 3073
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3073
  float *xp;
#line 3073
  int nrange = 0;         /* number of range errors */
#line 3073
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3073
  long cxp = (long) *((char**)xpp);
#line 3073

#line 3073
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3073
  /* sjl: manually stripmine so we can limit amount of
#line 3073
   * vector work space reserved to LOOPCNT elements. Also
#line 3073
   * makes vectorisation easy */
#line 3073
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3073
    ni=Min(nelems-j,LOOPCNT);
#line 3073
    if (realign) {
#line 3073
      xp = tmp;
#line 3073
    } else {
#line 3073
      xp = (float *) *xpp;
#line 3073
    }
#line 3073
   /* copy the next block */
#line 3073
#pragma cdir loopcnt=LOOPCNT
#line 3073
#pragma cdir shortloop
#line 3073
    for (i=0; i<ni; i++) {
#line 3073
      /* the normal case: */
#line 3073
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3073
     /* test for range errors (not always needed but do it anyway) */
#line 3073
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3073
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3073
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3073
    }
#line 3073
   /* copy workspace back if necessary */ 
#line 3073
    if (realign) {
#line 3073
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3073
      xp = (float *) *xpp;
#line 3073
    }
#line 3073
   /* update xpp and tp */
#line 3073
    xp += ni;
#line 3073
    tp += ni;
#line 3073
    *xpp = (void*)xp;
#line 3073
  }
#line 3073
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3073

#line 3073
#else   /* not SX */
#line 3073

#line 3073
	char *xp = (char *) *xpp;
#line 3073
	int status = ENOERR;
#line 3073

#line 3073
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3073
	{
#line 3073
		int lstatus = ncx_put_float_short(xp, tp);
#line 3073
		if(lstatus != ENOERR)
#line 3073
			status = lstatus;
#line 3073
	}
#line 3073

#line 3073
	*xpp = (void *)xp;
#line 3073
	return status;
#line 3073
#endif
#line 3073
}
#line 3073

int
#line 3074
ncx_putn_float_int(void **xpp, size_t nelems, const int *tp)
#line 3074
{
#line 3074
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3074

#line 3074
 /* basic algorithm is:
#line 3074
  *   - ensure sane alignment of output data
#line 3074
  *   - copy (conversion happens automatically) input data
#line 3074
  *     to output
#line 3074
  *   - update tp to point at next unconverted input, and xpp to point
#line 3074
  *     at next location for converted output
#line 3074
  */
#line 3074
  long i, j, ni;
#line 3074
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3074
  float *xp;
#line 3074
  int nrange = 0;         /* number of range errors */
#line 3074
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3074
  long cxp = (long) *((char**)xpp);
#line 3074

#line 3074
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3074
  /* sjl: manually stripmine so we can limit amount of
#line 3074
   * vector work space reserved to LOOPCNT elements. Also
#line 3074
   * makes vectorisation easy */
#line 3074
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3074
    ni=Min(nelems-j,LOOPCNT);
#line 3074
    if (realign) {
#line 3074
      xp = tmp;
#line 3074
    } else {
#line 3074
      xp = (float *) *xpp;
#line 3074
    }
#line 3074
   /* copy the next block */
#line 3074
#pragma cdir loopcnt=LOOPCNT
#line 3074
#pragma cdir shortloop
#line 3074
    for (i=0; i<ni; i++) {
#line 3074
      /* the normal case: */
#line 3074
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3074
     /* test for range errors (not always needed but do it anyway) */
#line 3074
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3074
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3074
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3074
    }
#line 3074
   /* copy workspace back if necessary */ 
#line 3074
    if (realign) {
#line 3074
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3074
      xp = (float *) *xpp;
#line 3074
    }
#line 3074
   /* update xpp and tp */
#line 3074
    xp += ni;
#line 3074
    tp += ni;
#line 3074
    *xpp = (void*)xp;
#line 3074
  }
#line 3074
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3074

#line 3074
#else   /* not SX */
#line 3074

#line 3074
	char *xp = (char *) *xpp;
#line 3074
	int status = ENOERR;
#line 3074

#line 3074
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3074
	{
#line 3074
		int lstatus = ncx_put_float_int(xp, tp);
#line 3074
		if(lstatus != ENOERR)
#line 3074
			status = lstatus;
#line 3074
	}
#line 3074

#line 3074
	*xpp = (void *)xp;
#line 3074
	return status;
#line 3074
#endif
#line 3074
}
#line 3074

int
#line 3075
ncx_putn_float_double(void **xpp, size_t nelems, const double *tp)
#line 3075
{
#line 3075
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3075

#line 3075
 /* basic algorithm is:
#line 3075
  *   - ensure sane alignment of output data
#line 3075
  *   - copy (conversion happens automatically) input data
#line 3075
  *     to output
#line 3075
  *   - update tp to point at next unconverted input, and xpp to point
#line 3075
  *     at next location for converted output
#line 3075
  */
#line 3075
  long i, j, ni;
#line 3075
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3075
  float *xp;
#line 3075
  int nrange = 0;         /* number of range errors */
#line 3075
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3075
  long cxp = (long) *((char**)xpp);
#line 3075

#line 3075
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3075
  /* sjl: manually stripmine so we can limit amount of
#line 3075
   * vector work space reserved to LOOPCNT elements. Also
#line 3075
   * makes vectorisation easy */
#line 3075
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3075
    ni=Min(nelems-j,LOOPCNT);
#line 3075
    if (realign) {
#line 3075
      xp = tmp;
#line 3075
    } else {
#line 3075
      xp = (float *) *xpp;
#line 3075
    }
#line 3075
   /* copy the next block */
#line 3075
#pragma cdir loopcnt=LOOPCNT
#line 3075
#pragma cdir shortloop
#line 3075
    for (i=0; i<ni; i++) {
#line 3075
      /* the normal case: */
#line 3075
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3075
     /* test for range errors (not always needed but do it anyway) */
#line 3075
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3075
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3075
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3075
    }
#line 3075
   /* copy workspace back if necessary */ 
#line 3075
    if (realign) {
#line 3075
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3075
      xp = (float *) *xpp;
#line 3075
    }
#line 3075
   /* update xpp and tp */
#line 3075
    xp += ni;
#line 3075
    tp += ni;
#line 3075
    *xpp = (void*)xp;
#line 3075
  }
#line 3075
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3075

#line 3075
#else   /* not SX */
#line 3075

#line 3075
	char *xp = (char *) *xpp;
#line 3075
	int status = ENOERR;
#line 3075

#line 3075
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3075
	{
#line 3075
		int lstatus = ncx_put_float_double(xp, tp);
#line 3075
		if(lstatus != ENOERR)
#line 3075
			status = lstatus;
#line 3075
	}
#line 3075

#line 3075
	*xpp = (void *)xp;
#line 3075
	return status;
#line 3075
#endif
#line 3075
}
#line 3075

int
#line 3076
ncx_putn_float_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3076
{
#line 3076
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3076

#line 3076
 /* basic algorithm is:
#line 3076
  *   - ensure sane alignment of output data
#line 3076
  *   - copy (conversion happens automatically) input data
#line 3076
  *     to output
#line 3076
  *   - update tp to point at next unconverted input, and xpp to point
#line 3076
  *     at next location for converted output
#line 3076
  */
#line 3076
  long i, j, ni;
#line 3076
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3076
  float *xp;
#line 3076
  int nrange = 0;         /* number of range errors */
#line 3076
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3076
  long cxp = (long) *((char**)xpp);
#line 3076

#line 3076
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3076
  /* sjl: manually stripmine so we can limit amount of
#line 3076
   * vector work space reserved to LOOPCNT elements. Also
#line 3076
   * makes vectorisation easy */
#line 3076
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3076
    ni=Min(nelems-j,LOOPCNT);
#line 3076
    if (realign) {
#line 3076
      xp = tmp;
#line 3076
    } else {
#line 3076
      xp = (float *) *xpp;
#line 3076
    }
#line 3076
   /* copy the next block */
#line 3076
#pragma cdir loopcnt=LOOPCNT
#line 3076
#pragma cdir shortloop
#line 3076
    for (i=0; i<ni; i++) {
#line 3076
      /* the normal case: */
#line 3076
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3076
     /* test for range errors (not always needed but do it anyway) */
#line 3076
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3076
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3076
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3076
    }
#line 3076
   /* copy workspace back if necessary */ 
#line 3076
    if (realign) {
#line 3076
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3076
      xp = (float *) *xpp;
#line 3076
    }
#line 3076
   /* update xpp and tp */
#line 3076
    xp += ni;
#line 3076
    tp += ni;
#line 3076
    *xpp = (void*)xp;
#line 3076
  }
#line 3076
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3076

#line 3076
#else   /* not SX */
#line 3076

#line 3076
	char *xp = (char *) *xpp;
#line 3076
	int status = ENOERR;
#line 3076

#line 3076
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3076
	{
#line 3076
		int lstatus = ncx_put_float_longlong(xp, tp);
#line 3076
		if(lstatus != ENOERR)
#line 3076
			status = lstatus;
#line 3076
	}
#line 3076

#line 3076
	*xpp = (void *)xp;
#line 3076
	return status;
#line 3076
#endif
#line 3076
}
#line 3076

int
#line 3077
ncx_putn_float_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3077
{
#line 3077
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3077

#line 3077
 /* basic algorithm is:
#line 3077
  *   - ensure sane alignment of output data
#line 3077
  *   - copy (conversion happens automatically) input data
#line 3077
  *     to output
#line 3077
  *   - update tp to point at next unconverted input, and xpp to point
#line 3077
  *     at next location for converted output
#line 3077
  */
#line 3077
  long i, j, ni;
#line 3077
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3077
  float *xp;
#line 3077
  int nrange = 0;         /* number of range errors */
#line 3077
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3077
  long cxp = (long) *((char**)xpp);
#line 3077

#line 3077
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3077
  /* sjl: manually stripmine so we can limit amount of
#line 3077
   * vector work space reserved to LOOPCNT elements. Also
#line 3077
   * makes vectorisation easy */
#line 3077
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3077
    ni=Min(nelems-j,LOOPCNT);
#line 3077
    if (realign) {
#line 3077
      xp = tmp;
#line 3077
    } else {
#line 3077
      xp = (float *) *xpp;
#line 3077
    }
#line 3077
   /* copy the next block */
#line 3077
#pragma cdir loopcnt=LOOPCNT
#line 3077
#pragma cdir shortloop
#line 3077
    for (i=0; i<ni; i++) {
#line 3077
      /* the normal case: */
#line 3077
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3077
     /* test for range errors (not always needed but do it anyway) */
#line 3077
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3077
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3077
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3077
    }
#line 3077
   /* copy workspace back if necessary */ 
#line 3077
    if (realign) {
#line 3077
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3077
      xp = (float *) *xpp;
#line 3077
    }
#line 3077
   /* update xpp and tp */
#line 3077
    xp += ni;
#line 3077
    tp += ni;
#line 3077
    *xpp = (void*)xp;
#line 3077
  }
#line 3077
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3077

#line 3077
#else   /* not SX */
#line 3077

#line 3077
	char *xp = (char *) *xpp;
#line 3077
	int status = ENOERR;
#line 3077

#line 3077
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3077
	{
#line 3077
		int lstatus = ncx_put_float_uchar(xp, tp);
#line 3077
		if(lstatus != ENOERR)
#line 3077
			status = lstatus;
#line 3077
	}
#line 3077

#line 3077
	*xpp = (void *)xp;
#line 3077
	return status;
#line 3077
#endif
#line 3077
}
#line 3077

int
#line 3078
ncx_putn_float_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3078
{
#line 3078
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3078

#line 3078
 /* basic algorithm is:
#line 3078
  *   - ensure sane alignment of output data
#line 3078
  *   - copy (conversion happens automatically) input data
#line 3078
  *     to output
#line 3078
  *   - update tp to point at next unconverted input, and xpp to point
#line 3078
  *     at next location for converted output
#line 3078
  */
#line 3078
  long i, j, ni;
#line 3078
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3078
  float *xp;
#line 3078
  int nrange = 0;         /* number of range errors */
#line 3078
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3078
  long cxp = (long) *((char**)xpp);
#line 3078

#line 3078
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3078
  /* sjl: manually stripmine so we can limit amount of
#line 3078
   * vector work space reserved to LOOPCNT elements. Also
#line 3078
   * makes vectorisation easy */
#line 3078
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3078
    ni=Min(nelems-j,LOOPCNT);
#line 3078
    if (realign) {
#line 3078
      xp = tmp;
#line 3078
    } else {
#line 3078
      xp = (float *) *xpp;
#line 3078
    }
#line 3078
   /* copy the next block */
#line 3078
#pragma cdir loopcnt=LOOPCNT
#line 3078
#pragma cdir shortloop
#line 3078
    for (i=0; i<ni; i++) {
#line 3078
      /* the normal case: */
#line 3078
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3078
     /* test for range errors (not always needed but do it anyway) */
#line 3078
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3078
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3078
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3078
    }
#line 3078
   /* copy workspace back if necessary */ 
#line 3078
    if (realign) {
#line 3078
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3078
      xp = (float *) *xpp;
#line 3078
    }
#line 3078
   /* update xpp and tp */
#line 3078
    xp += ni;
#line 3078
    tp += ni;
#line 3078
    *xpp = (void*)xp;
#line 3078
  }
#line 3078
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3078

#line 3078
#else   /* not SX */
#line 3078

#line 3078
	char *xp = (char *) *xpp;
#line 3078
	int status = ENOERR;
#line 3078

#line 3078
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3078
	{
#line 3078
		int lstatus = ncx_put_float_ushort(xp, tp);
#line 3078
		if(lstatus != ENOERR)
#line 3078
			status = lstatus;
#line 3078
	}
#line 3078

#line 3078
	*xpp = (void *)xp;
#line 3078
	return status;
#line 3078
#endif
#line 3078
}
#line 3078

int
#line 3079
ncx_putn_float_uint(void **xpp, size_t nelems, const uint *tp)
#line 3079
{
#line 3079
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3079

#line 3079
 /* basic algorithm is:
#line 3079
  *   - ensure sane alignment of output data
#line 3079
  *   - copy (conversion happens automatically) input data
#line 3079
  *     to output
#line 3079
  *   - update tp to point at next unconverted input, and xpp to point
#line 3079
  *     at next location for converted output
#line 3079
  */
#line 3079
  long i, j, ni;
#line 3079
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3079
  float *xp;
#line 3079
  int nrange = 0;         /* number of range errors */
#line 3079
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3079
  long cxp = (long) *((char**)xpp);
#line 3079

#line 3079
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3079
  /* sjl: manually stripmine so we can limit amount of
#line 3079
   * vector work space reserved to LOOPCNT elements. Also
#line 3079
   * makes vectorisation easy */
#line 3079
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3079
    ni=Min(nelems-j,LOOPCNT);
#line 3079
    if (realign) {
#line 3079
      xp = tmp;
#line 3079
    } else {
#line 3079
      xp = (float *) *xpp;
#line 3079
    }
#line 3079
   /* copy the next block */
#line 3079
#pragma cdir loopcnt=LOOPCNT
#line 3079
#pragma cdir shortloop
#line 3079
    for (i=0; i<ni; i++) {
#line 3079
      /* the normal case: */
#line 3079
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3079
     /* test for range errors (not always needed but do it anyway) */
#line 3079
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3079
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3079
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3079
    }
#line 3079
   /* copy workspace back if necessary */ 
#line 3079
    if (realign) {
#line 3079
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3079
      xp = (float *) *xpp;
#line 3079
    }
#line 3079
   /* update xpp and tp */
#line 3079
    xp += ni;
#line 3079
    tp += ni;
#line 3079
    *xpp = (void*)xp;
#line 3079
  }
#line 3079
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3079

#line 3079
#else   /* not SX */
#line 3079

#line 3079
	char *xp = (char *) *xpp;
#line 3079
	int status = ENOERR;
#line 3079

#line 3079
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3079
	{
#line 3079
		int lstatus = ncx_put_float_uint(xp, tp);
#line 3079
		if(lstatus != ENOERR)
#line 3079
			status = lstatus;
#line 3079
	}
#line 3079

#line 3079
	*xpp = (void *)xp;
#line 3079
	return status;
#line 3079
#endif
#line 3079
}
#line 3079

int
#line 3080
ncx_putn_float_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3080
{
#line 3080
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3080

#line 3080
 /* basic algorithm is:
#line 3080
  *   - ensure sane alignment of output data
#line 3080
  *   - copy (conversion happens automatically) input data
#line 3080
  *     to output
#line 3080
  *   - update tp to point at next unconverted input, and xpp to point
#line 3080
  *     at next location for converted output
#line 3080
  */
#line 3080
  long i, j, ni;
#line 3080
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3080
  float *xp;
#line 3080
  int nrange = 0;         /* number of range errors */
#line 3080
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3080
  long cxp = (long) *((char**)xpp);
#line 3080

#line 3080
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3080
  /* sjl: manually stripmine so we can limit amount of
#line 3080
   * vector work space reserved to LOOPCNT elements. Also
#line 3080
   * makes vectorisation easy */
#line 3080
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3080
    ni=Min(nelems-j,LOOPCNT);
#line 3080
    if (realign) {
#line 3080
      xp = tmp;
#line 3080
    } else {
#line 3080
      xp = (float *) *xpp;
#line 3080
    }
#line 3080
   /* copy the next block */
#line 3080
#pragma cdir loopcnt=LOOPCNT
#line 3080
#pragma cdir shortloop
#line 3080
    for (i=0; i<ni; i++) {
#line 3080
      /* the normal case: */
#line 3080
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3080
     /* test for range errors (not always needed but do it anyway) */
#line 3080
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3080
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3080
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3080
    }
#line 3080
   /* copy workspace back if necessary */ 
#line 3080
    if (realign) {
#line 3080
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3080
      xp = (float *) *xpp;
#line 3080
    }
#line 3080
   /* update xpp and tp */
#line 3080
    xp += ni;
#line 3080
    tp += ni;
#line 3080
    *xpp = (void*)xp;
#line 3080
  }
#line 3080
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3080

#line 3080
#else   /* not SX */
#line 3080

#line 3080
	char *xp = (char *) *xpp;
#line 3080
	int status = ENOERR;
#line 3080

#line 3080
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3080
	{
#line 3080
		int lstatus = ncx_put_float_ulonglong(xp, tp);
#line 3080
		if(lstatus != ENOERR)
#line 3080
			status = lstatus;
#line 3080
	}
#line 3080

#line 3080
	*xpp = (void *)xp;
#line 3080
	return status;
#line 3080
#endif
#line 3080
}
#line 3080


/* double --------------------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(double));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return ENOERR;
}
#elif vax
int
ncx_getn_double_double(const void **xpp, size_t ndoubles, double *ip)
{
	double *const end = ip + ndoubles;

	while(ip < end)
	{
	struct vax_double *const vdp =
#line 3105
			 (struct vax_double *)ip;
#line 3105
	const struct ieee_double *const idp =
#line 3105
			 (const struct ieee_double *) (*xpp);
#line 3105
	{
#line 3105
		const struct dbl_limits *lim;
#line 3105
		int ii;
#line 3105
		for (ii = 0, lim = dbl_limits;
#line 3105
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 3105
			ii++, lim++)
#line 3105
		{
#line 3105
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 3105
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 3105
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 3105
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 3105
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 3105
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 3105
				)
#line 3105
			{
#line 3105
				*vdp = lim->d;
#line 3105
				goto doneit;
#line 3105
			}
#line 3105
		}
#line 3105
	}
#line 3105
	{
#line 3105
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 3105
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 3105
	}
#line 3105
	{
#line 3105
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 3105
				 | (idp->mant_5 << 8)
#line 3105
				 | idp->mant_4);
#line 3105
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 3105
		vdp->mantissa1 = (mant_hi >> 13);
#line 3105
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 3105
				| (mant_lo >> 29);
#line 3105
		vdp->mantissa3 = (mant_lo >> 13);
#line 3105
		vdp->mantissa4 = (mant_lo << 3);
#line 3105
	}
#line 3105
	doneit:
#line 3105
		vdp->sign = idp->sign;
#line 3105

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return ENOERR;
}
	/* vax */
#else
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
	const char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		const int lstatus = ncx_get_double_double(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}
#endif
int
#line 3130
ncx_getn_double_schar(const void **xpp, size_t nelems, schar *tp)
#line 3130
{
#line 3130
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3130

#line 3130
 /* basic algorithm is:
#line 3130
  *   - ensure sane alignment of input data
#line 3130
  *   - copy (conversion happens automatically) input data
#line 3130
  *     to output
#line 3130
  *   - update xpp to point at next unconverted input, and tp to point
#line 3130
  *     at next location for converted output
#line 3130
  */
#line 3130
  long i, j, ni;
#line 3130
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3130
  double *xp;
#line 3130
  int nrange = 0;         /* number of range errors */
#line 3130
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3130
  long cxp = (long) *((char**)xpp);
#line 3130

#line 3130
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3130
  /* sjl: manually stripmine so we can limit amount of
#line 3130
   * vector work space reserved to LOOPCNT elements. Also
#line 3130
   * makes vectorisation easy */
#line 3130
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3130
    ni=Min(nelems-j,LOOPCNT);
#line 3130
    if (realign) {
#line 3130
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3130
      xp = tmp;
#line 3130
    } else {
#line 3130
      xp = (double *) *xpp;
#line 3130
    }
#line 3130
   /* copy the next block */
#line 3130
#pragma cdir loopcnt=LOOPCNT
#line 3130
#pragma cdir shortloop
#line 3130
    for (i=0; i<ni; i++) {
#line 3130
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3130
     /* test for range errors (not always needed but do it anyway) */
#line 3130
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3130
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3130
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3130
    }
#line 3130
   /* update xpp and tp */
#line 3130
    if (realign) xp = (double *) *xpp;
#line 3130
    xp += ni;
#line 3130
    tp += ni;
#line 3130
    *xpp = (void*)xp;
#line 3130
  }
#line 3130
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3130

#line 3130
#else   /* not SX */
#line 3130
	const char *xp = (const char *) *xpp;
#line 3130
	int status = ENOERR;
#line 3130

#line 3130
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3130
	{
#line 3130
		const int lstatus = ncx_get_double_schar(xp, tp);
#line 3130
		if(lstatus != ENOERR)
#line 3130
			status = lstatus;
#line 3130
	}
#line 3130

#line 3130
	*xpp = (const void *)xp;
#line 3130
	return status;
#line 3130
#  endif
#line 3130
}
#line 3130

int
#line 3131
ncx_getn_double_short(const void **xpp, size_t nelems, short *tp)
#line 3131
{
#line 3131
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3131

#line 3131
 /* basic algorithm is:
#line 3131
  *   - ensure sane alignment of input data
#line 3131
  *   - copy (conversion happens automatically) input data
#line 3131
  *     to output
#line 3131
  *   - update xpp to point at next unconverted input, and tp to point
#line 3131
  *     at next location for converted output
#line 3131
  */
#line 3131
  long i, j, ni;
#line 3131
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3131
  double *xp;
#line 3131
  int nrange = 0;         /* number of range errors */
#line 3131
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3131
  long cxp = (long) *((char**)xpp);
#line 3131

#line 3131
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3131
  /* sjl: manually stripmine so we can limit amount of
#line 3131
   * vector work space reserved to LOOPCNT elements. Also
#line 3131
   * makes vectorisation easy */
#line 3131
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3131
    ni=Min(nelems-j,LOOPCNT);
#line 3131
    if (realign) {
#line 3131
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3131
      xp = tmp;
#line 3131
    } else {
#line 3131
      xp = (double *) *xpp;
#line 3131
    }
#line 3131
   /* copy the next block */
#line 3131
#pragma cdir loopcnt=LOOPCNT
#line 3131
#pragma cdir shortloop
#line 3131
    for (i=0; i<ni; i++) {
#line 3131
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3131
     /* test for range errors (not always needed but do it anyway) */
#line 3131
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3131
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3131
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3131
    }
#line 3131
   /* update xpp and tp */
#line 3131
    if (realign) xp = (double *) *xpp;
#line 3131
    xp += ni;
#line 3131
    tp += ni;
#line 3131
    *xpp = (void*)xp;
#line 3131
  }
#line 3131
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3131

#line 3131
#else   /* not SX */
#line 3131
	const char *xp = (const char *) *xpp;
#line 3131
	int status = ENOERR;
#line 3131

#line 3131
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3131
	{
#line 3131
		const int lstatus = ncx_get_double_short(xp, tp);
#line 3131
		if(lstatus != ENOERR)
#line 3131
			status = lstatus;
#line 3131
	}
#line 3131

#line 3131
	*xpp = (const void *)xp;
#line 3131
	return status;
#line 3131
#  endif
#line 3131
}
#line 3131

int
#line 3132
ncx_getn_double_int(const void **xpp, size_t nelems, int *tp)
#line 3132
{
#line 3132
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3132

#line 3132
 /* basic algorithm is:
#line 3132
  *   - ensure sane alignment of input data
#line 3132
  *   - copy (conversion happens automatically) input data
#line 3132
  *     to output
#line 3132
  *   - update xpp to point at next unconverted input, and tp to point
#line 3132
  *     at next location for converted output
#line 3132
  */
#line 3132
  long i, j, ni;
#line 3132
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3132
  double *xp;
#line 3132
  int nrange = 0;         /* number of range errors */
#line 3132
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3132
  long cxp = (long) *((char**)xpp);
#line 3132

#line 3132
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3132
  /* sjl: manually stripmine so we can limit amount of
#line 3132
   * vector work space reserved to LOOPCNT elements. Also
#line 3132
   * makes vectorisation easy */
#line 3132
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3132
    ni=Min(nelems-j,LOOPCNT);
#line 3132
    if (realign) {
#line 3132
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3132
      xp = tmp;
#line 3132
    } else {
#line 3132
      xp = (double *) *xpp;
#line 3132
    }
#line 3132
   /* copy the next block */
#line 3132
#pragma cdir loopcnt=LOOPCNT
#line 3132
#pragma cdir shortloop
#line 3132
    for (i=0; i<ni; i++) {
#line 3132
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3132
     /* test for range errors (not always needed but do it anyway) */
#line 3132
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3132
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3132
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3132
    }
#line 3132
   /* update xpp and tp */
#line 3132
    if (realign) xp = (double *) *xpp;
#line 3132
    xp += ni;
#line 3132
    tp += ni;
#line 3132
    *xpp = (void*)xp;
#line 3132
  }
#line 3132
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3132

#line 3132
#else   /* not SX */
#line 3132
	const char *xp = (const char *) *xpp;
#line 3132
	int status = ENOERR;
#line 3132

#line 3132
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3132
	{
#line 3132
		const int lstatus = ncx_get_double_int(xp, tp);
#line 3132
		if(lstatus != ENOERR)
#line 3132
			status = lstatus;
#line 3132
	}
#line 3132

#line 3132
	*xpp = (const void *)xp;
#line 3132
	return status;
#line 3132
#  endif
#line 3132
}
#line 3132

int
#line 3133
ncx_getn_double_float(const void **xpp, size_t nelems, float *tp)
#line 3133
{
#line 3133
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3133

#line 3133
 /* basic algorithm is:
#line 3133
  *   - ensure sane alignment of input data
#line 3133
  *   - copy (conversion happens automatically) input data
#line 3133
  *     to output
#line 3133
  *   - update xpp to point at next unconverted input, and tp to point
#line 3133
  *     at next location for converted output
#line 3133
  */
#line 3133
  long i, j, ni;
#line 3133
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3133
  double *xp;
#line 3133
  int nrange = 0;         /* number of range errors */
#line 3133
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3133
  long cxp = (long) *((char**)xpp);
#line 3133

#line 3133
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3133
  /* sjl: manually stripmine so we can limit amount of
#line 3133
   * vector work space reserved to LOOPCNT elements. Also
#line 3133
   * makes vectorisation easy */
#line 3133
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3133
    ni=Min(nelems-j,LOOPCNT);
#line 3133
    if (realign) {
#line 3133
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3133
      xp = tmp;
#line 3133
    } else {
#line 3133
      xp = (double *) *xpp;
#line 3133
    }
#line 3133
   /* copy the next block */
#line 3133
#pragma cdir loopcnt=LOOPCNT
#line 3133
#pragma cdir shortloop
#line 3133
    for (i=0; i<ni; i++) {
#line 3133
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3133
     /* test for range errors (not always needed but do it anyway) */
#line 3133
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3133
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3133
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3133
    }
#line 3133
   /* update xpp and tp */
#line 3133
    if (realign) xp = (double *) *xpp;
#line 3133
    xp += ni;
#line 3133
    tp += ni;
#line 3133
    *xpp = (void*)xp;
#line 3133
  }
#line 3133
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3133

#line 3133
#else   /* not SX */
#line 3133
	const char *xp = (const char *) *xpp;
#line 3133
	int status = ENOERR;
#line 3133

#line 3133
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3133
	{
#line 3133
		const int lstatus = ncx_get_double_float(xp, tp);
#line 3133
		if(lstatus != ENOERR)
#line 3133
			status = lstatus;
#line 3133
	}
#line 3133

#line 3133
	*xpp = (const void *)xp;
#line 3133
	return status;
#line 3133
#  endif
#line 3133
}
#line 3133

int
#line 3134
ncx_getn_double_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3134
{
#line 3134
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3134

#line 3134
 /* basic algorithm is:
#line 3134
  *   - ensure sane alignment of input data
#line 3134
  *   - copy (conversion happens automatically) input data
#line 3134
  *     to output
#line 3134
  *   - update xpp to point at next unconverted input, and tp to point
#line 3134
  *     at next location for converted output
#line 3134
  */
#line 3134
  long i, j, ni;
#line 3134
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3134
  double *xp;
#line 3134
  int nrange = 0;         /* number of range errors */
#line 3134
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3134
  long cxp = (long) *((char**)xpp);
#line 3134

#line 3134
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3134
  /* sjl: manually stripmine so we can limit amount of
#line 3134
   * vector work space reserved to LOOPCNT elements. Also
#line 3134
   * makes vectorisation easy */
#line 3134
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3134
    ni=Min(nelems-j,LOOPCNT);
#line 3134
    if (realign) {
#line 3134
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3134
      xp = tmp;
#line 3134
    } else {
#line 3134
      xp = (double *) *xpp;
#line 3134
    }
#line 3134
   /* copy the next block */
#line 3134
#pragma cdir loopcnt=LOOPCNT
#line 3134
#pragma cdir shortloop
#line 3134
    for (i=0; i<ni; i++) {
#line 3134
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3134
     /* test for range errors (not always needed but do it anyway) */
#line 3134
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3134
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3134
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3134
    }
#line 3134
   /* update xpp and tp */
#line 3134
    if (realign) xp = (double *) *xpp;
#line 3134
    xp += ni;
#line 3134
    tp += ni;
#line 3134
    *xpp = (void*)xp;
#line 3134
  }
#line 3134
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3134

#line 3134
#else   /* not SX */
#line 3134
	const char *xp = (const char *) *xpp;
#line 3134
	int status = ENOERR;
#line 3134

#line 3134
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3134
	{
#line 3134
		const int lstatus = ncx_get_double_longlong(xp, tp);
#line 3134
		if(lstatus != ENOERR)
#line 3134
			status = lstatus;
#line 3134
	}
#line 3134

#line 3134
	*xpp = (const void *)xp;
#line 3134
	return status;
#line 3134
#  endif
#line 3134
}
#line 3134

int
#line 3135
ncx_getn_double_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3135
{
#line 3135
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3135

#line 3135
 /* basic algorithm is:
#line 3135
  *   - ensure sane alignment of input data
#line 3135
  *   - copy (conversion happens automatically) input data
#line 3135
  *     to output
#line 3135
  *   - update xpp to point at next unconverted input, and tp to point
#line 3135
  *     at next location for converted output
#line 3135
  */
#line 3135
  long i, j, ni;
#line 3135
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3135
  double *xp;
#line 3135
  int nrange = 0;         /* number of range errors */
#line 3135
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3135
  long cxp = (long) *((char**)xpp);
#line 3135

#line 3135
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3135
  /* sjl: manually stripmine so we can limit amount of
#line 3135
   * vector work space reserved to LOOPCNT elements. Also
#line 3135
   * makes vectorisation easy */
#line 3135
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3135
    ni=Min(nelems-j,LOOPCNT);
#line 3135
    if (realign) {
#line 3135
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3135
      xp = tmp;
#line 3135
    } else {
#line 3135
      xp = (double *) *xpp;
#line 3135
    }
#line 3135
   /* copy the next block */
#line 3135
#pragma cdir loopcnt=LOOPCNT
#line 3135
#pragma cdir shortloop
#line 3135
    for (i=0; i<ni; i++) {
#line 3135
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3135
     /* test for range errors (not always needed but do it anyway) */
#line 3135
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3135
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3135
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3135
    }
#line 3135
   /* update xpp and tp */
#line 3135
    if (realign) xp = (double *) *xpp;
#line 3135
    xp += ni;
#line 3135
    tp += ni;
#line 3135
    *xpp = (void*)xp;
#line 3135
  }
#line 3135
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3135

#line 3135
#else   /* not SX */
#line 3135
	const char *xp = (const char *) *xpp;
#line 3135
	int status = ENOERR;
#line 3135

#line 3135
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3135
	{
#line 3135
		const int lstatus = ncx_get_double_uchar(xp, tp);
#line 3135
		if(lstatus != ENOERR)
#line 3135
			status = lstatus;
#line 3135
	}
#line 3135

#line 3135
	*xpp = (const void *)xp;
#line 3135
	return status;
#line 3135
#  endif
#line 3135
}
#line 3135

int
#line 3136
ncx_getn_double_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3136
{
#line 3136
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3136

#line 3136
 /* basic algorithm is:
#line 3136
  *   - ensure sane alignment of input data
#line 3136
  *   - copy (conversion happens automatically) input data
#line 3136
  *     to output
#line 3136
  *   - update xpp to point at next unconverted input, and tp to point
#line 3136
  *     at next location for converted output
#line 3136
  */
#line 3136
  long i, j, ni;
#line 3136
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3136
  double *xp;
#line 3136
  int nrange = 0;         /* number of range errors */
#line 3136
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3136
  long cxp = (long) *((char**)xpp);
#line 3136

#line 3136
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3136
  /* sjl: manually stripmine so we can limit amount of
#line 3136
   * vector work space reserved to LOOPCNT elements. Also
#line 3136
   * makes vectorisation easy */
#line 3136
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3136
    ni=Min(nelems-j,LOOPCNT);
#line 3136
    if (realign) {
#line 3136
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3136
      xp = tmp;
#line 3136
    } else {
#line 3136
      xp = (double *) *xpp;
#line 3136
    }
#line 3136
   /* copy the next block */
#line 3136
#pragma cdir loopcnt=LOOPCNT
#line 3136
#pragma cdir shortloop
#line 3136
    for (i=0; i<ni; i++) {
#line 3136
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3136
     /* test for range errors (not always needed but do it anyway) */
#line 3136
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3136
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3136
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3136
    }
#line 3136
   /* update xpp and tp */
#line 3136
    if (realign) xp = (double *) *xpp;
#line 3136
    xp += ni;
#line 3136
    tp += ni;
#line 3136
    *xpp = (void*)xp;
#line 3136
  }
#line 3136
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3136

#line 3136
#else   /* not SX */
#line 3136
	const char *xp = (const char *) *xpp;
#line 3136
	int status = ENOERR;
#line 3136

#line 3136
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3136
	{
#line 3136
		const int lstatus = ncx_get_double_ushort(xp, tp);
#line 3136
		if(lstatus != ENOERR)
#line 3136
			status = lstatus;
#line 3136
	}
#line 3136

#line 3136
	*xpp = (const void *)xp;
#line 3136
	return status;
#line 3136
#  endif
#line 3136
}
#line 3136

int
#line 3137
ncx_getn_double_uint(const void **xpp, size_t nelems, uint *tp)
#line 3137
{
#line 3137
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3137

#line 3137
 /* basic algorithm is:
#line 3137
  *   - ensure sane alignment of input data
#line 3137
  *   - copy (conversion happens automatically) input data
#line 3137
  *     to output
#line 3137
  *   - update xpp to point at next unconverted input, and tp to point
#line 3137
  *     at next location for converted output
#line 3137
  */
#line 3137
  long i, j, ni;
#line 3137
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3137
  double *xp;
#line 3137
  int nrange = 0;         /* number of range errors */
#line 3137
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3137
  long cxp = (long) *((char**)xpp);
#line 3137

#line 3137
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3137
  /* sjl: manually stripmine so we can limit amount of
#line 3137
   * vector work space reserved to LOOPCNT elements. Also
#line 3137
   * makes vectorisation easy */
#line 3137
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3137
    ni=Min(nelems-j,LOOPCNT);
#line 3137
    if (realign) {
#line 3137
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3137
      xp = tmp;
#line 3137
    } else {
#line 3137
      xp = (double *) *xpp;
#line 3137
    }
#line 3137
   /* copy the next block */
#line 3137
#pragma cdir loopcnt=LOOPCNT
#line 3137
#pragma cdir shortloop
#line 3137
    for (i=0; i<ni; i++) {
#line 3137
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3137
     /* test for range errors (not always needed but do it anyway) */
#line 3137
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3137
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3137
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3137
    }
#line 3137
   /* update xpp and tp */
#line 3137
    if (realign) xp = (double *) *xpp;
#line 3137
    xp += ni;
#line 3137
    tp += ni;
#line 3137
    *xpp = (void*)xp;
#line 3137
  }
#line 3137
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3137

#line 3137
#else   /* not SX */
#line 3137
	const char *xp = (const char *) *xpp;
#line 3137
	int status = ENOERR;
#line 3137

#line 3137
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3137
	{
#line 3137
		const int lstatus = ncx_get_double_uint(xp, tp);
#line 3137
		if(lstatus != ENOERR)
#line 3137
			status = lstatus;
#line 3137
	}
#line 3137

#line 3137
	*xpp = (const void *)xp;
#line 3137
	return status;
#line 3137
#  endif
#line 3137
}
#line 3137

int
#line 3138
ncx_getn_double_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3138
{
#line 3138
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3138

#line 3138
 /* basic algorithm is:
#line 3138
  *   - ensure sane alignment of input data
#line 3138
  *   - copy (conversion happens automatically) input data
#line 3138
  *     to output
#line 3138
  *   - update xpp to point at next unconverted input, and tp to point
#line 3138
  *     at next location for converted output
#line 3138
  */
#line 3138
  long i, j, ni;
#line 3138
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3138
  double *xp;
#line 3138
  int nrange = 0;         /* number of range errors */
#line 3138
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3138
  long cxp = (long) *((char**)xpp);
#line 3138

#line 3138
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3138
  /* sjl: manually stripmine so we can limit amount of
#line 3138
   * vector work space reserved to LOOPCNT elements. Also
#line 3138
   * makes vectorisation easy */
#line 3138
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3138
    ni=Min(nelems-j,LOOPCNT);
#line 3138
    if (realign) {
#line 3138
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3138
      xp = tmp;
#line 3138
    } else {
#line 3138
      xp = (double *) *xpp;
#line 3138
    }
#line 3138
   /* copy the next block */
#line 3138
#pragma cdir loopcnt=LOOPCNT
#line 3138
#pragma cdir shortloop
#line 3138
    for (i=0; i<ni; i++) {
#line 3138
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3138
     /* test for range errors (not always needed but do it anyway) */
#line 3138
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3138
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3138
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3138
    }
#line 3138
   /* update xpp and tp */
#line 3138
    if (realign) xp = (double *) *xpp;
#line 3138
    xp += ni;
#line 3138
    tp += ni;
#line 3138
    *xpp = (void*)xp;
#line 3138
  }
#line 3138
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3138

#line 3138
#else   /* not SX */
#line 3138
	const char *xp = (const char *) *xpp;
#line 3138
	int status = ENOERR;
#line 3138

#line 3138
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3138
	{
#line 3138
		const int lstatus = ncx_get_double_ulonglong(xp, tp);
#line 3138
		if(lstatus != ENOERR)
#line 3138
			status = lstatus;
#line 3138
	}
#line 3138

#line 3138
	*xpp = (const void *)xp;
#line 3138
	return status;
#line 3138
#  endif
#line 3138
}
#line 3138


#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_DOUBLE);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return ENOERR;
}
#elif vax
int
ncx_putn_double_double(void **xpp, size_t ndoubles, const double *ip)
{
	const double *const end = ip + ndoubles;

	while(ip < end)
	{
	const struct vax_double *const vdp = 
#line 3161
			(const struct vax_double *)ip;
#line 3161
	struct ieee_double *const idp =
#line 3161
			 (struct ieee_double *) (*xpp);
#line 3161

#line 3161
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 3161
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 3161
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 3161
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 3161
		(vdp->exp == dbl_limits[0].d.exp))
#line 3161
	{
#line 3161
		*idp = dbl_limits[0].ieee;
#line 3161
		goto shipit;
#line 3161
	}
#line 3161
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 3161
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 3161
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 3161
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 3161
		(vdp->exp == dbl_limits[1].d.exp))
#line 3161
	{
#line 3161
		*idp = dbl_limits[1].ieee;
#line 3161
		goto shipit;
#line 3161
	}
#line 3161

#line 3161
	{
#line 3161
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 3161

#line 3161
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 3161
			(vdp->mantissa3 << 13) |
#line 3161
			((vdp->mantissa4 >> 3) & MASK(13));
#line 3161

#line 3161
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 3161
				 | (vdp->mantissa2 >> 3);
#line 3161

#line 3161
		if((vdp->mantissa4 & 7) > 4)
#line 3161
		{
#line 3161
			/* round up */
#line 3161
			mant_lo++;
#line 3161
			if(mant_lo == 0)
#line 3161
			{
#line 3161
				mant_hi++;
#line 3161
				if(mant_hi > 0xffffff)
#line 3161
				{
#line 3161
					mant_hi = 0;
#line 3161
					exp++;
#line 3161
				}
#line 3161
			}
#line 3161
		}
#line 3161

#line 3161
		idp->mant_lo = SWAP4(mant_lo);
#line 3161
		idp->mant_6 = mant_hi >> 16;
#line 3161
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 3161
		idp->mant_4 = mant_hi;
#line 3161
		idp->exp_hi = exp >> 4;
#line 3161
		idp->exp_lo = exp;
#line 3161
	}
#line 3161
		
#line 3161
	shipit:
#line 3161
		idp->sign = vdp->sign;
#line 3161

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return ENOERR;
}
	/* vax */
#else
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp)
{
	char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		int lstatus = ncx_put_double_double(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3186
ncx_putn_double_schar(void **xpp, size_t nelems, const schar *tp)
#line 3186
{
#line 3186
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3186

#line 3186
 /* basic algorithm is:
#line 3186
  *   - ensure sane alignment of output data
#line 3186
  *   - copy (conversion happens automatically) input data
#line 3186
  *     to output
#line 3186
  *   - update tp to point at next unconverted input, and xpp to point
#line 3186
  *     at next location for converted output
#line 3186
  */
#line 3186
  long i, j, ni;
#line 3186
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3186
  double *xp;
#line 3186
  int nrange = 0;         /* number of range errors */
#line 3186
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3186
  long cxp = (long) *((char**)xpp);
#line 3186

#line 3186
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3186
  /* sjl: manually stripmine so we can limit amount of
#line 3186
   * vector work space reserved to LOOPCNT elements. Also
#line 3186
   * makes vectorisation easy */
#line 3186
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3186
    ni=Min(nelems-j,LOOPCNT);
#line 3186
    if (realign) {
#line 3186
      xp = tmp;
#line 3186
    } else {
#line 3186
      xp = (double *) *xpp;
#line 3186
    }
#line 3186
   /* copy the next block */
#line 3186
#pragma cdir loopcnt=LOOPCNT
#line 3186
#pragma cdir shortloop
#line 3186
    for (i=0; i<ni; i++) {
#line 3186
      /* the normal case: */
#line 3186
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3186
     /* test for range errors (not always needed but do it anyway) */
#line 3186
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3186
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3186
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3186
    }
#line 3186
   /* copy workspace back if necessary */ 
#line 3186
    if (realign) {
#line 3186
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3186
      xp = (double *) *xpp;
#line 3186
    }
#line 3186
   /* update xpp and tp */
#line 3186
    xp += ni;
#line 3186
    tp += ni;
#line 3186
    *xpp = (void*)xp;
#line 3186
  }
#line 3186
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3186

#line 3186
#else   /* not SX */
#line 3186

#line 3186
	char *xp = (char *) *xpp;
#line 3186
	int status = ENOERR;
#line 3186

#line 3186
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3186
	{
#line 3186
		int lstatus = ncx_put_double_schar(xp, tp);
#line 3186
		if(lstatus != ENOERR)
#line 3186
			status = lstatus;
#line 3186
	}
#line 3186

#line 3186
	*xpp = (void *)xp;
#line 3186
	return status;
#line 3186
#endif
#line 3186
}
#line 3186

int
#line 3187
ncx_putn_double_short(void **xpp, size_t nelems, const short *tp)
#line 3187
{
#line 3187
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3187

#line 3187
 /* basic algorithm is:
#line 3187
  *   - ensure sane alignment of output data
#line 3187
  *   - copy (conversion happens automatically) input data
#line 3187
  *     to output
#line 3187
  *   - update tp to point at next unconverted input, and xpp to point
#line 3187
  *     at next location for converted output
#line 3187
  */
#line 3187
  long i, j, ni;
#line 3187
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3187
  double *xp;
#line 3187
  int nrange = 0;         /* number of range errors */
#line 3187
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3187
  long cxp = (long) *((char**)xpp);
#line 3187

#line 3187
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3187
  /* sjl: manually stripmine so we can limit amount of
#line 3187
   * vector work space reserved to LOOPCNT elements. Also
#line 3187
   * makes vectorisation easy */
#line 3187
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3187
    ni=Min(nelems-j,LOOPCNT);
#line 3187
    if (realign) {
#line 3187
      xp = tmp;
#line 3187
    } else {
#line 3187
      xp = (double *) *xpp;
#line 3187
    }
#line 3187
   /* copy the next block */
#line 3187
#pragma cdir loopcnt=LOOPCNT
#line 3187
#pragma cdir shortloop
#line 3187
    for (i=0; i<ni; i++) {
#line 3187
      /* the normal case: */
#line 3187
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3187
     /* test for range errors (not always needed but do it anyway) */
#line 3187
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3187
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3187
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3187
    }
#line 3187
   /* copy workspace back if necessary */ 
#line 3187
    if (realign) {
#line 3187
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3187
      xp = (double *) *xpp;
#line 3187
    }
#line 3187
   /* update xpp and tp */
#line 3187
    xp += ni;
#line 3187
    tp += ni;
#line 3187
    *xpp = (void*)xp;
#line 3187
  }
#line 3187
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3187

#line 3187
#else   /* not SX */
#line 3187

#line 3187
	char *xp = (char *) *xpp;
#line 3187
	int status = ENOERR;
#line 3187

#line 3187
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3187
	{
#line 3187
		int lstatus = ncx_put_double_short(xp, tp);
#line 3187
		if(lstatus != ENOERR)
#line 3187
			status = lstatus;
#line 3187
	}
#line 3187

#line 3187
	*xpp = (void *)xp;
#line 3187
	return status;
#line 3187
#endif
#line 3187
}
#line 3187

int
#line 3188
ncx_putn_double_int(void **xpp, size_t nelems, const int *tp)
#line 3188
{
#line 3188
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3188

#line 3188
 /* basic algorithm is:
#line 3188
  *   - ensure sane alignment of output data
#line 3188
  *   - copy (conversion happens automatically) input data
#line 3188
  *     to output
#line 3188
  *   - update tp to point at next unconverted input, and xpp to point
#line 3188
  *     at next location for converted output
#line 3188
  */
#line 3188
  long i, j, ni;
#line 3188
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3188
  double *xp;
#line 3188
  int nrange = 0;         /* number of range errors */
#line 3188
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3188
  long cxp = (long) *((char**)xpp);
#line 3188

#line 3188
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3188
  /* sjl: manually stripmine so we can limit amount of
#line 3188
   * vector work space reserved to LOOPCNT elements. Also
#line 3188
   * makes vectorisation easy */
#line 3188
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3188
    ni=Min(nelems-j,LOOPCNT);
#line 3188
    if (realign) {
#line 3188
      xp = tmp;
#line 3188
    } else {
#line 3188
      xp = (double *) *xpp;
#line 3188
    }
#line 3188
   /* copy the next block */
#line 3188
#pragma cdir loopcnt=LOOPCNT
#line 3188
#pragma cdir shortloop
#line 3188
    for (i=0; i<ni; i++) {
#line 3188
      /* the normal case: */
#line 3188
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3188
     /* test for range errors (not always needed but do it anyway) */
#line 3188
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3188
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3188
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3188
    }
#line 3188
   /* copy workspace back if necessary */ 
#line 3188
    if (realign) {
#line 3188
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3188
      xp = (double *) *xpp;
#line 3188
    }
#line 3188
   /* update xpp and tp */
#line 3188
    xp += ni;
#line 3188
    tp += ni;
#line 3188
    *xpp = (void*)xp;
#line 3188
  }
#line 3188
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3188

#line 3188
#else   /* not SX */
#line 3188

#line 3188
	char *xp = (char *) *xpp;
#line 3188
	int status = ENOERR;
#line 3188

#line 3188
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3188
	{
#line 3188
		int lstatus = ncx_put_double_int(xp, tp);
#line 3188
		if(lstatus != ENOERR)
#line 3188
			status = lstatus;
#line 3188
	}
#line 3188

#line 3188
	*xpp = (void *)xp;
#line 3188
	return status;
#line 3188
#endif
#line 3188
}
#line 3188

int
#line 3189
ncx_putn_double_float(void **xpp, size_t nelems, const float *tp)
#line 3189
{
#line 3189
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3189

#line 3189
 /* basic algorithm is:
#line 3189
  *   - ensure sane alignment of output data
#line 3189
  *   - copy (conversion happens automatically) input data
#line 3189
  *     to output
#line 3189
  *   - update tp to point at next unconverted input, and xpp to point
#line 3189
  *     at next location for converted output
#line 3189
  */
#line 3189
  long i, j, ni;
#line 3189
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3189
  double *xp;
#line 3189
  int nrange = 0;         /* number of range errors */
#line 3189
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3189
  long cxp = (long) *((char**)xpp);
#line 3189

#line 3189
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3189
  /* sjl: manually stripmine so we can limit amount of
#line 3189
   * vector work space reserved to LOOPCNT elements. Also
#line 3189
   * makes vectorisation easy */
#line 3189
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3189
    ni=Min(nelems-j,LOOPCNT);
#line 3189
    if (realign) {
#line 3189
      xp = tmp;
#line 3189
    } else {
#line 3189
      xp = (double *) *xpp;
#line 3189
    }
#line 3189
   /* copy the next block */
#line 3189
#pragma cdir loopcnt=LOOPCNT
#line 3189
#pragma cdir shortloop
#line 3189
    for (i=0; i<ni; i++) {
#line 3189
      /* the normal case: */
#line 3189
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3189
     /* test for range errors (not always needed but do it anyway) */
#line 3189
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3189
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3189
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3189
    }
#line 3189
   /* copy workspace back if necessary */ 
#line 3189
    if (realign) {
#line 3189
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3189
      xp = (double *) *xpp;
#line 3189
    }
#line 3189
   /* update xpp and tp */
#line 3189
    xp += ni;
#line 3189
    tp += ni;
#line 3189
    *xpp = (void*)xp;
#line 3189
  }
#line 3189
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3189

#line 3189
#else   /* not SX */
#line 3189

#line 3189
	char *xp = (char *) *xpp;
#line 3189
	int status = ENOERR;
#line 3189

#line 3189
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3189
	{
#line 3189
		int lstatus = ncx_put_double_float(xp, tp);
#line 3189
		if(lstatus != ENOERR)
#line 3189
			status = lstatus;
#line 3189
	}
#line 3189

#line 3189
	*xpp = (void *)xp;
#line 3189
	return status;
#line 3189
#endif
#line 3189
}
#line 3189

int
#line 3190
ncx_putn_double_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3190
{
#line 3190
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3190

#line 3190
 /* basic algorithm is:
#line 3190
  *   - ensure sane alignment of output data
#line 3190
  *   - copy (conversion happens automatically) input data
#line 3190
  *     to output
#line 3190
  *   - update tp to point at next unconverted input, and xpp to point
#line 3190
  *     at next location for converted output
#line 3190
  */
#line 3190
  long i, j, ni;
#line 3190
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3190
  double *xp;
#line 3190
  int nrange = 0;         /* number of range errors */
#line 3190
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3190
  long cxp = (long) *((char**)xpp);
#line 3190

#line 3190
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3190
  /* sjl: manually stripmine so we can limit amount of
#line 3190
   * vector work space reserved to LOOPCNT elements. Also
#line 3190
   * makes vectorisation easy */
#line 3190
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3190
    ni=Min(nelems-j,LOOPCNT);
#line 3190
    if (realign) {
#line 3190
      xp = tmp;
#line 3190
    } else {
#line 3190
      xp = (double *) *xpp;
#line 3190
    }
#line 3190
   /* copy the next block */
#line 3190
#pragma cdir loopcnt=LOOPCNT
#line 3190
#pragma cdir shortloop
#line 3190
    for (i=0; i<ni; i++) {
#line 3190
      /* the normal case: */
#line 3190
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3190
     /* test for range errors (not always needed but do it anyway) */
#line 3190
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3190
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3190
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3190
    }
#line 3190
   /* copy workspace back if necessary */ 
#line 3190
    if (realign) {
#line 3190
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3190
      xp = (double *) *xpp;
#line 3190
    }
#line 3190
   /* update xpp and tp */
#line 3190
    xp += ni;
#line 3190
    tp += ni;
#line 3190
    *xpp = (void*)xp;
#line 3190
  }
#line 3190
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3190

#line 3190
#else   /* not SX */
#line 3190

#line 3190
	char *xp = (char *) *xpp;
#line 3190
	int status = ENOERR;
#line 3190

#line 3190
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3190
	{
#line 3190
		int lstatus = ncx_put_double_longlong(xp, tp);
#line 3190
		if(lstatus != ENOERR)
#line 3190
			status = lstatus;
#line 3190
	}
#line 3190

#line 3190
	*xpp = (void *)xp;
#line 3190
	return status;
#line 3190
#endif
#line 3190
}
#line 3190

int
#line 3191
ncx_putn_double_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3191
{
#line 3191
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3191

#line 3191
 /* basic algorithm is:
#line 3191
  *   - ensure sane alignment of output data
#line 3191
  *   - copy (conversion happens automatically) input data
#line 3191
  *     to output
#line 3191
  *   - update tp to point at next unconverted input, and xpp to point
#line 3191
  *     at next location for converted output
#line 3191
  */
#line 3191
  long i, j, ni;
#line 3191
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3191
  double *xp;
#line 3191
  int nrange = 0;         /* number of range errors */
#line 3191
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3191
  long cxp = (long) *((char**)xpp);
#line 3191

#line 3191
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3191
  /* sjl: manually stripmine so we can limit amount of
#line 3191
   * vector work space reserved to LOOPCNT elements. Also
#line 3191
   * makes vectorisation easy */
#line 3191
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3191
    ni=Min(nelems-j,LOOPCNT);
#line 3191
    if (realign) {
#line 3191
      xp = tmp;
#line 3191
    } else {
#line 3191
      xp = (double *) *xpp;
#line 3191
    }
#line 3191
   /* copy the next block */
#line 3191
#pragma cdir loopcnt=LOOPCNT
#line 3191
#pragma cdir shortloop
#line 3191
    for (i=0; i<ni; i++) {
#line 3191
      /* the normal case: */
#line 3191
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3191
     /* test for range errors (not always needed but do it anyway) */
#line 3191
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3191
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3191
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3191
    }
#line 3191
   /* copy workspace back if necessary */ 
#line 3191
    if (realign) {
#line 3191
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3191
      xp = (double *) *xpp;
#line 3191
    }
#line 3191
   /* update xpp and tp */
#line 3191
    xp += ni;
#line 3191
    tp += ni;
#line 3191
    *xpp = (void*)xp;
#line 3191
  }
#line 3191
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3191

#line 3191
#else   /* not SX */
#line 3191

#line 3191
	char *xp = (char *) *xpp;
#line 3191
	int status = ENOERR;
#line 3191

#line 3191
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3191
	{
#line 3191
		int lstatus = ncx_put_double_uchar(xp, tp);
#line 3191
		if(lstatus != ENOERR)
#line 3191
			status = lstatus;
#line 3191
	}
#line 3191

#line 3191
	*xpp = (void *)xp;
#line 3191
	return status;
#line 3191
#endif
#line 3191
}
#line 3191

int
#line 3192
ncx_putn_double_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3192
{
#line 3192
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3192

#line 3192
 /* basic algorithm is:
#line 3192
  *   - ensure sane alignment of output data
#line 3192
  *   - copy (conversion happens automatically) input data
#line 3192
  *     to output
#line 3192
  *   - update tp to point at next unconverted input, and xpp to point
#line 3192
  *     at next location for converted output
#line 3192
  */
#line 3192
  long i, j, ni;
#line 3192
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3192
  double *xp;
#line 3192
  int nrange = 0;         /* number of range errors */
#line 3192
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3192
  long cxp = (long) *((char**)xpp);
#line 3192

#line 3192
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3192
  /* sjl: manually stripmine so we can limit amount of
#line 3192
   * vector work space reserved to LOOPCNT elements. Also
#line 3192
   * makes vectorisation easy */
#line 3192
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3192
    ni=Min(nelems-j,LOOPCNT);
#line 3192
    if (realign) {
#line 3192
      xp = tmp;
#line 3192
    } else {
#line 3192
      xp = (double *) *xpp;
#line 3192
    }
#line 3192
   /* copy the next block */
#line 3192
#pragma cdir loopcnt=LOOPCNT
#line 3192
#pragma cdir shortloop
#line 3192
    for (i=0; i<ni; i++) {
#line 3192
      /* the normal case: */
#line 3192
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3192
     /* test for range errors (not always needed but do it anyway) */
#line 3192
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3192
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3192
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3192
    }
#line 3192
   /* copy workspace back if necessary */ 
#line 3192
    if (realign) {
#line 3192
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3192
      xp = (double *) *xpp;
#line 3192
    }
#line 3192
   /* update xpp and tp */
#line 3192
    xp += ni;
#line 3192
    tp += ni;
#line 3192
    *xpp = (void*)xp;
#line 3192
  }
#line 3192
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3192

#line 3192
#else   /* not SX */
#line 3192

#line 3192
	char *xp = (char *) *xpp;
#line 3192
	int status = ENOERR;
#line 3192

#line 3192
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3192
	{
#line 3192
		int lstatus = ncx_put_double_ushort(xp, tp);
#line 3192
		if(lstatus != ENOERR)
#line 3192
			status = lstatus;
#line 3192
	}
#line 3192

#line 3192
	*xpp = (void *)xp;
#line 3192
	return status;
#line 3192
#endif
#line 3192
}
#line 3192

int
#line 3193
ncx_putn_double_uint(void **xpp, size_t nelems, const uint *tp)
#line 3193
{
#line 3193
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3193

#line 3193
 /* basic algorithm is:
#line 3193
  *   - ensure sane alignment of output data
#line 3193
  *   - copy (conversion happens automatically) input data
#line 3193
  *     to output
#line 3193
  *   - update tp to point at next unconverted input, and xpp to point
#line 3193
  *     at next location for converted output
#line 3193
  */
#line 3193
  long i, j, ni;
#line 3193
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3193
  double *xp;
#line 3193
  int nrange = 0;         /* number of range errors */
#line 3193
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3193
  long cxp = (long) *((char**)xpp);
#line 3193

#line 3193
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3193
  /* sjl: manually stripmine so we can limit amount of
#line 3193
   * vector work space reserved to LOOPCNT elements. Also
#line 3193
   * makes vectorisation easy */
#line 3193
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3193
    ni=Min(nelems-j,LOOPCNT);
#line 3193
    if (realign) {
#line 3193
      xp = tmp;
#line 3193
    } else {
#line 3193
      xp = (double *) *xpp;
#line 3193
    }
#line 3193
   /* copy the next block */
#line 3193
#pragma cdir loopcnt=LOOPCNT
#line 3193
#pragma cdir shortloop
#line 3193
    for (i=0; i<ni; i++) {
#line 3193
      /* the normal case: */
#line 3193
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3193
     /* test for range errors (not always needed but do it anyway) */
#line 3193
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3193
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3193
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3193
    }
#line 3193
   /* copy workspace back if necessary */ 
#line 3193
    if (realign) {
#line 3193
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3193
      xp = (double *) *xpp;
#line 3193
    }
#line 3193
   /* update xpp and tp */
#line 3193
    xp += ni;
#line 3193
    tp += ni;
#line 3193
    *xpp = (void*)xp;
#line 3193
  }
#line 3193
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3193

#line 3193
#else   /* not SX */
#line 3193

#line 3193
	char *xp = (char *) *xpp;
#line 3193
	int status = ENOERR;
#line 3193

#line 3193
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3193
	{
#line 3193
		int lstatus = ncx_put_double_uint(xp, tp);
#line 3193
		if(lstatus != ENOERR)
#line 3193
			status = lstatus;
#line 3193
	}
#line 3193

#line 3193
	*xpp = (void *)xp;
#line 3193
	return status;
#line 3193
#endif
#line 3193
}
#line 3193

int
#line 3194
ncx_putn_double_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3194
{
#line 3194
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3194

#line 3194
 /* basic algorithm is:
#line 3194
  *   - ensure sane alignment of output data
#line 3194
  *   - copy (conversion happens automatically) input data
#line 3194
  *     to output
#line 3194
  *   - update tp to point at next unconverted input, and xpp to point
#line 3194
  *     at next location for converted output
#line 3194
  */
#line 3194
  long i, j, ni;
#line 3194
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3194
  double *xp;
#line 3194
  int nrange = 0;         /* number of range errors */
#line 3194
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3194
  long cxp = (long) *((char**)xpp);
#line 3194

#line 3194
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3194
  /* sjl: manually stripmine so we can limit amount of
#line 3194
   * vector work space reserved to LOOPCNT elements. Also
#line 3194
   * makes vectorisation easy */
#line 3194
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3194
    ni=Min(nelems-j,LOOPCNT);
#line 3194
    if (realign) {
#line 3194
      xp = tmp;
#line 3194
    } else {
#line 3194
      xp = (double *) *xpp;
#line 3194
    }
#line 3194
   /* copy the next block */
#line 3194
#pragma cdir loopcnt=LOOPCNT
#line 3194
#pragma cdir shortloop
#line 3194
    for (i=0; i<ni; i++) {
#line 3194
      /* the normal case: */
#line 3194
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3194
     /* test for range errors (not always needed but do it anyway) */
#line 3194
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3194
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3194
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3194
    }
#line 3194
   /* copy workspace back if necessary */ 
#line 3194
    if (realign) {
#line 3194
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3194
      xp = (double *) *xpp;
#line 3194
    }
#line 3194
   /* update xpp and tp */
#line 3194
    xp += ni;
#line 3194
    tp += ni;
#line 3194
    *xpp = (void*)xp;
#line 3194
  }
#line 3194
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3194

#line 3194
#else   /* not SX */
#line 3194

#line 3194
	char *xp = (char *) *xpp;
#line 3194
	int status = ENOERR;
#line 3194

#line 3194
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3194
	{
#line 3194
		int lstatus = ncx_put_double_ulonglong(xp, tp);
#line 3194
		if(lstatus != ENOERR)
#line 3194
			status = lstatus;
#line 3194
	}
#line 3194

#line 3194
	*xpp = (void *)xp;
#line 3194
	return status;
#line 3194
#endif
#line 3194
}
#line 3194



/* longlong -----------------------------------------------------------------------*/

#if X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
/* optimized version */
int
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(long long));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_LONGLONG);
	return ENOERR;
}
#else
int
#line 3213
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3213
{
#line 3213
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3213

#line 3213
 /* basic algorithm is:
#line 3213
  *   - ensure sane alignment of input data
#line 3213
  *   - copy (conversion happens automatically) input data
#line 3213
  *     to output
#line 3213
  *   - update xpp to point at next unconverted input, and tp to point
#line 3213
  *     at next location for converted output
#line 3213
  */
#line 3213
  long i, j, ni;
#line 3213
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3213
  longlong *xp;
#line 3213
  int nrange = 0;         /* number of range errors */
#line 3213
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3213
  long cxp = (long) *((char**)xpp);
#line 3213

#line 3213
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3213
  /* sjl: manually stripmine so we can limit amount of
#line 3213
   * vector work space reserved to LOOPCNT elements. Also
#line 3213
   * makes vectorisation easy */
#line 3213
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3213
    ni=Min(nelems-j,LOOPCNT);
#line 3213
    if (realign) {
#line 3213
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3213
      xp = tmp;
#line 3213
    } else {
#line 3213
      xp = (longlong *) *xpp;
#line 3213
    }
#line 3213
   /* copy the next block */
#line 3213
#pragma cdir loopcnt=LOOPCNT
#line 3213
#pragma cdir shortloop
#line 3213
    for (i=0; i<ni; i++) {
#line 3213
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3213
     /* test for range errors (not always needed but do it anyway) */
#line 3213
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3213
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3213
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3213
    }
#line 3213
   /* update xpp and tp */
#line 3213
    if (realign) xp = (longlong *) *xpp;
#line 3213
    xp += ni;
#line 3213
    tp += ni;
#line 3213
    *xpp = (void*)xp;
#line 3213
  }
#line 3213
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3213

#line 3213
#else   /* not SX */
#line 3213
	const char *xp = (const char *) *xpp;
#line 3213
	int status = ENOERR;
#line 3213

#line 3213
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3213
	{
#line 3213
		const int lstatus = ncx_get_longlong_longlong(xp, tp);
#line 3213
		if(lstatus != ENOERR)
#line 3213
			status = lstatus;
#line 3213
	}
#line 3213

#line 3213
	*xpp = (const void *)xp;
#line 3213
	return status;
#line 3213
#  endif
#line 3213
}
#line 3213

#endif
int
#line 3215
ncx_getn_longlong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3215
{
#line 3215
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3215

#line 3215
 /* basic algorithm is:
#line 3215
  *   - ensure sane alignment of input data
#line 3215
  *   - copy (conversion happens automatically) input data
#line 3215
  *     to output
#line 3215
  *   - update xpp to point at next unconverted input, and tp to point
#line 3215
  *     at next location for converted output
#line 3215
  */
#line 3215
  long i, j, ni;
#line 3215
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3215
  longlong *xp;
#line 3215
  int nrange = 0;         /* number of range errors */
#line 3215
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3215
  long cxp = (long) *((char**)xpp);
#line 3215

#line 3215
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3215
  /* sjl: manually stripmine so we can limit amount of
#line 3215
   * vector work space reserved to LOOPCNT elements. Also
#line 3215
   * makes vectorisation easy */
#line 3215
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3215
    ni=Min(nelems-j,LOOPCNT);
#line 3215
    if (realign) {
#line 3215
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3215
      xp = tmp;
#line 3215
    } else {
#line 3215
      xp = (longlong *) *xpp;
#line 3215
    }
#line 3215
   /* copy the next block */
#line 3215
#pragma cdir loopcnt=LOOPCNT
#line 3215
#pragma cdir shortloop
#line 3215
    for (i=0; i<ni; i++) {
#line 3215
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3215
     /* test for range errors (not always needed but do it anyway) */
#line 3215
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3215
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3215
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3215
    }
#line 3215
   /* update xpp and tp */
#line 3215
    if (realign) xp = (longlong *) *xpp;
#line 3215
    xp += ni;
#line 3215
    tp += ni;
#line 3215
    *xpp = (void*)xp;
#line 3215
  }
#line 3215
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3215

#line 3215
#else   /* not SX */
#line 3215
	const char *xp = (const char *) *xpp;
#line 3215
	int status = ENOERR;
#line 3215

#line 3215
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3215
	{
#line 3215
		const int lstatus = ncx_get_longlong_schar(xp, tp);
#line 3215
		if(lstatus != ENOERR)
#line 3215
			status = lstatus;
#line 3215
	}
#line 3215

#line 3215
	*xpp = (const void *)xp;
#line 3215
	return status;
#line 3215
#  endif
#line 3215
}
#line 3215

int
#line 3216
ncx_getn_longlong_short(const void **xpp, size_t nelems, short *tp)
#line 3216
{
#line 3216
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3216

#line 3216
 /* basic algorithm is:
#line 3216
  *   - ensure sane alignment of input data
#line 3216
  *   - copy (conversion happens automatically) input data
#line 3216
  *     to output
#line 3216
  *   - update xpp to point at next unconverted input, and tp to point
#line 3216
  *     at next location for converted output
#line 3216
  */
#line 3216
  long i, j, ni;
#line 3216
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3216
  longlong *xp;
#line 3216
  int nrange = 0;         /* number of range errors */
#line 3216
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3216
  long cxp = (long) *((char**)xpp);
#line 3216

#line 3216
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3216
  /* sjl: manually stripmine so we can limit amount of
#line 3216
   * vector work space reserved to LOOPCNT elements. Also
#line 3216
   * makes vectorisation easy */
#line 3216
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3216
    ni=Min(nelems-j,LOOPCNT);
#line 3216
    if (realign) {
#line 3216
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3216
      xp = tmp;
#line 3216
    } else {
#line 3216
      xp = (longlong *) *xpp;
#line 3216
    }
#line 3216
   /* copy the next block */
#line 3216
#pragma cdir loopcnt=LOOPCNT
#line 3216
#pragma cdir shortloop
#line 3216
    for (i=0; i<ni; i++) {
#line 3216
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3216
     /* test for range errors (not always needed but do it anyway) */
#line 3216
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3216
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3216
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3216
    }
#line 3216
   /* update xpp and tp */
#line 3216
    if (realign) xp = (longlong *) *xpp;
#line 3216
    xp += ni;
#line 3216
    tp += ni;
#line 3216
    *xpp = (void*)xp;
#line 3216
  }
#line 3216
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3216

#line 3216
#else   /* not SX */
#line 3216
	const char *xp = (const char *) *xpp;
#line 3216
	int status = ENOERR;
#line 3216

#line 3216
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3216
	{
#line 3216
		const int lstatus = ncx_get_longlong_short(xp, tp);
#line 3216
		if(lstatus != ENOERR)
#line 3216
			status = lstatus;
#line 3216
	}
#line 3216

#line 3216
	*xpp = (const void *)xp;
#line 3216
	return status;
#line 3216
#  endif
#line 3216
}
#line 3216

int
#line 3217
ncx_getn_longlong_int(const void **xpp, size_t nelems, int *tp)
#line 3217
{
#line 3217
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3217

#line 3217
 /* basic algorithm is:
#line 3217
  *   - ensure sane alignment of input data
#line 3217
  *   - copy (conversion happens automatically) input data
#line 3217
  *     to output
#line 3217
  *   - update xpp to point at next unconverted input, and tp to point
#line 3217
  *     at next location for converted output
#line 3217
  */
#line 3217
  long i, j, ni;
#line 3217
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3217
  longlong *xp;
#line 3217
  int nrange = 0;         /* number of range errors */
#line 3217
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3217
  long cxp = (long) *((char**)xpp);
#line 3217

#line 3217
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3217
  /* sjl: manually stripmine so we can limit amount of
#line 3217
   * vector work space reserved to LOOPCNT elements. Also
#line 3217
   * makes vectorisation easy */
#line 3217
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3217
    ni=Min(nelems-j,LOOPCNT);
#line 3217
    if (realign) {
#line 3217
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3217
      xp = tmp;
#line 3217
    } else {
#line 3217
      xp = (longlong *) *xpp;
#line 3217
    }
#line 3217
   /* copy the next block */
#line 3217
#pragma cdir loopcnt=LOOPCNT
#line 3217
#pragma cdir shortloop
#line 3217
    for (i=0; i<ni; i++) {
#line 3217
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3217
     /* test for range errors (not always needed but do it anyway) */
#line 3217
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3217
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3217
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3217
    }
#line 3217
   /* update xpp and tp */
#line 3217
    if (realign) xp = (longlong *) *xpp;
#line 3217
    xp += ni;
#line 3217
    tp += ni;
#line 3217
    *xpp = (void*)xp;
#line 3217
  }
#line 3217
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3217

#line 3217
#else   /* not SX */
#line 3217
	const char *xp = (const char *) *xpp;
#line 3217
	int status = ENOERR;
#line 3217

#line 3217
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3217
	{
#line 3217
		const int lstatus = ncx_get_longlong_int(xp, tp);
#line 3217
		if(lstatus != ENOERR)
#line 3217
			status = lstatus;
#line 3217
	}
#line 3217

#line 3217
	*xpp = (const void *)xp;
#line 3217
	return status;
#line 3217
#  endif
#line 3217
}
#line 3217

int
#line 3218
ncx_getn_longlong_float(const void **xpp, size_t nelems, float *tp)
#line 3218
{
#line 3218
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3218

#line 3218
 /* basic algorithm is:
#line 3218
  *   - ensure sane alignment of input data
#line 3218
  *   - copy (conversion happens automatically) input data
#line 3218
  *     to output
#line 3218
  *   - update xpp to point at next unconverted input, and tp to point
#line 3218
  *     at next location for converted output
#line 3218
  */
#line 3218
  long i, j, ni;
#line 3218
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3218
  longlong *xp;
#line 3218
  int nrange = 0;         /* number of range errors */
#line 3218
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3218
  long cxp = (long) *((char**)xpp);
#line 3218

#line 3218
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3218
  /* sjl: manually stripmine so we can limit amount of
#line 3218
   * vector work space reserved to LOOPCNT elements. Also
#line 3218
   * makes vectorisation easy */
#line 3218
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3218
    ni=Min(nelems-j,LOOPCNT);
#line 3218
    if (realign) {
#line 3218
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3218
      xp = tmp;
#line 3218
    } else {
#line 3218
      xp = (longlong *) *xpp;
#line 3218
    }
#line 3218
   /* copy the next block */
#line 3218
#pragma cdir loopcnt=LOOPCNT
#line 3218
#pragma cdir shortloop
#line 3218
    for (i=0; i<ni; i++) {
#line 3218
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3218
     /* test for range errors (not always needed but do it anyway) */
#line 3218
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3218
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3218
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3218
    }
#line 3218
   /* update xpp and tp */
#line 3218
    if (realign) xp = (longlong *) *xpp;
#line 3218
    xp += ni;
#line 3218
    tp += ni;
#line 3218
    *xpp = (void*)xp;
#line 3218
  }
#line 3218
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3218

#line 3218
#else   /* not SX */
#line 3218
	const char *xp = (const char *) *xpp;
#line 3218
	int status = ENOERR;
#line 3218

#line 3218
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3218
	{
#line 3218
		const int lstatus = ncx_get_longlong_float(xp, tp);
#line 3218
		if(lstatus != ENOERR)
#line 3218
			status = lstatus;
#line 3218
	}
#line 3218

#line 3218
	*xpp = (const void *)xp;
#line 3218
	return status;
#line 3218
#  endif
#line 3218
}
#line 3218

int
#line 3219
ncx_getn_longlong_double(const void **xpp, size_t nelems, double *tp)
#line 3219
{
#line 3219
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3219

#line 3219
 /* basic algorithm is:
#line 3219
  *   - ensure sane alignment of input data
#line 3219
  *   - copy (conversion happens automatically) input data
#line 3219
  *     to output
#line 3219
  *   - update xpp to point at next unconverted input, and tp to point
#line 3219
  *     at next location for converted output
#line 3219
  */
#line 3219
  long i, j, ni;
#line 3219
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3219
  longlong *xp;
#line 3219
  int nrange = 0;         /* number of range errors */
#line 3219
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3219
  long cxp = (long) *((char**)xpp);
#line 3219

#line 3219
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3219
  /* sjl: manually stripmine so we can limit amount of
#line 3219
   * vector work space reserved to LOOPCNT elements. Also
#line 3219
   * makes vectorisation easy */
#line 3219
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3219
    ni=Min(nelems-j,LOOPCNT);
#line 3219
    if (realign) {
#line 3219
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3219
      xp = tmp;
#line 3219
    } else {
#line 3219
      xp = (longlong *) *xpp;
#line 3219
    }
#line 3219
   /* copy the next block */
#line 3219
#pragma cdir loopcnt=LOOPCNT
#line 3219
#pragma cdir shortloop
#line 3219
    for (i=0; i<ni; i++) {
#line 3219
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3219
     /* test for range errors (not always needed but do it anyway) */
#line 3219
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3219
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3219
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3219
    }
#line 3219
   /* update xpp and tp */
#line 3219
    if (realign) xp = (longlong *) *xpp;
#line 3219
    xp += ni;
#line 3219
    tp += ni;
#line 3219
    *xpp = (void*)xp;
#line 3219
  }
#line 3219
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3219

#line 3219
#else   /* not SX */
#line 3219
	const char *xp = (const char *) *xpp;
#line 3219
	int status = ENOERR;
#line 3219

#line 3219
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3219
	{
#line 3219
		const int lstatus = ncx_get_longlong_double(xp, tp);
#line 3219
		if(lstatus != ENOERR)
#line 3219
			status = lstatus;
#line 3219
	}
#line 3219

#line 3219
	*xpp = (const void *)xp;
#line 3219
	return status;
#line 3219
#  endif
#line 3219
}
#line 3219

int
#line 3220
ncx_getn_longlong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3220
{
#line 3220
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3220

#line 3220
 /* basic algorithm is:
#line 3220
  *   - ensure sane alignment of input data
#line 3220
  *   - copy (conversion happens automatically) input data
#line 3220
  *     to output
#line 3220
  *   - update xpp to point at next unconverted input, and tp to point
#line 3220
  *     at next location for converted output
#line 3220
  */
#line 3220
  long i, j, ni;
#line 3220
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3220
  longlong *xp;
#line 3220
  int nrange = 0;         /* number of range errors */
#line 3220
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3220
  long cxp = (long) *((char**)xpp);
#line 3220

#line 3220
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3220
  /* sjl: manually stripmine so we can limit amount of
#line 3220
   * vector work space reserved to LOOPCNT elements. Also
#line 3220
   * makes vectorisation easy */
#line 3220
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3220
    ni=Min(nelems-j,LOOPCNT);
#line 3220
    if (realign) {
#line 3220
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3220
      xp = tmp;
#line 3220
    } else {
#line 3220
      xp = (longlong *) *xpp;
#line 3220
    }
#line 3220
   /* copy the next block */
#line 3220
#pragma cdir loopcnt=LOOPCNT
#line 3220
#pragma cdir shortloop
#line 3220
    for (i=0; i<ni; i++) {
#line 3220
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3220
     /* test for range errors (not always needed but do it anyway) */
#line 3220
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3220
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3220
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3220
    }
#line 3220
   /* update xpp and tp */
#line 3220
    if (realign) xp = (longlong *) *xpp;
#line 3220
    xp += ni;
#line 3220
    tp += ni;
#line 3220
    *xpp = (void*)xp;
#line 3220
  }
#line 3220
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3220

#line 3220
#else   /* not SX */
#line 3220
	const char *xp = (const char *) *xpp;
#line 3220
	int status = ENOERR;
#line 3220

#line 3220
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3220
	{
#line 3220
		const int lstatus = ncx_get_longlong_uchar(xp, tp);
#line 3220
		if(lstatus != ENOERR)
#line 3220
			status = lstatus;
#line 3220
	}
#line 3220

#line 3220
	*xpp = (const void *)xp;
#line 3220
	return status;
#line 3220
#  endif
#line 3220
}
#line 3220

int
#line 3221
ncx_getn_longlong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3221
{
#line 3221
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3221

#line 3221
 /* basic algorithm is:
#line 3221
  *   - ensure sane alignment of input data
#line 3221
  *   - copy (conversion happens automatically) input data
#line 3221
  *     to output
#line 3221
  *   - update xpp to point at next unconverted input, and tp to point
#line 3221
  *     at next location for converted output
#line 3221
  */
#line 3221
  long i, j, ni;
#line 3221
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3221
  longlong *xp;
#line 3221
  int nrange = 0;         /* number of range errors */
#line 3221
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3221
  long cxp = (long) *((char**)xpp);
#line 3221

#line 3221
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3221
  /* sjl: manually stripmine so we can limit amount of
#line 3221
   * vector work space reserved to LOOPCNT elements. Also
#line 3221
   * makes vectorisation easy */
#line 3221
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3221
    ni=Min(nelems-j,LOOPCNT);
#line 3221
    if (realign) {
#line 3221
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3221
      xp = tmp;
#line 3221
    } else {
#line 3221
      xp = (longlong *) *xpp;
#line 3221
    }
#line 3221
   /* copy the next block */
#line 3221
#pragma cdir loopcnt=LOOPCNT
#line 3221
#pragma cdir shortloop
#line 3221
    for (i=0; i<ni; i++) {
#line 3221
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3221
     /* test for range errors (not always needed but do it anyway) */
#line 3221
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3221
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3221
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3221
    }
#line 3221
   /* update xpp and tp */
#line 3221
    if (realign) xp = (longlong *) *xpp;
#line 3221
    xp += ni;
#line 3221
    tp += ni;
#line 3221
    *xpp = (void*)xp;
#line 3221
  }
#line 3221
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3221

#line 3221
#else   /* not SX */
#line 3221
	const char *xp = (const char *) *xpp;
#line 3221
	int status = ENOERR;
#line 3221

#line 3221
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3221
	{
#line 3221
		const int lstatus = ncx_get_longlong_ushort(xp, tp);
#line 3221
		if(lstatus != ENOERR)
#line 3221
			status = lstatus;
#line 3221
	}
#line 3221

#line 3221
	*xpp = (const void *)xp;
#line 3221
	return status;
#line 3221
#  endif
#line 3221
}
#line 3221

int
#line 3222
ncx_getn_longlong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3222
{
#line 3222
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3222

#line 3222
 /* basic algorithm is:
#line 3222
  *   - ensure sane alignment of input data
#line 3222
  *   - copy (conversion happens automatically) input data
#line 3222
  *     to output
#line 3222
  *   - update xpp to point at next unconverted input, and tp to point
#line 3222
  *     at next location for converted output
#line 3222
  */
#line 3222
  long i, j, ni;
#line 3222
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3222
  longlong *xp;
#line 3222
  int nrange = 0;         /* number of range errors */
#line 3222
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3222
  long cxp = (long) *((char**)xpp);
#line 3222

#line 3222
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3222
  /* sjl: manually stripmine so we can limit amount of
#line 3222
   * vector work space reserved to LOOPCNT elements. Also
#line 3222
   * makes vectorisation easy */
#line 3222
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3222
    ni=Min(nelems-j,LOOPCNT);
#line 3222
    if (realign) {
#line 3222
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3222
      xp = tmp;
#line 3222
    } else {
#line 3222
      xp = (longlong *) *xpp;
#line 3222
    }
#line 3222
   /* copy the next block */
#line 3222
#pragma cdir loopcnt=LOOPCNT
#line 3222
#pragma cdir shortloop
#line 3222
    for (i=0; i<ni; i++) {
#line 3222
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3222
     /* test for range errors (not always needed but do it anyway) */
#line 3222
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3222
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3222
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3222
    }
#line 3222
   /* update xpp and tp */
#line 3222
    if (realign) xp = (longlong *) *xpp;
#line 3222
    xp += ni;
#line 3222
    tp += ni;
#line 3222
    *xpp = (void*)xp;
#line 3222
  }
#line 3222
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3222

#line 3222
#else   /* not SX */
#line 3222
	const char *xp = (const char *) *xpp;
#line 3222
	int status = ENOERR;
#line 3222

#line 3222
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3222
	{
#line 3222
		const int lstatus = ncx_get_longlong_uint(xp, tp);
#line 3222
		if(lstatus != ENOERR)
#line 3222
			status = lstatus;
#line 3222
	}
#line 3222

#line 3222
	*xpp = (const void *)xp;
#line 3222
	return status;
#line 3222
#  endif
#line 3222
}
#line 3222

int
#line 3223
ncx_getn_longlong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3223
{
#line 3223
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3223

#line 3223
 /* basic algorithm is:
#line 3223
  *   - ensure sane alignment of input data
#line 3223
  *   - copy (conversion happens automatically) input data
#line 3223
  *     to output
#line 3223
  *   - update xpp to point at next unconverted input, and tp to point
#line 3223
  *     at next location for converted output
#line 3223
  */
#line 3223
  long i, j, ni;
#line 3223
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3223
  longlong *xp;
#line 3223
  int nrange = 0;         /* number of range errors */
#line 3223
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3223
  long cxp = (long) *((char**)xpp);
#line 3223

#line 3223
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3223
  /* sjl: manually stripmine so we can limit amount of
#line 3223
   * vector work space reserved to LOOPCNT elements. Also
#line 3223
   * makes vectorisation easy */
#line 3223
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3223
    ni=Min(nelems-j,LOOPCNT);
#line 3223
    if (realign) {
#line 3223
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3223
      xp = tmp;
#line 3223
    } else {
#line 3223
      xp = (longlong *) *xpp;
#line 3223
    }
#line 3223
   /* copy the next block */
#line 3223
#pragma cdir loopcnt=LOOPCNT
#line 3223
#pragma cdir shortloop
#line 3223
    for (i=0; i<ni; i++) {
#line 3223
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3223
     /* test for range errors (not always needed but do it anyway) */
#line 3223
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3223
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3223
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3223
    }
#line 3223
   /* update xpp and tp */
#line 3223
    if (realign) xp = (longlong *) *xpp;
#line 3223
    xp += ni;
#line 3223
    tp += ni;
#line 3223
    *xpp = (void*)xp;
#line 3223
  }
#line 3223
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3223

#line 3223
#else   /* not SX */
#line 3223
	const char *xp = (const char *) *xpp;
#line 3223
	int status = ENOERR;
#line 3223

#line 3223
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3223
	{
#line 3223
		const int lstatus = ncx_get_longlong_ulonglong(xp, tp);
#line 3223
		if(lstatus != ENOERR)
#line 3223
			status = lstatus;
#line 3223
	}
#line 3223

#line 3223
	*xpp = (const void *)xp;
#line 3223
	return status;
#line 3223
#  endif
#line 3223
}
#line 3223


#if X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
/* optimized version */
int
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_LONGLONG);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_LONGLONG);
	return ENOERR;
}
#else
int
#line 3239
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3239
{
#line 3239
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3239

#line 3239
 /* basic algorithm is:
#line 3239
  *   - ensure sane alignment of output data
#line 3239
  *   - copy (conversion happens automatically) input data
#line 3239
  *     to output
#line 3239
  *   - update tp to point at next unconverted input, and xpp to point
#line 3239
  *     at next location for converted output
#line 3239
  */
#line 3239
  long i, j, ni;
#line 3239
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3239
  longlong *xp;
#line 3239
  int nrange = 0;         /* number of range errors */
#line 3239
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3239
  long cxp = (long) *((char**)xpp);
#line 3239

#line 3239
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3239
  /* sjl: manually stripmine so we can limit amount of
#line 3239
   * vector work space reserved to LOOPCNT elements. Also
#line 3239
   * makes vectorisation easy */
#line 3239
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3239
    ni=Min(nelems-j,LOOPCNT);
#line 3239
    if (realign) {
#line 3239
      xp = tmp;
#line 3239
    } else {
#line 3239
      xp = (longlong *) *xpp;
#line 3239
    }
#line 3239
   /* copy the next block */
#line 3239
#pragma cdir loopcnt=LOOPCNT
#line 3239
#pragma cdir shortloop
#line 3239
    for (i=0; i<ni; i++) {
#line 3239
      /* the normal case: */
#line 3239
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3239
     /* test for range errors (not always needed but do it anyway) */
#line 3239
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3239
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3239
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3239
    }
#line 3239
   /* copy workspace back if necessary */ 
#line 3239
    if (realign) {
#line 3239
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3239
      xp = (longlong *) *xpp;
#line 3239
    }
#line 3239
   /* update xpp and tp */
#line 3239
    xp += ni;
#line 3239
    tp += ni;
#line 3239
    *xpp = (void*)xp;
#line 3239
  }
#line 3239
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3239

#line 3239
#else   /* not SX */
#line 3239

#line 3239
	char *xp = (char *) *xpp;
#line 3239
	int status = ENOERR;
#line 3239

#line 3239
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3239
	{
#line 3239
		int lstatus = ncx_put_longlong_longlong(xp, tp);
#line 3239
		if(lstatus != ENOERR)
#line 3239
			status = lstatus;
#line 3239
	}
#line 3239

#line 3239
	*xpp = (void *)xp;
#line 3239
	return status;
#line 3239
#endif
#line 3239
}
#line 3239

#endif
int
#line 3241
ncx_putn_longlong_schar(void **xpp, size_t nelems, const schar *tp)
#line 3241
{
#line 3241
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3241

#line 3241
 /* basic algorithm is:
#line 3241
  *   - ensure sane alignment of output data
#line 3241
  *   - copy (conversion happens automatically) input data
#line 3241
  *     to output
#line 3241
  *   - update tp to point at next unconverted input, and xpp to point
#line 3241
  *     at next location for converted output
#line 3241
  */
#line 3241
  long i, j, ni;
#line 3241
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3241
  longlong *xp;
#line 3241
  int nrange = 0;         /* number of range errors */
#line 3241
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3241
  long cxp = (long) *((char**)xpp);
#line 3241

#line 3241
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3241
  /* sjl: manually stripmine so we can limit amount of
#line 3241
   * vector work space reserved to LOOPCNT elements. Also
#line 3241
   * makes vectorisation easy */
#line 3241
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3241
    ni=Min(nelems-j,LOOPCNT);
#line 3241
    if (realign) {
#line 3241
      xp = tmp;
#line 3241
    } else {
#line 3241
      xp = (longlong *) *xpp;
#line 3241
    }
#line 3241
   /* copy the next block */
#line 3241
#pragma cdir loopcnt=LOOPCNT
#line 3241
#pragma cdir shortloop
#line 3241
    for (i=0; i<ni; i++) {
#line 3241
      /* the normal case: */
#line 3241
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3241
     /* test for range errors (not always needed but do it anyway) */
#line 3241
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3241
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3241
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3241
    }
#line 3241
   /* copy workspace back if necessary */ 
#line 3241
    if (realign) {
#line 3241
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3241
      xp = (longlong *) *xpp;
#line 3241
    }
#line 3241
   /* update xpp and tp */
#line 3241
    xp += ni;
#line 3241
    tp += ni;
#line 3241
    *xpp = (void*)xp;
#line 3241
  }
#line 3241
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3241

#line 3241
#else   /* not SX */
#line 3241

#line 3241
	char *xp = (char *) *xpp;
#line 3241
	int status = ENOERR;
#line 3241

#line 3241
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3241
	{
#line 3241
		int lstatus = ncx_put_longlong_schar(xp, tp);
#line 3241
		if(lstatus != ENOERR)
#line 3241
			status = lstatus;
#line 3241
	}
#line 3241

#line 3241
	*xpp = (void *)xp;
#line 3241
	return status;
#line 3241
#endif
#line 3241
}
#line 3241

int
#line 3242
ncx_putn_longlong_short(void **xpp, size_t nelems, const short *tp)
#line 3242
{
#line 3242
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3242

#line 3242
 /* basic algorithm is:
#line 3242
  *   - ensure sane alignment of output data
#line 3242
  *   - copy (conversion happens automatically) input data
#line 3242
  *     to output
#line 3242
  *   - update tp to point at next unconverted input, and xpp to point
#line 3242
  *     at next location for converted output
#line 3242
  */
#line 3242
  long i, j, ni;
#line 3242
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3242
  longlong *xp;
#line 3242
  int nrange = 0;         /* number of range errors */
#line 3242
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3242
  long cxp = (long) *((char**)xpp);
#line 3242

#line 3242
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3242
  /* sjl: manually stripmine so we can limit amount of
#line 3242
   * vector work space reserved to LOOPCNT elements. Also
#line 3242
   * makes vectorisation easy */
#line 3242
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3242
    ni=Min(nelems-j,LOOPCNT);
#line 3242
    if (realign) {
#line 3242
      xp = tmp;
#line 3242
    } else {
#line 3242
      xp = (longlong *) *xpp;
#line 3242
    }
#line 3242
   /* copy the next block */
#line 3242
#pragma cdir loopcnt=LOOPCNT
#line 3242
#pragma cdir shortloop
#line 3242
    for (i=0; i<ni; i++) {
#line 3242
      /* the normal case: */
#line 3242
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3242
     /* test for range errors (not always needed but do it anyway) */
#line 3242
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3242
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3242
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3242
    }
#line 3242
   /* copy workspace back if necessary */ 
#line 3242
    if (realign) {
#line 3242
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3242
      xp = (longlong *) *xpp;
#line 3242
    }
#line 3242
   /* update xpp and tp */
#line 3242
    xp += ni;
#line 3242
    tp += ni;
#line 3242
    *xpp = (void*)xp;
#line 3242
  }
#line 3242
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3242

#line 3242
#else   /* not SX */
#line 3242

#line 3242
	char *xp = (char *) *xpp;
#line 3242
	int status = ENOERR;
#line 3242

#line 3242
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3242
	{
#line 3242
		int lstatus = ncx_put_longlong_short(xp, tp);
#line 3242
		if(lstatus != ENOERR)
#line 3242
			status = lstatus;
#line 3242
	}
#line 3242

#line 3242
	*xpp = (void *)xp;
#line 3242
	return status;
#line 3242
#endif
#line 3242
}
#line 3242

int
#line 3243
ncx_putn_longlong_int(void **xpp, size_t nelems, const int *tp)
#line 3243
{
#line 3243
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3243

#line 3243
 /* basic algorithm is:
#line 3243
  *   - ensure sane alignment of output data
#line 3243
  *   - copy (conversion happens automatically) input data
#line 3243
  *     to output
#line 3243
  *   - update tp to point at next unconverted input, and xpp to point
#line 3243
  *     at next location for converted output
#line 3243
  */
#line 3243
  long i, j, ni;
#line 3243
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3243
  longlong *xp;
#line 3243
  int nrange = 0;         /* number of range errors */
#line 3243
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3243
  long cxp = (long) *((char**)xpp);
#line 3243

#line 3243
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3243
  /* sjl: manually stripmine so we can limit amount of
#line 3243
   * vector work space reserved to LOOPCNT elements. Also
#line 3243
   * makes vectorisation easy */
#line 3243
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3243
    ni=Min(nelems-j,LOOPCNT);
#line 3243
    if (realign) {
#line 3243
      xp = tmp;
#line 3243
    } else {
#line 3243
      xp = (longlong *) *xpp;
#line 3243
    }
#line 3243
   /* copy the next block */
#line 3243
#pragma cdir loopcnt=LOOPCNT
#line 3243
#pragma cdir shortloop
#line 3243
    for (i=0; i<ni; i++) {
#line 3243
      /* the normal case: */
#line 3243
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3243
     /* test for range errors (not always needed but do it anyway) */
#line 3243
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3243
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3243
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3243
    }
#line 3243
   /* copy workspace back if necessary */ 
#line 3243
    if (realign) {
#line 3243
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3243
      xp = (longlong *) *xpp;
#line 3243
    }
#line 3243
   /* update xpp and tp */
#line 3243
    xp += ni;
#line 3243
    tp += ni;
#line 3243
    *xpp = (void*)xp;
#line 3243
  }
#line 3243
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3243

#line 3243
#else   /* not SX */
#line 3243

#line 3243
	char *xp = (char *) *xpp;
#line 3243
	int status = ENOERR;
#line 3243

#line 3243
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3243
	{
#line 3243
		int lstatus = ncx_put_longlong_int(xp, tp);
#line 3243
		if(lstatus != ENOERR)
#line 3243
			status = lstatus;
#line 3243
	}
#line 3243

#line 3243
	*xpp = (void *)xp;
#line 3243
	return status;
#line 3243
#endif
#line 3243
}
#line 3243

int
#line 3244
ncx_putn_longlong_float(void **xpp, size_t nelems, const float *tp)
#line 3244
{
#line 3244
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3244

#line 3244
 /* basic algorithm is:
#line 3244
  *   - ensure sane alignment of output data
#line 3244
  *   - copy (conversion happens automatically) input data
#line 3244
  *     to output
#line 3244
  *   - update tp to point at next unconverted input, and xpp to point
#line 3244
  *     at next location for converted output
#line 3244
  */
#line 3244
  long i, j, ni;
#line 3244
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3244
  longlong *xp;
#line 3244
  int nrange = 0;         /* number of range errors */
#line 3244
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3244
  long cxp = (long) *((char**)xpp);
#line 3244

#line 3244
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3244
  /* sjl: manually stripmine so we can limit amount of
#line 3244
   * vector work space reserved to LOOPCNT elements. Also
#line 3244
   * makes vectorisation easy */
#line 3244
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3244
    ni=Min(nelems-j,LOOPCNT);
#line 3244
    if (realign) {
#line 3244
      xp = tmp;
#line 3244
    } else {
#line 3244
      xp = (longlong *) *xpp;
#line 3244
    }
#line 3244
   /* copy the next block */
#line 3244
#pragma cdir loopcnt=LOOPCNT
#line 3244
#pragma cdir shortloop
#line 3244
    for (i=0; i<ni; i++) {
#line 3244
      /* the normal case: */
#line 3244
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3244
     /* test for range errors (not always needed but do it anyway) */
#line 3244
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3244
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3244
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3244
    }
#line 3244
   /* copy workspace back if necessary */ 
#line 3244
    if (realign) {
#line 3244
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3244
      xp = (longlong *) *xpp;
#line 3244
    }
#line 3244
   /* update xpp and tp */
#line 3244
    xp += ni;
#line 3244
    tp += ni;
#line 3244
    *xpp = (void*)xp;
#line 3244
  }
#line 3244
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3244

#line 3244
#else   /* not SX */
#line 3244

#line 3244
	char *xp = (char *) *xpp;
#line 3244
	int status = ENOERR;
#line 3244

#line 3244
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3244
	{
#line 3244
		int lstatus = ncx_put_longlong_float(xp, tp);
#line 3244
		if(lstatus != ENOERR)
#line 3244
			status = lstatus;
#line 3244
	}
#line 3244

#line 3244
	*xpp = (void *)xp;
#line 3244
	return status;
#line 3244
#endif
#line 3244
}
#line 3244

int
#line 3245
ncx_putn_longlong_double(void **xpp, size_t nelems, const double *tp)
#line 3245
{
#line 3245
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3245

#line 3245
 /* basic algorithm is:
#line 3245
  *   - ensure sane alignment of output data
#line 3245
  *   - copy (conversion happens automatically) input data
#line 3245
  *     to output
#line 3245
  *   - update tp to point at next unconverted input, and xpp to point
#line 3245
  *     at next location for converted output
#line 3245
  */
#line 3245
  long i, j, ni;
#line 3245
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3245
  longlong *xp;
#line 3245
  int nrange = 0;         /* number of range errors */
#line 3245
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3245
  long cxp = (long) *((char**)xpp);
#line 3245

#line 3245
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3245
  /* sjl: manually stripmine so we can limit amount of
#line 3245
   * vector work space reserved to LOOPCNT elements. Also
#line 3245
   * makes vectorisation easy */
#line 3245
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3245
    ni=Min(nelems-j,LOOPCNT);
#line 3245
    if (realign) {
#line 3245
      xp = tmp;
#line 3245
    } else {
#line 3245
      xp = (longlong *) *xpp;
#line 3245
    }
#line 3245
   /* copy the next block */
#line 3245
#pragma cdir loopcnt=LOOPCNT
#line 3245
#pragma cdir shortloop
#line 3245
    for (i=0; i<ni; i++) {
#line 3245
      /* the normal case: */
#line 3245
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3245
     /* test for range errors (not always needed but do it anyway) */
#line 3245
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3245
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3245
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3245
    }
#line 3245
   /* copy workspace back if necessary */ 
#line 3245
    if (realign) {
#line 3245
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3245
      xp = (longlong *) *xpp;
#line 3245
    }
#line 3245
   /* update xpp and tp */
#line 3245
    xp += ni;
#line 3245
    tp += ni;
#line 3245
    *xpp = (void*)xp;
#line 3245
  }
#line 3245
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3245

#line 3245
#else   /* not SX */
#line 3245

#line 3245
	char *xp = (char *) *xpp;
#line 3245
	int status = ENOERR;
#line 3245

#line 3245
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3245
	{
#line 3245
		int lstatus = ncx_put_longlong_double(xp, tp);
#line 3245
		if(lstatus != ENOERR)
#line 3245
			status = lstatus;
#line 3245
	}
#line 3245

#line 3245
	*xpp = (void *)xp;
#line 3245
	return status;
#line 3245
#endif
#line 3245
}
#line 3245

int
#line 3246
ncx_putn_longlong_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3246
{
#line 3246
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3246

#line 3246
 /* basic algorithm is:
#line 3246
  *   - ensure sane alignment of output data
#line 3246
  *   - copy (conversion happens automatically) input data
#line 3246
  *     to output
#line 3246
  *   - update tp to point at next unconverted input, and xpp to point
#line 3246
  *     at next location for converted output
#line 3246
  */
#line 3246
  long i, j, ni;
#line 3246
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3246
  longlong *xp;
#line 3246
  int nrange = 0;         /* number of range errors */
#line 3246
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3246
  long cxp = (long) *((char**)xpp);
#line 3246

#line 3246
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3246
  /* sjl: manually stripmine so we can limit amount of
#line 3246
   * vector work space reserved to LOOPCNT elements. Also
#line 3246
   * makes vectorisation easy */
#line 3246
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3246
    ni=Min(nelems-j,LOOPCNT);
#line 3246
    if (realign) {
#line 3246
      xp = tmp;
#line 3246
    } else {
#line 3246
      xp = (longlong *) *xpp;
#line 3246
    }
#line 3246
   /* copy the next block */
#line 3246
#pragma cdir loopcnt=LOOPCNT
#line 3246
#pragma cdir shortloop
#line 3246
    for (i=0; i<ni; i++) {
#line 3246
      /* the normal case: */
#line 3246
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3246
     /* test for range errors (not always needed but do it anyway) */
#line 3246
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3246
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3246
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3246
    }
#line 3246
   /* copy workspace back if necessary */ 
#line 3246
    if (realign) {
#line 3246
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3246
      xp = (longlong *) *xpp;
#line 3246
    }
#line 3246
   /* update xpp and tp */
#line 3246
    xp += ni;
#line 3246
    tp += ni;
#line 3246
    *xpp = (void*)xp;
#line 3246
  }
#line 3246
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3246

#line 3246
#else   /* not SX */
#line 3246

#line 3246
	char *xp = (char *) *xpp;
#line 3246
	int status = ENOERR;
#line 3246

#line 3246
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3246
	{
#line 3246
		int lstatus = ncx_put_longlong_uchar(xp, tp);
#line 3246
		if(lstatus != ENOERR)
#line 3246
			status = lstatus;
#line 3246
	}
#line 3246

#line 3246
	*xpp = (void *)xp;
#line 3246
	return status;
#line 3246
#endif
#line 3246
}
#line 3246

int
#line 3247
ncx_putn_longlong_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3247
{
#line 3247
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3247

#line 3247
 /* basic algorithm is:
#line 3247
  *   - ensure sane alignment of output data
#line 3247
  *   - copy (conversion happens automatically) input data
#line 3247
  *     to output
#line 3247
  *   - update tp to point at next unconverted input, and xpp to point
#line 3247
  *     at next location for converted output
#line 3247
  */
#line 3247
  long i, j, ni;
#line 3247
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3247
  longlong *xp;
#line 3247
  int nrange = 0;         /* number of range errors */
#line 3247
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3247
  long cxp = (long) *((char**)xpp);
#line 3247

#line 3247
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3247
  /* sjl: manually stripmine so we can limit amount of
#line 3247
   * vector work space reserved to LOOPCNT elements. Also
#line 3247
   * makes vectorisation easy */
#line 3247
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3247
    ni=Min(nelems-j,LOOPCNT);
#line 3247
    if (realign) {
#line 3247
      xp = tmp;
#line 3247
    } else {
#line 3247
      xp = (longlong *) *xpp;
#line 3247
    }
#line 3247
   /* copy the next block */
#line 3247
#pragma cdir loopcnt=LOOPCNT
#line 3247
#pragma cdir shortloop
#line 3247
    for (i=0; i<ni; i++) {
#line 3247
      /* the normal case: */
#line 3247
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3247
     /* test for range errors (not always needed but do it anyway) */
#line 3247
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3247
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3247
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3247
    }
#line 3247
   /* copy workspace back if necessary */ 
#line 3247
    if (realign) {
#line 3247
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3247
      xp = (longlong *) *xpp;
#line 3247
    }
#line 3247
   /* update xpp and tp */
#line 3247
    xp += ni;
#line 3247
    tp += ni;
#line 3247
    *xpp = (void*)xp;
#line 3247
  }
#line 3247
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3247

#line 3247
#else   /* not SX */
#line 3247

#line 3247
	char *xp = (char *) *xpp;
#line 3247
	int status = ENOERR;
#line 3247

#line 3247
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3247
	{
#line 3247
		int lstatus = ncx_put_longlong_ushort(xp, tp);
#line 3247
		if(lstatus != ENOERR)
#line 3247
			status = lstatus;
#line 3247
	}
#line 3247

#line 3247
	*xpp = (void *)xp;
#line 3247
	return status;
#line 3247
#endif
#line 3247
}
#line 3247

int
#line 3248
ncx_putn_longlong_uint(void **xpp, size_t nelems, const uint *tp)
#line 3248
{
#line 3248
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3248

#line 3248
 /* basic algorithm is:
#line 3248
  *   - ensure sane alignment of output data
#line 3248
  *   - copy (conversion happens automatically) input data
#line 3248
  *     to output
#line 3248
  *   - update tp to point at next unconverted input, and xpp to point
#line 3248
  *     at next location for converted output
#line 3248
  */
#line 3248
  long i, j, ni;
#line 3248
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3248
  longlong *xp;
#line 3248
  int nrange = 0;         /* number of range errors */
#line 3248
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3248
  long cxp = (long) *((char**)xpp);
#line 3248

#line 3248
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3248
  /* sjl: manually stripmine so we can limit amount of
#line 3248
   * vector work space reserved to LOOPCNT elements. Also
#line 3248
   * makes vectorisation easy */
#line 3248
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3248
    ni=Min(nelems-j,LOOPCNT);
#line 3248
    if (realign) {
#line 3248
      xp = tmp;
#line 3248
    } else {
#line 3248
      xp = (longlong *) *xpp;
#line 3248
    }
#line 3248
   /* copy the next block */
#line 3248
#pragma cdir loopcnt=LOOPCNT
#line 3248
#pragma cdir shortloop
#line 3248
    for (i=0; i<ni; i++) {
#line 3248
      /* the normal case: */
#line 3248
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3248
     /* test for range errors (not always needed but do it anyway) */
#line 3248
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3248
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3248
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3248
    }
#line 3248
   /* copy workspace back if necessary */ 
#line 3248
    if (realign) {
#line 3248
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3248
      xp = (longlong *) *xpp;
#line 3248
    }
#line 3248
   /* update xpp and tp */
#line 3248
    xp += ni;
#line 3248
    tp += ni;
#line 3248
    *xpp = (void*)xp;
#line 3248
  }
#line 3248
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3248

#line 3248
#else   /* not SX */
#line 3248

#line 3248
	char *xp = (char *) *xpp;
#line 3248
	int status = ENOERR;
#line 3248

#line 3248
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3248
	{
#line 3248
		int lstatus = ncx_put_longlong_uint(xp, tp);
#line 3248
		if(lstatus != ENOERR)
#line 3248
			status = lstatus;
#line 3248
	}
#line 3248

#line 3248
	*xpp = (void *)xp;
#line 3248
	return status;
#line 3248
#endif
#line 3248
}
#line 3248

int
#line 3249
ncx_putn_longlong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3249
{
#line 3249
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3249

#line 3249
 /* basic algorithm is:
#line 3249
  *   - ensure sane alignment of output data
#line 3249
  *   - copy (conversion happens automatically) input data
#line 3249
  *     to output
#line 3249
  *   - update tp to point at next unconverted input, and xpp to point
#line 3249
  *     at next location for converted output
#line 3249
  */
#line 3249
  long i, j, ni;
#line 3249
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3249
  longlong *xp;
#line 3249
  int nrange = 0;         /* number of range errors */
#line 3249
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3249
  long cxp = (long) *((char**)xpp);
#line 3249

#line 3249
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3249
  /* sjl: manually stripmine so we can limit amount of
#line 3249
   * vector work space reserved to LOOPCNT elements. Also
#line 3249
   * makes vectorisation easy */
#line 3249
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3249
    ni=Min(nelems-j,LOOPCNT);
#line 3249
    if (realign) {
#line 3249
      xp = tmp;
#line 3249
    } else {
#line 3249
      xp = (longlong *) *xpp;
#line 3249
    }
#line 3249
   /* copy the next block */
#line 3249
#pragma cdir loopcnt=LOOPCNT
#line 3249
#pragma cdir shortloop
#line 3249
    for (i=0; i<ni; i++) {
#line 3249
      /* the normal case: */
#line 3249
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3249
     /* test for range errors (not always needed but do it anyway) */
#line 3249
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3249
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3249
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3249
    }
#line 3249
   /* copy workspace back if necessary */ 
#line 3249
    if (realign) {
#line 3249
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3249
      xp = (longlong *) *xpp;
#line 3249
    }
#line 3249
   /* update xpp and tp */
#line 3249
    xp += ni;
#line 3249
    tp += ni;
#line 3249
    *xpp = (void*)xp;
#line 3249
  }
#line 3249
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3249

#line 3249
#else   /* not SX */
#line 3249

#line 3249
	char *xp = (char *) *xpp;
#line 3249
	int status = ENOERR;
#line 3249

#line 3249
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3249
	{
#line 3249
		int lstatus = ncx_put_longlong_ulonglong(xp, tp);
#line 3249
		if(lstatus != ENOERR)
#line 3249
			status = lstatus;
#line 3249
	}
#line 3249

#line 3249
	*xpp = (void *)xp;
#line 3249
	return status;
#line 3249
#endif
#line 3249
}
#line 3249


/* ulonglong ----------------------------------------------------------------------*/

#if X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, unsigned long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(unsigned long long));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_ULONGLONG);
	return ENOERR;
}
#else
int
#line 3267
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3267
{
#line 3267
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3267

#line 3267
 /* basic algorithm is:
#line 3267
  *   - ensure sane alignment of input data
#line 3267
  *   - copy (conversion happens automatically) input data
#line 3267
  *     to output
#line 3267
  *   - update xpp to point at next unconverted input, and tp to point
#line 3267
  *     at next location for converted output
#line 3267
  */
#line 3267
  long i, j, ni;
#line 3267
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3267
  ulonglong *xp;
#line 3267
  int nrange = 0;         /* number of range errors */
#line 3267
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3267
  long cxp = (long) *((char**)xpp);
#line 3267

#line 3267
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3267
  /* sjl: manually stripmine so we can limit amount of
#line 3267
   * vector work space reserved to LOOPCNT elements. Also
#line 3267
   * makes vectorisation easy */
#line 3267
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3267
    ni=Min(nelems-j,LOOPCNT);
#line 3267
    if (realign) {
#line 3267
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3267
      xp = tmp;
#line 3267
    } else {
#line 3267
      xp = (ulonglong *) *xpp;
#line 3267
    }
#line 3267
   /* copy the next block */
#line 3267
#pragma cdir loopcnt=LOOPCNT
#line 3267
#pragma cdir shortloop
#line 3267
    for (i=0; i<ni; i++) {
#line 3267
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3267
     /* test for range errors (not always needed but do it anyway) */
#line 3267
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3267
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3267
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3267
    }
#line 3267
   /* update xpp and tp */
#line 3267
    if (realign) xp = (ulonglong *) *xpp;
#line 3267
    xp += ni;
#line 3267
    tp += ni;
#line 3267
    *xpp = (void*)xp;
#line 3267
  }
#line 3267
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3267

#line 3267
#else   /* not SX */
#line 3267
	const char *xp = (const char *) *xpp;
#line 3267
	int status = ENOERR;
#line 3267

#line 3267
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3267
	{
#line 3267
		const int lstatus = ncx_get_ulonglong_ulonglong(xp, tp);
#line 3267
		if(lstatus != ENOERR)
#line 3267
			status = lstatus;
#line 3267
	}
#line 3267

#line 3267
	*xpp = (const void *)xp;
#line 3267
	return status;
#line 3267
#  endif
#line 3267
}
#line 3267

#endif
int
#line 3269
ncx_getn_ulonglong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3269
{
#line 3269
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3269

#line 3269
 /* basic algorithm is:
#line 3269
  *   - ensure sane alignment of input data
#line 3269
  *   - copy (conversion happens automatically) input data
#line 3269
  *     to output
#line 3269
  *   - update xpp to point at next unconverted input, and tp to point
#line 3269
  *     at next location for converted output
#line 3269
  */
#line 3269
  long i, j, ni;
#line 3269
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3269
  ulonglong *xp;
#line 3269
  int nrange = 0;         /* number of range errors */
#line 3269
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3269
  long cxp = (long) *((char**)xpp);
#line 3269

#line 3269
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3269
  /* sjl: manually stripmine so we can limit amount of
#line 3269
   * vector work space reserved to LOOPCNT elements. Also
#line 3269
   * makes vectorisation easy */
#line 3269
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3269
    ni=Min(nelems-j,LOOPCNT);
#line 3269
    if (realign) {
#line 3269
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3269
      xp = tmp;
#line 3269
    } else {
#line 3269
      xp = (ulonglong *) *xpp;
#line 3269
    }
#line 3269
   /* copy the next block */
#line 3269
#pragma cdir loopcnt=LOOPCNT
#line 3269
#pragma cdir shortloop
#line 3269
    for (i=0; i<ni; i++) {
#line 3269
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3269
     /* test for range errors (not always needed but do it anyway) */
#line 3269
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3269
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3269
      nrange += xp[i] > SCHAR_MAX ;
#line 3269
    }
#line 3269
   /* update xpp and tp */
#line 3269
    if (realign) xp = (ulonglong *) *xpp;
#line 3269
    xp += ni;
#line 3269
    tp += ni;
#line 3269
    *xpp = (void*)xp;
#line 3269
  }
#line 3269
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3269

#line 3269
#else   /* not SX */
#line 3269
	const char *xp = (const char *) *xpp;
#line 3269
	int status = ENOERR;
#line 3269

#line 3269
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3269
	{
#line 3269
		const int lstatus = ncx_get_ulonglong_schar(xp, tp);
#line 3269
		if(lstatus != ENOERR)
#line 3269
			status = lstatus;
#line 3269
	}
#line 3269

#line 3269
	*xpp = (const void *)xp;
#line 3269
	return status;
#line 3269
#  endif
#line 3269
}
#line 3269

int
#line 3270
ncx_getn_ulonglong_short(const void **xpp, size_t nelems, short *tp)
#line 3270
{
#line 3270
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3270

#line 3270
 /* basic algorithm is:
#line 3270
  *   - ensure sane alignment of input data
#line 3270
  *   - copy (conversion happens automatically) input data
#line 3270
  *     to output
#line 3270
  *   - update xpp to point at next unconverted input, and tp to point
#line 3270
  *     at next location for converted output
#line 3270
  */
#line 3270
  long i, j, ni;
#line 3270
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3270
  ulonglong *xp;
#line 3270
  int nrange = 0;         /* number of range errors */
#line 3270
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3270
  long cxp = (long) *((char**)xpp);
#line 3270

#line 3270
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3270
  /* sjl: manually stripmine so we can limit amount of
#line 3270
   * vector work space reserved to LOOPCNT elements. Also
#line 3270
   * makes vectorisation easy */
#line 3270
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3270
    ni=Min(nelems-j,LOOPCNT);
#line 3270
    if (realign) {
#line 3270
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3270
      xp = tmp;
#line 3270
    } else {
#line 3270
      xp = (ulonglong *) *xpp;
#line 3270
    }
#line 3270
   /* copy the next block */
#line 3270
#pragma cdir loopcnt=LOOPCNT
#line 3270
#pragma cdir shortloop
#line 3270
    for (i=0; i<ni; i++) {
#line 3270
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3270
     /* test for range errors (not always needed but do it anyway) */
#line 3270
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3270
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3270
      nrange += xp[i] > SHORT_MAX ;
#line 3270
    }
#line 3270
   /* update xpp and tp */
#line 3270
    if (realign) xp = (ulonglong *) *xpp;
#line 3270
    xp += ni;
#line 3270
    tp += ni;
#line 3270
    *xpp = (void*)xp;
#line 3270
  }
#line 3270
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3270

#line 3270
#else   /* not SX */
#line 3270
	const char *xp = (const char *) *xpp;
#line 3270
	int status = ENOERR;
#line 3270

#line 3270
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3270
	{
#line 3270
		const int lstatus = ncx_get_ulonglong_short(xp, tp);
#line 3270
		if(lstatus != ENOERR)
#line 3270
			status = lstatus;
#line 3270
	}
#line 3270

#line 3270
	*xpp = (const void *)xp;
#line 3270
	return status;
#line 3270
#  endif
#line 3270
}
#line 3270

int
#line 3271
ncx_getn_ulonglong_int(const void **xpp, size_t nelems, int *tp)
#line 3271
{
#line 3271
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3271

#line 3271
 /* basic algorithm is:
#line 3271
  *   - ensure sane alignment of input data
#line 3271
  *   - copy (conversion happens automatically) input data
#line 3271
  *     to output
#line 3271
  *   - update xpp to point at next unconverted input, and tp to point
#line 3271
  *     at next location for converted output
#line 3271
  */
#line 3271
  long i, j, ni;
#line 3271
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3271
  ulonglong *xp;
#line 3271
  int nrange = 0;         /* number of range errors */
#line 3271
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3271
  long cxp = (long) *((char**)xpp);
#line 3271

#line 3271
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3271
  /* sjl: manually stripmine so we can limit amount of
#line 3271
   * vector work space reserved to LOOPCNT elements. Also
#line 3271
   * makes vectorisation easy */
#line 3271
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3271
    ni=Min(nelems-j,LOOPCNT);
#line 3271
    if (realign) {
#line 3271
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3271
      xp = tmp;
#line 3271
    } else {
#line 3271
      xp = (ulonglong *) *xpp;
#line 3271
    }
#line 3271
   /* copy the next block */
#line 3271
#pragma cdir loopcnt=LOOPCNT
#line 3271
#pragma cdir shortloop
#line 3271
    for (i=0; i<ni; i++) {
#line 3271
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3271
     /* test for range errors (not always needed but do it anyway) */
#line 3271
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3271
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3271
      nrange += xp[i] > INT_MAX ;
#line 3271
    }
#line 3271
   /* update xpp and tp */
#line 3271
    if (realign) xp = (ulonglong *) *xpp;
#line 3271
    xp += ni;
#line 3271
    tp += ni;
#line 3271
    *xpp = (void*)xp;
#line 3271
  }
#line 3271
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3271

#line 3271
#else   /* not SX */
#line 3271
	const char *xp = (const char *) *xpp;
#line 3271
	int status = ENOERR;
#line 3271

#line 3271
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3271
	{
#line 3271
		const int lstatus = ncx_get_ulonglong_int(xp, tp);
#line 3271
		if(lstatus != ENOERR)
#line 3271
			status = lstatus;
#line 3271
	}
#line 3271

#line 3271
	*xpp = (const void *)xp;
#line 3271
	return status;
#line 3271
#  endif
#line 3271
}
#line 3271

int
#line 3272
ncx_getn_ulonglong_float(const void **xpp, size_t nelems, float *tp)
#line 3272
{
#line 3272
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3272

#line 3272
 /* basic algorithm is:
#line 3272
  *   - ensure sane alignment of input data
#line 3272
  *   - copy (conversion happens automatically) input data
#line 3272
  *     to output
#line 3272
  *   - update xpp to point at next unconverted input, and tp to point
#line 3272
  *     at next location for converted output
#line 3272
  */
#line 3272
  long i, j, ni;
#line 3272
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3272
  ulonglong *xp;
#line 3272
  int nrange = 0;         /* number of range errors */
#line 3272
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3272
  long cxp = (long) *((char**)xpp);
#line 3272

#line 3272
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3272
  /* sjl: manually stripmine so we can limit amount of
#line 3272
   * vector work space reserved to LOOPCNT elements. Also
#line 3272
   * makes vectorisation easy */
#line 3272
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3272
    ni=Min(nelems-j,LOOPCNT);
#line 3272
    if (realign) {
#line 3272
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3272
      xp = tmp;
#line 3272
    } else {
#line 3272
      xp = (ulonglong *) *xpp;
#line 3272
    }
#line 3272
   /* copy the next block */
#line 3272
#pragma cdir loopcnt=LOOPCNT
#line 3272
#pragma cdir shortloop
#line 3272
    for (i=0; i<ni; i++) {
#line 3272
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3272
     /* test for range errors (not always needed but do it anyway) */
#line 3272
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3272
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3272
      nrange += xp[i] > FLOAT_MAX ;
#line 3272
    }
#line 3272
   /* update xpp and tp */
#line 3272
    if (realign) xp = (ulonglong *) *xpp;
#line 3272
    xp += ni;
#line 3272
    tp += ni;
#line 3272
    *xpp = (void*)xp;
#line 3272
  }
#line 3272
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3272

#line 3272
#else   /* not SX */
#line 3272
	const char *xp = (const char *) *xpp;
#line 3272
	int status = ENOERR;
#line 3272

#line 3272
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3272
	{
#line 3272
		const int lstatus = ncx_get_ulonglong_float(xp, tp);
#line 3272
		if(lstatus != ENOERR)
#line 3272
			status = lstatus;
#line 3272
	}
#line 3272

#line 3272
	*xpp = (const void *)xp;
#line 3272
	return status;
#line 3272
#  endif
#line 3272
}
#line 3272

int
#line 3273
ncx_getn_ulonglong_double(const void **xpp, size_t nelems, double *tp)
#line 3273
{
#line 3273
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3273

#line 3273
 /* basic algorithm is:
#line 3273
  *   - ensure sane alignment of input data
#line 3273
  *   - copy (conversion happens automatically) input data
#line 3273
  *     to output
#line 3273
  *   - update xpp to point at next unconverted input, and tp to point
#line 3273
  *     at next location for converted output
#line 3273
  */
#line 3273
  long i, j, ni;
#line 3273
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3273
  ulonglong *xp;
#line 3273
  int nrange = 0;         /* number of range errors */
#line 3273
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3273
  long cxp = (long) *((char**)xpp);
#line 3273

#line 3273
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3273
  /* sjl: manually stripmine so we can limit amount of
#line 3273
   * vector work space reserved to LOOPCNT elements. Also
#line 3273
   * makes vectorisation easy */
#line 3273
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3273
    ni=Min(nelems-j,LOOPCNT);
#line 3273
    if (realign) {
#line 3273
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3273
      xp = tmp;
#line 3273
    } else {
#line 3273
      xp = (ulonglong *) *xpp;
#line 3273
    }
#line 3273
   /* copy the next block */
#line 3273
#pragma cdir loopcnt=LOOPCNT
#line 3273
#pragma cdir shortloop
#line 3273
    for (i=0; i<ni; i++) {
#line 3273
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3273
     /* test for range errors (not always needed but do it anyway) */
#line 3273
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3273
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3273
      nrange += xp[i] > DOUBLE_MAX ;
#line 3273
    }
#line 3273
   /* update xpp and tp */
#line 3273
    if (realign) xp = (ulonglong *) *xpp;
#line 3273
    xp += ni;
#line 3273
    tp += ni;
#line 3273
    *xpp = (void*)xp;
#line 3273
  }
#line 3273
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3273

#line 3273
#else   /* not SX */
#line 3273
	const char *xp = (const char *) *xpp;
#line 3273
	int status = ENOERR;
#line 3273

#line 3273
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3273
	{
#line 3273
		const int lstatus = ncx_get_ulonglong_double(xp, tp);
#line 3273
		if(lstatus != ENOERR)
#line 3273
			status = lstatus;
#line 3273
	}
#line 3273

#line 3273
	*xpp = (const void *)xp;
#line 3273
	return status;
#line 3273
#  endif
#line 3273
}
#line 3273

int
#line 3274
ncx_getn_ulonglong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3274
{
#line 3274
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3274

#line 3274
 /* basic algorithm is:
#line 3274
  *   - ensure sane alignment of input data
#line 3274
  *   - copy (conversion happens automatically) input data
#line 3274
  *     to output
#line 3274
  *   - update xpp to point at next unconverted input, and tp to point
#line 3274
  *     at next location for converted output
#line 3274
  */
#line 3274
  long i, j, ni;
#line 3274
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3274
  ulonglong *xp;
#line 3274
  int nrange = 0;         /* number of range errors */
#line 3274
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3274
  long cxp = (long) *((char**)xpp);
#line 3274

#line 3274
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3274
  /* sjl: manually stripmine so we can limit amount of
#line 3274
   * vector work space reserved to LOOPCNT elements. Also
#line 3274
   * makes vectorisation easy */
#line 3274
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3274
    ni=Min(nelems-j,LOOPCNT);
#line 3274
    if (realign) {
#line 3274
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3274
      xp = tmp;
#line 3274
    } else {
#line 3274
      xp = (ulonglong *) *xpp;
#line 3274
    }
#line 3274
   /* copy the next block */
#line 3274
#pragma cdir loopcnt=LOOPCNT
#line 3274
#pragma cdir shortloop
#line 3274
    for (i=0; i<ni; i++) {
#line 3274
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3274
     /* test for range errors (not always needed but do it anyway) */
#line 3274
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3274
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3274
      nrange += xp[i] > LONGLONG_MAX ;
#line 3274
    }
#line 3274
   /* update xpp and tp */
#line 3274
    if (realign) xp = (ulonglong *) *xpp;
#line 3274
    xp += ni;
#line 3274
    tp += ni;
#line 3274
    *xpp = (void*)xp;
#line 3274
  }
#line 3274
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3274

#line 3274
#else   /* not SX */
#line 3274
	const char *xp = (const char *) *xpp;
#line 3274
	int status = ENOERR;
#line 3274

#line 3274
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3274
	{
#line 3274
		const int lstatus = ncx_get_ulonglong_longlong(xp, tp);
#line 3274
		if(lstatus != ENOERR)
#line 3274
			status = lstatus;
#line 3274
	}
#line 3274

#line 3274
	*xpp = (const void *)xp;
#line 3274
	return status;
#line 3274
#  endif
#line 3274
}
#line 3274

int
#line 3275
ncx_getn_ulonglong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3275
{
#line 3275
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3275

#line 3275
 /* basic algorithm is:
#line 3275
  *   - ensure sane alignment of input data
#line 3275
  *   - copy (conversion happens automatically) input data
#line 3275
  *     to output
#line 3275
  *   - update xpp to point at next unconverted input, and tp to point
#line 3275
  *     at next location for converted output
#line 3275
  */
#line 3275
  long i, j, ni;
#line 3275
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3275
  ulonglong *xp;
#line 3275
  int nrange = 0;         /* number of range errors */
#line 3275
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3275
  long cxp = (long) *((char**)xpp);
#line 3275

#line 3275
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3275
  /* sjl: manually stripmine so we can limit amount of
#line 3275
   * vector work space reserved to LOOPCNT elements. Also
#line 3275
   * makes vectorisation easy */
#line 3275
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3275
    ni=Min(nelems-j,LOOPCNT);
#line 3275
    if (realign) {
#line 3275
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3275
      xp = tmp;
#line 3275
    } else {
#line 3275
      xp = (ulonglong *) *xpp;
#line 3275
    }
#line 3275
   /* copy the next block */
#line 3275
#pragma cdir loopcnt=LOOPCNT
#line 3275
#pragma cdir shortloop
#line 3275
    for (i=0; i<ni; i++) {
#line 3275
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3275
     /* test for range errors (not always needed but do it anyway) */
#line 3275
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3275
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3275
      nrange += xp[i] > UCHAR_MAX ;
#line 3275
    }
#line 3275
   /* update xpp and tp */
#line 3275
    if (realign) xp = (ulonglong *) *xpp;
#line 3275
    xp += ni;
#line 3275
    tp += ni;
#line 3275
    *xpp = (void*)xp;
#line 3275
  }
#line 3275
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3275

#line 3275
#else   /* not SX */
#line 3275
	const char *xp = (const char *) *xpp;
#line 3275
	int status = ENOERR;
#line 3275

#line 3275
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3275
	{
#line 3275
		const int lstatus = ncx_get_ulonglong_uchar(xp, tp);
#line 3275
		if(lstatus != ENOERR)
#line 3275
			status = lstatus;
#line 3275
	}
#line 3275

#line 3275
	*xpp = (const void *)xp;
#line 3275
	return status;
#line 3275
#  endif
#line 3275
}
#line 3275

int
#line 3276
ncx_getn_ulonglong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3276
{
#line 3276
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3276

#line 3276
 /* basic algorithm is:
#line 3276
  *   - ensure sane alignment of input data
#line 3276
  *   - copy (conversion happens automatically) input data
#line 3276
  *     to output
#line 3276
  *   - update xpp to point at next unconverted input, and tp to point
#line 3276
  *     at next location for converted output
#line 3276
  */
#line 3276
  long i, j, ni;
#line 3276
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3276
  ulonglong *xp;
#line 3276
  int nrange = 0;         /* number of range errors */
#line 3276
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3276
  long cxp = (long) *((char**)xpp);
#line 3276

#line 3276
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3276
  /* sjl: manually stripmine so we can limit amount of
#line 3276
   * vector work space reserved to LOOPCNT elements. Also
#line 3276
   * makes vectorisation easy */
#line 3276
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3276
    ni=Min(nelems-j,LOOPCNT);
#line 3276
    if (realign) {
#line 3276
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3276
      xp = tmp;
#line 3276
    } else {
#line 3276
      xp = (ulonglong *) *xpp;
#line 3276
    }
#line 3276
   /* copy the next block */
#line 3276
#pragma cdir loopcnt=LOOPCNT
#line 3276
#pragma cdir shortloop
#line 3276
    for (i=0; i<ni; i++) {
#line 3276
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3276
     /* test for range errors (not always needed but do it anyway) */
#line 3276
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3276
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3276
      nrange += xp[i] > USHORT_MAX ;
#line 3276
    }
#line 3276
   /* update xpp and tp */
#line 3276
    if (realign) xp = (ulonglong *) *xpp;
#line 3276
    xp += ni;
#line 3276
    tp += ni;
#line 3276
    *xpp = (void*)xp;
#line 3276
  }
#line 3276
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3276

#line 3276
#else   /* not SX */
#line 3276
	const char *xp = (const char *) *xpp;
#line 3276
	int status = ENOERR;
#line 3276

#line 3276
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3276
	{
#line 3276
		const int lstatus = ncx_get_ulonglong_ushort(xp, tp);
#line 3276
		if(lstatus != ENOERR)
#line 3276
			status = lstatus;
#line 3276
	}
#line 3276

#line 3276
	*xpp = (const void *)xp;
#line 3276
	return status;
#line 3276
#  endif
#line 3276
}
#line 3276

int
#line 3277
ncx_getn_ulonglong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3277
{
#line 3277
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3277

#line 3277
 /* basic algorithm is:
#line 3277
  *   - ensure sane alignment of input data
#line 3277
  *   - copy (conversion happens automatically) input data
#line 3277
  *     to output
#line 3277
  *   - update xpp to point at next unconverted input, and tp to point
#line 3277
  *     at next location for converted output
#line 3277
  */
#line 3277
  long i, j, ni;
#line 3277
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3277
  ulonglong *xp;
#line 3277
  int nrange = 0;         /* number of range errors */
#line 3277
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3277
  long cxp = (long) *((char**)xpp);
#line 3277

#line 3277
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3277
  /* sjl: manually stripmine so we can limit amount of
#line 3277
   * vector work space reserved to LOOPCNT elements. Also
#line 3277
   * makes vectorisation easy */
#line 3277
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3277
    ni=Min(nelems-j,LOOPCNT);
#line 3277
    if (realign) {
#line 3277
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3277
      xp = tmp;
#line 3277
    } else {
#line 3277
      xp = (ulonglong *) *xpp;
#line 3277
    }
#line 3277
   /* copy the next block */
#line 3277
#pragma cdir loopcnt=LOOPCNT
#line 3277
#pragma cdir shortloop
#line 3277
    for (i=0; i<ni; i++) {
#line 3277
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3277
     /* test for range errors (not always needed but do it anyway) */
#line 3277
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3277
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3277
      nrange += xp[i] > UINT_MAX ;
#line 3277
    }
#line 3277
   /* update xpp and tp */
#line 3277
    if (realign) xp = (ulonglong *) *xpp;
#line 3277
    xp += ni;
#line 3277
    tp += ni;
#line 3277
    *xpp = (void*)xp;
#line 3277
  }
#line 3277
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3277

#line 3277
#else   /* not SX */
#line 3277
	const char *xp = (const char *) *xpp;
#line 3277
	int status = ENOERR;
#line 3277

#line 3277
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3277
	{
#line 3277
		const int lstatus = ncx_get_ulonglong_uint(xp, tp);
#line 3277
		if(lstatus != ENOERR)
#line 3277
			status = lstatus;
#line 3277
	}
#line 3277

#line 3277
	*xpp = (const void *)xp;
#line 3277
	return status;
#line 3277
#  endif
#line 3277
}
#line 3277


#if X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const unsigned long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_ULONGLONG);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_ULONGLONG);
	return ENOERR;
}
#else
int
#line 3293
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3293
{
#line 3293
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3293

#line 3293
 /* basic algorithm is:
#line 3293
  *   - ensure sane alignment of output data
#line 3293
  *   - copy (conversion happens automatically) input data
#line 3293
  *     to output
#line 3293
  *   - update tp to point at next unconverted input, and xpp to point
#line 3293
  *     at next location for converted output
#line 3293
  */
#line 3293
  long i, j, ni;
#line 3293
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3293
  ulonglong *xp;
#line 3293
  int nrange = 0;         /* number of range errors */
#line 3293
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3293
  long cxp = (long) *((char**)xpp);
#line 3293

#line 3293
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3293
  /* sjl: manually stripmine so we can limit amount of
#line 3293
   * vector work space reserved to LOOPCNT elements. Also
#line 3293
   * makes vectorisation easy */
#line 3293
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3293
    ni=Min(nelems-j,LOOPCNT);
#line 3293
    if (realign) {
#line 3293
      xp = tmp;
#line 3293
    } else {
#line 3293
      xp = (ulonglong *) *xpp;
#line 3293
    }
#line 3293
   /* copy the next block */
#line 3293
#pragma cdir loopcnt=LOOPCNT
#line 3293
#pragma cdir shortloop
#line 3293
    for (i=0; i<ni; i++) {
#line 3293
      /* the normal case: */
#line 3293
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3293
     /* test for range errors (not always needed but do it anyway) */
#line 3293
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3293
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3293
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3293
    }
#line 3293
   /* copy workspace back if necessary */ 
#line 3293
    if (realign) {
#line 3293
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3293
      xp = (ulonglong *) *xpp;
#line 3293
    }
#line 3293
   /* update xpp and tp */
#line 3293
    xp += ni;
#line 3293
    tp += ni;
#line 3293
    *xpp = (void*)xp;
#line 3293
  }
#line 3293
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3293

#line 3293
#else   /* not SX */
#line 3293

#line 3293
	char *xp = (char *) *xpp;
#line 3293
	int status = ENOERR;
#line 3293

#line 3293
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3293
	{
#line 3293
		int lstatus = ncx_put_ulonglong_ulonglong(xp, tp);
#line 3293
		if(lstatus != ENOERR)
#line 3293
			status = lstatus;
#line 3293
	}
#line 3293

#line 3293
	*xpp = (void *)xp;
#line 3293
	return status;
#line 3293
#endif
#line 3293
}
#line 3293

#endif
int
#line 3295
ncx_putn_ulonglong_schar(void **xpp, size_t nelems, const schar *tp)
#line 3295
{
#line 3295
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3295

#line 3295
 /* basic algorithm is:
#line 3295
  *   - ensure sane alignment of output data
#line 3295
  *   - copy (conversion happens automatically) input data
#line 3295
  *     to output
#line 3295
  *   - update tp to point at next unconverted input, and xpp to point
#line 3295
  *     at next location for converted output
#line 3295
  */
#line 3295
  long i, j, ni;
#line 3295
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3295
  ulonglong *xp;
#line 3295
  int nrange = 0;         /* number of range errors */
#line 3295
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3295
  long cxp = (long) *((char**)xpp);
#line 3295

#line 3295
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3295
  /* sjl: manually stripmine so we can limit amount of
#line 3295
   * vector work space reserved to LOOPCNT elements. Also
#line 3295
   * makes vectorisation easy */
#line 3295
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3295
    ni=Min(nelems-j,LOOPCNT);
#line 3295
    if (realign) {
#line 3295
      xp = tmp;
#line 3295
    } else {
#line 3295
      xp = (ulonglong *) *xpp;
#line 3295
    }
#line 3295
   /* copy the next block */
#line 3295
#pragma cdir loopcnt=LOOPCNT
#line 3295
#pragma cdir shortloop
#line 3295
    for (i=0; i<ni; i++) {
#line 3295
      /* the normal case: */
#line 3295
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3295
     /* test for range errors (not always needed but do it anyway) */
#line 3295
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3295
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3295
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3295
    }
#line 3295
   /* copy workspace back if necessary */ 
#line 3295
    if (realign) {
#line 3295
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3295
      xp = (ulonglong *) *xpp;
#line 3295
    }
#line 3295
   /* update xpp and tp */
#line 3295
    xp += ni;
#line 3295
    tp += ni;
#line 3295
    *xpp = (void*)xp;
#line 3295
  }
#line 3295
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3295

#line 3295
#else   /* not SX */
#line 3295

#line 3295
	char *xp = (char *) *xpp;
#line 3295
	int status = ENOERR;
#line 3295

#line 3295
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3295
	{
#line 3295
		int lstatus = ncx_put_ulonglong_schar(xp, tp);
#line 3295
		if(lstatus != ENOERR)
#line 3295
			status = lstatus;
#line 3295
	}
#line 3295

#line 3295
	*xpp = (void *)xp;
#line 3295
	return status;
#line 3295
#endif
#line 3295
}
#line 3295

int
#line 3296
ncx_putn_ulonglong_short(void **xpp, size_t nelems, const short *tp)
#line 3296
{
#line 3296
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3296

#line 3296
 /* basic algorithm is:
#line 3296
  *   - ensure sane alignment of output data
#line 3296
  *   - copy (conversion happens automatically) input data
#line 3296
  *     to output
#line 3296
  *   - update tp to point at next unconverted input, and xpp to point
#line 3296
  *     at next location for converted output
#line 3296
  */
#line 3296
  long i, j, ni;
#line 3296
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3296
  ulonglong *xp;
#line 3296
  int nrange = 0;         /* number of range errors */
#line 3296
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3296
  long cxp = (long) *((char**)xpp);
#line 3296

#line 3296
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3296
  /* sjl: manually stripmine so we can limit amount of
#line 3296
   * vector work space reserved to LOOPCNT elements. Also
#line 3296
   * makes vectorisation easy */
#line 3296
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3296
    ni=Min(nelems-j,LOOPCNT);
#line 3296
    if (realign) {
#line 3296
      xp = tmp;
#line 3296
    } else {
#line 3296
      xp = (ulonglong *) *xpp;
#line 3296
    }
#line 3296
   /* copy the next block */
#line 3296
#pragma cdir loopcnt=LOOPCNT
#line 3296
#pragma cdir shortloop
#line 3296
    for (i=0; i<ni; i++) {
#line 3296
      /* the normal case: */
#line 3296
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3296
     /* test for range errors (not always needed but do it anyway) */
#line 3296
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3296
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3296
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3296
    }
#line 3296
   /* copy workspace back if necessary */ 
#line 3296
    if (realign) {
#line 3296
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3296
      xp = (ulonglong *) *xpp;
#line 3296
    }
#line 3296
   /* update xpp and tp */
#line 3296
    xp += ni;
#line 3296
    tp += ni;
#line 3296
    *xpp = (void*)xp;
#line 3296
  }
#line 3296
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3296

#line 3296
#else   /* not SX */
#line 3296

#line 3296
	char *xp = (char *) *xpp;
#line 3296
	int status = ENOERR;
#line 3296

#line 3296
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3296
	{
#line 3296
		int lstatus = ncx_put_ulonglong_short(xp, tp);
#line 3296
		if(lstatus != ENOERR)
#line 3296
			status = lstatus;
#line 3296
	}
#line 3296

#line 3296
	*xpp = (void *)xp;
#line 3296
	return status;
#line 3296
#endif
#line 3296
}
#line 3296

int
#line 3297
ncx_putn_ulonglong_int(void **xpp, size_t nelems, const int *tp)
#line 3297
{
#line 3297
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3297

#line 3297
 /* basic algorithm is:
#line 3297
  *   - ensure sane alignment of output data
#line 3297
  *   - copy (conversion happens automatically) input data
#line 3297
  *     to output
#line 3297
  *   - update tp to point at next unconverted input, and xpp to point
#line 3297
  *     at next location for converted output
#line 3297
  */
#line 3297
  long i, j, ni;
#line 3297
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3297
  ulonglong *xp;
#line 3297
  int nrange = 0;         /* number of range errors */
#line 3297
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3297
  long cxp = (long) *((char**)xpp);
#line 3297

#line 3297
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3297
  /* sjl: manually stripmine so we can limit amount of
#line 3297
   * vector work space reserved to LOOPCNT elements. Also
#line 3297
   * makes vectorisation easy */
#line 3297
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3297
    ni=Min(nelems-j,LOOPCNT);
#line 3297
    if (realign) {
#line 3297
      xp = tmp;
#line 3297
    } else {
#line 3297
      xp = (ulonglong *) *xpp;
#line 3297
    }
#line 3297
   /* copy the next block */
#line 3297
#pragma cdir loopcnt=LOOPCNT
#line 3297
#pragma cdir shortloop
#line 3297
    for (i=0; i<ni; i++) {
#line 3297
      /* the normal case: */
#line 3297
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3297
     /* test for range errors (not always needed but do it anyway) */
#line 3297
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3297
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3297
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3297
    }
#line 3297
   /* copy workspace back if necessary */ 
#line 3297
    if (realign) {
#line 3297
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3297
      xp = (ulonglong *) *xpp;
#line 3297
    }
#line 3297
   /* update xpp and tp */
#line 3297
    xp += ni;
#line 3297
    tp += ni;
#line 3297
    *xpp = (void*)xp;
#line 3297
  }
#line 3297
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3297

#line 3297
#else   /* not SX */
#line 3297

#line 3297
	char *xp = (char *) *xpp;
#line 3297
	int status = ENOERR;
#line 3297

#line 3297
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3297
	{
#line 3297
		int lstatus = ncx_put_ulonglong_int(xp, tp);
#line 3297
		if(lstatus != ENOERR)
#line 3297
			status = lstatus;
#line 3297
	}
#line 3297

#line 3297
	*xpp = (void *)xp;
#line 3297
	return status;
#line 3297
#endif
#line 3297
}
#line 3297

int
#line 3298
ncx_putn_ulonglong_float(void **xpp, size_t nelems, const float *tp)
#line 3298
{
#line 3298
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3298

#line 3298
 /* basic algorithm is:
#line 3298
  *   - ensure sane alignment of output data
#line 3298
  *   - copy (conversion happens automatically) input data
#line 3298
  *     to output
#line 3298
  *   - update tp to point at next unconverted input, and xpp to point
#line 3298
  *     at next location for converted output
#line 3298
  */
#line 3298
  long i, j, ni;
#line 3298
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3298
  ulonglong *xp;
#line 3298
  int nrange = 0;         /* number of range errors */
#line 3298
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3298
  long cxp = (long) *((char**)xpp);
#line 3298

#line 3298
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3298
  /* sjl: manually stripmine so we can limit amount of
#line 3298
   * vector work space reserved to LOOPCNT elements. Also
#line 3298
   * makes vectorisation easy */
#line 3298
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3298
    ni=Min(nelems-j,LOOPCNT);
#line 3298
    if (realign) {
#line 3298
      xp = tmp;
#line 3298
    } else {
#line 3298
      xp = (ulonglong *) *xpp;
#line 3298
    }
#line 3298
   /* copy the next block */
#line 3298
#pragma cdir loopcnt=LOOPCNT
#line 3298
#pragma cdir shortloop
#line 3298
    for (i=0; i<ni; i++) {
#line 3298
      /* the normal case: */
#line 3298
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3298
     /* test for range errors (not always needed but do it anyway) */
#line 3298
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3298
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3298
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3298
    }
#line 3298
   /* copy workspace back if necessary */ 
#line 3298
    if (realign) {
#line 3298
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3298
      xp = (ulonglong *) *xpp;
#line 3298
    }
#line 3298
   /* update xpp and tp */
#line 3298
    xp += ni;
#line 3298
    tp += ni;
#line 3298
    *xpp = (void*)xp;
#line 3298
  }
#line 3298
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3298

#line 3298
#else   /* not SX */
#line 3298

#line 3298
	char *xp = (char *) *xpp;
#line 3298
	int status = ENOERR;
#line 3298

#line 3298
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3298
	{
#line 3298
		int lstatus = ncx_put_ulonglong_float(xp, tp);
#line 3298
		if(lstatus != ENOERR)
#line 3298
			status = lstatus;
#line 3298
	}
#line 3298

#line 3298
	*xpp = (void *)xp;
#line 3298
	return status;
#line 3298
#endif
#line 3298
}
#line 3298

int
#line 3299
ncx_putn_ulonglong_double(void **xpp, size_t nelems, const double *tp)
#line 3299
{
#line 3299
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3299

#line 3299
 /* basic algorithm is:
#line 3299
  *   - ensure sane alignment of output data
#line 3299
  *   - copy (conversion happens automatically) input data
#line 3299
  *     to output
#line 3299
  *   - update tp to point at next unconverted input, and xpp to point
#line 3299
  *     at next location for converted output
#line 3299
  */
#line 3299
  long i, j, ni;
#line 3299
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3299
  ulonglong *xp;
#line 3299
  int nrange = 0;         /* number of range errors */
#line 3299
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3299
  long cxp = (long) *((char**)xpp);
#line 3299

#line 3299
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3299
  /* sjl: manually stripmine so we can limit amount of
#line 3299
   * vector work space reserved to LOOPCNT elements. Also
#line 3299
   * makes vectorisation easy */
#line 3299
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3299
    ni=Min(nelems-j,LOOPCNT);
#line 3299
    if (realign) {
#line 3299
      xp = tmp;
#line 3299
    } else {
#line 3299
      xp = (ulonglong *) *xpp;
#line 3299
    }
#line 3299
   /* copy the next block */
#line 3299
#pragma cdir loopcnt=LOOPCNT
#line 3299
#pragma cdir shortloop
#line 3299
    for (i=0; i<ni; i++) {
#line 3299
      /* the normal case: */
#line 3299
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3299
     /* test for range errors (not always needed but do it anyway) */
#line 3299
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3299
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3299
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3299
    }
#line 3299
   /* copy workspace back if necessary */ 
#line 3299
    if (realign) {
#line 3299
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3299
      xp = (ulonglong *) *xpp;
#line 3299
    }
#line 3299
   /* update xpp and tp */
#line 3299
    xp += ni;
#line 3299
    tp += ni;
#line 3299
    *xpp = (void*)xp;
#line 3299
  }
#line 3299
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3299

#line 3299
#else   /* not SX */
#line 3299

#line 3299
	char *xp = (char *) *xpp;
#line 3299
	int status = ENOERR;
#line 3299

#line 3299
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3299
	{
#line 3299
		int lstatus = ncx_put_ulonglong_double(xp, tp);
#line 3299
		if(lstatus != ENOERR)
#line 3299
			status = lstatus;
#line 3299
	}
#line 3299

#line 3299
	*xpp = (void *)xp;
#line 3299
	return status;
#line 3299
#endif
#line 3299
}
#line 3299

int
#line 3300
ncx_putn_ulonglong_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3300
{
#line 3300
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3300

#line 3300
 /* basic algorithm is:
#line 3300
  *   - ensure sane alignment of output data
#line 3300
  *   - copy (conversion happens automatically) input data
#line 3300
  *     to output
#line 3300
  *   - update tp to point at next unconverted input, and xpp to point
#line 3300
  *     at next location for converted output
#line 3300
  */
#line 3300
  long i, j, ni;
#line 3300
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3300
  ulonglong *xp;
#line 3300
  int nrange = 0;         /* number of range errors */
#line 3300
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3300
  long cxp = (long) *((char**)xpp);
#line 3300

#line 3300
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3300
  /* sjl: manually stripmine so we can limit amount of
#line 3300
   * vector work space reserved to LOOPCNT elements. Also
#line 3300
   * makes vectorisation easy */
#line 3300
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3300
    ni=Min(nelems-j,LOOPCNT);
#line 3300
    if (realign) {
#line 3300
      xp = tmp;
#line 3300
    } else {
#line 3300
      xp = (ulonglong *) *xpp;
#line 3300
    }
#line 3300
   /* copy the next block */
#line 3300
#pragma cdir loopcnt=LOOPCNT
#line 3300
#pragma cdir shortloop
#line 3300
    for (i=0; i<ni; i++) {
#line 3300
      /* the normal case: */
#line 3300
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3300
     /* test for range errors (not always needed but do it anyway) */
#line 3300
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3300
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3300
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3300
    }
#line 3300
   /* copy workspace back if necessary */ 
#line 3300
    if (realign) {
#line 3300
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3300
      xp = (ulonglong *) *xpp;
#line 3300
    }
#line 3300
   /* update xpp and tp */
#line 3300
    xp += ni;
#line 3300
    tp += ni;
#line 3300
    *xpp = (void*)xp;
#line 3300
  }
#line 3300
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3300

#line 3300
#else   /* not SX */
#line 3300

#line 3300
	char *xp = (char *) *xpp;
#line 3300
	int status = ENOERR;
#line 3300

#line 3300
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3300
	{
#line 3300
		int lstatus = ncx_put_ulonglong_longlong(xp, tp);
#line 3300
		if(lstatus != ENOERR)
#line 3300
			status = lstatus;
#line 3300
	}
#line 3300

#line 3300
	*xpp = (void *)xp;
#line 3300
	return status;
#line 3300
#endif
#line 3300
}
#line 3300

int
#line 3301
ncx_putn_ulonglong_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3301
{
#line 3301
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3301

#line 3301
 /* basic algorithm is:
#line 3301
  *   - ensure sane alignment of output data
#line 3301
  *   - copy (conversion happens automatically) input data
#line 3301
  *     to output
#line 3301
  *   - update tp to point at next unconverted input, and xpp to point
#line 3301
  *     at next location for converted output
#line 3301
  */
#line 3301
  long i, j, ni;
#line 3301
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3301
  ulonglong *xp;
#line 3301
  int nrange = 0;         /* number of range errors */
#line 3301
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3301
  long cxp = (long) *((char**)xpp);
#line 3301

#line 3301
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3301
  /* sjl: manually stripmine so we can limit amount of
#line 3301
   * vector work space reserved to LOOPCNT elements. Also
#line 3301
   * makes vectorisation easy */
#line 3301
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3301
    ni=Min(nelems-j,LOOPCNT);
#line 3301
    if (realign) {
#line 3301
      xp = tmp;
#line 3301
    } else {
#line 3301
      xp = (ulonglong *) *xpp;
#line 3301
    }
#line 3301
   /* copy the next block */
#line 3301
#pragma cdir loopcnt=LOOPCNT
#line 3301
#pragma cdir shortloop
#line 3301
    for (i=0; i<ni; i++) {
#line 3301
      /* the normal case: */
#line 3301
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3301
     /* test for range errors (not always needed but do it anyway) */
#line 3301
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3301
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3301
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3301
    }
#line 3301
   /* copy workspace back if necessary */ 
#line 3301
    if (realign) {
#line 3301
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3301
      xp = (ulonglong *) *xpp;
#line 3301
    }
#line 3301
   /* update xpp and tp */
#line 3301
    xp += ni;
#line 3301
    tp += ni;
#line 3301
    *xpp = (void*)xp;
#line 3301
  }
#line 3301
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3301

#line 3301
#else   /* not SX */
#line 3301

#line 3301
	char *xp = (char *) *xpp;
#line 3301
	int status = ENOERR;
#line 3301

#line 3301
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3301
	{
#line 3301
		int lstatus = ncx_put_ulonglong_uchar(xp, tp);
#line 3301
		if(lstatus != ENOERR)
#line 3301
			status = lstatus;
#line 3301
	}
#line 3301

#line 3301
	*xpp = (void *)xp;
#line 3301
	return status;
#line 3301
#endif
#line 3301
}
#line 3301

int
#line 3302
ncx_putn_ulonglong_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3302
{
#line 3302
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3302

#line 3302
 /* basic algorithm is:
#line 3302
  *   - ensure sane alignment of output data
#line 3302
  *   - copy (conversion happens automatically) input data
#line 3302
  *     to output
#line 3302
  *   - update tp to point at next unconverted input, and xpp to point
#line 3302
  *     at next location for converted output
#line 3302
  */
#line 3302
  long i, j, ni;
#line 3302
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3302
  ulonglong *xp;
#line 3302
  int nrange = 0;         /* number of range errors */
#line 3302
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3302
  long cxp = (long) *((char**)xpp);
#line 3302

#line 3302
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3302
  /* sjl: manually stripmine so we can limit amount of
#line 3302
   * vector work space reserved to LOOPCNT elements. Also
#line 3302
   * makes vectorisation easy */
#line 3302
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3302
    ni=Min(nelems-j,LOOPCNT);
#line 3302
    if (realign) {
#line 3302
      xp = tmp;
#line 3302
    } else {
#line 3302
      xp = (ulonglong *) *xpp;
#line 3302
    }
#line 3302
   /* copy the next block */
#line 3302
#pragma cdir loopcnt=LOOPCNT
#line 3302
#pragma cdir shortloop
#line 3302
    for (i=0; i<ni; i++) {
#line 3302
      /* the normal case: */
#line 3302
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3302
     /* test for range errors (not always needed but do it anyway) */
#line 3302
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3302
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3302
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3302
    }
#line 3302
   /* copy workspace back if necessary */ 
#line 3302
    if (realign) {
#line 3302
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3302
      xp = (ulonglong *) *xpp;
#line 3302
    }
#line 3302
   /* update xpp and tp */
#line 3302
    xp += ni;
#line 3302
    tp += ni;
#line 3302
    *xpp = (void*)xp;
#line 3302
  }
#line 3302
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3302

#line 3302
#else   /* not SX */
#line 3302

#line 3302
	char *xp = (char *) *xpp;
#line 3302
	int status = ENOERR;
#line 3302

#line 3302
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3302
	{
#line 3302
		int lstatus = ncx_put_ulonglong_ushort(xp, tp);
#line 3302
		if(lstatus != ENOERR)
#line 3302
			status = lstatus;
#line 3302
	}
#line 3302

#line 3302
	*xpp = (void *)xp;
#line 3302
	return status;
#line 3302
#endif
#line 3302
}
#line 3302

int
#line 3303
ncx_putn_ulonglong_uint(void **xpp, size_t nelems, const uint *tp)
#line 3303
{
#line 3303
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3303

#line 3303
 /* basic algorithm is:
#line 3303
  *   - ensure sane alignment of output data
#line 3303
  *   - copy (conversion happens automatically) input data
#line 3303
  *     to output
#line 3303
  *   - update tp to point at next unconverted input, and xpp to point
#line 3303
  *     at next location for converted output
#line 3303
  */
#line 3303
  long i, j, ni;
#line 3303
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3303
  ulonglong *xp;
#line 3303
  int nrange = 0;         /* number of range errors */
#line 3303
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3303
  long cxp = (long) *((char**)xpp);
#line 3303

#line 3303
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3303
  /* sjl: manually stripmine so we can limit amount of
#line 3303
   * vector work space reserved to LOOPCNT elements. Also
#line 3303
   * makes vectorisation easy */
#line 3303
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3303
    ni=Min(nelems-j,LOOPCNT);
#line 3303
    if (realign) {
#line 3303
      xp = tmp;
#line 3303
    } else {
#line 3303
      xp = (ulonglong *) *xpp;
#line 3303
    }
#line 3303
   /* copy the next block */
#line 3303
#pragma cdir loopcnt=LOOPCNT
#line 3303
#pragma cdir shortloop
#line 3303
    for (i=0; i<ni; i++) {
#line 3303
      /* the normal case: */
#line 3303
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3303
     /* test for range errors (not always needed but do it anyway) */
#line 3303
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3303
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3303
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3303
    }
#line 3303
   /* copy workspace back if necessary */ 
#line 3303
    if (realign) {
#line 3303
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3303
      xp = (ulonglong *) *xpp;
#line 3303
    }
#line 3303
   /* update xpp and tp */
#line 3303
    xp += ni;
#line 3303
    tp += ni;
#line 3303
    *xpp = (void*)xp;
#line 3303
  }
#line 3303
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3303

#line 3303
#else   /* not SX */
#line 3303

#line 3303
	char *xp = (char *) *xpp;
#line 3303
	int status = ENOERR;
#line 3303

#line 3303
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3303
	{
#line 3303
		int lstatus = ncx_put_ulonglong_uint(xp, tp);
#line 3303
		if(lstatus != ENOERR)
#line 3303
			status = lstatus;
#line 3303
	}
#line 3303

#line 3303
	*xpp = (void *)xp;
#line 3303
	return status;
#line 3303
#endif
#line 3303
}
#line 3303



/*
 * Other aggregate conversion functions.
 */

/* text */

int
ncx_getn_text(const void **xpp, size_t nelems, char *tp)
{
	(void) memcpy(tp, *xpp, nelems);
#line 3315
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3315
	return ENOERR;
#line 3315

}

int
ncx_pad_getn_text(const void **xpp, size_t nelems, char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3321

#line 3321
	if(rndup)
#line 3321
		rndup = X_ALIGN - rndup;
#line 3321

#line 3321
	(void) memcpy(tp, *xpp, nelems);
#line 3321
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3321

#line 3321
	return ENOERR;
#line 3321

}

int
ncx_putn_text(void **xpp, size_t nelems, const char *tp)
{
	(void) memcpy(*xpp, tp, nelems);
#line 3327
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3327

#line 3327
	return ENOERR;
#line 3327

}

int
ncx_pad_putn_text(void **xpp, size_t nelems, const char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3333

#line 3333
	if(rndup)
#line 3333
		rndup = X_ALIGN - rndup;
#line 3333

#line 3333
	(void) memcpy(*xpp, tp, nelems);
#line 3333
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3333

#line 3333
	if(rndup)
#line 3333
	{
#line 3333
		(void) memcpy(*xpp, nada, rndup);
#line 3333
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3333
	}
#line 3333
	
#line 3333
	return ENOERR;
#line 3333

}


/* opaque */

int
ncx_getn_void(const void **xpp, size_t nelems, void *tp)
{
	(void) memcpy(tp, *xpp, nelems);
#line 3342
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3342
	return ENOERR;
#line 3342

}

int
ncx_pad_getn_void(const void **xpp, size_t nelems, void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3348

#line 3348
	if(rndup)
#line 3348
		rndup = X_ALIGN - rndup;
#line 3348

#line 3348
	(void) memcpy(tp, *xpp, nelems);
#line 3348
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3348

#line 3348
	return ENOERR;
#line 3348

}

int
ncx_putn_void(void **xpp, size_t nelems, const void *tp)
{
	(void) memcpy(*xpp, tp, nelems);
#line 3354
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3354

#line 3354
	return ENOERR;
#line 3354

}

int
ncx_pad_putn_void(void **xpp, size_t nelems, const void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3360

#line 3360
	if(rndup)
#line 3360
		rndup = X_ALIGN - rndup;
#line 3360

#line 3360
	(void) memcpy(*xpp, tp, nelems);
#line 3360
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3360

#line 3360
	if(rndup)
#line 3360
	{
#line 3360
		(void) memcpy(*xpp, nada, rndup);
#line 3360
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3360
	}
#line 3360
	
#line 3360
	return ENOERR;
#line 3360

}
