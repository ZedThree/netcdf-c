#line 11 "stdin"
/* Do not edit this file. It is produced from the corresponding .m4 source */
#line 13
/*
 *	Copyright 1996, University Corporation for Atmospheric Research
 *	See netcdf/COPYRIGHT file for copying and redistribution conditions.
 *
 * 	This file contains some routines derived from code
 *	which is copyrighted by Sun Microsystems, Inc.
 *	The "#ifdef vax" versions of
 *		 ncx_put_float_float()
 *		 ncx_get_float_float()
 *		 ncx_put_double_double()
 *		 ncx_get_double_double()
 *		 ncx_putn_float_float()
 *		 ncx_getn_float_float()
 *		 ncx_putn_double_double()
 *		 ncx_getn_double_double()
 * 	are derived from xdr_float() and xdr_double() routines
 *	in the freely available, copyrighted Sun RPCSRC 3.9
 *	distribution, xdr_float.c.
 * 	Our "value added" is that these are always memory to memory,
 *	they handle IEEE subnormals properly, and their "n" versions
 *	operate speedily on arrays.
 */
/* $Id: ncx.m4 2795 2014-10-27 23:12:51Z wkliao $ */

/*
 * An external data representation interface.
 */

#include "ncx.h"
#include "nc3dispatch.h"
#include <string.h>
#include <limits.h>

/* alias poorly named limits.h macros */
#define  SHORT_MAX  SHRT_MAX
#define  SHORT_MIN  SHRT_MIN
#define USHORT_MAX USHRT_MAX
#ifndef LLONG_MAX
#   define LLONG_MAX	9223372036854775807LL
#   define LLONG_MIN	(-LLONG_MAX - 1LL)
#   define ULLONG_MAX	18446744073709551615ULL
#endif
#ifndef LONG_LONG_MAX
#define LONG_LONG_MAX LLONG_MAX
#endif
#ifndef LONGLONG_MAX
#define LONGLONG_MAX LONG_LONG_MAX
#endif
#ifndef LONG_LONG_MIN
#define LONG_LONG_MIN LLONG_MIN
#endif
#ifndef LONGLONG_MIN
#define LONGLONG_MIN LONG_LONG_MIN
#endif
#ifndef ULONG_LONG_MAX
#define ULONG_LONG_MAX ULLONG_MAX
#endif
#ifndef ULONGLONG_MAX
#define ULONGLONG_MAX ULONG_LONG_MAX
#endif
#include <float.h>
#ifndef FLT_MAX /* This POSIX macro missing on some systems */
# ifndef NO_IEEE_FLOAT
# define FLT_MAX 3.40282347e+38f
# else
# error "You will need to define FLT_MAX"
# endif
#endif
/* alias poorly named float.h macros */
#define FLOAT_MAX FLT_MAX
#define FLOAT_MIN (-FLT_MAX)
#define DOUBLE_MAX DBL_MAX
#define DOUBLE_MIN (-DBL_MAX)
#define FLOAT_MAX_EXP FLT_MAX_EXP
#define DOUBLE_MAX_EXP DBL_MAX_EXP
#include <assert.h>
#define UCHAR_MIN 0
#define Min(a,b) ((a) < (b) ? (a) : (b))
#define Max(a,b) ((a) > (b) ? (a) : (b))

#ifndef SIZEOF_USHORT
#define SIZEOF_USHORT SIZEOF_UNSIGNED_SHORT_INT
#endif
#ifndef SIZEOF_UINT
#define SIZEOF_UINT SIZEOF_UNSIGNED_INT
#endif
#ifndef SIZEOF_ULONG_LONG
#define SIZEOF_ULONG_LONG SIZEOF_UNSIGNED_LONG_LONG
#endif

/*
 * If the machine's float domain is "smaller" than the external one
 * use the machine domain
 */
#if defined(FLT_MAX_EXP) && FLT_MAX_EXP < 128 /* 128 is X_FLT_MAX_EXP */
#undef X_FLOAT_MAX
# define X_FLOAT_MAX FLT_MAX
#undef X_FLOAT_MIN
# define X_FLOAT_MIN (-X_FLOAT_MAX)
#endif

#if _SX /* NEC SUPER UX */
#define LOOPCNT 256    /* must be no longer than hardware vector length */
#if _INT64
#undef  INT_MAX /* workaround cpp bug */
#define INT_MAX  X_INT_MAX
#undef  INT_MIN /* workaround cpp bug */
#define INT_MIN  X_INT_MIN
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  X_INT_MAX
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN  X_INT_MIN
#elif _LONG64
#undef  LONG_MAX /* workaround cpp bug */
#define LONG_MAX  4294967295L
#undef  LONG_MIN /* workaround cpp bug */
#define LONG_MIN -4294967295L
#endif
#if !_FLOAT0
#error "FLOAT1 and FLOAT2 not supported"
#endif
#endif /* _SX */

static const char nada[X_ALIGN] = {0, 0, 0, 0};

#ifndef WORDS_BIGENDIAN
/* LITTLE_ENDIAN: DEC and intel */
/*
 * Routines to convert to BIGENDIAN.
 * Optimize the swapn?b() and swap?b() routines aggressivly.
 */

#define SWAP2(a) ( (((a) & 0xff) << 8) | \
		(((a) >> 8) & 0xff) )

#define SWAP4(a) ( ((a) << 24) | \
		(((a) <<  8) & 0x00ff0000) | \
		(((a) >>  8) & 0x0000ff00) | \
		(((a) >> 24) & 0x000000ff) )


static void
swapn2b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *
 *	while(nn-- != 0)
 *	{
 *		*op++ = *(++ip);
 *		*op++ = *(ip++ -1);
 *	}
 */
	while(nn > 3)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
		nn -= 4;
	}
	while(nn-- != 0)
	{
		*op++ = *(++ip);
		*op++ = *(ip++ -1);
	}
}

# ifndef vax
void
swap4b(void *dst, const void *src)
{
    unsigned int *op = dst;
    const char *ip = src;
    unsigned int tempIn;
    unsigned int tempOut;

    tempIn = *(unsigned int *)(ip+0);
    tempOut =
    ( tempIn << 24) |
    ((tempIn & 0x0000ff00) << 8) |
    ((tempIn & 0x00ff0000) >> 8) |
    ( tempIn >> 24);

    *(float *)op = *(float *)(&tempOut);
}
# endif /* !vax */

static void
swapn4b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while(nn-- != 0)
 *	{
 *		op[0] = ip[3];
 *		op[1] = ip[2];
 *		op[2] = ip[1];
 *		op[3] = ip[0];
 *		op += 4;
 *		ip += 4;
 *	}
 */
	while(nn > 3)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op[8] = ip[11];
		op[9] = ip[10];
		op[10] = ip[9];
		op[11] = ip[8];
		op[12] = ip[15];
		op[13] = ip[14];
		op[14] = ip[13];
		op[15] = ip[12];
		op += 16;
		ip += 16;
		nn -= 4;
	}
	while(nn-- != 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op += 4;
		ip += 4;
	}
}

# ifndef vax
static void
swap8b(void *dst, const void *src)
{
	char *op = dst;
	const char *ip = src;
#  ifndef FLOAT_WORDS_BIGENDIAN
	op[0] = ip[7];
	op[1] = ip[6];
	op[2] = ip[5];
	op[3] = ip[4];
	op[4] = ip[3];
	op[5] = ip[2];
	op[6] = ip[1];
	op[7] = ip[0];
#  else
	op[0] = ip[3];
	op[1] = ip[2];
	op[2] = ip[1];
	op[3] = ip[0];
	op[4] = ip[7];
	op[5] = ip[6];
	op[6] = ip[5];
	op[7] = ip[4];
#  endif
}
# endif /* !vax */

# ifndef vax
static void
swapn8b(void *dst, const void *src, size_t nn)
{
	char *op = dst;
	const char *ip = src;

/* unroll the following to reduce loop overhead
 *	while(nn-- != 0)
 *	{
 *		op[0] = ip[7];
 *		op[1] = ip[6];
 *		op[2] = ip[5];
 *		op[3] = ip[4];
 *		op[4] = ip[3];
 *		op[5] = ip[2];
 *		op[6] = ip[1];
 *		op[7] = ip[0];
 *		op += 8;
 *		ip += 8;
 *	}
 */
#  ifndef FLOAT_WORDS_BIGENDIAN
	while(nn > 1)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op[8] = ip[15];
		op[9] = ip[14];
		op[10] = ip[13];
		op[11] = ip[12];
		op[12] = ip[11];
		op[13] = ip[10];
		op[14] = ip[9];
		op[15] = ip[8];
		op += 16;
		ip += 16;
		nn -= 2;
	}
	while(nn-- != 0)
	{
		op[0] = ip[7];
		op[1] = ip[6];
		op[2] = ip[5];
		op[3] = ip[4];
		op[4] = ip[3];
		op[5] = ip[2];
		op[6] = ip[1];
		op[7] = ip[0];
		op += 8;
		ip += 8;
	}
#  else
	while(nn-- != 0)
	{
		op[0] = ip[3];
		op[1] = ip[2];
		op[2] = ip[1];
		op[3] = ip[0];
		op[4] = ip[7];
		op[5] = ip[6];
		op[6] = ip[5];
		op[7] = ip[4];
		op += 8;
		ip += 8;
	}
#  endif
}
# endif /* !vax */

#endif /* LITTLE_ENDIAN */

#line 386

#line 394

#line 402

#line 409


#line 417


#line 425


#line 433


/*
 * Primitive numeric conversion functions.
 */

#line 455

#line 481

#line 497

#line 522

/* x_schar */
/* x_uchar */

/* We don't implement any x_schar and x_uchar primitives. */


/* x_short -------------------------------------------------------------------*/

#if SHORT_MAX == X_SHORT_MAX
typedef short ix_short;
#define SIZEOF_IX_SHORT SIZEOF_SHORT
#define IX_SHORT_MAX SHORT_MAX
#elif INT_MAX >= X_SHORT_MAX
typedef int ix_short;
#define SIZEOF_IX_SHORT SIZEOF_INT
#define IX_SHORT_MAX INT_MAX
#elif LONG_MAX >= X_SHORT_MAX
typedef long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG
#define IX_SHORT_MAX LONG_MAX
#elif LLONG_MAX >= X_SHORT_MAX
typedef long long ix_short;
#define SIZEOF_IX_SHORT SIZEOF_LONG_LONG
#define IX_SHORT_MAX LLONG_MAX
#else
#error "ix_short implementation"
#endif

static void
get_ix_short(const void *xp, ix_short *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = *cp++ << 8;
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if(*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= *cp;
}

static void
put_ix_short(void *xp, const ix_short *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (*ip) >> 8;
	*cp = (*ip) & 0xff;
}

static int
#line 574
ncx_get_short_schar(const void *xp, schar *ip)
#line 574
{
#line 574
	ix_short xx;
#line 574
	get_ix_short(xp, &xx);
#line 574
	*ip = (schar) xx;
#line 574
#if IX_SHORT_MAX > SCHAR_MAX
#line 574
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 574
#endif
#line 574

#line 574
	return ENOERR;
#line 574
}
#line 574

static int
#line 575
ncx_get_short_short(const void *xp, short *ip)
#line 575
{
#line 575
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 575
	get_ix_short(xp, (ix_short *)ip);
#line 575
	return ENOERR;
#line 575
#else
#line 575
	ix_short xx;
#line 575
	get_ix_short(xp, &xx);
#line 575
	*ip = (short) xx;
#line 575
#if IX_SHORT_MAX > SHORT_MAX
#line 575
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 575
#endif
#line 575

#line 575
#endif
#line 575
	return ENOERR;
#line 575
}
#line 575

static int
#line 576
ncx_get_short_int(const void *xp, int *ip)
#line 576
{
#line 576
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 576
	get_ix_short(xp, (ix_short *)ip);
#line 576
	return ENOERR;
#line 576
#else
#line 576
	ix_short xx;
#line 576
	get_ix_short(xp, &xx);
#line 576
	*ip = (int) xx;
#line 576
#if IX_SHORT_MAX > INT_MAX
#line 576
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 576
#endif
#line 576

#line 576
#endif
#line 576
	return ENOERR;
#line 576
}
#line 576

static int
#line 577
ncx_get_short_longlong(const void *xp, longlong *ip)
#line 577
{
#line 577
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 577
	get_ix_short(xp, (ix_short *)ip);
#line 577
	return ENOERR;
#line 577
#else
#line 577
	ix_short xx;
#line 577
	get_ix_short(xp, &xx);
#line 577
	*ip = (longlong) xx;
#line 577
#if IX_SHORT_MAX > LONGLONG_MAX
#line 577
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 577
#endif
#line 577

#line 577
#endif
#line 577
	return ENOERR;
#line 577
}
#line 577

static int
#line 578
ncx_get_short_ushort(const void *xp, ushort *ip)
#line 578
{
#line 578
	ix_short xx;
#line 578
	get_ix_short(xp, &xx);
#line 578
	*ip = (ushort) xx;
#line 578
#if IX_SHORT_MAX > USHORT_MAX
#line 578
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 578
#endif
#line 578
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 578
	return ENOERR;
#line 578
}
#line 578

static int
#line 579
ncx_get_short_uchar(const void *xp, uchar *ip)
#line 579
{
#line 579
	ix_short xx;
#line 579
	get_ix_short(xp, &xx);
#line 579
	*ip = (uchar) xx;
#line 579
#if IX_SHORT_MAX > UCHAR_MAX
#line 579
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 579
#endif
#line 579
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 579
	return ENOERR;
#line 579
}
#line 579

static int
#line 580
ncx_get_short_uint(const void *xp, uint *ip)
#line 580
{
#line 580
	ix_short xx;
#line 580
	get_ix_short(xp, &xx);
#line 580
	*ip = (uint) xx;
#line 580
#if IX_SHORT_MAX > UINT_MAX
#line 580
	if (xx > UINT_MAX) return NC_ERANGE;
#line 580
#endif
#line 580
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 580
	return ENOERR;
#line 580
}
#line 580

static int
#line 581
ncx_get_short_ulonglong(const void *xp, ulonglong *ip)
#line 581
{
#line 581
	ix_short xx;
#line 581
	get_ix_short(xp, &xx);
#line 581
	*ip = (ulonglong) xx;
#line 581
#if IX_SHORT_MAX > ULONGLONG_MAX
#line 581
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 581
#endif
#line 581
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 581
	return ENOERR;
#line 581
}
#line 581

static int
#line 582
ncx_get_short_float(const void *xp, float *ip)
#line 582
{
#line 582
	ix_short xx;
#line 582
	get_ix_short(xp, &xx);
#line 582
	*ip = (float) xx;
#line 582

#line 582
	return ENOERR;
#line 582
}
#line 582

static int
#line 583
ncx_get_short_double(const void *xp, double *ip)
#line 583
{
#line 583
	ix_short xx;
#line 583
	get_ix_short(xp, &xx);
#line 583
	*ip = (double) xx;
#line 583

#line 583
	return ENOERR;
#line 583
}
#line 583


static int
ncx_put_short_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
	return ENOERR;
}

static int
ncx_put_short_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return ENOERR;
}

static int
#line 606
ncx_put_short_short(void *xp, const short *ip)
#line 606
{
#line 606
#if SIZEOF_IX_SHORT == SIZEOF_SHORT && IX_SHORT_MAX == SHORT_MAX
#line 606
	put_ix_short(xp, (const ix_short *)ip);
#line 606
	return ENOERR;
#line 606
#else
#line 606
	ix_short xx = (ix_short)*ip;
#line 606
	put_ix_short(xp, &xx);
#line 606
#if IX_SHORT_MAX < SHORT_MAX
#line 606
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 606
#endif
#line 606

#line 606
#endif
#line 606
	return ENOERR;
#line 606
}
#line 606

static int
#line 607
ncx_put_short_int(void *xp, const int *ip)
#line 607
{
#line 607
#if SIZEOF_IX_SHORT == SIZEOF_INT && IX_SHORT_MAX == INT_MAX
#line 607
	put_ix_short(xp, (const ix_short *)ip);
#line 607
	return ENOERR;
#line 607
#else
#line 607
	ix_short xx = (ix_short)*ip;
#line 607
	put_ix_short(xp, &xx);
#line 607
#if IX_SHORT_MAX < INT_MAX
#line 607
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 607
#endif
#line 607

#line 607
#endif
#line 607
	return ENOERR;
#line 607
}
#line 607

static int
#line 608
ncx_put_short_longlong(void *xp, const longlong *ip)
#line 608
{
#line 608
#if SIZEOF_IX_SHORT == SIZEOF_LONGLONG && IX_SHORT_MAX == LONGLONG_MAX
#line 608
	put_ix_short(xp, (const ix_short *)ip);
#line 608
	return ENOERR;
#line 608
#else
#line 608
	ix_short xx = (ix_short)*ip;
#line 608
	put_ix_short(xp, &xx);
#line 608
#if IX_SHORT_MAX < LONGLONG_MAX
#line 608
	if (*ip > IX_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 608
#endif
#line 608

#line 608
#endif
#line 608
	return ENOERR;
#line 608
}
#line 608

static int
#line 609
ncx_put_short_ushort(void *xp, const ushort *ip)
#line 609
{
#line 609
	ix_short xx = (ix_short)*ip;
#line 609
	put_ix_short(xp, &xx);
#line 609
#if IX_SHORT_MAX < USHORT_MAX
#line 609
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 609
#endif
#line 609

#line 609
	return ENOERR;
#line 609
}
#line 609

static int
#line 610
ncx_put_short_uint(void *xp, const uint *ip)
#line 610
{
#line 610
	ix_short xx = (ix_short)*ip;
#line 610
	put_ix_short(xp, &xx);
#line 610
#if IX_SHORT_MAX < UINT_MAX
#line 610
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 610
#endif
#line 610

#line 610
	return ENOERR;
#line 610
}
#line 610

static int
#line 611
ncx_put_short_ulonglong(void *xp, const ulonglong *ip)
#line 611
{
#line 611
	ix_short xx = (ix_short)*ip;
#line 611
	put_ix_short(xp, &xx);
#line 611
#if IX_SHORT_MAX < ULONGLONG_MAX
#line 611
	if (*ip > IX_SHORT_MAX) return NC_ERANGE;
#line 611
#endif
#line 611

#line 611
	return ENOERR;
#line 611
}
#line 611

static int
#line 612
ncx_put_short_float(void *xp, const float *ip)
#line 612
{
#line 612
	ix_short xx = (ix_short)*ip;
#line 612
	put_ix_short(xp, &xx);
#line 612
	if(*ip > (double)X_SHORT_MAX || *ip < (double)X_SHORT_MIN) return NC_ERANGE;
#line 612
	return ENOERR;
#line 612
}
#line 612

static int
#line 613
ncx_put_short_double(void *xp, const double *ip)
#line 613
{
#line 613
	ix_short xx = (ix_short)*ip;
#line 613
	put_ix_short(xp, &xx);
#line 613
	if(*ip > X_SHORT_MAX || *ip < X_SHORT_MIN) return NC_ERANGE;
#line 613
	return ENOERR;
#line 613
}
#line 613


/* x_ushort ------------------------------------------------------------------*/

#if USHORT_MAX == X_USHORT_MAX
typedef unsigned short ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_USHORT
#define IX_USHORT_MAX USHORT_MAX
#elif UINT_MAX >= X_USHORT_MAX
typedef unsigned int ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_UINT
#define IX_USHORT_MAX UINT_MAX
#elif ULONG_MAX >= X_USHORT_MAX
typedef unsigned long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONG
#define IX_USHORT_MAX ULONG_MAX
#elif ULLONG_MAX >= X_USHORT_MAX
typedef unsigned long long ix_ushort;
#define SIZEOF_IX_USHORT SIZEOF_ULONG_LONG
#define IX_USHORT_MAX ULLONG_MAX
#else
#error "ix_ushort implementation"
#endif

static void
get_ix_ushort(const void *xp, ix_ushort *ip)
{
	const uchar *cp = (const uchar *) xp;
	*ip = *cp++ << 8;
#if SIZEOF_IX_SHORT > X_SIZEOF_SHORT
	if(*ip & 0x8000)
	{
		/* extern is negative */
		*ip |= (~(0xffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= *cp; 
}

static void
put_ix_ushort(void *xp, const ix_ushort *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = (*ip) >> 8;
	*cp = (*ip) & 0xff;
}

static int
#line 660
ncx_get_ushort_schar(const void *xp, schar *ip)
#line 660
{
#line 660
	ix_ushort xx;
#line 660
	get_ix_ushort(xp, &xx);
#line 660
	*ip = (schar) xx;
#line 660
#if IX_USHORT_MAX > SCHAR_MAX
#line 660
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 660
#endif
#line 660

#line 660
	return ENOERR;
#line 660
}
#line 660

static int
#line 661
ncx_get_ushort_short(const void *xp, short *ip)
#line 661
{
#line 661
	ix_ushort xx;
#line 661
	get_ix_ushort(xp, &xx);
#line 661
	*ip = (short) xx;
#line 661
#if IX_USHORT_MAX > SHORT_MAX
#line 661
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 661
#endif
#line 661

#line 661
	return ENOERR;
#line 661
}
#line 661

static int
#line 662
ncx_get_ushort_int(const void *xp, int *ip)
#line 662
{
#line 662
	ix_ushort xx;
#line 662
	get_ix_ushort(xp, &xx);
#line 662
	*ip = (int) xx;
#line 662
#if IX_USHORT_MAX > INT_MAX
#line 662
	if (xx > INT_MAX) return NC_ERANGE;
#line 662
#endif
#line 662

#line 662
	return ENOERR;
#line 662
}
#line 662

static int
#line 663
ncx_get_ushort_longlong(const void *xp, longlong *ip)
#line 663
{
#line 663
	ix_ushort xx;
#line 663
	get_ix_ushort(xp, &xx);
#line 663
	*ip = (longlong) xx;
#line 663
#if IX_USHORT_MAX > LONGLONG_MAX
#line 663
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 663
#endif
#line 663

#line 663
	return ENOERR;
#line 663
}
#line 663

static int
#line 664
ncx_get_ushort_ushort(const void *xp, ushort *ip)
#line 664
{
#line 664
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 664
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 664
	return ENOERR;
#line 664
#else
#line 664
	ix_ushort xx;
#line 664
	get_ix_ushort(xp, &xx);
#line 664
	*ip = (ushort) xx;
#line 664
#if IX_USHORT_MAX > USHORT_MAX
#line 664
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 664
#endif
#line 664

#line 664
#endif
#line 664
	return ENOERR;
#line 664
}
#line 664

static int
#line 665
ncx_get_ushort_uchar(const void *xp, uchar *ip)
#line 665
{
#line 665
#if SIZEOF_IX_USHORT == SIZEOF_UCHAR && IX_USHORT_MAX == UCHAR_MAX
#line 665
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 665
	return ENOERR;
#line 665
#else
#line 665
	ix_ushort xx;
#line 665
	get_ix_ushort(xp, &xx);
#line 665
	*ip = (uchar) xx;
#line 665
#if IX_USHORT_MAX > UCHAR_MAX
#line 665
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 665
#endif
#line 665

#line 665
#endif
#line 665
	return ENOERR;
#line 665
}
#line 665

static int
#line 666
ncx_get_ushort_uint(const void *xp, uint *ip)
#line 666
{
#line 666
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 666
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 666
	return ENOERR;
#line 666
#else
#line 666
	ix_ushort xx;
#line 666
	get_ix_ushort(xp, &xx);
#line 666
	*ip = (uint) xx;
#line 666
#if IX_USHORT_MAX > UINT_MAX
#line 666
	if (xx > UINT_MAX) return NC_ERANGE;
#line 666
#endif
#line 666

#line 666
#endif
#line 666
	return ENOERR;
#line 666
}
#line 666

static int
#line 667
ncx_get_ushort_ulonglong(const void *xp, ulonglong *ip)
#line 667
{
#line 667
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 667
	get_ix_ushort(xp, (ix_ushort *)ip);
#line 667
	return ENOERR;
#line 667
#else
#line 667
	ix_ushort xx;
#line 667
	get_ix_ushort(xp, &xx);
#line 667
	*ip = (ulonglong) xx;
#line 667
#if IX_USHORT_MAX > ULONGLONG_MAX
#line 667
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 667
#endif
#line 667

#line 667
#endif
#line 667
	return ENOERR;
#line 667
}
#line 667

static int
#line 668
ncx_get_ushort_float(const void *xp, float *ip)
#line 668
{
#line 668
	ix_ushort xx;
#line 668
	get_ix_ushort(xp, &xx);
#line 668
	*ip = (float) xx;
#line 668

#line 668
	return ENOERR;
#line 668
}
#line 668

static int
#line 669
ncx_get_ushort_double(const void *xp, double *ip)
#line 669
{
#line 669
	ix_ushort xx;
#line 669
	get_ix_ushort(xp, &xx);
#line 669
	*ip = (double) xx;
#line 669

#line 669
	return ENOERR;
#line 669
}
#line 669


static int
ncx_put_ushort_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
		*cp++ = 0xff;
	else
		*cp++ = 0;
	*cp = (uchar)*ip;
        if (*ip < 0) return NC_ERANGE;

	return ENOERR;
}

static int
ncx_put_ushort_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0;
	*cp = *ip;
	return ENOERR;
}

static int
#line 694
ncx_put_ushort_short(void *xp, const short *ip)
#line 694
{
#line 694
	ix_ushort xx = (ix_ushort)*ip;
#line 694
	put_ix_ushort(xp, &xx);
#line 694
#if IX_USHORT_MAX < SHORT_MAX
#line 694
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 694
#endif
#line 694
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 694
	return ENOERR;
#line 694
}
#line 694

static int
#line 695
ncx_put_ushort_int(void *xp, const int *ip)
#line 695
{
#line 695
	ix_ushort xx = (ix_ushort)*ip;
#line 695
	put_ix_ushort(xp, &xx);
#line 695
#if IX_USHORT_MAX < INT_MAX
#line 695
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 695
#endif
#line 695
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 695
	return ENOERR;
#line 695
}
#line 695

static int
#line 696
ncx_put_ushort_longlong(void *xp, const longlong *ip)
#line 696
{
#line 696
	ix_ushort xx = (ix_ushort)*ip;
#line 696
	put_ix_ushort(xp, &xx);
#line 696
#if IX_USHORT_MAX < LONGLONG_MAX
#line 696
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 696
#endif
#line 696
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 696
	return ENOERR;
#line 696
}
#line 696

static int
#line 697
ncx_put_ushort_ushort(void *xp, const ushort *ip)
#line 697
{
#line 697
#if SIZEOF_IX_USHORT == SIZEOF_USHORT && IX_USHORT_MAX == USHORT_MAX
#line 697
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 697
	return ENOERR;
#line 697
#else
#line 697
	ix_ushort xx = (ix_ushort)*ip;
#line 697
	put_ix_ushort(xp, &xx);
#line 697
#if IX_USHORT_MAX < USHORT_MAX
#line 697
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 697
#endif
#line 697

#line 697
#endif
#line 697
	return ENOERR;
#line 697
}
#line 697

static int
#line 698
ncx_put_ushort_uint(void *xp, const uint *ip)
#line 698
{
#line 698
#if SIZEOF_IX_USHORT == SIZEOF_UINT && IX_USHORT_MAX == UINT_MAX
#line 698
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 698
	return ENOERR;
#line 698
#else
#line 698
	ix_ushort xx = (ix_ushort)*ip;
#line 698
	put_ix_ushort(xp, &xx);
#line 698
#if IX_USHORT_MAX < UINT_MAX
#line 698
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 698
#endif
#line 698

#line 698
#endif
#line 698
	return ENOERR;
#line 698
}
#line 698

static int
#line 699
ncx_put_ushort_ulonglong(void *xp, const ulonglong *ip)
#line 699
{
#line 699
#if SIZEOF_IX_USHORT == SIZEOF_ULONGLONG && IX_USHORT_MAX == ULONGLONG_MAX
#line 699
	put_ix_ushort(xp, (const ix_ushort *)ip);
#line 699
	return ENOERR;
#line 699
#else
#line 699
	ix_ushort xx = (ix_ushort)*ip;
#line 699
	put_ix_ushort(xp, &xx);
#line 699
#if IX_USHORT_MAX < ULONGLONG_MAX
#line 699
	if (*ip > IX_USHORT_MAX) return NC_ERANGE;
#line 699
#endif
#line 699

#line 699
#endif
#line 699
	return ENOERR;
#line 699
}
#line 699

static int
#line 700
ncx_put_ushort_float(void *xp, const float *ip)
#line 700
{
#line 700
	ix_ushort xx = (ix_ushort)*ip;
#line 700
	put_ix_ushort(xp, &xx);
#line 700
	if(*ip > (double)X_USHORT_MAX || *ip < 0) return NC_ERANGE;
#line 700
	return ENOERR;
#line 700
}
#line 700

static int
#line 701
ncx_put_ushort_double(void *xp, const double *ip)
#line 701
{
#line 701
	ix_ushort xx = (ix_ushort)*ip;
#line 701
	put_ix_ushort(xp, &xx);
#line 701
	if(*ip > X_USHORT_MAX || *ip < 0) return NC_ERANGE;
#line 701
	return ENOERR;
#line 701
}
#line 701


/* x_int ---------------------------------------------------------------------*/

#if SHORT_MAX == X_INT_MAX
typedef short ix_int;
#define SIZEOF_IX_INT SIZEOF_SHORT
#define IX_INT_MAX SHORT_MAX
#elif INT_MAX  >= X_INT_MAX
typedef int ix_int;
#define SIZEOF_IX_INT SIZEOF_INT
#define IX_INT_MAX INT_MAX
#elif LONG_MAX  >= X_INT_MAX
typedef long ix_int;
#define SIZEOF_IX_INT SIZEOF_LONG
#define IX_INT_MAX LONG_MAX
#else
#error "ix_int implementation"
#endif


static void
get_ix_int(const void *xp, ix_int *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = *cp++ << 24;
#if SIZEOF_IX_INT > X_SIZEOF_INT
	if(*ip & 0x80000000)
	{
		/* extern is negative */
		*ip |= (~(0xffffffff)); /* N.B. Assumes "twos complement" */
	}
#endif
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp;
}

static void
put_ix_int(void *xp, const ix_int *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (*ip) >> 24;
	*cp++ = ((*ip) & 0x00ff0000) >> 16;
	*cp++ = ((*ip) & 0x0000ff00) >>  8;
	*cp   = ((*ip) & 0x000000ff);
}

static int
#line 751
ncx_get_int_schar(const void *xp, schar *ip)
#line 751
{
#line 751
	ix_int xx;
#line 751
	get_ix_int(xp, &xx);
#line 751
	*ip = (schar) xx;
#line 751
#if IX_INT_MAX > SCHAR_MAX
#line 751
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 751
#endif
#line 751

#line 751
	return ENOERR;
#line 751
}
#line 751

static int
#line 752
ncx_get_int_short(const void *xp, short *ip)
#line 752
{
#line 752
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 752
	get_ix_int(xp, (ix_int *)ip);
#line 752
	return ENOERR;
#line 752
#else
#line 752
	ix_int xx;
#line 752
	get_ix_int(xp, &xx);
#line 752
	*ip = (short) xx;
#line 752
#if IX_INT_MAX > SHORT_MAX
#line 752
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 752
#endif
#line 752

#line 752
#endif
#line 752
	return ENOERR;
#line 752
}
#line 752

       int
#line 753
ncx_get_int_int(const void *xp, int *ip)
#line 753
{
#line 753
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 753
	get_ix_int(xp, (ix_int *)ip);
#line 753
	return ENOERR;
#line 753
#else
#line 753
	ix_int xx;
#line 753
	get_ix_int(xp, &xx);
#line 753
	*ip = (int) xx;
#line 753
#if IX_INT_MAX > INT_MAX
#line 753
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 753
#endif
#line 753

#line 753
#endif
#line 753
	return ENOERR;
#line 753
}
#line 753

static int
#line 754
ncx_get_int_longlong(const void *xp, longlong *ip)
#line 754
{
#line 754
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 754
	get_ix_int(xp, (ix_int *)ip);
#line 754
	return ENOERR;
#line 754
#else
#line 754
	ix_int xx;
#line 754
	get_ix_int(xp, &xx);
#line 754
	*ip = (longlong) xx;
#line 754
#if IX_INT_MAX > LONGLONG_MAX
#line 754
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 754
#endif
#line 754

#line 754
#endif
#line 754
	return ENOERR;
#line 754
}
#line 754

static int
#line 755
ncx_get_int_ushort(const void *xp, ushort *ip)
#line 755
{
#line 755
	ix_int xx;
#line 755
	get_ix_int(xp, &xx);
#line 755
	*ip = (ushort) xx;
#line 755
#if IX_INT_MAX > USHORT_MAX
#line 755
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 755
#endif
#line 755
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 755
	return ENOERR;
#line 755
}
#line 755

static int
#line 756
ncx_get_int_uchar(const void *xp, uchar *ip)
#line 756
{
#line 756
	ix_int xx;
#line 756
	get_ix_int(xp, &xx);
#line 756
	*ip = (uchar) xx;
#line 756
#if IX_INT_MAX > UCHAR_MAX
#line 756
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 756
#endif
#line 756
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 756
	return ENOERR;
#line 756
}
#line 756

static int
#line 757
ncx_get_int_uint(const void *xp, uint *ip)
#line 757
{
#line 757
	ix_int xx;
#line 757
	get_ix_int(xp, &xx);
#line 757
	*ip = (uint) xx;
#line 757
#if IX_INT_MAX > UINT_MAX
#line 757
	if (xx > UINT_MAX) return NC_ERANGE;
#line 757
#endif
#line 757
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 757
	return ENOERR;
#line 757
}
#line 757

static int
#line 758
ncx_get_int_ulonglong(const void *xp, ulonglong *ip)
#line 758
{
#line 758
	ix_int xx;
#line 758
	get_ix_int(xp, &xx);
#line 758
	*ip = (ulonglong) xx;
#line 758
#if IX_INT_MAX > ULONGLONG_MAX
#line 758
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 758
#endif
#line 758
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 758
	return ENOERR;
#line 758
}
#line 758

static int
#line 759
ncx_get_int_float(const void *xp, float *ip)
#line 759
{
#line 759
	ix_int xx;
#line 759
	get_ix_int(xp, &xx);
#line 759
	*ip = (float) xx;
#line 759

#line 759
	return ENOERR;
#line 759
}
#line 759

static int
#line 760
ncx_get_int_double(const void *xp, double *ip)
#line 760
{
#line 760
	ix_int xx;
#line 760
	get_ix_int(xp, &xx);
#line 760
	*ip = (double) xx;
#line 760

#line 760
	return ENOERR;
#line 760
}
#line 760


static int
ncx_put_int_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	if(*ip & 0x80)
	{
		*cp++ = 0xff;
		*cp++ = 0xff;
		*cp++ = 0xff;
	}
	else
	{
		*cp++ = 0x00;
		*cp++ = 0x00;
		*cp++ = 0x00;
	}
	*cp = (uchar)*ip;
	return ENOERR;
}

static int
ncx_put_int_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return ENOERR;
}

static int
#line 793
ncx_put_int_short(void *xp, const short *ip)
#line 793
{
#line 793
#if SIZEOF_IX_INT == SIZEOF_SHORT && IX_INT_MAX == SHORT_MAX
#line 793
	put_ix_int(xp, (const ix_int *)ip);
#line 793
	return ENOERR;
#line 793
#else
#line 793
	ix_int xx = (ix_int)*ip;
#line 793
	put_ix_int(xp, &xx);
#line 793
#if IX_INT_MAX < SHORT_MAX
#line 793
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 793
#endif
#line 793

#line 793
#endif
#line 793
	return ENOERR;
#line 793
}
#line 793

       int
#line 794
ncx_put_int_int(void *xp, const int *ip)
#line 794
{
#line 794
#if SIZEOF_IX_INT == SIZEOF_INT && IX_INT_MAX == INT_MAX
#line 794
	put_ix_int(xp, (const ix_int *)ip);
#line 794
	return ENOERR;
#line 794
#else
#line 794
	ix_int xx = (ix_int)*ip;
#line 794
	put_ix_int(xp, &xx);
#line 794
#if IX_INT_MAX < INT_MAX
#line 794
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 794
#endif
#line 794

#line 794
#endif
#line 794
	return ENOERR;
#line 794
}
#line 794

static int
#line 795
ncx_put_int_longlong(void *xp, const longlong *ip)
#line 795
{
#line 795
#if SIZEOF_IX_INT == SIZEOF_LONGLONG && IX_INT_MAX == LONGLONG_MAX
#line 795
	put_ix_int(xp, (const ix_int *)ip);
#line 795
	return ENOERR;
#line 795
#else
#line 795
	ix_int xx = (ix_int)*ip;
#line 795
	put_ix_int(xp, &xx);
#line 795
#if IX_INT_MAX < LONGLONG_MAX
#line 795
	if (*ip > IX_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 795
#endif
#line 795

#line 795
#endif
#line 795
	return ENOERR;
#line 795
}
#line 795

static int
#line 796
ncx_put_int_ushort(void *xp, const ushort *ip)
#line 796
{
#line 796
	ix_int xx = (ix_int)*ip;
#line 796
	put_ix_int(xp, &xx);
#line 796
#if IX_INT_MAX < USHORT_MAX
#line 796
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 796
#endif
#line 796

#line 796
	return ENOERR;
#line 796
}
#line 796

static int
#line 797
ncx_put_int_uint(void *xp, const uint *ip)
#line 797
{
#line 797
	ix_int xx = (ix_int)*ip;
#line 797
	put_ix_int(xp, &xx);
#line 797
#if IX_INT_MAX < UINT_MAX
#line 797
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 797
#endif
#line 797

#line 797
	return ENOERR;
#line 797
}
#line 797

static int
#line 798
ncx_put_int_ulonglong(void *xp, const ulonglong *ip)
#line 798
{
#line 798
	ix_int xx = (ix_int)*ip;
#line 798
	put_ix_int(xp, &xx);
#line 798
#if IX_INT_MAX < ULONGLONG_MAX
#line 798
	if (*ip > IX_INT_MAX) return NC_ERANGE;
#line 798
#endif
#line 798

#line 798
	return ENOERR;
#line 798
}
#line 798

static int
#line 799
ncx_put_int_float(void *xp, const float *ip)
#line 799
{
#line 799
	ix_int xx = (ix_int)*ip;
#line 799
	put_ix_int(xp, &xx);
#line 799
	if(*ip > (double)X_INT_MAX || *ip < (double)X_INT_MIN) return NC_ERANGE;
#line 799
	return ENOERR;
#line 799
}
#line 799

static int
#line 800
ncx_put_int_double(void *xp, const double *ip)
#line 800
{
#line 800
	ix_int xx = (ix_int)*ip;
#line 800
	put_ix_int(xp, &xx);
#line 800
	if(*ip > X_INT_MAX || *ip < X_INT_MIN) return NC_ERANGE;
#line 800
	return ENOERR;
#line 800
}
#line 800



/* x_uint --------------------------------------------------------------------*/

#if USHORT_MAX == X_UINT_MAX
typedef ushort ix_uint;
#define SIZEOF_IX_UINT SIZEOF_USHORT
#define IX_UINT_MAX USHORT_MAX
#elif UINT_MAX  >= X_UINT_MAX
typedef uint ix_uint;
#define SIZEOF_IX_UINT SIZEOF_UINT
#define IX_UINT_MAX UINT_MAX
#elif ULONG_MAX  >= X_UINT_MAX
typedef ulong ix_uint;
#define SIZEOF_IX_UINT SIZEOF_ULONG
#define IX_UINT_MAX ULONG_MAX
#else
#error "ix_uint implementation"
#endif


static void
get_ix_uint(const void *xp, ix_uint *ip)
{
	const uchar *cp = (const uchar *) xp;

	*ip = *cp++ << 24;
	*ip |= (*cp++ << 16);
	*ip |= (*cp++ << 8);
	*ip |= *cp; 
}

static void
put_ix_uint(void *xp, const ix_uint *ip)
{
	uchar *cp = (uchar *) xp;

	*cp++ = (*ip) >> 24;
	*cp++ = ((*ip) & 0x00ff0000) >> 16;
	*cp++ = ((*ip) & 0x0000ff00) >>  8;
	*cp   = ((*ip) & 0x000000ff);
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 845
ncx_get_uint_uint(const void *xp, uint *ip)
#line 845
{
#line 845
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 845
	get_ix_uint(xp, (ix_uint *)ip);
#line 845
	return ENOERR;
#line 845
#else
#line 845
	ix_uint xx;
#line 845
	get_ix_uint(xp, &xx);
#line 845
	*ip = (uint) xx;
#line 845
#if IX_UINT_MAX > UINT_MAX
#line 845
	if (xx > UINT_MAX) return NC_ERANGE;
#line 845
#endif
#line 845

#line 845
#endif
#line 845
	return ENOERR;
#line 845
}
#line 845

#endif

static int
#line 848
ncx_get_uint_schar(const void *xp, schar *ip)
#line 848
{
#line 848
	ix_uint xx;
#line 848
	get_ix_uint(xp, &xx);
#line 848
	*ip = (schar) xx;
#line 848
#if IX_UINT_MAX > SCHAR_MAX
#line 848
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 848
#endif
#line 848

#line 848
	return ENOERR;
#line 848
}
#line 848

static int
#line 849
ncx_get_uint_short(const void *xp, short *ip)
#line 849
{
#line 849
	ix_uint xx;
#line 849
	get_ix_uint(xp, &xx);
#line 849
	*ip = (short) xx;
#line 849
#if IX_UINT_MAX > SHORT_MAX
#line 849
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 849
#endif
#line 849

#line 849
	return ENOERR;
#line 849
}
#line 849

static int
#line 850
ncx_get_uint_int(const void *xp, int *ip)
#line 850
{
#line 850
	ix_uint xx;
#line 850
	get_ix_uint(xp, &xx);
#line 850
	*ip = (int) xx;
#line 850
#if IX_UINT_MAX > INT_MAX
#line 850
	if (xx > INT_MAX) return NC_ERANGE;
#line 850
#endif
#line 850

#line 850
	return ENOERR;
#line 850
}
#line 850

static int
#line 851
ncx_get_uint_longlong(const void *xp, longlong *ip)
#line 851
{
#line 851
	ix_uint xx;
#line 851
	get_ix_uint(xp, &xx);
#line 851
	*ip = (longlong) xx;
#line 851
#if IX_UINT_MAX > LONGLONG_MAX
#line 851
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 851
#endif
#line 851

#line 851
	return ENOERR;
#line 851
}
#line 851

static int
#line 852
ncx_get_uint_ushort(const void *xp, ushort *ip)
#line 852
{
#line 852
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 852
	get_ix_uint(xp, (ix_uint *)ip);
#line 852
	return ENOERR;
#line 852
#else
#line 852
	ix_uint xx;
#line 852
	get_ix_uint(xp, &xx);
#line 852
	*ip = (ushort) xx;
#line 852
#if IX_UINT_MAX > USHORT_MAX
#line 852
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 852
#endif
#line 852

#line 852
#endif
#line 852
	return ENOERR;
#line 852
}
#line 852

static int
#line 853
ncx_get_uint_uchar(const void *xp, uchar *ip)
#line 853
{
#line 853
#if SIZEOF_IX_UINT == SIZEOF_UCHAR && IX_UINT_MAX == UCHAR_MAX
#line 853
	get_ix_uint(xp, (ix_uint *)ip);
#line 853
	return ENOERR;
#line 853
#else
#line 853
	ix_uint xx;
#line 853
	get_ix_uint(xp, &xx);
#line 853
	*ip = (uchar) xx;
#line 853
#if IX_UINT_MAX > UCHAR_MAX
#line 853
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 853
#endif
#line 853

#line 853
#endif
#line 853
	return ENOERR;
#line 853
}
#line 853

static int
#line 854
ncx_get_uint_ulonglong(const void *xp, ulonglong *ip)
#line 854
{
#line 854
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 854
	get_ix_uint(xp, (ix_uint *)ip);
#line 854
	return ENOERR;
#line 854
#else
#line 854
	ix_uint xx;
#line 854
	get_ix_uint(xp, &xx);
#line 854
	*ip = (ulonglong) xx;
#line 854
#if IX_UINT_MAX > ULONGLONG_MAX
#line 854
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 854
#endif
#line 854

#line 854
#endif
#line 854
	return ENOERR;
#line 854
}
#line 854

static int
#line 855
ncx_get_uint_float(const void *xp, float *ip)
#line 855
{
#line 855
	ix_uint xx;
#line 855
	get_ix_uint(xp, &xx);
#line 855
	*ip = (float) xx;
#line 855

#line 855
	return ENOERR;
#line 855
}
#line 855

static int
#line 856
ncx_get_uint_double(const void *xp, double *ip)
#line 856
{
#line 856
	ix_uint xx;
#line 856
	get_ix_uint(xp, &xx);
#line 856
	*ip = (double) xx;
#line 856

#line 856
	return ENOERR;
#line 856
}
#line 856


static int
ncx_put_uint_schar(void *xp, const schar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp = (uchar)*ip;

	if (*ip < 0) return NC_ERANGE;

	return ENOERR;
}

static int
ncx_put_uint_uchar(void *xp, const uchar *ip)
{
	uchar *cp = (uchar *) xp;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp++ = 0x00;
	*cp   = *ip;
	return ENOERR;
}

#if X_SIZEOF_UINT != SIZEOF_UINT
static int
#line 884
ncx_put_uint_uint(void *xp, const uint *ip)
#line 884
{
#line 884
#if SIZEOF_IX_UINT == SIZEOF_UINT && IX_UINT_MAX == UINT_MAX
#line 884
	put_ix_uint(xp, (const ix_uint *)ip);
#line 884
	return ENOERR;
#line 884
#else
#line 884
	ix_uint xx = (ix_uint)*ip;
#line 884
	put_ix_uint(xp, &xx);
#line 884
#if IX_UINT_MAX < UINT_MAX
#line 884
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 884
#endif
#line 884

#line 884
#endif
#line 884
	return ENOERR;
#line 884
}
#line 884

#endif
static int
#line 886
ncx_put_uint_short(void *xp, const short *ip)
#line 886
{
#line 886
	ix_uint xx = (ix_uint)*ip;
#line 886
	put_ix_uint(xp, &xx);
#line 886
#if IX_UINT_MAX < SHORT_MAX
#line 886
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 886
#endif
#line 886
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 886
	return ENOERR;
#line 886
}
#line 886

static int
#line 887
ncx_put_uint_int(void *xp, const int *ip)
#line 887
{
#line 887
	ix_uint xx = (ix_uint)*ip;
#line 887
	put_ix_uint(xp, &xx);
#line 887
#if IX_UINT_MAX < INT_MAX
#line 887
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 887
#endif
#line 887
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 887
	return ENOERR;
#line 887
}
#line 887

static int
#line 888
ncx_put_uint_longlong(void *xp, const longlong *ip)
#line 888
{
#line 888
	ix_uint xx = (ix_uint)*ip;
#line 888
	put_ix_uint(xp, &xx);
#line 888
#if IX_UINT_MAX < LONGLONG_MAX
#line 888
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 888
#endif
#line 888
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 888
	return ENOERR;
#line 888
}
#line 888

static int
#line 889
ncx_put_uint_ushort(void *xp, const ushort *ip)
#line 889
{
#line 889
#if SIZEOF_IX_UINT == SIZEOF_USHORT && IX_UINT_MAX == USHORT_MAX
#line 889
	put_ix_uint(xp, (const ix_uint *)ip);
#line 889
	return ENOERR;
#line 889
#else
#line 889
	ix_uint xx = (ix_uint)*ip;
#line 889
	put_ix_uint(xp, &xx);
#line 889
#if IX_UINT_MAX < USHORT_MAX
#line 889
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 889
#endif
#line 889

#line 889
#endif
#line 889
	return ENOERR;
#line 889
}
#line 889

static int
#line 890
ncx_put_uint_ulonglong(void *xp, const ulonglong *ip)
#line 890
{
#line 890
#if SIZEOF_IX_UINT == SIZEOF_ULONGLONG && IX_UINT_MAX == ULONGLONG_MAX
#line 890
	put_ix_uint(xp, (const ix_uint *)ip);
#line 890
	return ENOERR;
#line 890
#else
#line 890
	ix_uint xx = (ix_uint)*ip;
#line 890
	put_ix_uint(xp, &xx);
#line 890
#if IX_UINT_MAX < ULONGLONG_MAX
#line 890
	if (*ip > IX_UINT_MAX) return NC_ERANGE;
#line 890
#endif
#line 890

#line 890
#endif
#line 890
	return ENOERR;
#line 890
}
#line 890

static int
#line 891
ncx_put_uint_float(void *xp, const float *ip)
#line 891
{
#line 891
	ix_uint xx = (ix_uint)*ip;
#line 891
	put_ix_uint(xp, &xx);
#line 891
	if(*ip > (double)X_UINT_MAX || *ip < 0) return NC_ERANGE;
#line 891
	return ENOERR;
#line 891
}
#line 891

static int
#line 892
ncx_put_uint_double(void *xp, const double *ip)
#line 892
{
#line 892
	ix_uint xx = (ix_uint)*ip;
#line 892
	put_ix_uint(xp, &xx);
#line 892
	if(*ip > X_UINT_MAX || *ip < 0) return NC_ERANGE;
#line 892
	return ENOERR;
#line 892
}
#line 892

 

/* x_float -------------------------------------------------------------------*/

#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)

static void
get_ix_float(const void *xp, float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, sizeof(float));
#else
	swap4b(ip, xp);
#endif
}

static void
put_ix_float(void *xp, const float *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_FLOAT);
#else
	swap4b(xp, ip);
#endif
}

#elif vax

/* What IEEE single precision floating point looks like on a Vax */
struct	ieee_single {
	unsigned int	exp_hi       : 7;
	unsigned int	sign         : 1;
	unsigned int 	mant_hi      : 7;
	unsigned int	exp_lo       : 1;
	unsigned int	mant_lo_hi   : 8;
	unsigned int	mant_lo_lo   : 8;
};

/* Vax single precision floating point */
struct	vax_single {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
};

#define VAX_SNG_BIAS	0x81
#define IEEE_SNG_BIAS	0x7f

static struct sgl_limits {
	struct vax_single s;
	struct ieee_single ieee;
} max = {
	{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0x1, 0x0, 0x0 }		/* Max IEEE */
};
static struct sgl_limits min = {
	{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }		/* Min IEEE */
};

#line 1006
static void
get_ix_float(const void *xp, float *ip)
{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 1009
		const struct ieee_single *const isp =
#line 1009
			 (const struct ieee_single *) xp;
#line 1009
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 1009

#line 1009
		switch(exp) {
#line 1009
		case 0 :
#line 1009
			/* ieee subnormal */
#line 1009
			if(isp->mant_hi == min.ieee.mant_hi
#line 1009
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 1009
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 1009
			{
#line 1009
				*vsp = min.s;
#line 1009
			}
#line 1009
			else
#line 1009
			{
#line 1009
				unsigned mantissa = (isp->mant_hi << 16)
#line 1009
					 | isp->mant_lo_hi << 8
#line 1009
					 | isp->mant_lo_lo;
#line 1009
				unsigned tmp = mantissa >> 20;
#line 1009
				if(tmp >= 4) {
#line 1009
					vsp->exp = 2;
#line 1009
				} else if (tmp >= 2) {
#line 1009
					vsp->exp = 1;
#line 1009
				} else {
#line 1009
					*vsp = min.s;
#line 1009
					break;
#line 1009
				} /* else */
#line 1009
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 1009
				tmp <<= 3 - vsp->exp;
#line 1009
				vsp->mantissa2 = tmp;
#line 1009
				vsp->mantissa1 = (tmp >> 16);
#line 1009
			}
#line 1009
			break;
#line 1009
		case 0xfe :
#line 1009
		case 0xff :
#line 1009
			*vsp = max.s;
#line 1009
			break;
#line 1009
		default :
#line 1009
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 1009
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 1009
			vsp->mantissa1 = isp->mant_hi;
#line 1009
		}
#line 1009

#line 1009
		vsp->sign = isp->sign;
#line 1009

}

#line 1063

static void
put_ix_float(void *xp, const float *ip)
{
		const struct vax_single *const vsp =
#line 1067
			 (const struct vax_single *)ip;
#line 1067
		struct ieee_single *const isp = (struct ieee_single *) xp;
#line 1067

#line 1067
		switch(vsp->exp){
#line 1067
		case 0 :
#line 1067
			/* all vax float with zero exponent map to zero */
#line 1067
			*isp = min.ieee;
#line 1067
			break;
#line 1067
		case 2 :
#line 1067
		case 1 :
#line 1067
		{
#line 1067
			/* These will map to subnormals */
#line 1067
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 1067
					 | vsp->mantissa2;
#line 1067
			mantissa >>= 3 - vsp->exp;
#line 1067
			mantissa += (1 << (20 + vsp->exp));
#line 1067
			isp->mant_lo_lo = mantissa;
#line 1067
			isp->mant_lo_hi = mantissa >> 8;
#line 1067
			isp->mant_hi = mantissa >> 16;
#line 1067
			isp->exp_lo = 0;
#line 1067
			isp->exp_hi = 0;
#line 1067
		}
#line 1067
			break;
#line 1067
		case 0xff : /* max.s.exp */
#line 1067
			if( vsp->mantissa2 == max.s.mantissa2
#line 1067
				&& vsp->mantissa1 == max.s.mantissa1)
#line 1067
			{
#line 1067
				/* map largest vax float to ieee infinity */
#line 1067
				*isp = max.ieee;
#line 1067
				break;
#line 1067
			} /* else, fall thru */
#line 1067
		default :
#line 1067
		{
#line 1067
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 1067
			isp->exp_hi = exp >> 1;
#line 1067
			isp->exp_lo = exp;
#line 1067
			isp->mant_lo_lo = vsp->mantissa2;
#line 1067
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 1067
			isp->mant_hi = vsp->mantissa1;
#line 1067
		}
#line 1067
		}
#line 1067

#line 1067
		isp->sign = vsp->sign;
#line 1067

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

/*
 * Return the number of bytes until the next "word" boundary
 * N.B. This is based on the very wierd YMP address structure,
 * which puts the address within a word in the leftmost 3 bits
 * of the address.
 */
static size_t
word_align(const void *vp)
{
	const size_t rem = ((size_t)vp >> (64 - 3)) & 0x7;
	return (rem != 0);
}

struct ieee_single_hi {
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
	unsigned int	pad	:32;
};
typedef struct ieee_single_hi ieee_single_hi;

struct ieee_single_lo {
	unsigned int	pad	:32;
	unsigned int	sign	: 1;
	unsigned int	 exp	: 8;
	unsigned int	mant	:23;
};
typedef struct ieee_single_lo ieee_single_lo;

static const int ieee_single_bias = 0x7f;

struct ieee_double {
	unsigned int	sign	: 1;
	unsigned int	 exp	:11;
	unsigned int	mant	:52;
};
typedef struct ieee_double ieee_double;

static const int ieee_double_bias = 0x3ff;

#if defined(NO_IEEE_FLOAT)

struct cray_single {
	unsigned int	sign	: 1;
	unsigned int	 exp	:15;
	unsigned int	mant	:48;
};
typedef struct cray_single cray_single;

static const int cs_ieis_bias = 0x4000 - 0x7f;

static const int cs_id_bias = 0x4000 - 0x3ff;

#line 1202

static void
get_ix_float(const void *xp, float *ip)
{

	if(word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1210

#line 1210
		if(isp->exp == 0)
#line 1210
		{
#line 1210
			/* ieee subnormal */
#line 1210
			*ip = (double)isp->mant;
#line 1210
			if(isp->mant != 0)
#line 1210
			{
#line 1210
				csp->exp -= (ieee_single_bias + 22);
#line 1210
			}
#line 1210
		}
#line 1210
		else
#line 1210
		{
#line 1210
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1210
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1210
			csp->mant |= (1 << (48 - 1));
#line 1210
		}
#line 1210
		csp->sign = isp->sign;
#line 1210

#line 1210

	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		cray_single *csp = (cray_single *) ip;
#line 1215

#line 1215
		if(isp->exp == 0)
#line 1215
		{
#line 1215
			/* ieee subnormal */
#line 1215
			*ip = (double)isp->mant;
#line 1215
			if(isp->mant != 0)
#line 1215
			{
#line 1215
				csp->exp -= (ieee_single_bias + 22);
#line 1215
			}
#line 1215
		}
#line 1215
		else
#line 1215
		{
#line 1215
			csp->exp  = isp->exp + cs_ieis_bias + 1;
#line 1215
			csp->mant = isp->mant << (48 - 1 - 23);
#line 1215
			csp->mant |= (1 << (48 - 1));
#line 1215
		}
#line 1215
		csp->sign = isp->sign;
#line 1215

#line 1215

	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	if(word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1225
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1225

#line 1225
	isp->sign = csp->sign;
#line 1225

#line 1225
	if(ieee_exp >= 0xff)
#line 1225
	{
#line 1225
		/* NC_ERANGE => ieee Inf */
#line 1225
		isp->exp = 0xff;
#line 1225
		isp->mant = 0x0;
#line 1225
	}
#line 1225
	else if(ieee_exp > 0)
#line 1225
	{
#line 1225
		/* normal ieee representation */
#line 1225
		isp->exp  = ieee_exp;
#line 1225
		/* assumes cray rep is in normal form */
#line 1225
		assert(csp->mant & 0x800000000000);
#line 1225
		isp->mant = (((csp->mant << 1) &
#line 1225
				0xffffffffffff) >> (48 - 23));
#line 1225
	}
#line 1225
	else if(ieee_exp > -23)
#line 1225
	{
#line 1225
		/* ieee subnormal, right shift */
#line 1225
		const int rshift = (48 - 23 - ieee_exp);
#line 1225

#line 1225
		isp->mant = csp->mant >> rshift;
#line 1225

#line 1225
#if 0
#line 1225
		if(csp->mant & (1 << (rshift -1)))
#line 1225
		{
#line 1225
			/* round up */
#line 1225
			isp->mant++;
#line 1225
		}
#line 1225
#endif
#line 1225

#line 1225
		isp->exp  = 0;
#line 1225
	}
#line 1225
	else
#line 1225
	{
#line 1225
		/* smaller than ieee can represent */
#line 1225
		isp->exp = 0;
#line 1225
		isp->mant = 0;
#line 1225
	}
#line 1225

	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
	const cray_single *csp = (const cray_single *) ip;
#line 1230
	int ieee_exp = csp->exp - cs_ieis_bias -1;
#line 1230

#line 1230
	isp->sign = csp->sign;
#line 1230

#line 1230
	if(ieee_exp >= 0xff)
#line 1230
	{
#line 1230
		/* NC_ERANGE => ieee Inf */
#line 1230
		isp->exp = 0xff;
#line 1230
		isp->mant = 0x0;
#line 1230
	}
#line 1230
	else if(ieee_exp > 0)
#line 1230
	{
#line 1230
		/* normal ieee representation */
#line 1230
		isp->exp  = ieee_exp;
#line 1230
		/* assumes cray rep is in normal form */
#line 1230
		assert(csp->mant & 0x800000000000);
#line 1230
		isp->mant = (((csp->mant << 1) &
#line 1230
				0xffffffffffff) >> (48 - 23));
#line 1230
	}
#line 1230
	else if(ieee_exp > -23)
#line 1230
	{
#line 1230
		/* ieee subnormal, right shift */
#line 1230
		const int rshift = (48 - 23 - ieee_exp);
#line 1230

#line 1230
		isp->mant = csp->mant >> rshift;
#line 1230

#line 1230
#if 0
#line 1230
		if(csp->mant & (1 << (rshift -1)))
#line 1230
		{
#line 1230
			/* round up */
#line 1230
			isp->mant++;
#line 1230
		}
#line 1230
#endif
#line 1230

#line 1230
		isp->exp  = 0;
#line 1230
	}
#line 1230
	else
#line 1230
	{
#line 1230
		/* smaller than ieee can represent */
#line 1230
		isp->exp = 0;
#line 1230
		isp->mant = 0;
#line 1230
	}
#line 1230

	}
}

#else
	/* IEEE Cray with only doubles */
static void
get_ix_float(const void *xp, float *ip)
{

	ieee_double *idp = (ieee_double *) ip;

	if(word_align(xp) == 0)
	{
		const ieee_single_hi *isp = (const ieee_single_hi *) xp;
		if(isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
	else
	{
		const ieee_single_lo *isp = (const ieee_single_lo *) xp;
		if(isp->exp == 0 && isp->mant == 0)
		{
			idp->exp = 0;
			idp->mant = 0;
		}
		else
		{
			idp->exp = isp->exp + (ieee_double_bias - ieee_single_bias);
			idp->mant = isp->mant << (52 - 23);
		}
		idp->sign = isp->sign;
	}
}

static void
put_ix_float(void *xp, const float *ip)
{
	const ieee_double *idp = (const ieee_double *) ip;
	if(word_align(xp) == 0)
	{
		ieee_single_hi *isp = (ieee_single_hi*)xp;
		if(idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
	else
	{
		ieee_single_lo *isp = (ieee_single_lo*)xp;
		if(idp->exp > (ieee_double_bias - ieee_single_bias))
			isp->exp = idp->exp - (ieee_double_bias - ieee_single_bias);
		else
			isp->exp = 0;
		isp->mant = idp->mant >> (52 - 23);
		isp->sign = idp->sign;
	}
}
#endif

#else
#error "ix_float implementation"
#endif

#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_get_float_float(const void *xp, float *ip)
{
	/* TODO */
	get_ix_float(xp, ip);
	return ENOERR;
}
#endif

#define ix_float float

static int
#line 1317
ncx_get_float_schar(const void *xp, schar *ip)
#line 1317
{
#line 1317
	ix_float xx;
#line 1317
	get_ix_float(xp, &xx);
#line 1317
	*ip = (schar) xx;
#line 1317
	if(xx > (double)SCHAR_MAX || xx < (double)SCHAR_MIN) return NC_ERANGE;
#line 1317
	return ENOERR;
#line 1317
}
#line 1317

static int
#line 1318
ncx_get_float_short(const void *xp, short *ip)
#line 1318
{
#line 1318
	ix_float xx;
#line 1318
	get_ix_float(xp, &xx);
#line 1318
	*ip = (short) xx;
#line 1318
	if(xx > (double)SHORT_MAX || xx < (double)SHORT_MIN) return NC_ERANGE;
#line 1318
	return ENOERR;
#line 1318
}
#line 1318

static int
#line 1319
ncx_get_float_int(const void *xp, int *ip)
#line 1319
{
#line 1319
	ix_float xx;
#line 1319
	get_ix_float(xp, &xx);
#line 1319
	*ip = (int) xx;
#line 1319
	if(xx > (double)INT_MAX || xx < (double)INT_MIN) return NC_ERANGE;
#line 1319
	return ENOERR;
#line 1319
}
#line 1319

static int
#line 1320
ncx_get_float_double(const void *xp, double *ip)
#line 1320
{
#line 1320
	ix_float xx;
#line 1320
	get_ix_float(xp, &xx);
#line 1320
	*ip = (double) xx;
#line 1320

#line 1320
	return ENOERR;
#line 1320
}
#line 1320

static int
#line 1321
ncx_get_float_longlong(const void *xp, longlong *ip)
#line 1321
{
#line 1321
	ix_float xx;
#line 1321
	get_ix_float(xp, &xx);
#line 1321
	*ip = (longlong) xx;
#line 1321
	if(xx > (double)LONGLONG_MAX || xx < (double)LONGLONG_MIN) return NC_ERANGE;
#line 1321
	return ENOERR;
#line 1321
}
#line 1321

static int
#line 1322
ncx_get_float_uchar(const void *xp, uchar *ip)
#line 1322
{
#line 1322
	ix_float xx;
#line 1322
	get_ix_float(xp, &xx);
#line 1322
	*ip = (uchar) xx;
#line 1322
	if(xx > (double)UCHAR_MAX || xx < 0) return NC_ERANGE;
#line 1322
	return ENOERR;
#line 1322
}
#line 1322

static int
#line 1323
ncx_get_float_ushort(const void *xp, ushort *ip)
#line 1323
{
#line 1323
	ix_float xx;
#line 1323
	get_ix_float(xp, &xx);
#line 1323
	*ip = (ushort) xx;
#line 1323
	if(xx > (double)USHORT_MAX || xx < 0) return NC_ERANGE;
#line 1323
	return ENOERR;
#line 1323
}
#line 1323

static int
#line 1324
ncx_get_float_uint(const void *xp, uint *ip)
#line 1324
{
#line 1324
	ix_float xx;
#line 1324
	get_ix_float(xp, &xx);
#line 1324
	*ip = (uint) xx;
#line 1324
	if(xx > (double)UINT_MAX || xx < 0) return NC_ERANGE;
#line 1324
	return ENOERR;
#line 1324
}
#line 1324

static int
#line 1325
ncx_get_float_ulonglong(const void *xp, ulonglong *ip)
#line 1325
{
#line 1325
	ix_float xx;
#line 1325
	get_ix_float(xp, &xx);
#line 1325
	*ip = (ulonglong) xx;
#line 1325
	if(xx > (double)ULONGLONG_MAX || xx < 0) return NC_ERANGE;
#line 1325
	return ENOERR;
#line 1325
}
#line 1325


#if X_SIZEOF_FLOAT != SIZEOF_FLOAT || defined(NO_IEEE_FLOAT)
static int
ncx_put_float_float(void *xp, const float *ip)
{
	put_ix_float(xp, ip);
#ifdef NO_IEEE_FLOAT
	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}
#endif

static int
#line 1340
ncx_put_float_schar(void *xp, const schar *ip)
#line 1340
{
#line 1340
	ix_float xx = (ix_float)*ip;
#line 1340
	put_ix_float(xp, &xx);
#line 1340

#line 1340
	return ENOERR;
#line 1340
}
#line 1340

static int
#line 1341
ncx_put_float_short(void *xp, const short *ip)
#line 1341
{
#line 1341
	ix_float xx = (ix_float)*ip;
#line 1341
	put_ix_float(xp, &xx);
#line 1341

#line 1341
	return ENOERR;
#line 1341
}
#line 1341

static int
#line 1342
ncx_put_float_int(void *xp, const int *ip)
#line 1342
{
#line 1342
	ix_float xx = (ix_float)*ip;
#line 1342
	put_ix_float(xp, &xx);
#line 1342

#line 1342
	return ENOERR;
#line 1342
}
#line 1342

static int
#line 1343
ncx_put_float_double(void *xp, const double *ip)
#line 1343
{
#line 1343
	ix_float xx = (ix_float)*ip;
#line 1343
	put_ix_float(xp, &xx);
#line 1343
	if(*ip > X_FLOAT_MAX || *ip < X_FLOAT_MIN) return NC_ERANGE;
#line 1343
	return ENOERR;
#line 1343
}
#line 1343

static int
#line 1344
ncx_put_float_longlong(void *xp, const longlong *ip)
#line 1344
{
#line 1344
	ix_float xx = (ix_float)*ip;
#line 1344
	put_ix_float(xp, &xx);
#line 1344

#line 1344
	return ENOERR;
#line 1344
}
#line 1344

static int
#line 1345
ncx_put_float_uchar(void *xp, const uchar *ip)
#line 1345
{
#line 1345
	ix_float xx = (ix_float)*ip;
#line 1345
	put_ix_float(xp, &xx);
#line 1345

#line 1345
	return ENOERR;
#line 1345
}
#line 1345

static int
#line 1346
ncx_put_float_ushort(void *xp, const ushort *ip)
#line 1346
{
#line 1346
	ix_float xx = (ix_float)*ip;
#line 1346
	put_ix_float(xp, &xx);
#line 1346

#line 1346
	return ENOERR;
#line 1346
}
#line 1346

static int
#line 1347
ncx_put_float_uint(void *xp, const uint *ip)
#line 1347
{
#line 1347
	ix_float xx = (ix_float)*ip;
#line 1347
	put_ix_float(xp, &xx);
#line 1347

#line 1347
	return ENOERR;
#line 1347
}
#line 1347

static int
#line 1348
ncx_put_float_ulonglong(void *xp, const ulonglong *ip)
#line 1348
{
#line 1348
	ix_float xx = (ix_float)*ip;
#line 1348
	put_ix_float(xp, &xx);
#line 1348

#line 1348
	return ENOERR;
#line 1348
}
#line 1348



/* x_double ------------------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE  && !defined(NO_IEEE_FLOAT)

static void
get_ix_double(const void *xp, double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(ip, xp, sizeof(double));
#else
	swap8b(ip, xp);
#endif
}

static void
put_ix_double(void *xp, const double *ip)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(xp, ip, X_SIZEOF_DOUBLE);
#else
	swap8b(xp, ip);
#endif
}

#elif vax

/* What IEEE double precision floating point looks like on a Vax */
struct	ieee_double {
	unsigned int	exp_hi   : 7;
	unsigned int	sign     : 1;
	unsigned int 	mant_6   : 4;
	unsigned int	exp_lo   : 4;
	unsigned int	mant_5   : 8;
	unsigned int	mant_4   : 8;

	unsigned int	mant_lo  : 32;
};

/* Vax double precision floating point */
struct  vax_double {
	unsigned int	mantissa1 : 7;
	unsigned int	exp       : 8;
	unsigned int	sign      : 1;
	unsigned int	mantissa2 : 16;
	unsigned int	mantissa3 : 16;
	unsigned int	mantissa4 : 16;
};

#define VAX_DBL_BIAS	0x81
#define IEEE_DBL_BIAS	0x3ff
#define MASK(nbits)	((1 << nbits) - 1)

static const struct dbl_limits {
	struct	vax_double d;
	struct	ieee_double ieee;
} dbl_limits[2] = {
	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
	{ 0x7f, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0}}, /* Max IEEE */
	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
	{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}, /* Min IEEE */
};


#line 1462
static void
get_ix_double(const void *xp, double *ip)
{
	struct vax_double *const vdp =
#line 1465
			 (struct vax_double *)ip;
#line 1465
	const struct ieee_double *const idp =
#line 1465
			 (const struct ieee_double *) xp;
#line 1465
	{
#line 1465
		const struct dbl_limits *lim;
#line 1465
		int ii;
#line 1465
		for (ii = 0, lim = dbl_limits;
#line 1465
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 1465
			ii++, lim++)
#line 1465
		{
#line 1465
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 1465
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 1465
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 1465
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 1465
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 1465
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 1465
				)
#line 1465
			{
#line 1465
				*vdp = lim->d;
#line 1465
				goto doneit;
#line 1465
			}
#line 1465
		}
#line 1465
	}
#line 1465
	{
#line 1465
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 1465
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 1465
	}
#line 1465
	{
#line 1465
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 1465
				 | (idp->mant_5 << 8)
#line 1465
				 | idp->mant_4);
#line 1465
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 1465
		vdp->mantissa1 = (mant_hi >> 13);
#line 1465
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 1465
				| (mant_lo >> 29);
#line 1465
		vdp->mantissa3 = (mant_lo >> 13);
#line 1465
		vdp->mantissa4 = (mant_lo << 3);
#line 1465
	}
#line 1465
	doneit:
#line 1465
		vdp->sign = idp->sign;
#line 1465

}


#line 1535
static void
put_ix_double(void *xp, const double *ip)
{
	const struct vax_double *const vdp =
#line 1538
			(const struct vax_double *)ip;
#line 1538
	struct ieee_double *const idp =
#line 1538
			 (struct ieee_double *) xp;
#line 1538

#line 1538
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 1538
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 1538
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 1538
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 1538
		(vdp->exp == dbl_limits[0].d.exp))
#line 1538
	{
#line 1538
		*idp = dbl_limits[0].ieee;
#line 1538
		goto shipit;
#line 1538
	}
#line 1538
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 1538
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 1538
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 1538
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 1538
		(vdp->exp == dbl_limits[1].d.exp))
#line 1538
	{
#line 1538
		*idp = dbl_limits[1].ieee;
#line 1538
		goto shipit;
#line 1538
	}
#line 1538

#line 1538
	{
#line 1538
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 1538

#line 1538
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 1538
			(vdp->mantissa3 << 13) |
#line 1538
			((vdp->mantissa4 >> 3) & MASK(13));
#line 1538

#line 1538
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 1538
				 | (vdp->mantissa2 >> 3);
#line 1538

#line 1538
		if((vdp->mantissa4 & 7) > 4)
#line 1538
		{
#line 1538
			/* round up */
#line 1538
			mant_lo++;
#line 1538
			if(mant_lo == 0)
#line 1538
			{
#line 1538
				mant_hi++;
#line 1538
				if(mant_hi > 0xffffff)
#line 1538
				{
#line 1538
					mant_hi = 0;
#line 1538
					exp++;
#line 1538
				}
#line 1538
			}
#line 1538
		}
#line 1538

#line 1538
		idp->mant_lo = SWAP4(mant_lo);
#line 1538
		idp->mant_6 = mant_hi >> 16;
#line 1538
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 1538
		idp->mant_4 = mant_hi;
#line 1538
		idp->exp_hi = exp >> 4;
#line 1538
		idp->exp_lo = exp;
#line 1538
	}
#line 1538

#line 1538
	shipit:
#line 1538
		idp->sign = vdp->sign;
#line 1538

}

	/* vax */
#elif defined(_CRAY) && !defined(__crayx1)

static void
get_ix_double(const void *xp, double *ip)
{
	const ieee_double *idp = (const ieee_double *) xp;
	cray_single *csp = (cray_single *) ip;

	if(idp->exp == 0)
	{
		/* ieee subnormal */
		*ip = (double)idp->mant;
		if(idp->mant != 0)
		{
			csp->exp -= (ieee_double_bias + 51);
		}
	}
	else
	{
		csp->exp  = idp->exp + cs_id_bias + 1;
		csp->mant = idp->mant >> (52 - 48 + 1);
		csp->mant |= (1 << (48 - 1));
	}
	csp->sign = idp->sign;
}

static void
put_ix_double(void *xp, const double *ip)
{
	ieee_double *idp = (ieee_double *) xp;
	const cray_single *csp = (const cray_single *) ip;

	int ieee_exp = csp->exp - cs_id_bias -1;

	idp->sign = csp->sign;

	if(ieee_exp >= 0x7ff)
	{
		/* NC_ERANGE => ieee Inf */
		idp->exp = 0x7ff;
		idp->mant = 0x0;
	}
	else if(ieee_exp > 0)
	{
		/* normal ieee representation */
		idp->exp  = ieee_exp;
		/* assumes cray rep is in normal form */
		assert(csp->mant & 0x800000000000);
		idp->mant = (((csp->mant << 1) &
				0xffffffffffff) << (52 - 48));
	}
	else if(ieee_exp >= (-(52 -48)))
	{
		/* ieee subnormal, left shift */
		const int lshift = (52 - 48) + ieee_exp;
		idp->mant = csp->mant << lshift;
		idp->exp  = 0;
	}
	else if(ieee_exp >= -52)
	{
		/* ieee subnormal, right shift */
		const int rshift = (- (52 - 48) - ieee_exp);

		idp->mant = csp->mant >> rshift;

#if 0
		if(csp->mant & (1 << (rshift -1)))
		{
			/* round up */
			idp->mant++;
		}
#endif

		idp->exp  = 0;
	}
	else
	{
		/* smaller than ieee can represent */
		idp->exp = 0;
		idp->mant = 0;
	}
}
#else
#error "ix_double implementation"
#endif

#define ix_double double

static int
#line 1630
ncx_get_double_schar(const void *xp, schar *ip)
#line 1630
{
#line 1630
	ix_double xx;
#line 1630
	get_ix_double(xp, &xx);
#line 1630
	*ip = (schar) xx;
#line 1630
	if(xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 1630
	return ENOERR;
#line 1630
}
#line 1630

static int
#line 1631
ncx_get_double_short(const void *xp, short *ip)
#line 1631
{
#line 1631
	ix_double xx;
#line 1631
	get_ix_double(xp, &xx);
#line 1631
	*ip = (short) xx;
#line 1631
	if(xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 1631
	return ENOERR;
#line 1631
}
#line 1631

static int
#line 1632
ncx_get_double_int(const void *xp, int *ip)
#line 1632
{
#line 1632
	ix_double xx;
#line 1632
	get_ix_double(xp, &xx);
#line 1632
	*ip = (int) xx;
#line 1632
	if(xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 1632
	return ENOERR;
#line 1632
}
#line 1632

static int
#line 1633
ncx_get_double_longlong(const void *xp, longlong *ip)
#line 1633
{
#line 1633
	ix_double xx;
#line 1633
	get_ix_double(xp, &xx);
#line 1633
	*ip = (longlong) xx;
#line 1633
	if(xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 1633
	return ENOERR;
#line 1633
}
#line 1633

static int
#line 1634
ncx_get_double_uchar(const void *xp, uchar *ip)
#line 1634
{
#line 1634
	ix_double xx;
#line 1634
	get_ix_double(xp, &xx);
#line 1634
	*ip = (uchar) xx;
#line 1634
	if(xx > UCHAR_MAX || xx < 0) return NC_ERANGE;
#line 1634
	return ENOERR;
#line 1634
}
#line 1634

static int
#line 1635
ncx_get_double_ushort(const void *xp, ushort *ip)
#line 1635
{
#line 1635
	ix_double xx;
#line 1635
	get_ix_double(xp, &xx);
#line 1635
	*ip = (ushort) xx;
#line 1635
	if(xx > USHORT_MAX || xx < 0) return NC_ERANGE;
#line 1635
	return ENOERR;
#line 1635
}
#line 1635

static int
#line 1636
ncx_get_double_uint(const void *xp, uint *ip)
#line 1636
{
#line 1636
	ix_double xx;
#line 1636
	get_ix_double(xp, &xx);
#line 1636
	*ip = (uint) xx;
#line 1636
	if(xx > UINT_MAX || xx < 0) return NC_ERANGE;
#line 1636
	return ENOERR;
#line 1636
}
#line 1636

static int
#line 1637
ncx_get_double_ulonglong(const void *xp, ulonglong *ip)
#line 1637
{
#line 1637
	ix_double xx;
#line 1637
	get_ix_double(xp, &xx);
#line 1637
	*ip = (ulonglong) xx;
#line 1637
	if(xx > ULONGLONG_MAX || xx < 0) return NC_ERANGE;
#line 1637
	return ENOERR;
#line 1637
}
#line 1637


static int
ncx_get_double_float(const void *xp, float *ip)
{
	double xx;
	get_ix_double(xp, &xx);
	if(xx > FLT_MAX)
	{
		*ip = FLT_MAX;
		return NC_ERANGE;
	}
	if(xx < (-FLT_MAX))
	{
		*ip = (-FLT_MAX);
		return NC_ERANGE;
	}
	*ip = (float) xx;
	return ENOERR;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_get_double_double(const void *xp, double *ip)
{
	/* TODO */
	get_ix_double(xp, ip);
	return ENOERR;
}
#endif

static int
#line 1668
ncx_put_double_schar(void *xp, const schar *ip)
#line 1668
{
#line 1668
	ix_double xx = (ix_double)*ip;
#line 1668
	put_ix_double(xp, &xx);
#line 1668

#line 1668
	return ENOERR;
#line 1668
}
#line 1668

static int
#line 1669
ncx_put_double_uchar(void *xp, const uchar *ip)
#line 1669
{
#line 1669
	ix_double xx = (ix_double)*ip;
#line 1669
	put_ix_double(xp, &xx);
#line 1669

#line 1669
	return ENOERR;
#line 1669
}
#line 1669

static int
#line 1670
ncx_put_double_short(void *xp, const short *ip)
#line 1670
{
#line 1670
	ix_double xx = (ix_double)*ip;
#line 1670
	put_ix_double(xp, &xx);
#line 1670

#line 1670
	return ENOERR;
#line 1670
}
#line 1670

static int
#line 1671
ncx_put_double_ushort(void *xp, const ushort *ip)
#line 1671
{
#line 1671
	ix_double xx = (ix_double)*ip;
#line 1671
	put_ix_double(xp, &xx);
#line 1671

#line 1671
	return ENOERR;
#line 1671
}
#line 1671

static int
#line 1672
ncx_put_double_int(void *xp, const int *ip)
#line 1672
{
#line 1672
	ix_double xx = (ix_double)*ip;
#line 1672
	put_ix_double(xp, &xx);
#line 1672

#line 1672
	return ENOERR;
#line 1672
}
#line 1672

static int
#line 1673
ncx_put_double_uint(void *xp, const uint *ip)
#line 1673
{
#line 1673
	ix_double xx = (ix_double)*ip;
#line 1673
	put_ix_double(xp, &xx);
#line 1673

#line 1673
	return ENOERR;
#line 1673
}
#line 1673

static int
#line 1674
ncx_put_double_longlong(void *xp, const longlong *ip)
#line 1674
{
#line 1674
	ix_double xx = (ix_double)*ip;
#line 1674
	put_ix_double(xp, &xx);
#line 1674

#line 1674
	return ENOERR;
#line 1674
}
#line 1674

static int
#line 1675
ncx_put_double_ulonglong(void *xp, const ulonglong *ip)
#line 1675
{
#line 1675
	ix_double xx = (ix_double)*ip;
#line 1675
	put_ix_double(xp, &xx);
#line 1675

#line 1675
	return ENOERR;
#line 1675
}
#line 1675


static int
ncx_put_double_float(void *xp, const float *ip)
{
	double xx = (double) *ip;
	put_ix_double(xp, &xx);
#if 1	/* TODO: figure this out */
	if((double)(*ip) > X_DOUBLE_MAX || (double)(*ip) < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}

#if X_SIZEOF_DOUBLE != SIZEOF_DOUBLE  || defined(NO_IEEE_FLOAT)
static int
ncx_put_double_double(void *xp, const double *ip)
{
	put_ix_double(xp, ip);
#ifdef NO_IEEE_FLOAT
	if(*ip > X_DOUBLE_MAX || *ip < X_DOUBLE_MIN)
		return NC_ERANGE;
#endif
	return ENOERR;
}
#endif


/* x_longlong ---------------------------------------------------------------------*/

#if SHORT_MAX == X_LONGLONG_MAX
typedef short ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_SHORT
#define IX_LONGLONG_MAX SHORT_MAX
#elif LONG_LONG_MAX  >= X_LONGLONG_MAX
typedef longlong ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_LONGLONG
#define IX_LONGLONG_MAX LONG_LONG_MAX
#elif LONG_MAX  >= X_LONGLONG_MAX
typedef long ix_longlong;
#define SIZEOF_IX_LONGLONG SIZEOF_LONG
#define IX_LONGLONG_MAX LONG_MAX
#else
#error "ix_longlong implementation"
#endif


static void
get_ix_longlong(const void *xp, ix_longlong *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((long long)(*cp++) << 56);
    *ip |= ((long long)(*cp++) << 48);
    *ip |= ((long long)(*cp++) << 40);
    *ip |= ((long long)(*cp++) << 32);
    *ip |= ((long long)(*cp++) << 24);
    *ip |= ((long long)(*cp++) << 16);
    *ip |= ((long long)(*cp++) <<  8);
    *ip |=  (long long)*cp;
}

static void
put_ix_longlong(void *xp, const ix_longlong *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (*ip) >> 56;
    *cp++ = ((*ip) & 0x00ff000000000000LL) >> 48;
    *cp++ = ((*ip) & 0x0000ff0000000000LL) >> 40;
    *cp++ = ((*ip) & 0x000000ff00000000LL) >> 32;
    *cp++ = ((*ip) & 0x00000000ff000000LL) >> 24;
    *cp++ = ((*ip) & 0x0000000000ff0000LL) >> 16;
    *cp++ = ((*ip) & 0x000000000000ff00LL) >>  8;
    *cp   = ((*ip) & 0x00000000000000ffLL);
}

static int
#line 1752
ncx_get_longlong_schar(const void *xp, schar *ip)
#line 1752
{
#line 1752
	ix_longlong xx;
#line 1752
	get_ix_longlong(xp, &xx);
#line 1752
	*ip = (schar) xx;
#line 1752
#if IX_LONGLONG_MAX > SCHAR_MAX
#line 1752
	if (xx > SCHAR_MAX || xx < SCHAR_MIN) return NC_ERANGE;
#line 1752
#endif
#line 1752

#line 1752
	return ENOERR;
#line 1752
}
#line 1752

static int
#line 1753
ncx_get_longlong_short(const void *xp, short *ip)
#line 1753
{
#line 1753
#if SIZEOF_IX_LONGLONG == SIZEOF_SHORT && IX_LONGLONG_MAX == SHORT_MAX
#line 1753
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1753
	return ENOERR;
#line 1753
#else
#line 1753
	ix_longlong xx;
#line 1753
	get_ix_longlong(xp, &xx);
#line 1753
	*ip = (short) xx;
#line 1753
#if IX_LONGLONG_MAX > SHORT_MAX
#line 1753
	if (xx > SHORT_MAX || xx < SHORT_MIN) return NC_ERANGE;
#line 1753
#endif
#line 1753

#line 1753
#endif
#line 1753
	return ENOERR;
#line 1753
}
#line 1753

static int
#line 1754
ncx_get_longlong_int(const void *xp, int *ip)
#line 1754
{
#line 1754
#if SIZEOF_IX_LONGLONG == SIZEOF_INT && IX_LONGLONG_MAX == INT_MAX
#line 1754
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1754
	return ENOERR;
#line 1754
#else
#line 1754
	ix_longlong xx;
#line 1754
	get_ix_longlong(xp, &xx);
#line 1754
	*ip = (int) xx;
#line 1754
#if IX_LONGLONG_MAX > INT_MAX
#line 1754
	if (xx > INT_MAX || xx < INT_MIN) return NC_ERANGE;
#line 1754
#endif
#line 1754

#line 1754
#endif
#line 1754
	return ENOERR;
#line 1754
}
#line 1754

static int
#line 1755
ncx_get_longlong_longlong(const void *xp, longlong *ip)
#line 1755
{
#line 1755
#if SIZEOF_IX_LONGLONG == SIZEOF_LONGLONG && IX_LONGLONG_MAX == LONGLONG_MAX
#line 1755
	get_ix_longlong(xp, (ix_longlong *)ip);
#line 1755
	return ENOERR;
#line 1755
#else
#line 1755
	ix_longlong xx;
#line 1755
	get_ix_longlong(xp, &xx);
#line 1755
	*ip = (longlong) xx;
#line 1755
#if IX_LONGLONG_MAX > LONGLONG_MAX
#line 1755
	if (xx > LONGLONG_MAX || xx < LONGLONG_MIN) return NC_ERANGE;
#line 1755
#endif
#line 1755

#line 1755
#endif
#line 1755
	return ENOERR;
#line 1755
}
#line 1755

static int
#line 1756
ncx_get_longlong_ushort(const void *xp, ushort *ip)
#line 1756
{
#line 1756
	ix_longlong xx;
#line 1756
	get_ix_longlong(xp, &xx);
#line 1756
	*ip = (ushort) xx;
#line 1756
#if IX_LONGLONG_MAX > USHORT_MAX
#line 1756
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 1756
#endif
#line 1756
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1756
	return ENOERR;
#line 1756
}
#line 1756

static int
#line 1757
ncx_get_longlong_uchar(const void *xp, uchar *ip)
#line 1757
{
#line 1757
	ix_longlong xx;
#line 1757
	get_ix_longlong(xp, &xx);
#line 1757
	*ip = (uchar) xx;
#line 1757
#if IX_LONGLONG_MAX > UCHAR_MAX
#line 1757
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 1757
#endif
#line 1757
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1757
	return ENOERR;
#line 1757
}
#line 1757

static int
#line 1758
ncx_get_longlong_uint(const void *xp, uint *ip)
#line 1758
{
#line 1758
	ix_longlong xx;
#line 1758
	get_ix_longlong(xp, &xx);
#line 1758
	*ip = (uint) xx;
#line 1758
#if IX_LONGLONG_MAX > UINT_MAX
#line 1758
	if (xx > UINT_MAX) return NC_ERANGE;
#line 1758
#endif
#line 1758
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1758
	return ENOERR;
#line 1758
}
#line 1758

static int
#line 1759
ncx_get_longlong_ulonglong(const void *xp, ulonglong *ip)
#line 1759
{
#line 1759
	ix_longlong xx;
#line 1759
	get_ix_longlong(xp, &xx);
#line 1759
	*ip = (ulonglong) xx;
#line 1759
#if IX_LONGLONG_MAX > ULONGLONG_MAX
#line 1759
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 1759
#endif
#line 1759
	if (xx < 0) return NC_ERANGE; /* because ip is unsigned */
#line 1759
	return ENOERR;
#line 1759
}
#line 1759

static int
#line 1760
ncx_get_longlong_float(const void *xp, float *ip)
#line 1760
{
#line 1760
	ix_longlong xx;
#line 1760
	get_ix_longlong(xp, &xx);
#line 1760
	*ip = (float) xx;
#line 1760

#line 1760
	return ENOERR;
#line 1760
}
#line 1760

static int
#line 1761
ncx_get_longlong_double(const void *xp, double *ip)
#line 1761
{
#line 1761
	ix_longlong xx;
#line 1761
	get_ix_longlong(xp, &xx);
#line 1761
	*ip = (double) xx;
#line 1761

#line 1761
	return ENOERR;
#line 1761
}
#line 1761


static int
#line 1763
ncx_put_longlong_schar(void *xp, const schar *ip)
#line 1763
{
#line 1763
	ix_longlong xx = (ix_longlong)*ip;
#line 1763
	put_ix_longlong(xp, &xx);
#line 1763
#if IX_LONGLONG_MAX < SCHAR_MAX
#line 1763
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1763
#endif
#line 1763

#line 1763
	return ENOERR;
#line 1763
}
#line 1763

static int
#line 1764
ncx_put_longlong_short(void *xp, const short *ip)
#line 1764
{
#line 1764
#if SIZEOF_IX_LONGLONG == SIZEOF_SHORT && IX_LONGLONG_MAX == SHORT_MAX
#line 1764
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1764
	return ENOERR;
#line 1764
#else
#line 1764
	ix_longlong xx = (ix_longlong)*ip;
#line 1764
	put_ix_longlong(xp, &xx);
#line 1764
#if IX_LONGLONG_MAX < SHORT_MAX
#line 1764
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1764
#endif
#line 1764

#line 1764
#endif
#line 1764
	return ENOERR;
#line 1764
}
#line 1764

static int
#line 1765
ncx_put_longlong_int(void *xp, const int *ip)
#line 1765
{
#line 1765
#if SIZEOF_IX_LONGLONG == SIZEOF_INT && IX_LONGLONG_MAX == INT_MAX
#line 1765
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1765
	return ENOERR;
#line 1765
#else
#line 1765
	ix_longlong xx = (ix_longlong)*ip;
#line 1765
	put_ix_longlong(xp, &xx);
#line 1765
#if IX_LONGLONG_MAX < INT_MAX
#line 1765
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1765
#endif
#line 1765

#line 1765
#endif
#line 1765
	return ENOERR;
#line 1765
}
#line 1765

static int
#line 1766
ncx_put_longlong_longlong(void *xp, const longlong *ip)
#line 1766
{
#line 1766
#if SIZEOF_IX_LONGLONG == SIZEOF_LONGLONG && IX_LONGLONG_MAX == LONGLONG_MAX
#line 1766
	put_ix_longlong(xp, (const ix_longlong *)ip);
#line 1766
	return ENOERR;
#line 1766
#else
#line 1766
	ix_longlong xx = (ix_longlong)*ip;
#line 1766
	put_ix_longlong(xp, &xx);
#line 1766
#if IX_LONGLONG_MAX < LONGLONG_MAX
#line 1766
	if (*ip > IX_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1766
#endif
#line 1766

#line 1766
#endif
#line 1766
	return ENOERR;
#line 1766
}
#line 1766

static int
#line 1767
ncx_put_longlong_ushort(void *xp, const ushort *ip)
#line 1767
{
#line 1767
	ix_longlong xx = (ix_longlong)*ip;
#line 1767
	put_ix_longlong(xp, &xx);
#line 1767
#if IX_LONGLONG_MAX < USHORT_MAX
#line 1767
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1767
#endif
#line 1767

#line 1767
	return ENOERR;
#line 1767
}
#line 1767

static int
#line 1768
ncx_put_longlong_uchar(void *xp, const uchar *ip)
#line 1768
{
#line 1768
	ix_longlong xx = (ix_longlong)*ip;
#line 1768
	put_ix_longlong(xp, &xx);
#line 1768
#if IX_LONGLONG_MAX < UCHAR_MAX
#line 1768
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1768
#endif
#line 1768

#line 1768
	return ENOERR;
#line 1768
}
#line 1768

static int
#line 1769
ncx_put_longlong_uint(void *xp, const uint *ip)
#line 1769
{
#line 1769
	ix_longlong xx = (ix_longlong)*ip;
#line 1769
	put_ix_longlong(xp, &xx);
#line 1769
#if IX_LONGLONG_MAX < UINT_MAX
#line 1769
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1769
#endif
#line 1769

#line 1769
	return ENOERR;
#line 1769
}
#line 1769

static int
#line 1770
ncx_put_longlong_ulonglong(void *xp, const ulonglong *ip)
#line 1770
{
#line 1770
	ix_longlong xx = (ix_longlong)*ip;
#line 1770
	put_ix_longlong(xp, &xx);
#line 1770
#if IX_LONGLONG_MAX < ULONGLONG_MAX
#line 1770
	if (*ip > IX_LONGLONG_MAX) return NC_ERANGE;
#line 1770
#endif
#line 1770

#line 1770
	return ENOERR;
#line 1770
}
#line 1770

static int
#line 1771
ncx_put_longlong_float(void *xp, const float *ip)
#line 1771
{
#line 1771
	ix_longlong xx = (ix_longlong)*ip;
#line 1771
	put_ix_longlong(xp, &xx);
#line 1771
	if(*ip > (double)X_LONGLONG_MAX || *ip < (double)X_LONGLONG_MIN) return NC_ERANGE;
#line 1771
	return ENOERR;
#line 1771
}
#line 1771

static int
#line 1772
ncx_put_longlong_double(void *xp, const double *ip)
#line 1772
{
#line 1772
	ix_longlong xx = (ix_longlong)*ip;
#line 1772
	put_ix_longlong(xp, &xx);
#line 1772
	if(*ip > X_LONGLONG_MAX || *ip < X_LONGLONG_MIN) return NC_ERANGE;
#line 1772
	return ENOERR;
#line 1772
}
#line 1772

 

/* x_ulonglong --------------------------------------------------------------------*/

#if USHORT_MAX == X_ULONGLONG_MAX
typedef ushort ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_USHORT
#define IX_ULONGLONG_MAX USHORT_MAX
#elif ULONG_LONG_MAX  >= X_ULONGLONG_MAX
typedef ulonglong ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_ULONGLONG
#define IX_ULONGLONG_MAX ULONG_LONG_MAX
#elif ULONG_MAX  >= X_ULONGLONG_MAX
typedef ulong ix_ulonglong;
#define SIZEOF_IX_ULONGLONG SIZEOF_ULONG
#define IX_ULONGLONG_MAX ULONG_MAX
#else
#error "ix_ulonglong implementation"
#endif


static void
get_ix_ulonglong(const void *xp, ix_ulonglong *ip)
{
    const uchar *cp = (const uchar *) xp;

    *ip  = ((unsigned long long)(*cp++) << 56);
    *ip |= ((unsigned long long)(*cp++) << 48);
    *ip |= ((unsigned long long)(*cp++) << 40);
    *ip |= ((unsigned long long)(*cp++) << 32);
    *ip |= ((unsigned long long)(*cp++) << 24);
    *ip |= ((unsigned long long)(*cp++) << 16);
    *ip |= ((unsigned long long)(*cp++) <<  8);
    *ip |=  (unsigned long long)*cp;
}

static void
put_ix_ulonglong(void *xp, const ix_ulonglong *ip)
{
    uchar *cp = (uchar *) xp;

    *cp++ = (*ip) >> 56;
    *cp++ = ((*ip) & 0x00ff000000000000ULL) >> 48;
    *cp++ = ((*ip) & 0x0000ff0000000000ULL) >> 40;
    *cp++ = ((*ip) & 0x000000ff00000000ULL) >> 32;
    *cp++ = ((*ip) & 0x00000000ff000000ULL) >> 24;
    *cp++ = ((*ip) & 0x0000000000ff0000ULL) >> 16;
    *cp++ = ((*ip) & 0x000000000000ff00ULL) >>  8;
    *cp   = ((*ip) & 0x00000000000000ffULL);
}

static int
#line 1824
ncx_get_ulonglong_schar(const void *xp, schar *ip)
#line 1824
{
#line 1824
	ix_ulonglong xx;
#line 1824
	get_ix_ulonglong(xp, &xx);
#line 1824
	*ip = (schar) xx;
#line 1824
#if IX_ULONGLONG_MAX > SCHAR_MAX
#line 1824
	if (xx > SCHAR_MAX) return NC_ERANGE;
#line 1824
#endif
#line 1824

#line 1824
	return ENOERR;
#line 1824
}
#line 1824

static int
#line 1825
ncx_get_ulonglong_short(const void *xp, short *ip)
#line 1825
{
#line 1825
	ix_ulonglong xx;
#line 1825
	get_ix_ulonglong(xp, &xx);
#line 1825
	*ip = (short) xx;
#line 1825
#if IX_ULONGLONG_MAX > SHORT_MAX
#line 1825
	if (xx > SHORT_MAX) return NC_ERANGE;
#line 1825
#endif
#line 1825

#line 1825
	return ENOERR;
#line 1825
}
#line 1825

static int
#line 1826
ncx_get_ulonglong_int(const void *xp, int *ip)
#line 1826
{
#line 1826
	ix_ulonglong xx;
#line 1826
	get_ix_ulonglong(xp, &xx);
#line 1826
	*ip = (int) xx;
#line 1826
#if IX_ULONGLONG_MAX > INT_MAX
#line 1826
	if (xx > INT_MAX) return NC_ERANGE;
#line 1826
#endif
#line 1826

#line 1826
	return ENOERR;
#line 1826
}
#line 1826

static int
#line 1827
ncx_get_ulonglong_longlong(const void *xp, longlong *ip)
#line 1827
{
#line 1827
	ix_ulonglong xx;
#line 1827
	get_ix_ulonglong(xp, &xx);
#line 1827
	*ip = (longlong) xx;
#line 1827
#if IX_ULONGLONG_MAX > LONGLONG_MAX
#line 1827
	if (xx > LONGLONG_MAX) return NC_ERANGE;
#line 1827
#endif
#line 1827

#line 1827
	return ENOERR;
#line 1827
}
#line 1827

static int
#line 1828
ncx_get_ulonglong_ushort(const void *xp, ushort *ip)
#line 1828
{
#line 1828
#if SIZEOF_IX_ULONGLONG == SIZEOF_USHORT && IX_ULONGLONG_MAX == USHORT_MAX
#line 1828
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1828
	return ENOERR;
#line 1828
#else
#line 1828
	ix_ulonglong xx;
#line 1828
	get_ix_ulonglong(xp, &xx);
#line 1828
	*ip = (ushort) xx;
#line 1828
#if IX_ULONGLONG_MAX > USHORT_MAX
#line 1828
	if (xx > USHORT_MAX) return NC_ERANGE;
#line 1828
#endif
#line 1828

#line 1828
#endif
#line 1828
	return ENOERR;
#line 1828
}
#line 1828

static int
#line 1829
ncx_get_ulonglong_uchar(const void *xp, uchar *ip)
#line 1829
{
#line 1829
#if SIZEOF_IX_ULONGLONG == SIZEOF_UCHAR && IX_ULONGLONG_MAX == UCHAR_MAX
#line 1829
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1829
	return ENOERR;
#line 1829
#else
#line 1829
	ix_ulonglong xx;
#line 1829
	get_ix_ulonglong(xp, &xx);
#line 1829
	*ip = (uchar) xx;
#line 1829
#if IX_ULONGLONG_MAX > UCHAR_MAX
#line 1829
	if (xx > UCHAR_MAX) return NC_ERANGE;
#line 1829
#endif
#line 1829

#line 1829
#endif
#line 1829
	return ENOERR;
#line 1829
}
#line 1829

static int
#line 1830
ncx_get_ulonglong_uint(const void *xp, uint *ip)
#line 1830
{
#line 1830
#if SIZEOF_IX_ULONGLONG == SIZEOF_UINT && IX_ULONGLONG_MAX == UINT_MAX
#line 1830
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1830
	return ENOERR;
#line 1830
#else
#line 1830
	ix_ulonglong xx;
#line 1830
	get_ix_ulonglong(xp, &xx);
#line 1830
	*ip = (uint) xx;
#line 1830
#if IX_ULONGLONG_MAX > UINT_MAX
#line 1830
	if (xx > UINT_MAX) return NC_ERANGE;
#line 1830
#endif
#line 1830

#line 1830
#endif
#line 1830
	return ENOERR;
#line 1830
}
#line 1830

static int
#line 1831
ncx_get_ulonglong_ulonglong(const void *xp, ulonglong *ip)
#line 1831
{
#line 1831
#if SIZEOF_IX_ULONGLONG == SIZEOF_ULONGLONG && IX_ULONGLONG_MAX == ULONGLONG_MAX
#line 1831
	get_ix_ulonglong(xp, (ix_ulonglong *)ip);
#line 1831
	return ENOERR;
#line 1831
#else
#line 1831
	ix_ulonglong xx;
#line 1831
	get_ix_ulonglong(xp, &xx);
#line 1831
	*ip = (ulonglong) xx;
#line 1831
#if IX_ULONGLONG_MAX > ULONGLONG_MAX
#line 1831
	if (xx > ULONGLONG_MAX) return NC_ERANGE;
#line 1831
#endif
#line 1831

#line 1831
#endif
#line 1831
	return ENOERR;
#line 1831
}
#line 1831

static int
#line 1832
ncx_get_ulonglong_float(const void *xp, float *ip)
#line 1832
{
#line 1832
	ix_ulonglong xx;
#line 1832
	get_ix_ulonglong(xp, &xx);
#line 1832
	*ip = (float) xx;
#line 1832

#line 1832
	return ENOERR;
#line 1832
}
#line 1832

static int
#line 1833
ncx_get_ulonglong_double(const void *xp, double *ip)
#line 1833
{
#line 1833
	ix_ulonglong xx;
#line 1833
	get_ix_ulonglong(xp, &xx);
#line 1833
	*ip = (double) xx;
#line 1833

#line 1833
	return ENOERR;
#line 1833
}
#line 1833


static int
#line 1835
ncx_put_ulonglong_schar(void *xp, const schar *ip)
#line 1835
{
#line 1835
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1835
	put_ix_ulonglong(xp, &xx);
#line 1835
#if IX_ULONGLONG_MAX < SCHAR_MAX
#line 1835
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1835
#endif
#line 1835
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1835
	return ENOERR;
#line 1835
}
#line 1835

static int
#line 1836
ncx_put_ulonglong_short(void *xp, const short *ip)
#line 1836
{
#line 1836
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1836
	put_ix_ulonglong(xp, &xx);
#line 1836
#if IX_ULONGLONG_MAX < SHORT_MAX
#line 1836
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1836
#endif
#line 1836
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1836
	return ENOERR;
#line 1836
}
#line 1836

static int
#line 1837
ncx_put_ulonglong_int(void *xp, const int *ip)
#line 1837
{
#line 1837
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1837
	put_ix_ulonglong(xp, &xx);
#line 1837
#if IX_ULONGLONG_MAX < INT_MAX
#line 1837
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1837
#endif
#line 1837
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1837
	return ENOERR;
#line 1837
}
#line 1837

static int
#line 1838
ncx_put_ulonglong_longlong(void *xp, const longlong *ip)
#line 1838
{
#line 1838
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1838
	put_ix_ulonglong(xp, &xx);
#line 1838
#if IX_ULONGLONG_MAX < LONGLONG_MAX
#line 1838
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1838
#endif
#line 1838
	if (*ip < 0) return NC_ERANGE; /* because xp is unsigned */
#line 1838
	return ENOERR;
#line 1838
}
#line 1838

static int
#line 1839
ncx_put_ulonglong_uchar(void *xp, const uchar *ip)
#line 1839
{
#line 1839
#if SIZEOF_IX_ULONGLONG == SIZEOF_UCHAR && IX_ULONGLONG_MAX == UCHAR_MAX
#line 1839
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1839
	return ENOERR;
#line 1839
#else
#line 1839
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1839
	put_ix_ulonglong(xp, &xx);
#line 1839
#if IX_ULONGLONG_MAX < UCHAR_MAX
#line 1839
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1839
#endif
#line 1839

#line 1839
#endif
#line 1839
	return ENOERR;
#line 1839
}
#line 1839

static int
#line 1840
ncx_put_ulonglong_ushort(void *xp, const ushort *ip)
#line 1840
{
#line 1840
#if SIZEOF_IX_ULONGLONG == SIZEOF_USHORT && IX_ULONGLONG_MAX == USHORT_MAX
#line 1840
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1840
	return ENOERR;
#line 1840
#else
#line 1840
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1840
	put_ix_ulonglong(xp, &xx);
#line 1840
#if IX_ULONGLONG_MAX < USHORT_MAX
#line 1840
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1840
#endif
#line 1840

#line 1840
#endif
#line 1840
	return ENOERR;
#line 1840
}
#line 1840

static int
#line 1841
ncx_put_ulonglong_uint(void *xp, const uint *ip)
#line 1841
{
#line 1841
#if SIZEOF_IX_ULONGLONG == SIZEOF_UINT && IX_ULONGLONG_MAX == UINT_MAX
#line 1841
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1841
	return ENOERR;
#line 1841
#else
#line 1841
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1841
	put_ix_ulonglong(xp, &xx);
#line 1841
#if IX_ULONGLONG_MAX < UINT_MAX
#line 1841
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1841
#endif
#line 1841

#line 1841
#endif
#line 1841
	return ENOERR;
#line 1841
}
#line 1841

static int
#line 1842
ncx_put_ulonglong_ulonglong(void *xp, const ulonglong *ip)
#line 1842
{
#line 1842
#if SIZEOF_IX_ULONGLONG == SIZEOF_ULONGLONG && IX_ULONGLONG_MAX == ULONGLONG_MAX
#line 1842
	put_ix_ulonglong(xp, (const ix_ulonglong *)ip);
#line 1842
	return ENOERR;
#line 1842
#else
#line 1842
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1842
	put_ix_ulonglong(xp, &xx);
#line 1842
#if IX_ULONGLONG_MAX < ULONGLONG_MAX
#line 1842
	if (*ip > IX_ULONGLONG_MAX) return NC_ERANGE;
#line 1842
#endif
#line 1842

#line 1842
#endif
#line 1842
	return ENOERR;
#line 1842
}
#line 1842

static int
#line 1843
ncx_put_ulonglong_float(void *xp, const float *ip)
#line 1843
{
#line 1843
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1843
	put_ix_ulonglong(xp, &xx);
#line 1843
	if(*ip > (double)X_ULONGLONG_MAX || *ip < 0) return NC_ERANGE;
#line 1843
	return ENOERR;
#line 1843
}
#line 1843

static int
#line 1844
ncx_put_ulonglong_double(void *xp, const double *ip)
#line 1844
{
#line 1844
	ix_ulonglong xx = (ix_ulonglong)*ip;
#line 1844
	put_ix_ulonglong(xp, &xx);
#line 1844
	if(*ip > X_ULONGLONG_MAX || *ip < 0) return NC_ERANGE;
#line 1844
	return ENOERR;
#line 1844
}
#line 1844

 

/* x_size_t */

#if SIZEOF_SIZE_T < X_SIZEOF_SIZE_T
#error "x_size_t implementation"
/* netcdf requires size_t which can hold a values from 0 to 2^32 -1 */
#endif

int
ncx_put_size_t(void **xpp, const size_t *ulp)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
	assert(*ulp <= X_SIZE_MAX);

	*cp++ = (uchar)((*ulp) >> 24);
	*cp++ = (uchar)(((*ulp) & 0x00ff0000) >> 16);
	*cp++ = (uchar)(((*ulp) & 0x0000ff00) >>  8);
	*cp   = (uchar)((*ulp) & 0x000000ff);

	*xpp = (void *)((char *)(*xpp) + X_SIZEOF_SIZE_T);
	return ENOERR;
}

int
ncx_get_size_t(const void **xpp,  size_t *ulp)
{
	/* similar to get_ix_int */
	const uchar *cp = (const uchar *) *xpp;

	*ulp = (unsigned)(*cp++ << 24);
	*ulp |= (*cp++ << 16);
	*ulp |= (*cp++ << 8);
	*ulp |= *cp;

	*xpp = (const void *)((const char *)(*xpp) + X_SIZEOF_SIZE_T);
	return ENOERR;
}

/* x_off_t */

int
ncx_put_off_t(void **xpp, const off_t *lp, size_t sizeof_off_t)
{
	/* similar to put_ix_int() */
	uchar *cp = (uchar *) *xpp;
		/* No negative offsets stored in netcdf */
	if (*lp < 0) {
	  /* Assume this is an overflow of a 32-bit int... */
	  return NC_ERANGE;
	}

	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

	if (sizeof_off_t == 4) {
		*cp++ = (uchar) ((*lp)               >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
	} else {
#if SIZEOF_OFF_T == 4
/* Write a 64-bit offset on a system with only a 32-bit offset */
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;
		*cp++ = (uchar)0;

		*cp++ = (uchar)(((*lp) & 0xff000000) >> 24);
		*cp++ = (uchar)(((*lp) & 0x00ff0000) >> 16);
		*cp++ = (uchar)(((*lp) & 0x0000ff00) >>  8);
		*cp   = (uchar)( (*lp) & 0x000000ff);
#else
		*cp++ = (uchar) ((*lp)                          >> 56);
		*cp++ = (uchar)(((*lp) & 0x00ff000000000000ULL) >> 48);
		*cp++ = (uchar)(((*lp) & 0x0000ff0000000000ULL) >> 40);
		*cp++ = (uchar)(((*lp) & 0x000000ff00000000ULL) >> 32);
		*cp++ = (uchar)(((*lp) & 0x00000000ff000000ULL) >> 24);
		*cp++ = (uchar)(((*lp) & 0x0000000000ff0000ULL) >> 16);
		*cp++ = (uchar)(((*lp) & 0x000000000000ff00ULL) >>  8);
		*cp   = (uchar)( (*lp) & 0x00000000000000ffULL);
#endif
	}
	*xpp = (void *)((char *)(*xpp) + sizeof_off_t);
	return ENOERR;
}

int
ncx_get_off_t(const void **xpp, off_t *lp, size_t sizeof_off_t)
{
	/* similar to get_ix_int() */
	const uchar *cp = (const uchar *) *xpp;
	assert(sizeof_off_t == 4 || sizeof_off_t == 8);

 	if (sizeof_off_t == 4) {
		*lp =  (off_t)(*cp++ << 24);
		*lp |= (off_t)(*cp++ << 16);
		*lp |= (off_t)(*cp++ <<  8);
		*lp |= (off_t)*cp;
	} else {
#if SIZEOF_OFF_T == 4
/* Read a 64-bit offset on a system with only a 32-bit offset */
/* If the offset overflows, set an error code and return */
		*lp =  ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |= ((off_t)(*cp++));
/*
 * lp now contains the upper 32-bits of the 64-bit offset.  if lp is
 * not zero, then the dataset is larger than can be represented
 * on this system.  Set an error code and return.
 */
		if (*lp != 0) {
		  return NC_ERANGE;
		}

		*lp  = ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;

		if (*lp < 0) {
		  /*
		   * If this fails, then the offset is >2^31, but less
		   * than 2^32 which is not allowed, but is not caught
		   * by the previous check
		   */
		  return NC_ERANGE;
		}
#else
		*lp =  ((off_t)(*cp++) << 56);
		*lp |= ((off_t)(*cp++) << 48);
		*lp |= ((off_t)(*cp++) << 40);
		*lp |= ((off_t)(*cp++) << 32);
		*lp |= ((off_t)(*cp++) << 24);
		*lp |= ((off_t)(*cp++) << 16);
		*lp |= ((off_t)(*cp++) <<  8);
		*lp |=  (off_t)*cp;
#endif
	}
	*xpp = (const void *)((const char *)(*xpp) + sizeof_off_t);
	return ENOERR;
}

/*----< ncx_get_int32() >--------------------------------------------------*/
int
ncx_get_int32(const void **xpp,
              int         *ip)
{
    const uchar *cp = (const uchar *) *xpp;

    /* cannot call swap4b(), as lp is 8-byte */
    *ip  = (*cp++ << 24);
    *ip |= (*cp++ << 16);
    *ip |= (*cp++ <<  8);
    *ip |=  *cp;

    /* advance *xpp 4 bytes */
    *xpp = (void *)((const char *)(*xpp) + 4);

    return NC_NOERR;
}

/*----< ncx_get_int64() >-------------------------------------------------*/
int
ncx_get_int64(const void **xpp,
              long long   *llp)
{
    const uchar *cp = (const uchar *) *xpp;

    /* below is the same as calling swap8b(llp, *xpp) */
    *llp  = ((long long)(*cp++) << 56);
    *llp |= ((long long)(*cp++) << 48);
    *llp |= ((long long)(*cp++) << 40);
    *llp |= ((long long)(*cp++) << 32);
    *llp |= ((long long)(*cp++) << 24);
    *llp |= ((long long)(*cp++) << 16);
    *llp |= ((long long)(*cp++) <<  8);
    *llp |=  (long long)*cp;

    /* advance *xpp 8 bytes */
    *xpp = (void *)((const char *)(*xpp) + 8);

    return NC_NOERR;
}

/*---< ncx_put_int32() >-----------------------------------------------------*/
/* copy the contents of lp (a signed 32-bit integer) to xpp in Big Endian
 * form and advance *xpp 4 bytes
 */
int
ncx_put_int32(void      **xpp,
              const int   ip)
{
#ifdef WORDS_BIGENDIAN
    int *ptr = (int*) (*xpp); /* typecast to 4-byte integer */
    *ptr = ip;
#else
    /* bitwise shifts below are to produce an integer in Big Endian */
    /* cannot call swap4b(), as lp is 8-byte */
    uchar *cp = (uchar *) *xpp;
    *cp++ = (uchar)((ip & 0xff000000) >> 24);
    *cp++ = (uchar)((ip & 0x00ff0000) >> 16);
    *cp++ = (uchar)((ip & 0x0000ff00) >>  8);
    *cp   = (uchar)( ip & 0x000000ff);
#endif
    /* advance *xpp 4 bytes */
    *xpp  = (void *)((char *)(*xpp) + 4);

    return NC_NOERR;
}

/*---< ncx_put_int64() >-----------------------------------------------------*/
/* copy the contents of lp (a signed 64-bit integer) to xpp in Big Endian
 * form and advance *xpp 8 bytes
 */
int
ncx_put_int64(void             **xpp,
              const long long    ip)
{
#ifdef WORDS_BIGENDIAN
    long long *ptr = (long long*) (*xpp); /* typecast to 8-byte integer */
    *ptr = ip;
#else
    uchar *cp = (uchar *) *xpp;
    /* below is the same as calling swap8b(*xpp, &ip) */
    *cp++ = (uchar)((ip & 0xff00000000000000ULL) >> 56);
    *cp++ = (uchar)((ip & 0x00ff000000000000ULL) >> 48);
    *cp++ = (uchar)((ip & 0x0000ff0000000000ULL) >> 40);
    *cp++ = (uchar)((ip & 0x000000ff00000000ULL) >> 32);
    *cp++ = (uchar)((ip & 0x00000000ff000000ULL) >> 24);
    *cp++ = (uchar)((ip & 0x0000000000ff0000ULL) >> 16);
    *cp++ = (uchar)((ip & 0x000000000000ff00ULL) >>  8);
    *cp   = (uchar)( ip & 0x00000000000000ffULL);
#endif
    /* advance *xpp 8 bytes */
    *xpp  = (void *)((char *)(*xpp) + 8);

    return NC_NOERR;
}


/*
 * Aggregate numeric conversion functions.
 */
#line 2093

#line 2530

#line 2536

/* schar ---------------------------------------------------------------------*/

#line 2540
int
ncx_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2543
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2543
	return ENOERR;
#line 2543

}
#line 2546
int
ncx_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2549
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2549
	return ENOERR;
#line 2549

}
int
#line 2551
ncx_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2551
{
#line 2551
	int status = ENOERR;
#line 2551
	schar *xp = (schar *)(*xpp);
#line 2551

#line 2551
	while(nelems-- != 0)
#line 2551
	{
#line 2551

#line 2551
		*tp++ = *xp++;
#line 2551
	}
#line 2551

#line 2551
	*xpp = (const void *)xp;
#line 2551
	return status;
#line 2551
}
#line 2551

int
#line 2552
ncx_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2552
{
#line 2552
	int status = ENOERR;
#line 2552
	schar *xp = (schar *)(*xpp);
#line 2552

#line 2552
	while(nelems-- != 0)
#line 2552
	{
#line 2552

#line 2552
		*tp++ = *xp++;
#line 2552
	}
#line 2552

#line 2552
	*xpp = (const void *)xp;
#line 2552
	return status;
#line 2552
}
#line 2552

int
#line 2553
ncx_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2553
{
#line 2553
	int status = ENOERR;
#line 2553
	schar *xp = (schar *)(*xpp);
#line 2553

#line 2553
	while(nelems-- != 0)
#line 2553
	{
#line 2553

#line 2553
		*tp++ = *xp++;
#line 2553
	}
#line 2553

#line 2553
	*xpp = (const void *)xp;
#line 2553
	return status;
#line 2553
}
#line 2553

int
#line 2554
ncx_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2554
{
#line 2554
	int status = ENOERR;
#line 2554
	schar *xp = (schar *)(*xpp);
#line 2554

#line 2554
	while(nelems-- != 0)
#line 2554
	{
#line 2554

#line 2554
		*tp++ = *xp++;
#line 2554
	}
#line 2554

#line 2554
	*xpp = (const void *)xp;
#line 2554
	return status;
#line 2554
}
#line 2554

int
#line 2555
ncx_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2555
{
#line 2555
	int status = ENOERR;
#line 2555
	schar *xp = (schar *)(*xpp);
#line 2555

#line 2555
	while(nelems-- != 0)
#line 2555
	{
#line 2555

#line 2555
		*tp++ = *xp++;
#line 2555
	}
#line 2555

#line 2555
	*xpp = (const void *)xp;
#line 2555
	return status;
#line 2555
}
#line 2555

int
#line 2556
ncx_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2556
{
#line 2556
	int status = ENOERR;
#line 2556
	schar *xp = (schar *)(*xpp);
#line 2556

#line 2556
	while(nelems-- != 0)
#line 2556
	{
#line 2556
		if (*xp < 0) status = NC_ERANGE;
#line 2556
		*tp++ = *xp++;
#line 2556
	}
#line 2556

#line 2556
	*xpp = (const void *)xp;
#line 2556
	return status;
#line 2556
}
#line 2556

int
#line 2557
ncx_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2557
{
#line 2557
	int status = ENOERR;
#line 2557
	schar *xp = (schar *)(*xpp);
#line 2557

#line 2557
	while(nelems-- != 0)
#line 2557
	{
#line 2557
		if (*xp < 0) status = NC_ERANGE;
#line 2557
		*tp++ = *xp++;
#line 2557
	}
#line 2557

#line 2557
	*xpp = (const void *)xp;
#line 2557
	return status;
#line 2557
}
#line 2557

int
#line 2558
ncx_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2558
{
#line 2558
	int status = ENOERR;
#line 2558
	schar *xp = (schar *)(*xpp);
#line 2558

#line 2558
	while(nelems-- != 0)
#line 2558
	{
#line 2558
		if (*xp < 0) status = NC_ERANGE;
#line 2558
		*tp++ = *xp++;
#line 2558
	}
#line 2558

#line 2558
	*xpp = (const void *)xp;
#line 2558
	return status;
#line 2558
}
#line 2558


#line 2561
int
ncx_pad_getn_schar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2564

#line 2564
	if(rndup)
#line 2564
		rndup = X_ALIGN - rndup;
#line 2564

#line 2564
	(void) memcpy(tp, *xpp, nelems);
#line 2564
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2564

#line 2564
	return ENOERR;
#line 2564

}
#line 2567
int
ncx_pad_getn_schar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2570

#line 2570
	if(rndup)
#line 2570
		rndup = X_ALIGN - rndup;
#line 2570

#line 2570
	(void) memcpy(tp, *xpp, nelems);
#line 2570
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2570

#line 2570
	return ENOERR;
#line 2570

}
int
#line 2572
ncx_pad_getn_schar_short(const void **xpp, size_t nelems, short *tp)
#line 2572
{
#line 2572
	int status = ENOERR;
#line 2572
	size_t rndup = nelems % X_ALIGN;
#line 2572
	schar *xp = (schar *) *xpp;
#line 2572

#line 2572
	if(rndup)
#line 2572
		rndup = X_ALIGN - rndup;
#line 2572

#line 2572
	while(nelems-- != 0)
#line 2572
	{
#line 2572

#line 2572
		*tp++ = *xp++;
#line 2572
	}
#line 2572

#line 2572
	*xpp = (void *)(xp + rndup);
#line 2572
	return status;
#line 2572
}
#line 2572

int
#line 2573
ncx_pad_getn_schar_int(const void **xpp, size_t nelems, int *tp)
#line 2573
{
#line 2573
	int status = ENOERR;
#line 2573
	size_t rndup = nelems % X_ALIGN;
#line 2573
	schar *xp = (schar *) *xpp;
#line 2573

#line 2573
	if(rndup)
#line 2573
		rndup = X_ALIGN - rndup;
#line 2573

#line 2573
	while(nelems-- != 0)
#line 2573
	{
#line 2573

#line 2573
		*tp++ = *xp++;
#line 2573
	}
#line 2573

#line 2573
	*xpp = (void *)(xp + rndup);
#line 2573
	return status;
#line 2573
}
#line 2573

int
#line 2574
ncx_pad_getn_schar_float(const void **xpp, size_t nelems, float *tp)
#line 2574
{
#line 2574
	int status = ENOERR;
#line 2574
	size_t rndup = nelems % X_ALIGN;
#line 2574
	schar *xp = (schar *) *xpp;
#line 2574

#line 2574
	if(rndup)
#line 2574
		rndup = X_ALIGN - rndup;
#line 2574

#line 2574
	while(nelems-- != 0)
#line 2574
	{
#line 2574

#line 2574
		*tp++ = *xp++;
#line 2574
	}
#line 2574

#line 2574
	*xpp = (void *)(xp + rndup);
#line 2574
	return status;
#line 2574
}
#line 2574

int
#line 2575
ncx_pad_getn_schar_double(const void **xpp, size_t nelems, double *tp)
#line 2575
{
#line 2575
	int status = ENOERR;
#line 2575
	size_t rndup = nelems % X_ALIGN;
#line 2575
	schar *xp = (schar *) *xpp;
#line 2575

#line 2575
	if(rndup)
#line 2575
		rndup = X_ALIGN - rndup;
#line 2575

#line 2575
	while(nelems-- != 0)
#line 2575
	{
#line 2575

#line 2575
		*tp++ = *xp++;
#line 2575
	}
#line 2575

#line 2575
	*xpp = (void *)(xp + rndup);
#line 2575
	return status;
#line 2575
}
#line 2575

int
#line 2576
ncx_pad_getn_schar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2576
{
#line 2576
	int status = ENOERR;
#line 2576
	size_t rndup = nelems % X_ALIGN;
#line 2576
	schar *xp = (schar *) *xpp;
#line 2576

#line 2576
	if(rndup)
#line 2576
		rndup = X_ALIGN - rndup;
#line 2576

#line 2576
	while(nelems-- != 0)
#line 2576
	{
#line 2576

#line 2576
		*tp++ = *xp++;
#line 2576
	}
#line 2576

#line 2576
	*xpp = (void *)(xp + rndup);
#line 2576
	return status;
#line 2576
}
#line 2576

int
#line 2577
ncx_pad_getn_schar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2577
{
#line 2577
	int status = ENOERR;
#line 2577
	size_t rndup = nelems % X_ALIGN;
#line 2577
	schar *xp = (schar *) *xpp;
#line 2577

#line 2577
	if(rndup)
#line 2577
		rndup = X_ALIGN - rndup;
#line 2577

#line 2577
	while(nelems-- != 0)
#line 2577
	{
#line 2577
		if (*xp < 0) status = NC_ERANGE;
#line 2577
		*tp++ = *xp++;
#line 2577
	}
#line 2577

#line 2577
	*xpp = (void *)(xp + rndup);
#line 2577
	return status;
#line 2577
}
#line 2577

int
#line 2578
ncx_pad_getn_schar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2578
{
#line 2578
	int status = ENOERR;
#line 2578
	size_t rndup = nelems % X_ALIGN;
#line 2578
	schar *xp = (schar *) *xpp;
#line 2578

#line 2578
	if(rndup)
#line 2578
		rndup = X_ALIGN - rndup;
#line 2578

#line 2578
	while(nelems-- != 0)
#line 2578
	{
#line 2578
		if (*xp < 0) status = NC_ERANGE;
#line 2578
		*tp++ = *xp++;
#line 2578
	}
#line 2578

#line 2578
	*xpp = (void *)(xp + rndup);
#line 2578
	return status;
#line 2578
}
#line 2578

int
#line 2579
ncx_pad_getn_schar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2579
{
#line 2579
	int status = ENOERR;
#line 2579
	size_t rndup = nelems % X_ALIGN;
#line 2579
	schar *xp = (schar *) *xpp;
#line 2579

#line 2579
	if(rndup)
#line 2579
		rndup = X_ALIGN - rndup;
#line 2579

#line 2579
	while(nelems-- != 0)
#line 2579
	{
#line 2579
		if (*xp < 0) status = NC_ERANGE;
#line 2579
		*tp++ = *xp++;
#line 2579
	}
#line 2579

#line 2579
	*xpp = (void *)(xp + rndup);
#line 2579
	return status;
#line 2579
}
#line 2579


#line 2582
int
ncx_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2585
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2585

#line 2585
	return ENOERR;
#line 2585

}
#line 2588
int
ncx_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2591
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2591

#line 2591
	return ENOERR;
#line 2591

}
int
#line 2593
ncx_putn_schar_short(void **xpp, size_t nelems, const short *tp)
#line 2593
{
#line 2593
	int status = ENOERR;
#line 2593
	schar *xp = (schar *) *xpp;
#line 2593

#line 2593
	while(nelems-- != 0)
#line 2593
	{
#line 2593
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2593
			status = NC_ERANGE;
#line 2593
		*xp++ = (schar) *tp++;
#line 2593
	}
#line 2593

#line 2593
	*xpp = (void *)xp;
#line 2593
	return status;
#line 2593
}
#line 2593

int
#line 2594
ncx_putn_schar_int(void **xpp, size_t nelems, const int *tp)
#line 2594
{
#line 2594
	int status = ENOERR;
#line 2594
	schar *xp = (schar *) *xpp;
#line 2594

#line 2594
	while(nelems-- != 0)
#line 2594
	{
#line 2594
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2594
			status = NC_ERANGE;
#line 2594
		*xp++ = (schar) *tp++;
#line 2594
	}
#line 2594

#line 2594
	*xpp = (void *)xp;
#line 2594
	return status;
#line 2594
}
#line 2594

int
#line 2595
ncx_putn_schar_float(void **xpp, size_t nelems, const float *tp)
#line 2595
{
#line 2595
	int status = ENOERR;
#line 2595
	schar *xp = (schar *) *xpp;
#line 2595

#line 2595
	while(nelems-- != 0)
#line 2595
	{
#line 2595
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2595
			status = NC_ERANGE;
#line 2595
		*xp++ = (schar) *tp++;
#line 2595
	}
#line 2595

#line 2595
	*xpp = (void *)xp;
#line 2595
	return status;
#line 2595
}
#line 2595

int
#line 2596
ncx_putn_schar_double(void **xpp, size_t nelems, const double *tp)
#line 2596
{
#line 2596
	int status = ENOERR;
#line 2596
	schar *xp = (schar *) *xpp;
#line 2596

#line 2596
	while(nelems-- != 0)
#line 2596
	{
#line 2596
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2596
			status = NC_ERANGE;
#line 2596
		*xp++ = (schar) *tp++;
#line 2596
	}
#line 2596

#line 2596
	*xpp = (void *)xp;
#line 2596
	return status;
#line 2596
}
#line 2596

int
#line 2597
ncx_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2597
{
#line 2597
	int status = ENOERR;
#line 2597
	schar *xp = (schar *) *xpp;
#line 2597

#line 2597
	while(nelems-- != 0)
#line 2597
	{
#line 2597
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2597
			status = NC_ERANGE;
#line 2597
		*xp++ = (schar) *tp++;
#line 2597
	}
#line 2597

#line 2597
	*xpp = (void *)xp;
#line 2597
	return status;
#line 2597
}
#line 2597

int
#line 2598
ncx_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2598
{
#line 2598
	int status = ENOERR;
#line 2598
	schar *xp = (schar *) *xpp;
#line 2598

#line 2598
	while(nelems-- != 0)
#line 2598
	{
#line 2598
		if(*tp > X_SCHAR_MAX )
#line 2598
			status = NC_ERANGE;
#line 2598
		*xp++ = (schar) *tp++;
#line 2598
	}
#line 2598

#line 2598
	*xpp = (void *)xp;
#line 2598
	return status;
#line 2598
}
#line 2598

int
#line 2599
ncx_putn_schar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2599
{
#line 2599
	int status = ENOERR;
#line 2599
	schar *xp = (schar *) *xpp;
#line 2599

#line 2599
	while(nelems-- != 0)
#line 2599
	{
#line 2599
		if(*tp > X_SCHAR_MAX )
#line 2599
			status = NC_ERANGE;
#line 2599
		*xp++ = (schar) *tp++;
#line 2599
	}
#line 2599

#line 2599
	*xpp = (void *)xp;
#line 2599
	return status;
#line 2599
}
#line 2599

int
#line 2600
ncx_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2600
{
#line 2600
	int status = ENOERR;
#line 2600
	schar *xp = (schar *) *xpp;
#line 2600

#line 2600
	while(nelems-- != 0)
#line 2600
	{
#line 2600
		if(*tp > X_SCHAR_MAX )
#line 2600
			status = NC_ERANGE;
#line 2600
		*xp++ = (schar) *tp++;
#line 2600
	}
#line 2600

#line 2600
	*xpp = (void *)xp;
#line 2600
	return status;
#line 2600
}
#line 2600


#line 2603
int
ncx_pad_putn_schar_schar(void **xpp, size_t nelems, const schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2606

#line 2606
	if(rndup)
#line 2606
		rndup = X_ALIGN - rndup;
#line 2606

#line 2606
	(void) memcpy(*xpp, tp, nelems);
#line 2606
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2606

#line 2606
	if(rndup)
#line 2606
	{
#line 2606
		(void) memcpy(*xpp, nada, rndup);
#line 2606
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2606
	}
#line 2606

#line 2606
	return ENOERR;
#line 2606

}
#line 2609
int
ncx_pad_putn_schar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2612

#line 2612
	if(rndup)
#line 2612
		rndup = X_ALIGN - rndup;
#line 2612

#line 2612
	(void) memcpy(*xpp, tp, nelems);
#line 2612
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2612

#line 2612
	if(rndup)
#line 2612
	{
#line 2612
		(void) memcpy(*xpp, nada, rndup);
#line 2612
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2612
	}
#line 2612

#line 2612
	return ENOERR;
#line 2612

}
int
#line 2614
ncx_pad_putn_schar_short(void **xpp, size_t nelems, const short *tp)
#line 2614
{
#line 2614
	int status = ENOERR;
#line 2614
	size_t rndup = nelems % X_ALIGN;
#line 2614
	schar *xp = (schar *) *xpp;
#line 2614

#line 2614
	if(rndup)
#line 2614
		rndup = X_ALIGN - rndup;
#line 2614

#line 2614
	while(nelems-- != 0)
#line 2614
	{
#line 2614
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2614
			status = NC_ERANGE;
#line 2614
		*xp++ = (schar) *tp++;
#line 2614
	}
#line 2614

#line 2614

#line 2614
	if(rndup)
#line 2614
	{
#line 2614
		(void) memcpy(xp, nada, rndup);
#line 2614
		xp += rndup;
#line 2614
	}
#line 2614

#line 2614
	*xpp = (void *)xp;
#line 2614
	return status;
#line 2614
}
#line 2614

int
#line 2615
ncx_pad_putn_schar_int(void **xpp, size_t nelems, const int *tp)
#line 2615
{
#line 2615
	int status = ENOERR;
#line 2615
	size_t rndup = nelems % X_ALIGN;
#line 2615
	schar *xp = (schar *) *xpp;
#line 2615

#line 2615
	if(rndup)
#line 2615
		rndup = X_ALIGN - rndup;
#line 2615

#line 2615
	while(nelems-- != 0)
#line 2615
	{
#line 2615
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2615
			status = NC_ERANGE;
#line 2615
		*xp++ = (schar) *tp++;
#line 2615
	}
#line 2615

#line 2615

#line 2615
	if(rndup)
#line 2615
	{
#line 2615
		(void) memcpy(xp, nada, rndup);
#line 2615
		xp += rndup;
#line 2615
	}
#line 2615

#line 2615
	*xpp = (void *)xp;
#line 2615
	return status;
#line 2615
}
#line 2615

int
#line 2616
ncx_pad_putn_schar_float(void **xpp, size_t nelems, const float *tp)
#line 2616
{
#line 2616
	int status = ENOERR;
#line 2616
	size_t rndup = nelems % X_ALIGN;
#line 2616
	schar *xp = (schar *) *xpp;
#line 2616

#line 2616
	if(rndup)
#line 2616
		rndup = X_ALIGN - rndup;
#line 2616

#line 2616
	while(nelems-- != 0)
#line 2616
	{
#line 2616
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2616
			status = NC_ERANGE;
#line 2616
		*xp++ = (schar) *tp++;
#line 2616
	}
#line 2616

#line 2616

#line 2616
	if(rndup)
#line 2616
	{
#line 2616
		(void) memcpy(xp, nada, rndup);
#line 2616
		xp += rndup;
#line 2616
	}
#line 2616

#line 2616
	*xpp = (void *)xp;
#line 2616
	return status;
#line 2616
}
#line 2616

int
#line 2617
ncx_pad_putn_schar_double(void **xpp, size_t nelems, const double *tp)
#line 2617
{
#line 2617
	int status = ENOERR;
#line 2617
	size_t rndup = nelems % X_ALIGN;
#line 2617
	schar *xp = (schar *) *xpp;
#line 2617

#line 2617
	if(rndup)
#line 2617
		rndup = X_ALIGN - rndup;
#line 2617

#line 2617
	while(nelems-- != 0)
#line 2617
	{
#line 2617
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2617
			status = NC_ERANGE;
#line 2617
		*xp++ = (schar) *tp++;
#line 2617
	}
#line 2617

#line 2617

#line 2617
	if(rndup)
#line 2617
	{
#line 2617
		(void) memcpy(xp, nada, rndup);
#line 2617
		xp += rndup;
#line 2617
	}
#line 2617

#line 2617
	*xpp = (void *)xp;
#line 2617
	return status;
#line 2617
}
#line 2617

int
#line 2618
ncx_pad_putn_schar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2618
{
#line 2618
	int status = ENOERR;
#line 2618
	size_t rndup = nelems % X_ALIGN;
#line 2618
	schar *xp = (schar *) *xpp;
#line 2618

#line 2618
	if(rndup)
#line 2618
		rndup = X_ALIGN - rndup;
#line 2618

#line 2618
	while(nelems-- != 0)
#line 2618
	{
#line 2618
		if(*tp > X_SCHAR_MAX || *tp < X_SCHAR_MIN)
#line 2618
			status = NC_ERANGE;
#line 2618
		*xp++ = (schar) *tp++;
#line 2618
	}
#line 2618

#line 2618

#line 2618
	if(rndup)
#line 2618
	{
#line 2618
		(void) memcpy(xp, nada, rndup);
#line 2618
		xp += rndup;
#line 2618
	}
#line 2618

#line 2618
	*xpp = (void *)xp;
#line 2618
	return status;
#line 2618
}
#line 2618

int
#line 2619
ncx_pad_putn_schar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2619
{
#line 2619
	int status = ENOERR;
#line 2619
	size_t rndup = nelems % X_ALIGN;
#line 2619
	schar *xp = (schar *) *xpp;
#line 2619

#line 2619
	if(rndup)
#line 2619
		rndup = X_ALIGN - rndup;
#line 2619

#line 2619
	while(nelems-- != 0)
#line 2619
	{
#line 2619
		if(*tp > X_SCHAR_MAX )
#line 2619
			status = NC_ERANGE;
#line 2619
		*xp++ = (schar) *tp++;
#line 2619
	}
#line 2619

#line 2619

#line 2619
	if(rndup)
#line 2619
	{
#line 2619
		(void) memcpy(xp, nada, rndup);
#line 2619
		xp += rndup;
#line 2619
	}
#line 2619

#line 2619
	*xpp = (void *)xp;
#line 2619
	return status;
#line 2619
}
#line 2619

int
#line 2620
ncx_pad_putn_schar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2620
{
#line 2620
	int status = ENOERR;
#line 2620
	size_t rndup = nelems % X_ALIGN;
#line 2620
	schar *xp = (schar *) *xpp;
#line 2620

#line 2620
	if(rndup)
#line 2620
		rndup = X_ALIGN - rndup;
#line 2620

#line 2620
	while(nelems-- != 0)
#line 2620
	{
#line 2620
		if(*tp > X_SCHAR_MAX )
#line 2620
			status = NC_ERANGE;
#line 2620
		*xp++ = (schar) *tp++;
#line 2620
	}
#line 2620

#line 2620

#line 2620
	if(rndup)
#line 2620
	{
#line 2620
		(void) memcpy(xp, nada, rndup);
#line 2620
		xp += rndup;
#line 2620
	}
#line 2620

#line 2620
	*xpp = (void *)xp;
#line 2620
	return status;
#line 2620
}
#line 2620

int
#line 2621
ncx_pad_putn_schar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2621
{
#line 2621
	int status = ENOERR;
#line 2621
	size_t rndup = nelems % X_ALIGN;
#line 2621
	schar *xp = (schar *) *xpp;
#line 2621

#line 2621
	if(rndup)
#line 2621
		rndup = X_ALIGN - rndup;
#line 2621

#line 2621
	while(nelems-- != 0)
#line 2621
	{
#line 2621
		if(*tp > X_SCHAR_MAX )
#line 2621
			status = NC_ERANGE;
#line 2621
		*xp++ = (schar) *tp++;
#line 2621
	}
#line 2621

#line 2621

#line 2621
	if(rndup)
#line 2621
	{
#line 2621
		(void) memcpy(xp, nada, rndup);
#line 2621
		xp += rndup;
#line 2621
	}
#line 2621

#line 2621
	*xpp = (void *)xp;
#line 2621
	return status;
#line 2621
}
#line 2621


/* uchar ---------------------------------------------------------------------*/
#line 2626
int
ncx_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2629
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2629
	return ENOERR;
#line 2629

}
#line 2632
int
ncx_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2635
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2635
	return ENOERR;
#line 2635

}
int
#line 2637
ncx_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2637
{
#line 2637
	int status = ENOERR;
#line 2637
	uchar *xp = (uchar *)(*xpp);
#line 2637

#line 2637
	while(nelems-- != 0)
#line 2637
	{
#line 2637

#line 2637
		*tp++ = *xp++;
#line 2637
	}
#line 2637

#line 2637
	*xpp = (const void *)xp;
#line 2637
	return status;
#line 2637
}
#line 2637

int
#line 2638
ncx_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2638
{
#line 2638
	int status = ENOERR;
#line 2638
	uchar *xp = (uchar *)(*xpp);
#line 2638

#line 2638
	while(nelems-- != 0)
#line 2638
	{
#line 2638

#line 2638
		*tp++ = *xp++;
#line 2638
	}
#line 2638

#line 2638
	*xpp = (const void *)xp;
#line 2638
	return status;
#line 2638
}
#line 2638

int
#line 2639
ncx_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2639
{
#line 2639
	int status = ENOERR;
#line 2639
	uchar *xp = (uchar *)(*xpp);
#line 2639

#line 2639
	while(nelems-- != 0)
#line 2639
	{
#line 2639

#line 2639
		*tp++ = *xp++;
#line 2639
	}
#line 2639

#line 2639
	*xpp = (const void *)xp;
#line 2639
	return status;
#line 2639
}
#line 2639

int
#line 2640
ncx_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2640
{
#line 2640
	int status = ENOERR;
#line 2640
	uchar *xp = (uchar *)(*xpp);
#line 2640

#line 2640
	while(nelems-- != 0)
#line 2640
	{
#line 2640

#line 2640
		*tp++ = *xp++;
#line 2640
	}
#line 2640

#line 2640
	*xpp = (const void *)xp;
#line 2640
	return status;
#line 2640
}
#line 2640

int
#line 2641
ncx_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2641
{
#line 2641
	int status = ENOERR;
#line 2641
	uchar *xp = (uchar *)(*xpp);
#line 2641

#line 2641
	while(nelems-- != 0)
#line 2641
	{
#line 2641

#line 2641
		*tp++ = *xp++;
#line 2641
	}
#line 2641

#line 2641
	*xpp = (const void *)xp;
#line 2641
	return status;
#line 2641
}
#line 2641

int
#line 2642
ncx_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2642
{
#line 2642
	int status = ENOERR;
#line 2642
	uchar *xp = (uchar *)(*xpp);
#line 2642

#line 2642
	while(nelems-- != 0)
#line 2642
	{
#line 2642

#line 2642
		*tp++ = *xp++;
#line 2642
	}
#line 2642

#line 2642
	*xpp = (const void *)xp;
#line 2642
	return status;
#line 2642
}
#line 2642

int
#line 2643
ncx_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2643
{
#line 2643
	int status = ENOERR;
#line 2643
	uchar *xp = (uchar *)(*xpp);
#line 2643

#line 2643
	while(nelems-- != 0)
#line 2643
	{
#line 2643

#line 2643
		*tp++ = *xp++;
#line 2643
	}
#line 2643

#line 2643
	*xpp = (const void *)xp;
#line 2643
	return status;
#line 2643
}
#line 2643

int
#line 2644
ncx_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2644
{
#line 2644
	int status = ENOERR;
#line 2644
	uchar *xp = (uchar *)(*xpp);
#line 2644

#line 2644
	while(nelems-- != 0)
#line 2644
	{
#line 2644

#line 2644
		*tp++ = *xp++;
#line 2644
	}
#line 2644

#line 2644
	*xpp = (const void *)xp;
#line 2644
	return status;
#line 2644
}
#line 2644


/* uchar ---------------------------------------------------------------------*/
#line 2649
int
ncx_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2652
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2652
	return ENOERR;
#line 2652

}
#line 2655
int
ncx_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		(void) memcpy(tp, *xpp, nelems);
#line 2658
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2658
	return ENOERR;
#line 2658

}
int
#line 2660
ncx_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2660
{
#line 2660
	int status = ENOERR;
#line 2660
	uchar *xp = (uchar *)(*xpp);
#line 2660

#line 2660
	while(nelems-- != 0)
#line 2660
	{
#line 2660

#line 2660
		*tp++ = *xp++;
#line 2660
	}
#line 2660

#line 2660
	*xpp = (const void *)xp;
#line 2660
	return status;
#line 2660
}
#line 2660

int
#line 2661
ncx_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2661
{
#line 2661
	int status = ENOERR;
#line 2661
	uchar *xp = (uchar *)(*xpp);
#line 2661

#line 2661
	while(nelems-- != 0)
#line 2661
	{
#line 2661

#line 2661
		*tp++ = *xp++;
#line 2661
	}
#line 2661

#line 2661
	*xpp = (const void *)xp;
#line 2661
	return status;
#line 2661
}
#line 2661

int
#line 2662
ncx_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2662
{
#line 2662
	int status = ENOERR;
#line 2662
	uchar *xp = (uchar *)(*xpp);
#line 2662

#line 2662
	while(nelems-- != 0)
#line 2662
	{
#line 2662

#line 2662
		*tp++ = *xp++;
#line 2662
	}
#line 2662

#line 2662
	*xpp = (const void *)xp;
#line 2662
	return status;
#line 2662
}
#line 2662

int
#line 2663
ncx_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2663
{
#line 2663
	int status = ENOERR;
#line 2663
	uchar *xp = (uchar *)(*xpp);
#line 2663

#line 2663
	while(nelems-- != 0)
#line 2663
	{
#line 2663

#line 2663
		*tp++ = *xp++;
#line 2663
	}
#line 2663

#line 2663
	*xpp = (const void *)xp;
#line 2663
	return status;
#line 2663
}
#line 2663

int
#line 2664
ncx_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2664
{
#line 2664
	int status = ENOERR;
#line 2664
	uchar *xp = (uchar *)(*xpp);
#line 2664

#line 2664
	while(nelems-- != 0)
#line 2664
	{
#line 2664

#line 2664
		*tp++ = *xp++;
#line 2664
	}
#line 2664

#line 2664
	*xpp = (const void *)xp;
#line 2664
	return status;
#line 2664
}
#line 2664

int
#line 2665
ncx_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2665
{
#line 2665
	int status = ENOERR;
#line 2665
	uchar *xp = (uchar *)(*xpp);
#line 2665

#line 2665
	while(nelems-- != 0)
#line 2665
	{
#line 2665

#line 2665
		*tp++ = *xp++;
#line 2665
	}
#line 2665

#line 2665
	*xpp = (const void *)xp;
#line 2665
	return status;
#line 2665
}
#line 2665

int
#line 2666
ncx_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2666
{
#line 2666
	int status = ENOERR;
#line 2666
	uchar *xp = (uchar *)(*xpp);
#line 2666

#line 2666
	while(nelems-- != 0)
#line 2666
	{
#line 2666

#line 2666
		*tp++ = *xp++;
#line 2666
	}
#line 2666

#line 2666
	*xpp = (const void *)xp;
#line 2666
	return status;
#line 2666
}
#line 2666

int
#line 2667
ncx_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2667
{
#line 2667
	int status = ENOERR;
#line 2667
	uchar *xp = (uchar *)(*xpp);
#line 2667

#line 2667
	while(nelems-- != 0)
#line 2667
	{
#line 2667

#line 2667
		*tp++ = *xp++;
#line 2667
	}
#line 2667

#line 2667
	*xpp = (const void *)xp;
#line 2667
	return status;
#line 2667
}
#line 2667


#line 2670
int
ncx_pad_getn_uchar_schar(const void **xpp, size_t nelems, schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2673

#line 2673
	if(rndup)
#line 2673
		rndup = X_ALIGN - rndup;
#line 2673

#line 2673
	(void) memcpy(tp, *xpp, nelems);
#line 2673
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2673

#line 2673
	return ENOERR;
#line 2673

}
#line 2676
int
ncx_pad_getn_uchar_uchar(const void **xpp, size_t nelems, uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2679

#line 2679
	if(rndup)
#line 2679
		rndup = X_ALIGN - rndup;
#line 2679

#line 2679
	(void) memcpy(tp, *xpp, nelems);
#line 2679
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 2679

#line 2679
	return ENOERR;
#line 2679

}
int
#line 2681
ncx_pad_getn_uchar_short(const void **xpp, size_t nelems, short *tp)
#line 2681
{
#line 2681
	int status = ENOERR;
#line 2681
	size_t rndup = nelems % X_ALIGN;
#line 2681
	uchar *xp = (uchar *) *xpp;
#line 2681

#line 2681
	if(rndup)
#line 2681
		rndup = X_ALIGN - rndup;
#line 2681

#line 2681
	while(nelems-- != 0)
#line 2681
	{
#line 2681

#line 2681
		*tp++ = *xp++;
#line 2681
	}
#line 2681

#line 2681
	*xpp = (void *)(xp + rndup);
#line 2681
	return status;
#line 2681
}
#line 2681

int
#line 2682
ncx_pad_getn_uchar_int(const void **xpp, size_t nelems, int *tp)
#line 2682
{
#line 2682
	int status = ENOERR;
#line 2682
	size_t rndup = nelems % X_ALIGN;
#line 2682
	uchar *xp = (uchar *) *xpp;
#line 2682

#line 2682
	if(rndup)
#line 2682
		rndup = X_ALIGN - rndup;
#line 2682

#line 2682
	while(nelems-- != 0)
#line 2682
	{
#line 2682

#line 2682
		*tp++ = *xp++;
#line 2682
	}
#line 2682

#line 2682
	*xpp = (void *)(xp + rndup);
#line 2682
	return status;
#line 2682
}
#line 2682

int
#line 2683
ncx_pad_getn_uchar_float(const void **xpp, size_t nelems, float *tp)
#line 2683
{
#line 2683
	int status = ENOERR;
#line 2683
	size_t rndup = nelems % X_ALIGN;
#line 2683
	uchar *xp = (uchar *) *xpp;
#line 2683

#line 2683
	if(rndup)
#line 2683
		rndup = X_ALIGN - rndup;
#line 2683

#line 2683
	while(nelems-- != 0)
#line 2683
	{
#line 2683

#line 2683
		*tp++ = *xp++;
#line 2683
	}
#line 2683

#line 2683
	*xpp = (void *)(xp + rndup);
#line 2683
	return status;
#line 2683
}
#line 2683

int
#line 2684
ncx_pad_getn_uchar_double(const void **xpp, size_t nelems, double *tp)
#line 2684
{
#line 2684
	int status = ENOERR;
#line 2684
	size_t rndup = nelems % X_ALIGN;
#line 2684
	uchar *xp = (uchar *) *xpp;
#line 2684

#line 2684
	if(rndup)
#line 2684
		rndup = X_ALIGN - rndup;
#line 2684

#line 2684
	while(nelems-- != 0)
#line 2684
	{
#line 2684

#line 2684
		*tp++ = *xp++;
#line 2684
	}
#line 2684

#line 2684
	*xpp = (void *)(xp + rndup);
#line 2684
	return status;
#line 2684
}
#line 2684

int
#line 2685
ncx_pad_getn_uchar_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2685
{
#line 2685
	int status = ENOERR;
#line 2685
	size_t rndup = nelems % X_ALIGN;
#line 2685
	uchar *xp = (uchar *) *xpp;
#line 2685

#line 2685
	if(rndup)
#line 2685
		rndup = X_ALIGN - rndup;
#line 2685

#line 2685
	while(nelems-- != 0)
#line 2685
	{
#line 2685

#line 2685
		*tp++ = *xp++;
#line 2685
	}
#line 2685

#line 2685
	*xpp = (void *)(xp + rndup);
#line 2685
	return status;
#line 2685
}
#line 2685

int
#line 2686
ncx_pad_getn_uchar_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2686
{
#line 2686
	int status = ENOERR;
#line 2686
	size_t rndup = nelems % X_ALIGN;
#line 2686
	uchar *xp = (uchar *) *xpp;
#line 2686

#line 2686
	if(rndup)
#line 2686
		rndup = X_ALIGN - rndup;
#line 2686

#line 2686
	while(nelems-- != 0)
#line 2686
	{
#line 2686

#line 2686
		*tp++ = *xp++;
#line 2686
	}
#line 2686

#line 2686
	*xpp = (void *)(xp + rndup);
#line 2686
	return status;
#line 2686
}
#line 2686

int
#line 2687
ncx_pad_getn_uchar_uint(const void **xpp, size_t nelems, uint *tp)
#line 2687
{
#line 2687
	int status = ENOERR;
#line 2687
	size_t rndup = nelems % X_ALIGN;
#line 2687
	uchar *xp = (uchar *) *xpp;
#line 2687

#line 2687
	if(rndup)
#line 2687
		rndup = X_ALIGN - rndup;
#line 2687

#line 2687
	while(nelems-- != 0)
#line 2687
	{
#line 2687

#line 2687
		*tp++ = *xp++;
#line 2687
	}
#line 2687

#line 2687
	*xpp = (void *)(xp + rndup);
#line 2687
	return status;
#line 2687
}
#line 2687

int
#line 2688
ncx_pad_getn_uchar_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2688
{
#line 2688
	int status = ENOERR;
#line 2688
	size_t rndup = nelems % X_ALIGN;
#line 2688
	uchar *xp = (uchar *) *xpp;
#line 2688

#line 2688
	if(rndup)
#line 2688
		rndup = X_ALIGN - rndup;
#line 2688

#line 2688
	while(nelems-- != 0)
#line 2688
	{
#line 2688

#line 2688
		*tp++ = *xp++;
#line 2688
	}
#line 2688

#line 2688
	*xpp = (void *)(xp + rndup);
#line 2688
	return status;
#line 2688
}
#line 2688


#line 2691
int
ncx_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2694
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2694

#line 2694
	return ENOERR;
#line 2694

}
#line 2697
int
ncx_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		(void) memcpy(*xpp, tp, nelems);
#line 2700
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2700

#line 2700
	return ENOERR;
#line 2700

}
int
#line 2702
ncx_putn_uchar_short(void **xpp, size_t nelems, const short *tp)
#line 2702
{
#line 2702
	int status = ENOERR;
#line 2702
	uchar *xp = (uchar *) *xpp;
#line 2702

#line 2702
	while(nelems-- != 0)
#line 2702
	{
#line 2702
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2702
			status = NC_ERANGE;
#line 2702
		*xp++ = (uchar) *tp++;
#line 2702
	}
#line 2702

#line 2702
	*xpp = (void *)xp;
#line 2702
	return status;
#line 2702
}
#line 2702

int
#line 2703
ncx_putn_uchar_int(void **xpp, size_t nelems, const int *tp)
#line 2703
{
#line 2703
	int status = ENOERR;
#line 2703
	uchar *xp = (uchar *) *xpp;
#line 2703

#line 2703
	while(nelems-- != 0)
#line 2703
	{
#line 2703
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2703
			status = NC_ERANGE;
#line 2703
		*xp++ = (uchar) *tp++;
#line 2703
	}
#line 2703

#line 2703
	*xpp = (void *)xp;
#line 2703
	return status;
#line 2703
}
#line 2703

int
#line 2704
ncx_putn_uchar_float(void **xpp, size_t nelems, const float *tp)
#line 2704
{
#line 2704
	int status = ENOERR;
#line 2704
	uchar *xp = (uchar *) *xpp;
#line 2704

#line 2704
	while(nelems-- != 0)
#line 2704
	{
#line 2704
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2704
			status = NC_ERANGE;
#line 2704
		*xp++ = (uchar) *tp++;
#line 2704
	}
#line 2704

#line 2704
	*xpp = (void *)xp;
#line 2704
	return status;
#line 2704
}
#line 2704

int
#line 2705
ncx_putn_uchar_double(void **xpp, size_t nelems, const double *tp)
#line 2705
{
#line 2705
	int status = ENOERR;
#line 2705
	uchar *xp = (uchar *) *xpp;
#line 2705

#line 2705
	while(nelems-- != 0)
#line 2705
	{
#line 2705
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2705
			status = NC_ERANGE;
#line 2705
		*xp++ = (uchar) *tp++;
#line 2705
	}
#line 2705

#line 2705
	*xpp = (void *)xp;
#line 2705
	return status;
#line 2705
}
#line 2705

int
#line 2706
ncx_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2706
{
#line 2706
	int status = ENOERR;
#line 2706
	uchar *xp = (uchar *) *xpp;
#line 2706

#line 2706
	while(nelems-- != 0)
#line 2706
	{
#line 2706
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2706
			status = NC_ERANGE;
#line 2706
		*xp++ = (uchar) *tp++;
#line 2706
	}
#line 2706

#line 2706
	*xpp = (void *)xp;
#line 2706
	return status;
#line 2706
}
#line 2706

int
#line 2707
ncx_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2707
{
#line 2707
	int status = ENOERR;
#line 2707
	uchar *xp = (uchar *) *xpp;
#line 2707

#line 2707
	while(nelems-- != 0)
#line 2707
	{
#line 2707
		if(*tp > X_UCHAR_MAX )
#line 2707
			status = NC_ERANGE;
#line 2707
		*xp++ = (uchar) *tp++;
#line 2707
	}
#line 2707

#line 2707
	*xpp = (void *)xp;
#line 2707
	return status;
#line 2707
}
#line 2707

int
#line 2708
ncx_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2708
{
#line 2708
	int status = ENOERR;
#line 2708
	uchar *xp = (uchar *) *xpp;
#line 2708

#line 2708
	while(nelems-- != 0)
#line 2708
	{
#line 2708
		if(*tp > X_UCHAR_MAX )
#line 2708
			status = NC_ERANGE;
#line 2708
		*xp++ = (uchar) *tp++;
#line 2708
	}
#line 2708

#line 2708
	*xpp = (void *)xp;
#line 2708
	return status;
#line 2708
}
#line 2708

int
#line 2709
ncx_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2709
{
#line 2709
	int status = ENOERR;
#line 2709
	uchar *xp = (uchar *) *xpp;
#line 2709

#line 2709
	while(nelems-- != 0)
#line 2709
	{
#line 2709
		if(*tp > X_UCHAR_MAX )
#line 2709
			status = NC_ERANGE;
#line 2709
		*xp++ = (uchar) *tp++;
#line 2709
	}
#line 2709

#line 2709
	*xpp = (void *)xp;
#line 2709
	return status;
#line 2709
}
#line 2709


#line 2712
int
ncx_pad_putn_uchar_schar(void **xpp, size_t nelems, const schar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2715

#line 2715
	if(rndup)
#line 2715
		rndup = X_ALIGN - rndup;
#line 2715

#line 2715
	(void) memcpy(*xpp, tp, nelems);
#line 2715
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2715

#line 2715
	if(rndup)
#line 2715
	{
#line 2715
		(void) memcpy(*xpp, nada, rndup);
#line 2715
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2715
	}
#line 2715

#line 2715
	return ENOERR;
#line 2715

}
#line 2718
int
ncx_pad_putn_uchar_uchar(void **xpp, size_t nelems, const uchar *tp)
{
		size_t rndup = nelems % X_ALIGN;
#line 2721

#line 2721
	if(rndup)
#line 2721
		rndup = X_ALIGN - rndup;
#line 2721

#line 2721
	(void) memcpy(*xpp, tp, nelems);
#line 2721
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 2721

#line 2721
	if(rndup)
#line 2721
	{
#line 2721
		(void) memcpy(*xpp, nada, rndup);
#line 2721
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 2721
	}
#line 2721

#line 2721
	return ENOERR;
#line 2721

}
int
#line 2723
ncx_pad_putn_uchar_short(void **xpp, size_t nelems, const short *tp)
#line 2723
{
#line 2723
	int status = ENOERR;
#line 2723
	size_t rndup = nelems % X_ALIGN;
#line 2723
	uchar *xp = (uchar *) *xpp;
#line 2723

#line 2723
	if(rndup)
#line 2723
		rndup = X_ALIGN - rndup;
#line 2723

#line 2723
	while(nelems-- != 0)
#line 2723
	{
#line 2723
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2723
			status = NC_ERANGE;
#line 2723
		*xp++ = (uchar) *tp++;
#line 2723
	}
#line 2723

#line 2723

#line 2723
	if(rndup)
#line 2723
	{
#line 2723
		(void) memcpy(xp, nada, rndup);
#line 2723
		xp += rndup;
#line 2723
	}
#line 2723

#line 2723
	*xpp = (void *)xp;
#line 2723
	return status;
#line 2723
}
#line 2723

int
#line 2724
ncx_pad_putn_uchar_int(void **xpp, size_t nelems, const int *tp)
#line 2724
{
#line 2724
	int status = ENOERR;
#line 2724
	size_t rndup = nelems % X_ALIGN;
#line 2724
	uchar *xp = (uchar *) *xpp;
#line 2724

#line 2724
	if(rndup)
#line 2724
		rndup = X_ALIGN - rndup;
#line 2724

#line 2724
	while(nelems-- != 0)
#line 2724
	{
#line 2724
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2724
			status = NC_ERANGE;
#line 2724
		*xp++ = (uchar) *tp++;
#line 2724
	}
#line 2724

#line 2724

#line 2724
	if(rndup)
#line 2724
	{
#line 2724
		(void) memcpy(xp, nada, rndup);
#line 2724
		xp += rndup;
#line 2724
	}
#line 2724

#line 2724
	*xpp = (void *)xp;
#line 2724
	return status;
#line 2724
}
#line 2724

int
#line 2725
ncx_pad_putn_uchar_float(void **xpp, size_t nelems, const float *tp)
#line 2725
{
#line 2725
	int status = ENOERR;
#line 2725
	size_t rndup = nelems % X_ALIGN;
#line 2725
	uchar *xp = (uchar *) *xpp;
#line 2725

#line 2725
	if(rndup)
#line 2725
		rndup = X_ALIGN - rndup;
#line 2725

#line 2725
	while(nelems-- != 0)
#line 2725
	{
#line 2725
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2725
			status = NC_ERANGE;
#line 2725
		*xp++ = (uchar) *tp++;
#line 2725
	}
#line 2725

#line 2725

#line 2725
	if(rndup)
#line 2725
	{
#line 2725
		(void) memcpy(xp, nada, rndup);
#line 2725
		xp += rndup;
#line 2725
	}
#line 2725

#line 2725
	*xpp = (void *)xp;
#line 2725
	return status;
#line 2725
}
#line 2725

int
#line 2726
ncx_pad_putn_uchar_double(void **xpp, size_t nelems, const double *tp)
#line 2726
{
#line 2726
	int status = ENOERR;
#line 2726
	size_t rndup = nelems % X_ALIGN;
#line 2726
	uchar *xp = (uchar *) *xpp;
#line 2726

#line 2726
	if(rndup)
#line 2726
		rndup = X_ALIGN - rndup;
#line 2726

#line 2726
	while(nelems-- != 0)
#line 2726
	{
#line 2726
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2726
			status = NC_ERANGE;
#line 2726
		*xp++ = (uchar) *tp++;
#line 2726
	}
#line 2726

#line 2726

#line 2726
	if(rndup)
#line 2726
	{
#line 2726
		(void) memcpy(xp, nada, rndup);
#line 2726
		xp += rndup;
#line 2726
	}
#line 2726

#line 2726
	*xpp = (void *)xp;
#line 2726
	return status;
#line 2726
}
#line 2726

int
#line 2727
ncx_pad_putn_uchar_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2727
{
#line 2727
	int status = ENOERR;
#line 2727
	size_t rndup = nelems % X_ALIGN;
#line 2727
	uchar *xp = (uchar *) *xpp;
#line 2727

#line 2727
	if(rndup)
#line 2727
		rndup = X_ALIGN - rndup;
#line 2727

#line 2727
	while(nelems-- != 0)
#line 2727
	{
#line 2727
		if(*tp > X_UCHAR_MAX || *tp < 0)
#line 2727
			status = NC_ERANGE;
#line 2727
		*xp++ = (uchar) *tp++;
#line 2727
	}
#line 2727

#line 2727

#line 2727
	if(rndup)
#line 2727
	{
#line 2727
		(void) memcpy(xp, nada, rndup);
#line 2727
		xp += rndup;
#line 2727
	}
#line 2727

#line 2727
	*xpp = (void *)xp;
#line 2727
	return status;
#line 2727
}
#line 2727

int
#line 2728
ncx_pad_putn_uchar_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2728
{
#line 2728
	int status = ENOERR;
#line 2728
	size_t rndup = nelems % X_ALIGN;
#line 2728
	uchar *xp = (uchar *) *xpp;
#line 2728

#line 2728
	if(rndup)
#line 2728
		rndup = X_ALIGN - rndup;
#line 2728

#line 2728
	while(nelems-- != 0)
#line 2728
	{
#line 2728
		if(*tp > X_UCHAR_MAX )
#line 2728
			status = NC_ERANGE;
#line 2728
		*xp++ = (uchar) *tp++;
#line 2728
	}
#line 2728

#line 2728

#line 2728
	if(rndup)
#line 2728
	{
#line 2728
		(void) memcpy(xp, nada, rndup);
#line 2728
		xp += rndup;
#line 2728
	}
#line 2728

#line 2728
	*xpp = (void *)xp;
#line 2728
	return status;
#line 2728
}
#line 2728

int
#line 2729
ncx_pad_putn_uchar_uint(void **xpp, size_t nelems, const uint *tp)
#line 2729
{
#line 2729
	int status = ENOERR;
#line 2729
	size_t rndup = nelems % X_ALIGN;
#line 2729
	uchar *xp = (uchar *) *xpp;
#line 2729

#line 2729
	if(rndup)
#line 2729
		rndup = X_ALIGN - rndup;
#line 2729

#line 2729
	while(nelems-- != 0)
#line 2729
	{
#line 2729
		if(*tp > X_UCHAR_MAX )
#line 2729
			status = NC_ERANGE;
#line 2729
		*xp++ = (uchar) *tp++;
#line 2729
	}
#line 2729

#line 2729

#line 2729
	if(rndup)
#line 2729
	{
#line 2729
		(void) memcpy(xp, nada, rndup);
#line 2729
		xp += rndup;
#line 2729
	}
#line 2729

#line 2729
	*xpp = (void *)xp;
#line 2729
	return status;
#line 2729
}
#line 2729

int
#line 2730
ncx_pad_putn_uchar_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2730
{
#line 2730
	int status = ENOERR;
#line 2730
	size_t rndup = nelems % X_ALIGN;
#line 2730
	uchar *xp = (uchar *) *xpp;
#line 2730

#line 2730
	if(rndup)
#line 2730
		rndup = X_ALIGN - rndup;
#line 2730

#line 2730
	while(nelems-- != 0)
#line 2730
	{
#line 2730
		if(*tp > X_UCHAR_MAX )
#line 2730
			status = NC_ERANGE;
#line 2730
		*xp++ = (uchar) *tp++;
#line 2730
	}
#line 2730

#line 2730

#line 2730
	if(rndup)
#line 2730
	{
#line 2730
		(void) memcpy(xp, nada, rndup);
#line 2730
		xp += rndup;
#line 2730
	}
#line 2730

#line 2730
	*xpp = (void *)xp;
#line 2730
	return status;
#line 2730
}
#line 2730


/* short ---------------------------------------------------------------------*/

#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(short));
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return ENOERR;
}
#else
int
#line 2748
ncx_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 2748
{
#line 2748
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2748

#line 2748
 /* basic algorithm is:
#line 2748
  *   - ensure sane alignment of input data
#line 2748
  *   - copy (conversion happens automatically) input data
#line 2748
  *     to output
#line 2748
  *   - update xpp to point at next unconverted input, and tp to point
#line 2748
  *     at next location for converted output
#line 2748
  */
#line 2748
  long i, j, ni;
#line 2748
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2748
  short *xp;
#line 2748
  int nrange = 0;         /* number of range errors */
#line 2748
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2748
  long cxp = (long) *((char**)xpp);
#line 2748

#line 2748
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2748
  /* sjl: manually stripmine so we can limit amount of
#line 2748
   * vector work space reserved to LOOPCNT elements. Also
#line 2748
   * makes vectorisation easy */
#line 2748
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2748
    ni=Min(nelems-j,LOOPCNT);
#line 2748
    if (realign) {
#line 2748
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2748
      xp = tmp;
#line 2748
    } else {
#line 2748
      xp = (short *) *xpp;
#line 2748
    }
#line 2748
   /* copy the next block */
#line 2748
#pragma cdir loopcnt=LOOPCNT
#line 2748
#pragma cdir shortloop
#line 2748
    for (i=0; i<ni; i++) {
#line 2748
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2748
     /* test for range errors (not always needed but do it anyway) */
#line 2748
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2748
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2748
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 2748
    }
#line 2748
   /* update xpp and tp */
#line 2748
    if (realign) xp = (short *) *xpp;
#line 2748
    xp += ni;
#line 2748
    tp += ni;
#line 2748
    *xpp = (void*)xp;
#line 2748
  }
#line 2748
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2748

#line 2748
#else   /* not SX */
#line 2748
	const char *xp = (const char *) *xpp;
#line 2748
	int status = ENOERR;
#line 2748

#line 2748
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2748
	{
#line 2748
		const int lstatus = ncx_get_short_short(xp, tp);
#line 2748
		if(lstatus != ENOERR)
#line 2748
			status = lstatus;
#line 2748
	}
#line 2748

#line 2748
	*xpp = (const void *)xp;
#line 2748
	return status;
#line 2748
#  endif
#line 2748
}
#line 2748

#endif
int
#line 2750
ncx_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 2750
{
#line 2750
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2750

#line 2750
 /* basic algorithm is:
#line 2750
  *   - ensure sane alignment of input data
#line 2750
  *   - copy (conversion happens automatically) input data
#line 2750
  *     to output
#line 2750
  *   - update xpp to point at next unconverted input, and tp to point
#line 2750
  *     at next location for converted output
#line 2750
  */
#line 2750
  long i, j, ni;
#line 2750
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2750
  short *xp;
#line 2750
  int nrange = 0;         /* number of range errors */
#line 2750
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2750
  long cxp = (long) *((char**)xpp);
#line 2750

#line 2750
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2750
  /* sjl: manually stripmine so we can limit amount of
#line 2750
   * vector work space reserved to LOOPCNT elements. Also
#line 2750
   * makes vectorisation easy */
#line 2750
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2750
    ni=Min(nelems-j,LOOPCNT);
#line 2750
    if (realign) {
#line 2750
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2750
      xp = tmp;
#line 2750
    } else {
#line 2750
      xp = (short *) *xpp;
#line 2750
    }
#line 2750
   /* copy the next block */
#line 2750
#pragma cdir loopcnt=LOOPCNT
#line 2750
#pragma cdir shortloop
#line 2750
    for (i=0; i<ni; i++) {
#line 2750
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2750
     /* test for range errors (not always needed but do it anyway) */
#line 2750
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2750
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2750
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 2750
    }
#line 2750
   /* update xpp and tp */
#line 2750
    if (realign) xp = (short *) *xpp;
#line 2750
    xp += ni;
#line 2750
    tp += ni;
#line 2750
    *xpp = (void*)xp;
#line 2750
  }
#line 2750
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2750

#line 2750
#else   /* not SX */
#line 2750
	const char *xp = (const char *) *xpp;
#line 2750
	int status = ENOERR;
#line 2750

#line 2750
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2750
	{
#line 2750
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 2750
		if(lstatus != ENOERR)
#line 2750
			status = lstatus;
#line 2750
	}
#line 2750

#line 2750
	*xpp = (const void *)xp;
#line 2750
	return status;
#line 2750
#  endif
#line 2750
}
#line 2750

int
#line 2751
ncx_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 2751
{
#line 2751
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2751

#line 2751
 /* basic algorithm is:
#line 2751
  *   - ensure sane alignment of input data
#line 2751
  *   - copy (conversion happens automatically) input data
#line 2751
  *     to output
#line 2751
  *   - update xpp to point at next unconverted input, and tp to point
#line 2751
  *     at next location for converted output
#line 2751
  */
#line 2751
  long i, j, ni;
#line 2751
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2751
  short *xp;
#line 2751
  int nrange = 0;         /* number of range errors */
#line 2751
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2751
  long cxp = (long) *((char**)xpp);
#line 2751

#line 2751
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2751
  /* sjl: manually stripmine so we can limit amount of
#line 2751
   * vector work space reserved to LOOPCNT elements. Also
#line 2751
   * makes vectorisation easy */
#line 2751
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2751
    ni=Min(nelems-j,LOOPCNT);
#line 2751
    if (realign) {
#line 2751
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2751
      xp = tmp;
#line 2751
    } else {
#line 2751
      xp = (short *) *xpp;
#line 2751
    }
#line 2751
   /* copy the next block */
#line 2751
#pragma cdir loopcnt=LOOPCNT
#line 2751
#pragma cdir shortloop
#line 2751
    for (i=0; i<ni; i++) {
#line 2751
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2751
     /* test for range errors (not always needed but do it anyway) */
#line 2751
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2751
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2751
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 2751
    }
#line 2751
   /* update xpp and tp */
#line 2751
    if (realign) xp = (short *) *xpp;
#line 2751
    xp += ni;
#line 2751
    tp += ni;
#line 2751
    *xpp = (void*)xp;
#line 2751
  }
#line 2751
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2751

#line 2751
#else   /* not SX */
#line 2751
	const char *xp = (const char *) *xpp;
#line 2751
	int status = ENOERR;
#line 2751

#line 2751
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2751
	{
#line 2751
		const int lstatus = ncx_get_short_int(xp, tp);
#line 2751
		if(lstatus != ENOERR)
#line 2751
			status = lstatus;
#line 2751
	}
#line 2751

#line 2751
	*xpp = (const void *)xp;
#line 2751
	return status;
#line 2751
#  endif
#line 2751
}
#line 2751

int
#line 2752
ncx_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 2752
{
#line 2752
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2752

#line 2752
 /* basic algorithm is:
#line 2752
  *   - ensure sane alignment of input data
#line 2752
  *   - copy (conversion happens automatically) input data
#line 2752
  *     to output
#line 2752
  *   - update xpp to point at next unconverted input, and tp to point
#line 2752
  *     at next location for converted output
#line 2752
  */
#line 2752
  long i, j, ni;
#line 2752
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2752
  short *xp;
#line 2752
  int nrange = 0;         /* number of range errors */
#line 2752
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2752
  long cxp = (long) *((char**)xpp);
#line 2752

#line 2752
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2752
  /* sjl: manually stripmine so we can limit amount of
#line 2752
   * vector work space reserved to LOOPCNT elements. Also
#line 2752
   * makes vectorisation easy */
#line 2752
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2752
    ni=Min(nelems-j,LOOPCNT);
#line 2752
    if (realign) {
#line 2752
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2752
      xp = tmp;
#line 2752
    } else {
#line 2752
      xp = (short *) *xpp;
#line 2752
    }
#line 2752
   /* copy the next block */
#line 2752
#pragma cdir loopcnt=LOOPCNT
#line 2752
#pragma cdir shortloop
#line 2752
    for (i=0; i<ni; i++) {
#line 2752
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2752
     /* test for range errors (not always needed but do it anyway) */
#line 2752
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2752
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2752
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 2752
    }
#line 2752
   /* update xpp and tp */
#line 2752
    if (realign) xp = (short *) *xpp;
#line 2752
    xp += ni;
#line 2752
    tp += ni;
#line 2752
    *xpp = (void*)xp;
#line 2752
  }
#line 2752
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2752

#line 2752
#else   /* not SX */
#line 2752
	const char *xp = (const char *) *xpp;
#line 2752
	int status = ENOERR;
#line 2752

#line 2752
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2752
	{
#line 2752
		const int lstatus = ncx_get_short_float(xp, tp);
#line 2752
		if(lstatus != ENOERR)
#line 2752
			status = lstatus;
#line 2752
	}
#line 2752

#line 2752
	*xpp = (const void *)xp;
#line 2752
	return status;
#line 2752
#  endif
#line 2752
}
#line 2752

int
#line 2753
ncx_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 2753
{
#line 2753
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2753

#line 2753
 /* basic algorithm is:
#line 2753
  *   - ensure sane alignment of input data
#line 2753
  *   - copy (conversion happens automatically) input data
#line 2753
  *     to output
#line 2753
  *   - update xpp to point at next unconverted input, and tp to point
#line 2753
  *     at next location for converted output
#line 2753
  */
#line 2753
  long i, j, ni;
#line 2753
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2753
  short *xp;
#line 2753
  int nrange = 0;         /* number of range errors */
#line 2753
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2753
  long cxp = (long) *((char**)xpp);
#line 2753

#line 2753
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2753
  /* sjl: manually stripmine so we can limit amount of
#line 2753
   * vector work space reserved to LOOPCNT elements. Also
#line 2753
   * makes vectorisation easy */
#line 2753
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2753
    ni=Min(nelems-j,LOOPCNT);
#line 2753
    if (realign) {
#line 2753
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2753
      xp = tmp;
#line 2753
    } else {
#line 2753
      xp = (short *) *xpp;
#line 2753
    }
#line 2753
   /* copy the next block */
#line 2753
#pragma cdir loopcnt=LOOPCNT
#line 2753
#pragma cdir shortloop
#line 2753
    for (i=0; i<ni; i++) {
#line 2753
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2753
     /* test for range errors (not always needed but do it anyway) */
#line 2753
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2753
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2753
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 2753
    }
#line 2753
   /* update xpp and tp */
#line 2753
    if (realign) xp = (short *) *xpp;
#line 2753
    xp += ni;
#line 2753
    tp += ni;
#line 2753
    *xpp = (void*)xp;
#line 2753
  }
#line 2753
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2753

#line 2753
#else   /* not SX */
#line 2753
	const char *xp = (const char *) *xpp;
#line 2753
	int status = ENOERR;
#line 2753

#line 2753
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2753
	{
#line 2753
		const int lstatus = ncx_get_short_double(xp, tp);
#line 2753
		if(lstatus != ENOERR)
#line 2753
			status = lstatus;
#line 2753
	}
#line 2753

#line 2753
	*xpp = (const void *)xp;
#line 2753
	return status;
#line 2753
#  endif
#line 2753
}
#line 2753

int
#line 2754
ncx_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2754
{
#line 2754
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2754

#line 2754
 /* basic algorithm is:
#line 2754
  *   - ensure sane alignment of input data
#line 2754
  *   - copy (conversion happens automatically) input data
#line 2754
  *     to output
#line 2754
  *   - update xpp to point at next unconverted input, and tp to point
#line 2754
  *     at next location for converted output
#line 2754
  */
#line 2754
  long i, j, ni;
#line 2754
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2754
  short *xp;
#line 2754
  int nrange = 0;         /* number of range errors */
#line 2754
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2754
  long cxp = (long) *((char**)xpp);
#line 2754

#line 2754
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2754
  /* sjl: manually stripmine so we can limit amount of
#line 2754
   * vector work space reserved to LOOPCNT elements. Also
#line 2754
   * makes vectorisation easy */
#line 2754
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2754
    ni=Min(nelems-j,LOOPCNT);
#line 2754
    if (realign) {
#line 2754
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2754
      xp = tmp;
#line 2754
    } else {
#line 2754
      xp = (short *) *xpp;
#line 2754
    }
#line 2754
   /* copy the next block */
#line 2754
#pragma cdir loopcnt=LOOPCNT
#line 2754
#pragma cdir shortloop
#line 2754
    for (i=0; i<ni; i++) {
#line 2754
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2754
     /* test for range errors (not always needed but do it anyway) */
#line 2754
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2754
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2754
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 2754
    }
#line 2754
   /* update xpp and tp */
#line 2754
    if (realign) xp = (short *) *xpp;
#line 2754
    xp += ni;
#line 2754
    tp += ni;
#line 2754
    *xpp = (void*)xp;
#line 2754
  }
#line 2754
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2754

#line 2754
#else   /* not SX */
#line 2754
	const char *xp = (const char *) *xpp;
#line 2754
	int status = ENOERR;
#line 2754

#line 2754
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2754
	{
#line 2754
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 2754
		if(lstatus != ENOERR)
#line 2754
			status = lstatus;
#line 2754
	}
#line 2754

#line 2754
	*xpp = (const void *)xp;
#line 2754
	return status;
#line 2754
#  endif
#line 2754
}
#line 2754

int
#line 2755
ncx_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2755
{
#line 2755
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2755

#line 2755
 /* basic algorithm is:
#line 2755
  *   - ensure sane alignment of input data
#line 2755
  *   - copy (conversion happens automatically) input data
#line 2755
  *     to output
#line 2755
  *   - update xpp to point at next unconverted input, and tp to point
#line 2755
  *     at next location for converted output
#line 2755
  */
#line 2755
  long i, j, ni;
#line 2755
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2755
  short *xp;
#line 2755
  int nrange = 0;         /* number of range errors */
#line 2755
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2755
  long cxp = (long) *((char**)xpp);
#line 2755

#line 2755
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2755
  /* sjl: manually stripmine so we can limit amount of
#line 2755
   * vector work space reserved to LOOPCNT elements. Also
#line 2755
   * makes vectorisation easy */
#line 2755
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2755
    ni=Min(nelems-j,LOOPCNT);
#line 2755
    if (realign) {
#line 2755
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2755
      xp = tmp;
#line 2755
    } else {
#line 2755
      xp = (short *) *xpp;
#line 2755
    }
#line 2755
   /* copy the next block */
#line 2755
#pragma cdir loopcnt=LOOPCNT
#line 2755
#pragma cdir shortloop
#line 2755
    for (i=0; i<ni; i++) {
#line 2755
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2755
     /* test for range errors (not always needed but do it anyway) */
#line 2755
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2755
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2755
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 2755
    }
#line 2755
   /* update xpp and tp */
#line 2755
    if (realign) xp = (short *) *xpp;
#line 2755
    xp += ni;
#line 2755
    tp += ni;
#line 2755
    *xpp = (void*)xp;
#line 2755
  }
#line 2755
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2755

#line 2755
#else   /* not SX */
#line 2755
	const char *xp = (const char *) *xpp;
#line 2755
	int status = ENOERR;
#line 2755

#line 2755
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2755
	{
#line 2755
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 2755
		if(lstatus != ENOERR)
#line 2755
			status = lstatus;
#line 2755
	}
#line 2755

#line 2755
	*xpp = (const void *)xp;
#line 2755
	return status;
#line 2755
#  endif
#line 2755
}
#line 2755

int
#line 2756
ncx_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2756
{
#line 2756
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2756

#line 2756
 /* basic algorithm is:
#line 2756
  *   - ensure sane alignment of input data
#line 2756
  *   - copy (conversion happens automatically) input data
#line 2756
  *     to output
#line 2756
  *   - update xpp to point at next unconverted input, and tp to point
#line 2756
  *     at next location for converted output
#line 2756
  */
#line 2756
  long i, j, ni;
#line 2756
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2756
  short *xp;
#line 2756
  int nrange = 0;         /* number of range errors */
#line 2756
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2756
  long cxp = (long) *((char**)xpp);
#line 2756

#line 2756
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2756
  /* sjl: manually stripmine so we can limit amount of
#line 2756
   * vector work space reserved to LOOPCNT elements. Also
#line 2756
   * makes vectorisation easy */
#line 2756
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2756
    ni=Min(nelems-j,LOOPCNT);
#line 2756
    if (realign) {
#line 2756
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2756
      xp = tmp;
#line 2756
    } else {
#line 2756
      xp = (short *) *xpp;
#line 2756
    }
#line 2756
   /* copy the next block */
#line 2756
#pragma cdir loopcnt=LOOPCNT
#line 2756
#pragma cdir shortloop
#line 2756
    for (i=0; i<ni; i++) {
#line 2756
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2756
     /* test for range errors (not always needed but do it anyway) */
#line 2756
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2756
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2756
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 2756
    }
#line 2756
   /* update xpp and tp */
#line 2756
    if (realign) xp = (short *) *xpp;
#line 2756
    xp += ni;
#line 2756
    tp += ni;
#line 2756
    *xpp = (void*)xp;
#line 2756
  }
#line 2756
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2756

#line 2756
#else   /* not SX */
#line 2756
	const char *xp = (const char *) *xpp;
#line 2756
	int status = ENOERR;
#line 2756

#line 2756
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2756
	{
#line 2756
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 2756
		if(lstatus != ENOERR)
#line 2756
			status = lstatus;
#line 2756
	}
#line 2756

#line 2756
	*xpp = (const void *)xp;
#line 2756
	return status;
#line 2756
#  endif
#line 2756
}
#line 2756

int
#line 2757
ncx_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 2757
{
#line 2757
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2757

#line 2757
 /* basic algorithm is:
#line 2757
  *   - ensure sane alignment of input data
#line 2757
  *   - copy (conversion happens automatically) input data
#line 2757
  *     to output
#line 2757
  *   - update xpp to point at next unconverted input, and tp to point
#line 2757
  *     at next location for converted output
#line 2757
  */
#line 2757
  long i, j, ni;
#line 2757
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2757
  short *xp;
#line 2757
  int nrange = 0;         /* number of range errors */
#line 2757
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2757
  long cxp = (long) *((char**)xpp);
#line 2757

#line 2757
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2757
  /* sjl: manually stripmine so we can limit amount of
#line 2757
   * vector work space reserved to LOOPCNT elements. Also
#line 2757
   * makes vectorisation easy */
#line 2757
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2757
    ni=Min(nelems-j,LOOPCNT);
#line 2757
    if (realign) {
#line 2757
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2757
      xp = tmp;
#line 2757
    } else {
#line 2757
      xp = (short *) *xpp;
#line 2757
    }
#line 2757
   /* copy the next block */
#line 2757
#pragma cdir loopcnt=LOOPCNT
#line 2757
#pragma cdir shortloop
#line 2757
    for (i=0; i<ni; i++) {
#line 2757
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2757
     /* test for range errors (not always needed but do it anyway) */
#line 2757
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2757
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2757
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 2757
    }
#line 2757
   /* update xpp and tp */
#line 2757
    if (realign) xp = (short *) *xpp;
#line 2757
    xp += ni;
#line 2757
    tp += ni;
#line 2757
    *xpp = (void*)xp;
#line 2757
  }
#line 2757
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2757

#line 2757
#else   /* not SX */
#line 2757
	const char *xp = (const char *) *xpp;
#line 2757
	int status = ENOERR;
#line 2757

#line 2757
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2757
	{
#line 2757
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 2757
		if(lstatus != ENOERR)
#line 2757
			status = lstatus;
#line 2757
	}
#line 2757

#line 2757
	*xpp = (const void *)xp;
#line 2757
	return status;
#line 2757
#  endif
#line 2757
}
#line 2757

int
#line 2758
ncx_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2758
{
#line 2758
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2758

#line 2758
 /* basic algorithm is:
#line 2758
  *   - ensure sane alignment of input data
#line 2758
  *   - copy (conversion happens automatically) input data
#line 2758
  *     to output
#line 2758
  *   - update xpp to point at next unconverted input, and tp to point
#line 2758
  *     at next location for converted output
#line 2758
  */
#line 2758
  long i, j, ni;
#line 2758
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2758
  short *xp;
#line 2758
  int nrange = 0;         /* number of range errors */
#line 2758
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2758
  long cxp = (long) *((char**)xpp);
#line 2758

#line 2758
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2758
  /* sjl: manually stripmine so we can limit amount of
#line 2758
   * vector work space reserved to LOOPCNT elements. Also
#line 2758
   * makes vectorisation easy */
#line 2758
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2758
    ni=Min(nelems-j,LOOPCNT);
#line 2758
    if (realign) {
#line 2758
      memcpy(tmp, *xpp, ni*SIZEOF_SHORT);
#line 2758
      xp = tmp;
#line 2758
    } else {
#line 2758
      xp = (short *) *xpp;
#line 2758
    }
#line 2758
   /* copy the next block */
#line 2758
#pragma cdir loopcnt=LOOPCNT
#line 2758
#pragma cdir shortloop
#line 2758
    for (i=0; i<ni; i++) {
#line 2758
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2758
     /* test for range errors (not always needed but do it anyway) */
#line 2758
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2758
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2758
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 2758
    }
#line 2758
   /* update xpp and tp */
#line 2758
    if (realign) xp = (short *) *xpp;
#line 2758
    xp += ni;
#line 2758
    tp += ni;
#line 2758
    *xpp = (void*)xp;
#line 2758
  }
#line 2758
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2758

#line 2758
#else   /* not SX */
#line 2758
	const char *xp = (const char *) *xpp;
#line 2758
	int status = ENOERR;
#line 2758

#line 2758
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2758
	{
#line 2758
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 2758
		if(lstatus != ENOERR)
#line 2758
			status = lstatus;
#line 2758
	}
#line 2758

#line 2758
	*xpp = (const void *)xp;
#line 2758
	return status;
#line 2758
#  endif
#line 2758
}
#line 2758


int
#line 2760
ncx_pad_getn_short_schar(const void **xpp, size_t nelems, schar *tp)
#line 2760
{
#line 2760
	const size_t rndup = nelems % 2;
#line 2760

#line 2760
	const char *xp = (const char *) *xpp;
#line 2760
	int status = ENOERR;
#line 2760

#line 2760
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2760
	{
#line 2760
		const int lstatus = ncx_get_short_schar(xp, tp);
#line 2760
		if(lstatus != ENOERR)
#line 2760
			status = lstatus;
#line 2760
	}
#line 2760

#line 2760
	if(rndup != 0)
#line 2760
		xp += X_SIZEOF_SHORT;
#line 2760
		
#line 2760
	*xpp = (void *)xp;
#line 2760
	return status;
#line 2760
}
#line 2760

int
#line 2761
ncx_pad_getn_short_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2761
{
#line 2761
	const size_t rndup = nelems % 2;
#line 2761

#line 2761
	const char *xp = (const char *) *xpp;
#line 2761
	int status = ENOERR;
#line 2761

#line 2761
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2761
	{
#line 2761
		const int lstatus = ncx_get_short_uchar(xp, tp);
#line 2761
		if(lstatus != ENOERR)
#line 2761
			status = lstatus;
#line 2761
	}
#line 2761

#line 2761
	if(rndup != 0)
#line 2761
		xp += X_SIZEOF_SHORT;
#line 2761
		
#line 2761
	*xpp = (void *)xp;
#line 2761
	return status;
#line 2761
}
#line 2761

int
#line 2762
ncx_pad_getn_short_short(const void **xpp, size_t nelems, short *tp)
#line 2762
{
#line 2762
	const size_t rndup = nelems % 2;
#line 2762

#line 2762
	const char *xp = (const char *) *xpp;
#line 2762
	int status = ENOERR;
#line 2762

#line 2762
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2762
	{
#line 2762
		const int lstatus = ncx_get_short_short(xp, tp);
#line 2762
		if(lstatus != ENOERR)
#line 2762
			status = lstatus;
#line 2762
	}
#line 2762

#line 2762
	if(rndup != 0)
#line 2762
		xp += X_SIZEOF_SHORT;
#line 2762
		
#line 2762
	*xpp = (void *)xp;
#line 2762
	return status;
#line 2762
}
#line 2762

int
#line 2763
ncx_pad_getn_short_int(const void **xpp, size_t nelems, int *tp)
#line 2763
{
#line 2763
	const size_t rndup = nelems % 2;
#line 2763

#line 2763
	const char *xp = (const char *) *xpp;
#line 2763
	int status = ENOERR;
#line 2763

#line 2763
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2763
	{
#line 2763
		const int lstatus = ncx_get_short_int(xp, tp);
#line 2763
		if(lstatus != ENOERR)
#line 2763
			status = lstatus;
#line 2763
	}
#line 2763

#line 2763
	if(rndup != 0)
#line 2763
		xp += X_SIZEOF_SHORT;
#line 2763
		
#line 2763
	*xpp = (void *)xp;
#line 2763
	return status;
#line 2763
}
#line 2763

int
#line 2764
ncx_pad_getn_short_float(const void **xpp, size_t nelems, float *tp)
#line 2764
{
#line 2764
	const size_t rndup = nelems % 2;
#line 2764

#line 2764
	const char *xp = (const char *) *xpp;
#line 2764
	int status = ENOERR;
#line 2764

#line 2764
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2764
	{
#line 2764
		const int lstatus = ncx_get_short_float(xp, tp);
#line 2764
		if(lstatus != ENOERR)
#line 2764
			status = lstatus;
#line 2764
	}
#line 2764

#line 2764
	if(rndup != 0)
#line 2764
		xp += X_SIZEOF_SHORT;
#line 2764
		
#line 2764
	*xpp = (void *)xp;
#line 2764
	return status;
#line 2764
}
#line 2764

int
#line 2765
ncx_pad_getn_short_double(const void **xpp, size_t nelems, double *tp)
#line 2765
{
#line 2765
	const size_t rndup = nelems % 2;
#line 2765

#line 2765
	const char *xp = (const char *) *xpp;
#line 2765
	int status = ENOERR;
#line 2765

#line 2765
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2765
	{
#line 2765
		const int lstatus = ncx_get_short_double(xp, tp);
#line 2765
		if(lstatus != ENOERR)
#line 2765
			status = lstatus;
#line 2765
	}
#line 2765

#line 2765
	if(rndup != 0)
#line 2765
		xp += X_SIZEOF_SHORT;
#line 2765
		
#line 2765
	*xpp = (void *)xp;
#line 2765
	return status;
#line 2765
}
#line 2765

int
#line 2766
ncx_pad_getn_short_uint(const void **xpp, size_t nelems, uint *tp)
#line 2766
{
#line 2766
	const size_t rndup = nelems % 2;
#line 2766

#line 2766
	const char *xp = (const char *) *xpp;
#line 2766
	int status = ENOERR;
#line 2766

#line 2766
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2766
	{
#line 2766
		const int lstatus = ncx_get_short_uint(xp, tp);
#line 2766
		if(lstatus != ENOERR)
#line 2766
			status = lstatus;
#line 2766
	}
#line 2766

#line 2766
	if(rndup != 0)
#line 2766
		xp += X_SIZEOF_SHORT;
#line 2766
		
#line 2766
	*xpp = (void *)xp;
#line 2766
	return status;
#line 2766
}
#line 2766

int
#line 2767
ncx_pad_getn_short_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2767
{
#line 2767
	const size_t rndup = nelems % 2;
#line 2767

#line 2767
	const char *xp = (const char *) *xpp;
#line 2767
	int status = ENOERR;
#line 2767

#line 2767
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2767
	{
#line 2767
		const int lstatus = ncx_get_short_longlong(xp, tp);
#line 2767
		if(lstatus != ENOERR)
#line 2767
			status = lstatus;
#line 2767
	}
#line 2767

#line 2767
	if(rndup != 0)
#line 2767
		xp += X_SIZEOF_SHORT;
#line 2767
		
#line 2767
	*xpp = (void *)xp;
#line 2767
	return status;
#line 2767
}
#line 2767

int
#line 2768
ncx_pad_getn_short_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2768
{
#line 2768
	const size_t rndup = nelems % 2;
#line 2768

#line 2768
	const char *xp = (const char *) *xpp;
#line 2768
	int status = ENOERR;
#line 2768

#line 2768
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2768
	{
#line 2768
		const int lstatus = ncx_get_short_ulonglong(xp, tp);
#line 2768
		if(lstatus != ENOERR)
#line 2768
			status = lstatus;
#line 2768
	}
#line 2768

#line 2768
	if(rndup != 0)
#line 2768
		xp += X_SIZEOF_SHORT;
#line 2768
		
#line 2768
	*xpp = (void *)xp;
#line 2768
	return status;
#line 2768
}
#line 2768

int
#line 2769
ncx_pad_getn_short_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2769
{
#line 2769
	const size_t rndup = nelems % 2;
#line 2769

#line 2769
	const char *xp = (const char *) *xpp;
#line 2769
	int status = ENOERR;
#line 2769

#line 2769
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2769
	{
#line 2769
		const int lstatus = ncx_get_short_ushort(xp, tp);
#line 2769
		if(lstatus != ENOERR)
#line 2769
			status = lstatus;
#line 2769
	}
#line 2769

#line 2769
	if(rndup != 0)
#line 2769
		xp += X_SIZEOF_SHORT;
#line 2769
		
#line 2769
	*xpp = (void *)xp;
#line 2769
	return status;
#line 2769
}
#line 2769


#if X_SIZEOF_SHORT == SIZEOF_SHORT
/* optimized version */
int
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_SHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_SHORT);
	return ENOERR;
}
#else
int
#line 2785
ncx_putn_short_short(void **xpp, size_t nelems, const short *tp)
#line 2785
{
#line 2785
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2785

#line 2785
 /* basic algorithm is:
#line 2785
  *   - ensure sane alignment of output data
#line 2785
  *   - copy (conversion happens automatically) input data
#line 2785
  *     to output
#line 2785
  *   - update tp to point at next unconverted input, and xpp to point
#line 2785
  *     at next location for converted output
#line 2785
  */
#line 2785
  long i, j, ni;
#line 2785
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2785
  short *xp;
#line 2785
  int nrange = 0;         /* number of range errors */
#line 2785
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2785
  long cxp = (long) *((char**)xpp);
#line 2785

#line 2785
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2785
  /* sjl: manually stripmine so we can limit amount of
#line 2785
   * vector work space reserved to LOOPCNT elements. Also
#line 2785
   * makes vectorisation easy */
#line 2785
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2785
    ni=Min(nelems-j,LOOPCNT);
#line 2785
    if (realign) {
#line 2785
      xp = tmp;
#line 2785
    } else {
#line 2785
      xp = (short *) *xpp;
#line 2785
    }
#line 2785
   /* copy the next block */
#line 2785
#pragma cdir loopcnt=LOOPCNT
#line 2785
#pragma cdir shortloop
#line 2785
    for (i=0; i<ni; i++) {
#line 2785
      /* the normal case: */
#line 2785
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2785
     /* test for range errors (not always needed but do it anyway) */
#line 2785
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2785
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2785
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2785
    }
#line 2785
   /* copy workspace back if necessary */
#line 2785
    if (realign) {
#line 2785
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2785
      xp = (short *) *xpp;
#line 2785
    }
#line 2785
   /* update xpp and tp */
#line 2785
    xp += ni;
#line 2785
    tp += ni;
#line 2785
    *xpp = (void*)xp;
#line 2785
  }
#line 2785
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2785

#line 2785
#else   /* not SX */
#line 2785

#line 2785
	char *xp = (char *) *xpp;
#line 2785
	int status = ENOERR;
#line 2785

#line 2785
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2785
	{
#line 2785
		int lstatus = ncx_put_short_short(xp, tp);
#line 2785
		if(lstatus != ENOERR)
#line 2785
			status = lstatus;
#line 2785
	}
#line 2785

#line 2785
	*xpp = (void *)xp;
#line 2785
	return status;
#line 2785
#endif
#line 2785
}
#line 2785

#endif
int
#line 2787
ncx_putn_short_schar(void **xpp, size_t nelems, const schar *tp)
#line 2787
{
#line 2787
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2787

#line 2787
 /* basic algorithm is:
#line 2787
  *   - ensure sane alignment of output data
#line 2787
  *   - copy (conversion happens automatically) input data
#line 2787
  *     to output
#line 2787
  *   - update tp to point at next unconverted input, and xpp to point
#line 2787
  *     at next location for converted output
#line 2787
  */
#line 2787
  long i, j, ni;
#line 2787
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2787
  short *xp;
#line 2787
  int nrange = 0;         /* number of range errors */
#line 2787
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2787
  long cxp = (long) *((char**)xpp);
#line 2787

#line 2787
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2787
  /* sjl: manually stripmine so we can limit amount of
#line 2787
   * vector work space reserved to LOOPCNT elements. Also
#line 2787
   * makes vectorisation easy */
#line 2787
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2787
    ni=Min(nelems-j,LOOPCNT);
#line 2787
    if (realign) {
#line 2787
      xp = tmp;
#line 2787
    } else {
#line 2787
      xp = (short *) *xpp;
#line 2787
    }
#line 2787
   /* copy the next block */
#line 2787
#pragma cdir loopcnt=LOOPCNT
#line 2787
#pragma cdir shortloop
#line 2787
    for (i=0; i<ni; i++) {
#line 2787
      /* the normal case: */
#line 2787
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2787
     /* test for range errors (not always needed but do it anyway) */
#line 2787
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2787
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2787
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2787
    }
#line 2787
   /* copy workspace back if necessary */
#line 2787
    if (realign) {
#line 2787
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2787
      xp = (short *) *xpp;
#line 2787
    }
#line 2787
   /* update xpp and tp */
#line 2787
    xp += ni;
#line 2787
    tp += ni;
#line 2787
    *xpp = (void*)xp;
#line 2787
  }
#line 2787
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2787

#line 2787
#else   /* not SX */
#line 2787

#line 2787
	char *xp = (char *) *xpp;
#line 2787
	int status = ENOERR;
#line 2787

#line 2787
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2787
	{
#line 2787
		int lstatus = ncx_put_short_schar(xp, tp);
#line 2787
		if(lstatus != ENOERR)
#line 2787
			status = lstatus;
#line 2787
	}
#line 2787

#line 2787
	*xpp = (void *)xp;
#line 2787
	return status;
#line 2787
#endif
#line 2787
}
#line 2787

int
#line 2788
ncx_putn_short_int(void **xpp, size_t nelems, const int *tp)
#line 2788
{
#line 2788
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2788

#line 2788
 /* basic algorithm is:
#line 2788
  *   - ensure sane alignment of output data
#line 2788
  *   - copy (conversion happens automatically) input data
#line 2788
  *     to output
#line 2788
  *   - update tp to point at next unconverted input, and xpp to point
#line 2788
  *     at next location for converted output
#line 2788
  */
#line 2788
  long i, j, ni;
#line 2788
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2788
  short *xp;
#line 2788
  int nrange = 0;         /* number of range errors */
#line 2788
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2788
  long cxp = (long) *((char**)xpp);
#line 2788

#line 2788
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2788
  /* sjl: manually stripmine so we can limit amount of
#line 2788
   * vector work space reserved to LOOPCNT elements. Also
#line 2788
   * makes vectorisation easy */
#line 2788
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2788
    ni=Min(nelems-j,LOOPCNT);
#line 2788
    if (realign) {
#line 2788
      xp = tmp;
#line 2788
    } else {
#line 2788
      xp = (short *) *xpp;
#line 2788
    }
#line 2788
   /* copy the next block */
#line 2788
#pragma cdir loopcnt=LOOPCNT
#line 2788
#pragma cdir shortloop
#line 2788
    for (i=0; i<ni; i++) {
#line 2788
      /* the normal case: */
#line 2788
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2788
     /* test for range errors (not always needed but do it anyway) */
#line 2788
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2788
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2788
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2788
    }
#line 2788
   /* copy workspace back if necessary */
#line 2788
    if (realign) {
#line 2788
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2788
      xp = (short *) *xpp;
#line 2788
    }
#line 2788
   /* update xpp and tp */
#line 2788
    xp += ni;
#line 2788
    tp += ni;
#line 2788
    *xpp = (void*)xp;
#line 2788
  }
#line 2788
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2788

#line 2788
#else   /* not SX */
#line 2788

#line 2788
	char *xp = (char *) *xpp;
#line 2788
	int status = ENOERR;
#line 2788

#line 2788
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2788
	{
#line 2788
		int lstatus = ncx_put_short_int(xp, tp);
#line 2788
		if(lstatus != ENOERR)
#line 2788
			status = lstatus;
#line 2788
	}
#line 2788

#line 2788
	*xpp = (void *)xp;
#line 2788
	return status;
#line 2788
#endif
#line 2788
}
#line 2788

int
#line 2789
ncx_putn_short_float(void **xpp, size_t nelems, const float *tp)
#line 2789
{
#line 2789
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2789

#line 2789
 /* basic algorithm is:
#line 2789
  *   - ensure sane alignment of output data
#line 2789
  *   - copy (conversion happens automatically) input data
#line 2789
  *     to output
#line 2789
  *   - update tp to point at next unconverted input, and xpp to point
#line 2789
  *     at next location for converted output
#line 2789
  */
#line 2789
  long i, j, ni;
#line 2789
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2789
  short *xp;
#line 2789
  int nrange = 0;         /* number of range errors */
#line 2789
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2789
  long cxp = (long) *((char**)xpp);
#line 2789

#line 2789
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2789
  /* sjl: manually stripmine so we can limit amount of
#line 2789
   * vector work space reserved to LOOPCNT elements. Also
#line 2789
   * makes vectorisation easy */
#line 2789
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2789
    ni=Min(nelems-j,LOOPCNT);
#line 2789
    if (realign) {
#line 2789
      xp = tmp;
#line 2789
    } else {
#line 2789
      xp = (short *) *xpp;
#line 2789
    }
#line 2789
   /* copy the next block */
#line 2789
#pragma cdir loopcnt=LOOPCNT
#line 2789
#pragma cdir shortloop
#line 2789
    for (i=0; i<ni; i++) {
#line 2789
      /* the normal case: */
#line 2789
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2789
     /* test for range errors (not always needed but do it anyway) */
#line 2789
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2789
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2789
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2789
    }
#line 2789
   /* copy workspace back if necessary */
#line 2789
    if (realign) {
#line 2789
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2789
      xp = (short *) *xpp;
#line 2789
    }
#line 2789
   /* update xpp and tp */
#line 2789
    xp += ni;
#line 2789
    tp += ni;
#line 2789
    *xpp = (void*)xp;
#line 2789
  }
#line 2789
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2789

#line 2789
#else   /* not SX */
#line 2789

#line 2789
	char *xp = (char *) *xpp;
#line 2789
	int status = ENOERR;
#line 2789

#line 2789
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2789
	{
#line 2789
		int lstatus = ncx_put_short_float(xp, tp);
#line 2789
		if(lstatus != ENOERR)
#line 2789
			status = lstatus;
#line 2789
	}
#line 2789

#line 2789
	*xpp = (void *)xp;
#line 2789
	return status;
#line 2789
#endif
#line 2789
}
#line 2789

int
#line 2790
ncx_putn_short_double(void **xpp, size_t nelems, const double *tp)
#line 2790
{
#line 2790
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2790

#line 2790
 /* basic algorithm is:
#line 2790
  *   - ensure sane alignment of output data
#line 2790
  *   - copy (conversion happens automatically) input data
#line 2790
  *     to output
#line 2790
  *   - update tp to point at next unconverted input, and xpp to point
#line 2790
  *     at next location for converted output
#line 2790
  */
#line 2790
  long i, j, ni;
#line 2790
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2790
  short *xp;
#line 2790
  int nrange = 0;         /* number of range errors */
#line 2790
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2790
  long cxp = (long) *((char**)xpp);
#line 2790

#line 2790
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2790
  /* sjl: manually stripmine so we can limit amount of
#line 2790
   * vector work space reserved to LOOPCNT elements. Also
#line 2790
   * makes vectorisation easy */
#line 2790
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2790
    ni=Min(nelems-j,LOOPCNT);
#line 2790
    if (realign) {
#line 2790
      xp = tmp;
#line 2790
    } else {
#line 2790
      xp = (short *) *xpp;
#line 2790
    }
#line 2790
   /* copy the next block */
#line 2790
#pragma cdir loopcnt=LOOPCNT
#line 2790
#pragma cdir shortloop
#line 2790
    for (i=0; i<ni; i++) {
#line 2790
      /* the normal case: */
#line 2790
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2790
     /* test for range errors (not always needed but do it anyway) */
#line 2790
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2790
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2790
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2790
    }
#line 2790
   /* copy workspace back if necessary */
#line 2790
    if (realign) {
#line 2790
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2790
      xp = (short *) *xpp;
#line 2790
    }
#line 2790
   /* update xpp and tp */
#line 2790
    xp += ni;
#line 2790
    tp += ni;
#line 2790
    *xpp = (void*)xp;
#line 2790
  }
#line 2790
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2790

#line 2790
#else   /* not SX */
#line 2790

#line 2790
	char *xp = (char *) *xpp;
#line 2790
	int status = ENOERR;
#line 2790

#line 2790
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2790
	{
#line 2790
		int lstatus = ncx_put_short_double(xp, tp);
#line 2790
		if(lstatus != ENOERR)
#line 2790
			status = lstatus;
#line 2790
	}
#line 2790

#line 2790
	*xpp = (void *)xp;
#line 2790
	return status;
#line 2790
#endif
#line 2790
}
#line 2790

int
#line 2791
ncx_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2791
{
#line 2791
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2791

#line 2791
 /* basic algorithm is:
#line 2791
  *   - ensure sane alignment of output data
#line 2791
  *   - copy (conversion happens automatically) input data
#line 2791
  *     to output
#line 2791
  *   - update tp to point at next unconverted input, and xpp to point
#line 2791
  *     at next location for converted output
#line 2791
  */
#line 2791
  long i, j, ni;
#line 2791
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2791
  short *xp;
#line 2791
  int nrange = 0;         /* number of range errors */
#line 2791
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2791
  long cxp = (long) *((char**)xpp);
#line 2791

#line 2791
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2791
  /* sjl: manually stripmine so we can limit amount of
#line 2791
   * vector work space reserved to LOOPCNT elements. Also
#line 2791
   * makes vectorisation easy */
#line 2791
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2791
    ni=Min(nelems-j,LOOPCNT);
#line 2791
    if (realign) {
#line 2791
      xp = tmp;
#line 2791
    } else {
#line 2791
      xp = (short *) *xpp;
#line 2791
    }
#line 2791
   /* copy the next block */
#line 2791
#pragma cdir loopcnt=LOOPCNT
#line 2791
#pragma cdir shortloop
#line 2791
    for (i=0; i<ni; i++) {
#line 2791
      /* the normal case: */
#line 2791
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2791
     /* test for range errors (not always needed but do it anyway) */
#line 2791
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2791
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2791
      nrange += tp[i] > X_SHORT_MAX || tp[i] < X_SHORT_MIN;
#line 2791
    }
#line 2791
   /* copy workspace back if necessary */
#line 2791
    if (realign) {
#line 2791
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2791
      xp = (short *) *xpp;
#line 2791
    }
#line 2791
   /* update xpp and tp */
#line 2791
    xp += ni;
#line 2791
    tp += ni;
#line 2791
    *xpp = (void*)xp;
#line 2791
  }
#line 2791
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2791

#line 2791
#else   /* not SX */
#line 2791

#line 2791
	char *xp = (char *) *xpp;
#line 2791
	int status = ENOERR;
#line 2791

#line 2791
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2791
	{
#line 2791
		int lstatus = ncx_put_short_longlong(xp, tp);
#line 2791
		if(lstatus != ENOERR)
#line 2791
			status = lstatus;
#line 2791
	}
#line 2791

#line 2791
	*xpp = (void *)xp;
#line 2791
	return status;
#line 2791
#endif
#line 2791
}
#line 2791

int
#line 2792
ncx_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2792
{
#line 2792
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2792

#line 2792
 /* basic algorithm is:
#line 2792
  *   - ensure sane alignment of output data
#line 2792
  *   - copy (conversion happens automatically) input data
#line 2792
  *     to output
#line 2792
  *   - update tp to point at next unconverted input, and xpp to point
#line 2792
  *     at next location for converted output
#line 2792
  */
#line 2792
  long i, j, ni;
#line 2792
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2792
  short *xp;
#line 2792
  int nrange = 0;         /* number of range errors */
#line 2792
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2792
  long cxp = (long) *((char**)xpp);
#line 2792

#line 2792
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2792
  /* sjl: manually stripmine so we can limit amount of
#line 2792
   * vector work space reserved to LOOPCNT elements. Also
#line 2792
   * makes vectorisation easy */
#line 2792
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2792
    ni=Min(nelems-j,LOOPCNT);
#line 2792
    if (realign) {
#line 2792
      xp = tmp;
#line 2792
    } else {
#line 2792
      xp = (short *) *xpp;
#line 2792
    }
#line 2792
   /* copy the next block */
#line 2792
#pragma cdir loopcnt=LOOPCNT
#line 2792
#pragma cdir shortloop
#line 2792
    for (i=0; i<ni; i++) {
#line 2792
      /* the normal case: */
#line 2792
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2792
     /* test for range errors (not always needed but do it anyway) */
#line 2792
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2792
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2792
      nrange += tp[i] > X_SHORT_MAX ;
#line 2792
    }
#line 2792
   /* copy workspace back if necessary */
#line 2792
    if (realign) {
#line 2792
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2792
      xp = (short *) *xpp;
#line 2792
    }
#line 2792
   /* update xpp and tp */
#line 2792
    xp += ni;
#line 2792
    tp += ni;
#line 2792
    *xpp = (void*)xp;
#line 2792
  }
#line 2792
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2792

#line 2792
#else   /* not SX */
#line 2792

#line 2792
	char *xp = (char *) *xpp;
#line 2792
	int status = ENOERR;
#line 2792

#line 2792
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2792
	{
#line 2792
		int lstatus = ncx_put_short_uchar(xp, tp);
#line 2792
		if(lstatus != ENOERR)
#line 2792
			status = lstatus;
#line 2792
	}
#line 2792

#line 2792
	*xpp = (void *)xp;
#line 2792
	return status;
#line 2792
#endif
#line 2792
}
#line 2792

int
#line 2793
ncx_putn_short_uint(void **xpp, size_t nelems, const uint *tp)
#line 2793
{
#line 2793
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2793

#line 2793
 /* basic algorithm is:
#line 2793
  *   - ensure sane alignment of output data
#line 2793
  *   - copy (conversion happens automatically) input data
#line 2793
  *     to output
#line 2793
  *   - update tp to point at next unconverted input, and xpp to point
#line 2793
  *     at next location for converted output
#line 2793
  */
#line 2793
  long i, j, ni;
#line 2793
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2793
  short *xp;
#line 2793
  int nrange = 0;         /* number of range errors */
#line 2793
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2793
  long cxp = (long) *((char**)xpp);
#line 2793

#line 2793
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2793
  /* sjl: manually stripmine so we can limit amount of
#line 2793
   * vector work space reserved to LOOPCNT elements. Also
#line 2793
   * makes vectorisation easy */
#line 2793
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2793
    ni=Min(nelems-j,LOOPCNT);
#line 2793
    if (realign) {
#line 2793
      xp = tmp;
#line 2793
    } else {
#line 2793
      xp = (short *) *xpp;
#line 2793
    }
#line 2793
   /* copy the next block */
#line 2793
#pragma cdir loopcnt=LOOPCNT
#line 2793
#pragma cdir shortloop
#line 2793
    for (i=0; i<ni; i++) {
#line 2793
      /* the normal case: */
#line 2793
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2793
     /* test for range errors (not always needed but do it anyway) */
#line 2793
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2793
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2793
      nrange += tp[i] > X_SHORT_MAX ;
#line 2793
    }
#line 2793
   /* copy workspace back if necessary */
#line 2793
    if (realign) {
#line 2793
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2793
      xp = (short *) *xpp;
#line 2793
    }
#line 2793
   /* update xpp and tp */
#line 2793
    xp += ni;
#line 2793
    tp += ni;
#line 2793
    *xpp = (void*)xp;
#line 2793
  }
#line 2793
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2793

#line 2793
#else   /* not SX */
#line 2793

#line 2793
	char *xp = (char *) *xpp;
#line 2793
	int status = ENOERR;
#line 2793

#line 2793
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2793
	{
#line 2793
		int lstatus = ncx_put_short_uint(xp, tp);
#line 2793
		if(lstatus != ENOERR)
#line 2793
			status = lstatus;
#line 2793
	}
#line 2793

#line 2793
	*xpp = (void *)xp;
#line 2793
	return status;
#line 2793
#endif
#line 2793
}
#line 2793

int
#line 2794
ncx_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2794
{
#line 2794
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2794

#line 2794
 /* basic algorithm is:
#line 2794
  *   - ensure sane alignment of output data
#line 2794
  *   - copy (conversion happens automatically) input data
#line 2794
  *     to output
#line 2794
  *   - update tp to point at next unconverted input, and xpp to point
#line 2794
  *     at next location for converted output
#line 2794
  */
#line 2794
  long i, j, ni;
#line 2794
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2794
  short *xp;
#line 2794
  int nrange = 0;         /* number of range errors */
#line 2794
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2794
  long cxp = (long) *((char**)xpp);
#line 2794

#line 2794
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2794
  /* sjl: manually stripmine so we can limit amount of
#line 2794
   * vector work space reserved to LOOPCNT elements. Also
#line 2794
   * makes vectorisation easy */
#line 2794
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2794
    ni=Min(nelems-j,LOOPCNT);
#line 2794
    if (realign) {
#line 2794
      xp = tmp;
#line 2794
    } else {
#line 2794
      xp = (short *) *xpp;
#line 2794
    }
#line 2794
   /* copy the next block */
#line 2794
#pragma cdir loopcnt=LOOPCNT
#line 2794
#pragma cdir shortloop
#line 2794
    for (i=0; i<ni; i++) {
#line 2794
      /* the normal case: */
#line 2794
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2794
     /* test for range errors (not always needed but do it anyway) */
#line 2794
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2794
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2794
      nrange += tp[i] > X_SHORT_MAX ;
#line 2794
    }
#line 2794
   /* copy workspace back if necessary */
#line 2794
    if (realign) {
#line 2794
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2794
      xp = (short *) *xpp;
#line 2794
    }
#line 2794
   /* update xpp and tp */
#line 2794
    xp += ni;
#line 2794
    tp += ni;
#line 2794
    *xpp = (void*)xp;
#line 2794
  }
#line 2794
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2794

#line 2794
#else   /* not SX */
#line 2794

#line 2794
	char *xp = (char *) *xpp;
#line 2794
	int status = ENOERR;
#line 2794

#line 2794
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2794
	{
#line 2794
		int lstatus = ncx_put_short_ulonglong(xp, tp);
#line 2794
		if(lstatus != ENOERR)
#line 2794
			status = lstatus;
#line 2794
	}
#line 2794

#line 2794
	*xpp = (void *)xp;
#line 2794
	return status;
#line 2794
#endif
#line 2794
}
#line 2794

int
#line 2795
ncx_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2795
{
#line 2795
#if _SX && X_SIZEOF_SHORT == SIZEOF_SHORT
#line 2795

#line 2795
 /* basic algorithm is:
#line 2795
  *   - ensure sane alignment of output data
#line 2795
  *   - copy (conversion happens automatically) input data
#line 2795
  *     to output
#line 2795
  *   - update tp to point at next unconverted input, and xpp to point
#line 2795
  *     at next location for converted output
#line 2795
  */
#line 2795
  long i, j, ni;
#line 2795
  short tmp[LOOPCNT];        /* in case input is misaligned */
#line 2795
  short *xp;
#line 2795
  int nrange = 0;         /* number of range errors */
#line 2795
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2795
  long cxp = (long) *((char**)xpp);
#line 2795

#line 2795
  realign = (cxp & 7) % SIZEOF_SHORT;
#line 2795
  /* sjl: manually stripmine so we can limit amount of
#line 2795
   * vector work space reserved to LOOPCNT elements. Also
#line 2795
   * makes vectorisation easy */
#line 2795
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2795
    ni=Min(nelems-j,LOOPCNT);
#line 2795
    if (realign) {
#line 2795
      xp = tmp;
#line 2795
    } else {
#line 2795
      xp = (short *) *xpp;
#line 2795
    }
#line 2795
   /* copy the next block */
#line 2795
#pragma cdir loopcnt=LOOPCNT
#line 2795
#pragma cdir shortloop
#line 2795
    for (i=0; i<ni; i++) {
#line 2795
      /* the normal case: */
#line 2795
      xp[i] = (short) Max( X_SHORT_MIN, Min(X_SHORT_MAX, (short) tp[i]));
#line 2795
     /* test for range errors (not always needed but do it anyway) */
#line 2795
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2795
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2795
      nrange += tp[i] > X_SHORT_MAX ;
#line 2795
    }
#line 2795
   /* copy workspace back if necessary */
#line 2795
    if (realign) {
#line 2795
      memcpy(*xpp, tmp, ni*X_SIZEOF_SHORT);
#line 2795
      xp = (short *) *xpp;
#line 2795
    }
#line 2795
   /* update xpp and tp */
#line 2795
    xp += ni;
#line 2795
    tp += ni;
#line 2795
    *xpp = (void*)xp;
#line 2795
  }
#line 2795
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2795

#line 2795
#else   /* not SX */
#line 2795

#line 2795
	char *xp = (char *) *xpp;
#line 2795
	int status = ENOERR;
#line 2795

#line 2795
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2795
	{
#line 2795
		int lstatus = ncx_put_short_ushort(xp, tp);
#line 2795
		if(lstatus != ENOERR)
#line 2795
			status = lstatus;
#line 2795
	}
#line 2795

#line 2795
	*xpp = (void *)xp;
#line 2795
	return status;
#line 2795
#endif
#line 2795
}
#line 2795


int
#line 2797
ncx_pad_putn_short_schar(void **xpp, size_t nelems, const schar *tp)
#line 2797
{
#line 2797
	const size_t rndup = nelems % 2;
#line 2797

#line 2797
	char *xp = (char *) *xpp;
#line 2797
	int status = ENOERR;
#line 2797

#line 2797
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2797
	{
#line 2797
		int lstatus = ncx_put_short_schar(xp, tp);
#line 2797
		if(lstatus != ENOERR)
#line 2797
			status = lstatus;
#line 2797
	}
#line 2797

#line 2797
	if(rndup != 0)
#line 2797
	{
#line 2797
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2797
		xp += X_SIZEOF_SHORT;	
#line 2797
	}
#line 2797

#line 2797
	*xpp = (void *)xp;
#line 2797
	return status;
#line 2797
}
#line 2797

int
#line 2798
ncx_pad_putn_short_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2798
{
#line 2798
	const size_t rndup = nelems % 2;
#line 2798

#line 2798
	char *xp = (char *) *xpp;
#line 2798
	int status = ENOERR;
#line 2798

#line 2798
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2798
	{
#line 2798
		int lstatus = ncx_put_short_uchar(xp, tp);
#line 2798
		if(lstatus != ENOERR)
#line 2798
			status = lstatus;
#line 2798
	}
#line 2798

#line 2798
	if(rndup != 0)
#line 2798
	{
#line 2798
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2798
		xp += X_SIZEOF_SHORT;	
#line 2798
	}
#line 2798

#line 2798
	*xpp = (void *)xp;
#line 2798
	return status;
#line 2798
}
#line 2798

int
#line 2799
ncx_pad_putn_short_short(void **xpp, size_t nelems, const short *tp)
#line 2799
{
#line 2799
	const size_t rndup = nelems % 2;
#line 2799

#line 2799
	char *xp = (char *) *xpp;
#line 2799
	int status = ENOERR;
#line 2799

#line 2799
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2799
	{
#line 2799
		int lstatus = ncx_put_short_short(xp, tp);
#line 2799
		if(lstatus != ENOERR)
#line 2799
			status = lstatus;
#line 2799
	}
#line 2799

#line 2799
	if(rndup != 0)
#line 2799
	{
#line 2799
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2799
		xp += X_SIZEOF_SHORT;	
#line 2799
	}
#line 2799

#line 2799
	*xpp = (void *)xp;
#line 2799
	return status;
#line 2799
}
#line 2799

int
#line 2800
ncx_pad_putn_short_int(void **xpp, size_t nelems, const int *tp)
#line 2800
{
#line 2800
	const size_t rndup = nelems % 2;
#line 2800

#line 2800
	char *xp = (char *) *xpp;
#line 2800
	int status = ENOERR;
#line 2800

#line 2800
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2800
	{
#line 2800
		int lstatus = ncx_put_short_int(xp, tp);
#line 2800
		if(lstatus != ENOERR)
#line 2800
			status = lstatus;
#line 2800
	}
#line 2800

#line 2800
	if(rndup != 0)
#line 2800
	{
#line 2800
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2800
		xp += X_SIZEOF_SHORT;	
#line 2800
	}
#line 2800

#line 2800
	*xpp = (void *)xp;
#line 2800
	return status;
#line 2800
}
#line 2800

int
#line 2801
ncx_pad_putn_short_float(void **xpp, size_t nelems, const float *tp)
#line 2801
{
#line 2801
	const size_t rndup = nelems % 2;
#line 2801

#line 2801
	char *xp = (char *) *xpp;
#line 2801
	int status = ENOERR;
#line 2801

#line 2801
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2801
	{
#line 2801
		int lstatus = ncx_put_short_float(xp, tp);
#line 2801
		if(lstatus != ENOERR)
#line 2801
			status = lstatus;
#line 2801
	}
#line 2801

#line 2801
	if(rndup != 0)
#line 2801
	{
#line 2801
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2801
		xp += X_SIZEOF_SHORT;	
#line 2801
	}
#line 2801

#line 2801
	*xpp = (void *)xp;
#line 2801
	return status;
#line 2801
}
#line 2801

int
#line 2802
ncx_pad_putn_short_double(void **xpp, size_t nelems, const double *tp)
#line 2802
{
#line 2802
	const size_t rndup = nelems % 2;
#line 2802

#line 2802
	char *xp = (char *) *xpp;
#line 2802
	int status = ENOERR;
#line 2802

#line 2802
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2802
	{
#line 2802
		int lstatus = ncx_put_short_double(xp, tp);
#line 2802
		if(lstatus != ENOERR)
#line 2802
			status = lstatus;
#line 2802
	}
#line 2802

#line 2802
	if(rndup != 0)
#line 2802
	{
#line 2802
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2802
		xp += X_SIZEOF_SHORT;	
#line 2802
	}
#line 2802

#line 2802
	*xpp = (void *)xp;
#line 2802
	return status;
#line 2802
}
#line 2802

int
#line 2803
ncx_pad_putn_short_uint(void **xpp, size_t nelems, const uint *tp)
#line 2803
{
#line 2803
	const size_t rndup = nelems % 2;
#line 2803

#line 2803
	char *xp = (char *) *xpp;
#line 2803
	int status = ENOERR;
#line 2803

#line 2803
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2803
	{
#line 2803
		int lstatus = ncx_put_short_uint(xp, tp);
#line 2803
		if(lstatus != ENOERR)
#line 2803
			status = lstatus;
#line 2803
	}
#line 2803

#line 2803
	if(rndup != 0)
#line 2803
	{
#line 2803
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2803
		xp += X_SIZEOF_SHORT;	
#line 2803
	}
#line 2803

#line 2803
	*xpp = (void *)xp;
#line 2803
	return status;
#line 2803
}
#line 2803

int
#line 2804
ncx_pad_putn_short_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2804
{
#line 2804
	const size_t rndup = nelems % 2;
#line 2804

#line 2804
	char *xp = (char *) *xpp;
#line 2804
	int status = ENOERR;
#line 2804

#line 2804
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2804
	{
#line 2804
		int lstatus = ncx_put_short_longlong(xp, tp);
#line 2804
		if(lstatus != ENOERR)
#line 2804
			status = lstatus;
#line 2804
	}
#line 2804

#line 2804
	if(rndup != 0)
#line 2804
	{
#line 2804
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2804
		xp += X_SIZEOF_SHORT;	
#line 2804
	}
#line 2804

#line 2804
	*xpp = (void *)xp;
#line 2804
	return status;
#line 2804
}
#line 2804

int
#line 2805
ncx_pad_putn_short_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2805
{
#line 2805
	const size_t rndup = nelems % 2;
#line 2805

#line 2805
	char *xp = (char *) *xpp;
#line 2805
	int status = ENOERR;
#line 2805

#line 2805
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2805
	{
#line 2805
		int lstatus = ncx_put_short_ulonglong(xp, tp);
#line 2805
		if(lstatus != ENOERR)
#line 2805
			status = lstatus;
#line 2805
	}
#line 2805

#line 2805
	if(rndup != 0)
#line 2805
	{
#line 2805
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2805
		xp += X_SIZEOF_SHORT;	
#line 2805
	}
#line 2805

#line 2805
	*xpp = (void *)xp;
#line 2805
	return status;
#line 2805
}
#line 2805

int
#line 2806
ncx_pad_putn_short_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2806
{
#line 2806
	const size_t rndup = nelems % 2;
#line 2806

#line 2806
	char *xp = (char *) *xpp;
#line 2806
	int status = ENOERR;
#line 2806

#line 2806
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_SHORT, tp++)
#line 2806
	{
#line 2806
		int lstatus = ncx_put_short_ushort(xp, tp);
#line 2806
		if(lstatus != ENOERR)
#line 2806
			status = lstatus;
#line 2806
	}
#line 2806

#line 2806
	if(rndup != 0)
#line 2806
	{
#line 2806
		(void) memcpy(xp, nada, X_SIZEOF_SHORT);
#line 2806
		xp += X_SIZEOF_SHORT;	
#line 2806
	}
#line 2806

#line 2806
	*xpp = (void *)xp;
#line 2806
	return status;
#line 2806
}
#line 2806



/* ushort --------------------------------------------------------------------*/

#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, unsigned short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(unsigned short));
# else
	swapn2b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return ENOERR;
}
#else
int
#line 2825
ncx_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2825
{
#line 2825
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2825

#line 2825
 /* basic algorithm is:
#line 2825
  *   - ensure sane alignment of input data
#line 2825
  *   - copy (conversion happens automatically) input data
#line 2825
  *     to output
#line 2825
  *   - update xpp to point at next unconverted input, and tp to point
#line 2825
  *     at next location for converted output
#line 2825
  */
#line 2825
  long i, j, ni;
#line 2825
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2825
  ushort *xp;
#line 2825
  int nrange = 0;         /* number of range errors */
#line 2825
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2825
  long cxp = (long) *((char**)xpp);
#line 2825

#line 2825
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2825
  /* sjl: manually stripmine so we can limit amount of
#line 2825
   * vector work space reserved to LOOPCNT elements. Also
#line 2825
   * makes vectorisation easy */
#line 2825
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2825
    ni=Min(nelems-j,LOOPCNT);
#line 2825
    if (realign) {
#line 2825
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2825
      xp = tmp;
#line 2825
    } else {
#line 2825
      xp = (ushort *) *xpp;
#line 2825
    }
#line 2825
   /* copy the next block */
#line 2825
#pragma cdir loopcnt=LOOPCNT
#line 2825
#pragma cdir shortloop
#line 2825
    for (i=0; i<ni; i++) {
#line 2825
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2825
     /* test for range errors (not always needed but do it anyway) */
#line 2825
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2825
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2825
      nrange += xp[i] > USHORT_MAX ;
#line 2825
    }
#line 2825
   /* update xpp and tp */
#line 2825
    if (realign) xp = (ushort *) *xpp;
#line 2825
    xp += ni;
#line 2825
    tp += ni;
#line 2825
    *xpp = (void*)xp;
#line 2825
  }
#line 2825
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2825

#line 2825
#else   /* not SX */
#line 2825
	const char *xp = (const char *) *xpp;
#line 2825
	int status = ENOERR;
#line 2825

#line 2825
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2825
	{
#line 2825
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 2825
		if(lstatus != ENOERR)
#line 2825
			status = lstatus;
#line 2825
	}
#line 2825

#line 2825
	*xpp = (const void *)xp;
#line 2825
	return status;
#line 2825
#  endif
#line 2825
}
#line 2825

#endif
int
#line 2827
ncx_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 2827
{
#line 2827
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2827

#line 2827
 /* basic algorithm is:
#line 2827
  *   - ensure sane alignment of input data
#line 2827
  *   - copy (conversion happens automatically) input data
#line 2827
  *     to output
#line 2827
  *   - update xpp to point at next unconverted input, and tp to point
#line 2827
  *     at next location for converted output
#line 2827
  */
#line 2827
  long i, j, ni;
#line 2827
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2827
  ushort *xp;
#line 2827
  int nrange = 0;         /* number of range errors */
#line 2827
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2827
  long cxp = (long) *((char**)xpp);
#line 2827

#line 2827
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2827
  /* sjl: manually stripmine so we can limit amount of
#line 2827
   * vector work space reserved to LOOPCNT elements. Also
#line 2827
   * makes vectorisation easy */
#line 2827
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2827
    ni=Min(nelems-j,LOOPCNT);
#line 2827
    if (realign) {
#line 2827
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2827
      xp = tmp;
#line 2827
    } else {
#line 2827
      xp = (ushort *) *xpp;
#line 2827
    }
#line 2827
   /* copy the next block */
#line 2827
#pragma cdir loopcnt=LOOPCNT
#line 2827
#pragma cdir shortloop
#line 2827
    for (i=0; i<ni; i++) {
#line 2827
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2827
     /* test for range errors (not always needed but do it anyway) */
#line 2827
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2827
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2827
      nrange += xp[i] > SCHAR_MAX ;
#line 2827
    }
#line 2827
   /* update xpp and tp */
#line 2827
    if (realign) xp = (ushort *) *xpp;
#line 2827
    xp += ni;
#line 2827
    tp += ni;
#line 2827
    *xpp = (void*)xp;
#line 2827
  }
#line 2827
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2827

#line 2827
#else   /* not SX */
#line 2827
	const char *xp = (const char *) *xpp;
#line 2827
	int status = ENOERR;
#line 2827

#line 2827
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2827
	{
#line 2827
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 2827
		if(lstatus != ENOERR)
#line 2827
			status = lstatus;
#line 2827
	}
#line 2827

#line 2827
	*xpp = (const void *)xp;
#line 2827
	return status;
#line 2827
#  endif
#line 2827
}
#line 2827

int
#line 2828
ncx_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 2828
{
#line 2828
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2828

#line 2828
 /* basic algorithm is:
#line 2828
  *   - ensure sane alignment of input data
#line 2828
  *   - copy (conversion happens automatically) input data
#line 2828
  *     to output
#line 2828
  *   - update xpp to point at next unconverted input, and tp to point
#line 2828
  *     at next location for converted output
#line 2828
  */
#line 2828
  long i, j, ni;
#line 2828
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2828
  ushort *xp;
#line 2828
  int nrange = 0;         /* number of range errors */
#line 2828
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2828
  long cxp = (long) *((char**)xpp);
#line 2828

#line 2828
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2828
  /* sjl: manually stripmine so we can limit amount of
#line 2828
   * vector work space reserved to LOOPCNT elements. Also
#line 2828
   * makes vectorisation easy */
#line 2828
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2828
    ni=Min(nelems-j,LOOPCNT);
#line 2828
    if (realign) {
#line 2828
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2828
      xp = tmp;
#line 2828
    } else {
#line 2828
      xp = (ushort *) *xpp;
#line 2828
    }
#line 2828
   /* copy the next block */
#line 2828
#pragma cdir loopcnt=LOOPCNT
#line 2828
#pragma cdir shortloop
#line 2828
    for (i=0; i<ni; i++) {
#line 2828
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2828
     /* test for range errors (not always needed but do it anyway) */
#line 2828
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2828
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2828
      nrange += xp[i] > SHORT_MAX ;
#line 2828
    }
#line 2828
   /* update xpp and tp */
#line 2828
    if (realign) xp = (ushort *) *xpp;
#line 2828
    xp += ni;
#line 2828
    tp += ni;
#line 2828
    *xpp = (void*)xp;
#line 2828
  }
#line 2828
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2828

#line 2828
#else   /* not SX */
#line 2828
	const char *xp = (const char *) *xpp;
#line 2828
	int status = ENOERR;
#line 2828

#line 2828
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2828
	{
#line 2828
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 2828
		if(lstatus != ENOERR)
#line 2828
			status = lstatus;
#line 2828
	}
#line 2828

#line 2828
	*xpp = (const void *)xp;
#line 2828
	return status;
#line 2828
#  endif
#line 2828
}
#line 2828

int
#line 2829
ncx_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 2829
{
#line 2829
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2829

#line 2829
 /* basic algorithm is:
#line 2829
  *   - ensure sane alignment of input data
#line 2829
  *   - copy (conversion happens automatically) input data
#line 2829
  *     to output
#line 2829
  *   - update xpp to point at next unconverted input, and tp to point
#line 2829
  *     at next location for converted output
#line 2829
  */
#line 2829
  long i, j, ni;
#line 2829
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2829
  ushort *xp;
#line 2829
  int nrange = 0;         /* number of range errors */
#line 2829
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2829
  long cxp = (long) *((char**)xpp);
#line 2829

#line 2829
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2829
  /* sjl: manually stripmine so we can limit amount of
#line 2829
   * vector work space reserved to LOOPCNT elements. Also
#line 2829
   * makes vectorisation easy */
#line 2829
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2829
    ni=Min(nelems-j,LOOPCNT);
#line 2829
    if (realign) {
#line 2829
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2829
      xp = tmp;
#line 2829
    } else {
#line 2829
      xp = (ushort *) *xpp;
#line 2829
    }
#line 2829
   /* copy the next block */
#line 2829
#pragma cdir loopcnt=LOOPCNT
#line 2829
#pragma cdir shortloop
#line 2829
    for (i=0; i<ni; i++) {
#line 2829
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2829
     /* test for range errors (not always needed but do it anyway) */
#line 2829
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2829
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2829
      nrange += xp[i] > INT_MAX ;
#line 2829
    }
#line 2829
   /* update xpp and tp */
#line 2829
    if (realign) xp = (ushort *) *xpp;
#line 2829
    xp += ni;
#line 2829
    tp += ni;
#line 2829
    *xpp = (void*)xp;
#line 2829
  }
#line 2829
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2829

#line 2829
#else   /* not SX */
#line 2829
	const char *xp = (const char *) *xpp;
#line 2829
	int status = ENOERR;
#line 2829

#line 2829
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2829
	{
#line 2829
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 2829
		if(lstatus != ENOERR)
#line 2829
			status = lstatus;
#line 2829
	}
#line 2829

#line 2829
	*xpp = (const void *)xp;
#line 2829
	return status;
#line 2829
#  endif
#line 2829
}
#line 2829

int
#line 2830
ncx_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 2830
{
#line 2830
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2830

#line 2830
 /* basic algorithm is:
#line 2830
  *   - ensure sane alignment of input data
#line 2830
  *   - copy (conversion happens automatically) input data
#line 2830
  *     to output
#line 2830
  *   - update xpp to point at next unconverted input, and tp to point
#line 2830
  *     at next location for converted output
#line 2830
  */
#line 2830
  long i, j, ni;
#line 2830
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2830
  ushort *xp;
#line 2830
  int nrange = 0;         /* number of range errors */
#line 2830
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2830
  long cxp = (long) *((char**)xpp);
#line 2830

#line 2830
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2830
  /* sjl: manually stripmine so we can limit amount of
#line 2830
   * vector work space reserved to LOOPCNT elements. Also
#line 2830
   * makes vectorisation easy */
#line 2830
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2830
    ni=Min(nelems-j,LOOPCNT);
#line 2830
    if (realign) {
#line 2830
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2830
      xp = tmp;
#line 2830
    } else {
#line 2830
      xp = (ushort *) *xpp;
#line 2830
    }
#line 2830
   /* copy the next block */
#line 2830
#pragma cdir loopcnt=LOOPCNT
#line 2830
#pragma cdir shortloop
#line 2830
    for (i=0; i<ni; i++) {
#line 2830
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2830
     /* test for range errors (not always needed but do it anyway) */
#line 2830
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2830
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2830
      nrange += xp[i] > FLOAT_MAX ;
#line 2830
    }
#line 2830
   /* update xpp and tp */
#line 2830
    if (realign) xp = (ushort *) *xpp;
#line 2830
    xp += ni;
#line 2830
    tp += ni;
#line 2830
    *xpp = (void*)xp;
#line 2830
  }
#line 2830
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2830

#line 2830
#else   /* not SX */
#line 2830
	const char *xp = (const char *) *xpp;
#line 2830
	int status = ENOERR;
#line 2830

#line 2830
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2830
	{
#line 2830
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 2830
		if(lstatus != ENOERR)
#line 2830
			status = lstatus;
#line 2830
	}
#line 2830

#line 2830
	*xpp = (const void *)xp;
#line 2830
	return status;
#line 2830
#  endif
#line 2830
}
#line 2830

int
#line 2831
ncx_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 2831
{
#line 2831
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2831

#line 2831
 /* basic algorithm is:
#line 2831
  *   - ensure sane alignment of input data
#line 2831
  *   - copy (conversion happens automatically) input data
#line 2831
  *     to output
#line 2831
  *   - update xpp to point at next unconverted input, and tp to point
#line 2831
  *     at next location for converted output
#line 2831
  */
#line 2831
  long i, j, ni;
#line 2831
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2831
  ushort *xp;
#line 2831
  int nrange = 0;         /* number of range errors */
#line 2831
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2831
  long cxp = (long) *((char**)xpp);
#line 2831

#line 2831
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2831
  /* sjl: manually stripmine so we can limit amount of
#line 2831
   * vector work space reserved to LOOPCNT elements. Also
#line 2831
   * makes vectorisation easy */
#line 2831
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2831
    ni=Min(nelems-j,LOOPCNT);
#line 2831
    if (realign) {
#line 2831
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2831
      xp = tmp;
#line 2831
    } else {
#line 2831
      xp = (ushort *) *xpp;
#line 2831
    }
#line 2831
   /* copy the next block */
#line 2831
#pragma cdir loopcnt=LOOPCNT
#line 2831
#pragma cdir shortloop
#line 2831
    for (i=0; i<ni; i++) {
#line 2831
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2831
     /* test for range errors (not always needed but do it anyway) */
#line 2831
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2831
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2831
      nrange += xp[i] > DOUBLE_MAX ;
#line 2831
    }
#line 2831
   /* update xpp and tp */
#line 2831
    if (realign) xp = (ushort *) *xpp;
#line 2831
    xp += ni;
#line 2831
    tp += ni;
#line 2831
    *xpp = (void*)xp;
#line 2831
  }
#line 2831
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2831

#line 2831
#else   /* not SX */
#line 2831
	const char *xp = (const char *) *xpp;
#line 2831
	int status = ENOERR;
#line 2831

#line 2831
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2831
	{
#line 2831
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 2831
		if(lstatus != ENOERR)
#line 2831
			status = lstatus;
#line 2831
	}
#line 2831

#line 2831
	*xpp = (const void *)xp;
#line 2831
	return status;
#line 2831
#  endif
#line 2831
}
#line 2831

int
#line 2832
ncx_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2832
{
#line 2832
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2832

#line 2832
 /* basic algorithm is:
#line 2832
  *   - ensure sane alignment of input data
#line 2832
  *   - copy (conversion happens automatically) input data
#line 2832
  *     to output
#line 2832
  *   - update xpp to point at next unconverted input, and tp to point
#line 2832
  *     at next location for converted output
#line 2832
  */
#line 2832
  long i, j, ni;
#line 2832
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2832
  ushort *xp;
#line 2832
  int nrange = 0;         /* number of range errors */
#line 2832
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2832
  long cxp = (long) *((char**)xpp);
#line 2832

#line 2832
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2832
  /* sjl: manually stripmine so we can limit amount of
#line 2832
   * vector work space reserved to LOOPCNT elements. Also
#line 2832
   * makes vectorisation easy */
#line 2832
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2832
    ni=Min(nelems-j,LOOPCNT);
#line 2832
    if (realign) {
#line 2832
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2832
      xp = tmp;
#line 2832
    } else {
#line 2832
      xp = (ushort *) *xpp;
#line 2832
    }
#line 2832
   /* copy the next block */
#line 2832
#pragma cdir loopcnt=LOOPCNT
#line 2832
#pragma cdir shortloop
#line 2832
    for (i=0; i<ni; i++) {
#line 2832
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2832
     /* test for range errors (not always needed but do it anyway) */
#line 2832
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2832
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2832
      nrange += xp[i] > LONGLONG_MAX ;
#line 2832
    }
#line 2832
   /* update xpp and tp */
#line 2832
    if (realign) xp = (ushort *) *xpp;
#line 2832
    xp += ni;
#line 2832
    tp += ni;
#line 2832
    *xpp = (void*)xp;
#line 2832
  }
#line 2832
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2832

#line 2832
#else   /* not SX */
#line 2832
	const char *xp = (const char *) *xpp;
#line 2832
	int status = ENOERR;
#line 2832

#line 2832
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2832
	{
#line 2832
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 2832
		if(lstatus != ENOERR)
#line 2832
			status = lstatus;
#line 2832
	}
#line 2832

#line 2832
	*xpp = (const void *)xp;
#line 2832
	return status;
#line 2832
#  endif
#line 2832
}
#line 2832

int
#line 2833
ncx_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2833
{
#line 2833
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2833

#line 2833
 /* basic algorithm is:
#line 2833
  *   - ensure sane alignment of input data
#line 2833
  *   - copy (conversion happens automatically) input data
#line 2833
  *     to output
#line 2833
  *   - update xpp to point at next unconverted input, and tp to point
#line 2833
  *     at next location for converted output
#line 2833
  */
#line 2833
  long i, j, ni;
#line 2833
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2833
  ushort *xp;
#line 2833
  int nrange = 0;         /* number of range errors */
#line 2833
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2833
  long cxp = (long) *((char**)xpp);
#line 2833

#line 2833
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2833
  /* sjl: manually stripmine so we can limit amount of
#line 2833
   * vector work space reserved to LOOPCNT elements. Also
#line 2833
   * makes vectorisation easy */
#line 2833
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2833
    ni=Min(nelems-j,LOOPCNT);
#line 2833
    if (realign) {
#line 2833
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2833
      xp = tmp;
#line 2833
    } else {
#line 2833
      xp = (ushort *) *xpp;
#line 2833
    }
#line 2833
   /* copy the next block */
#line 2833
#pragma cdir loopcnt=LOOPCNT
#line 2833
#pragma cdir shortloop
#line 2833
    for (i=0; i<ni; i++) {
#line 2833
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2833
     /* test for range errors (not always needed but do it anyway) */
#line 2833
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2833
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2833
      nrange += xp[i] > UCHAR_MAX ;
#line 2833
    }
#line 2833
   /* update xpp and tp */
#line 2833
    if (realign) xp = (ushort *) *xpp;
#line 2833
    xp += ni;
#line 2833
    tp += ni;
#line 2833
    *xpp = (void*)xp;
#line 2833
  }
#line 2833
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2833

#line 2833
#else   /* not SX */
#line 2833
	const char *xp = (const char *) *xpp;
#line 2833
	int status = ENOERR;
#line 2833

#line 2833
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2833
	{
#line 2833
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 2833
		if(lstatus != ENOERR)
#line 2833
			status = lstatus;
#line 2833
	}
#line 2833

#line 2833
	*xpp = (const void *)xp;
#line 2833
	return status;
#line 2833
#  endif
#line 2833
}
#line 2833

int
#line 2834
ncx_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 2834
{
#line 2834
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2834

#line 2834
 /* basic algorithm is:
#line 2834
  *   - ensure sane alignment of input data
#line 2834
  *   - copy (conversion happens automatically) input data
#line 2834
  *     to output
#line 2834
  *   - update xpp to point at next unconverted input, and tp to point
#line 2834
  *     at next location for converted output
#line 2834
  */
#line 2834
  long i, j, ni;
#line 2834
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2834
  ushort *xp;
#line 2834
  int nrange = 0;         /* number of range errors */
#line 2834
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2834
  long cxp = (long) *((char**)xpp);
#line 2834

#line 2834
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2834
  /* sjl: manually stripmine so we can limit amount of
#line 2834
   * vector work space reserved to LOOPCNT elements. Also
#line 2834
   * makes vectorisation easy */
#line 2834
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2834
    ni=Min(nelems-j,LOOPCNT);
#line 2834
    if (realign) {
#line 2834
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2834
      xp = tmp;
#line 2834
    } else {
#line 2834
      xp = (ushort *) *xpp;
#line 2834
    }
#line 2834
   /* copy the next block */
#line 2834
#pragma cdir loopcnt=LOOPCNT
#line 2834
#pragma cdir shortloop
#line 2834
    for (i=0; i<ni; i++) {
#line 2834
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2834
     /* test for range errors (not always needed but do it anyway) */
#line 2834
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2834
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2834
      nrange += xp[i] > UINT_MAX ;
#line 2834
    }
#line 2834
   /* update xpp and tp */
#line 2834
    if (realign) xp = (ushort *) *xpp;
#line 2834
    xp += ni;
#line 2834
    tp += ni;
#line 2834
    *xpp = (void*)xp;
#line 2834
  }
#line 2834
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2834

#line 2834
#else   /* not SX */
#line 2834
	const char *xp = (const char *) *xpp;
#line 2834
	int status = ENOERR;
#line 2834

#line 2834
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2834
	{
#line 2834
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 2834
		if(lstatus != ENOERR)
#line 2834
			status = lstatus;
#line 2834
	}
#line 2834

#line 2834
	*xpp = (const void *)xp;
#line 2834
	return status;
#line 2834
#  endif
#line 2834
}
#line 2834

int
#line 2835
ncx_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2835
{
#line 2835
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2835

#line 2835
 /* basic algorithm is:
#line 2835
  *   - ensure sane alignment of input data
#line 2835
  *   - copy (conversion happens automatically) input data
#line 2835
  *     to output
#line 2835
  *   - update xpp to point at next unconverted input, and tp to point
#line 2835
  *     at next location for converted output
#line 2835
  */
#line 2835
  long i, j, ni;
#line 2835
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2835
  ushort *xp;
#line 2835
  int nrange = 0;         /* number of range errors */
#line 2835
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2835
  long cxp = (long) *((char**)xpp);
#line 2835

#line 2835
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2835
  /* sjl: manually stripmine so we can limit amount of
#line 2835
   * vector work space reserved to LOOPCNT elements. Also
#line 2835
   * makes vectorisation easy */
#line 2835
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2835
    ni=Min(nelems-j,LOOPCNT);
#line 2835
    if (realign) {
#line 2835
      memcpy(tmp, *xpp, ni*SIZEOF_USHORT);
#line 2835
      xp = tmp;
#line 2835
    } else {
#line 2835
      xp = (ushort *) *xpp;
#line 2835
    }
#line 2835
   /* copy the next block */
#line 2835
#pragma cdir loopcnt=LOOPCNT
#line 2835
#pragma cdir shortloop
#line 2835
    for (i=0; i<ni; i++) {
#line 2835
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2835
     /* test for range errors (not always needed but do it anyway) */
#line 2835
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2835
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2835
      nrange += xp[i] > ULONGLONG_MAX ;
#line 2835
    }
#line 2835
   /* update xpp and tp */
#line 2835
    if (realign) xp = (ushort *) *xpp;
#line 2835
    xp += ni;
#line 2835
    tp += ni;
#line 2835
    *xpp = (void*)xp;
#line 2835
  }
#line 2835
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2835

#line 2835
#else   /* not SX */
#line 2835
	const char *xp = (const char *) *xpp;
#line 2835
	int status = ENOERR;
#line 2835

#line 2835
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2835
	{
#line 2835
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 2835
		if(lstatus != ENOERR)
#line 2835
			status = lstatus;
#line 2835
	}
#line 2835

#line 2835
	*xpp = (const void *)xp;
#line 2835
	return status;
#line 2835
#  endif
#line 2835
}
#line 2835


int
#line 2837
ncx_pad_getn_ushort_schar(const void **xpp, size_t nelems, schar *tp)
#line 2837
{
#line 2837
	const size_t rndup = nelems % 2;
#line 2837

#line 2837
	const char *xp = (const char *) *xpp;
#line 2837
	int status = ENOERR;
#line 2837

#line 2837
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2837
	{
#line 2837
		const int lstatus = ncx_get_ushort_schar(xp, tp);
#line 2837
		if(lstatus != ENOERR)
#line 2837
			status = lstatus;
#line 2837
	}
#line 2837

#line 2837
	if(rndup != 0)
#line 2837
		xp += X_SIZEOF_USHORT;
#line 2837
		
#line 2837
	*xpp = (void *)xp;
#line 2837
	return status;
#line 2837
}
#line 2837

int
#line 2838
ncx_pad_getn_ushort_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2838
{
#line 2838
	const size_t rndup = nelems % 2;
#line 2838

#line 2838
	const char *xp = (const char *) *xpp;
#line 2838
	int status = ENOERR;
#line 2838

#line 2838
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2838
	{
#line 2838
		const int lstatus = ncx_get_ushort_uchar(xp, tp);
#line 2838
		if(lstatus != ENOERR)
#line 2838
			status = lstatus;
#line 2838
	}
#line 2838

#line 2838
	if(rndup != 0)
#line 2838
		xp += X_SIZEOF_USHORT;
#line 2838
		
#line 2838
	*xpp = (void *)xp;
#line 2838
	return status;
#line 2838
}
#line 2838

int
#line 2839
ncx_pad_getn_ushort_short(const void **xpp, size_t nelems, short *tp)
#line 2839
{
#line 2839
	const size_t rndup = nelems % 2;
#line 2839

#line 2839
	const char *xp = (const char *) *xpp;
#line 2839
	int status = ENOERR;
#line 2839

#line 2839
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2839
	{
#line 2839
		const int lstatus = ncx_get_ushort_short(xp, tp);
#line 2839
		if(lstatus != ENOERR)
#line 2839
			status = lstatus;
#line 2839
	}
#line 2839

#line 2839
	if(rndup != 0)
#line 2839
		xp += X_SIZEOF_USHORT;
#line 2839
		
#line 2839
	*xpp = (void *)xp;
#line 2839
	return status;
#line 2839
}
#line 2839

int
#line 2840
ncx_pad_getn_ushort_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2840
{
#line 2840
	const size_t rndup = nelems % 2;
#line 2840

#line 2840
	const char *xp = (const char *) *xpp;
#line 2840
	int status = ENOERR;
#line 2840

#line 2840
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2840
	{
#line 2840
		const int lstatus = ncx_get_ushort_ushort(xp, tp);
#line 2840
		if(lstatus != ENOERR)
#line 2840
			status = lstatus;
#line 2840
	}
#line 2840

#line 2840
	if(rndup != 0)
#line 2840
		xp += X_SIZEOF_USHORT;
#line 2840
		
#line 2840
	*xpp = (void *)xp;
#line 2840
	return status;
#line 2840
}
#line 2840

int
#line 2841
ncx_pad_getn_ushort_int(const void **xpp, size_t nelems, int *tp)
#line 2841
{
#line 2841
	const size_t rndup = nelems % 2;
#line 2841

#line 2841
	const char *xp = (const char *) *xpp;
#line 2841
	int status = ENOERR;
#line 2841

#line 2841
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2841
	{
#line 2841
		const int lstatus = ncx_get_ushort_int(xp, tp);
#line 2841
		if(lstatus != ENOERR)
#line 2841
			status = lstatus;
#line 2841
	}
#line 2841

#line 2841
	if(rndup != 0)
#line 2841
		xp += X_SIZEOF_USHORT;
#line 2841
		
#line 2841
	*xpp = (void *)xp;
#line 2841
	return status;
#line 2841
}
#line 2841

int
#line 2842
ncx_pad_getn_ushort_uint(const void **xpp, size_t nelems, uint *tp)
#line 2842
{
#line 2842
	const size_t rndup = nelems % 2;
#line 2842

#line 2842
	const char *xp = (const char *) *xpp;
#line 2842
	int status = ENOERR;
#line 2842

#line 2842
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2842
	{
#line 2842
		const int lstatus = ncx_get_ushort_uint(xp, tp);
#line 2842
		if(lstatus != ENOERR)
#line 2842
			status = lstatus;
#line 2842
	}
#line 2842

#line 2842
	if(rndup != 0)
#line 2842
		xp += X_SIZEOF_USHORT;
#line 2842
		
#line 2842
	*xpp = (void *)xp;
#line 2842
	return status;
#line 2842
}
#line 2842

int
#line 2843
ncx_pad_getn_ushort_float(const void **xpp, size_t nelems, float *tp)
#line 2843
{
#line 2843
	const size_t rndup = nelems % 2;
#line 2843

#line 2843
	const char *xp = (const char *) *xpp;
#line 2843
	int status = ENOERR;
#line 2843

#line 2843
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2843
	{
#line 2843
		const int lstatus = ncx_get_ushort_float(xp, tp);
#line 2843
		if(lstatus != ENOERR)
#line 2843
			status = lstatus;
#line 2843
	}
#line 2843

#line 2843
	if(rndup != 0)
#line 2843
		xp += X_SIZEOF_USHORT;
#line 2843
		
#line 2843
	*xpp = (void *)xp;
#line 2843
	return status;
#line 2843
}
#line 2843

int
#line 2844
ncx_pad_getn_ushort_double(const void **xpp, size_t nelems, double *tp)
#line 2844
{
#line 2844
	const size_t rndup = nelems % 2;
#line 2844

#line 2844
	const char *xp = (const char *) *xpp;
#line 2844
	int status = ENOERR;
#line 2844

#line 2844
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2844
	{
#line 2844
		const int lstatus = ncx_get_ushort_double(xp, tp);
#line 2844
		if(lstatus != ENOERR)
#line 2844
			status = lstatus;
#line 2844
	}
#line 2844

#line 2844
	if(rndup != 0)
#line 2844
		xp += X_SIZEOF_USHORT;
#line 2844
		
#line 2844
	*xpp = (void *)xp;
#line 2844
	return status;
#line 2844
}
#line 2844

int
#line 2845
ncx_pad_getn_ushort_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2845
{
#line 2845
	const size_t rndup = nelems % 2;
#line 2845

#line 2845
	const char *xp = (const char *) *xpp;
#line 2845
	int status = ENOERR;
#line 2845

#line 2845
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2845
	{
#line 2845
		const int lstatus = ncx_get_ushort_longlong(xp, tp);
#line 2845
		if(lstatus != ENOERR)
#line 2845
			status = lstatus;
#line 2845
	}
#line 2845

#line 2845
	if(rndup != 0)
#line 2845
		xp += X_SIZEOF_USHORT;
#line 2845
		
#line 2845
	*xpp = (void *)xp;
#line 2845
	return status;
#line 2845
}
#line 2845

int
#line 2846
ncx_pad_getn_ushort_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2846
{
#line 2846
	const size_t rndup = nelems % 2;
#line 2846

#line 2846
	const char *xp = (const char *) *xpp;
#line 2846
	int status = ENOERR;
#line 2846

#line 2846
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2846
	{
#line 2846
		const int lstatus = ncx_get_ushort_ulonglong(xp, tp);
#line 2846
		if(lstatus != ENOERR)
#line 2846
			status = lstatus;
#line 2846
	}
#line 2846

#line 2846
	if(rndup != 0)
#line 2846
		xp += X_SIZEOF_USHORT;
#line 2846
		
#line 2846
	*xpp = (void *)xp;
#line 2846
	return status;
#line 2846
}
#line 2846


#if X_SIZEOF_USHORT == SIZEOF_USHORT
/* optimized version */
int
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const unsigned short *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_USHORT);
# else
	swapn2b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_USHORT);
	return ENOERR;
}
#else
int
#line 2862
ncx_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2862
{
#line 2862
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2862

#line 2862
 /* basic algorithm is:
#line 2862
  *   - ensure sane alignment of output data
#line 2862
  *   - copy (conversion happens automatically) input data
#line 2862
  *     to output
#line 2862
  *   - update tp to point at next unconverted input, and xpp to point
#line 2862
  *     at next location for converted output
#line 2862
  */
#line 2862
  long i, j, ni;
#line 2862
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2862
  ushort *xp;
#line 2862
  int nrange = 0;         /* number of range errors */
#line 2862
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2862
  long cxp = (long) *((char**)xpp);
#line 2862

#line 2862
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2862
  /* sjl: manually stripmine so we can limit amount of
#line 2862
   * vector work space reserved to LOOPCNT elements. Also
#line 2862
   * makes vectorisation easy */
#line 2862
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2862
    ni=Min(nelems-j,LOOPCNT);
#line 2862
    if (realign) {
#line 2862
      xp = tmp;
#line 2862
    } else {
#line 2862
      xp = (ushort *) *xpp;
#line 2862
    }
#line 2862
   /* copy the next block */
#line 2862
#pragma cdir loopcnt=LOOPCNT
#line 2862
#pragma cdir shortloop
#line 2862
    for (i=0; i<ni; i++) {
#line 2862
      /* the normal case: */
#line 2862
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2862
     /* test for range errors (not always needed but do it anyway) */
#line 2862
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2862
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2862
      nrange += tp[i] > X_USHORT_MAX ;
#line 2862
    }
#line 2862
   /* copy workspace back if necessary */
#line 2862
    if (realign) {
#line 2862
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2862
      xp = (ushort *) *xpp;
#line 2862
    }
#line 2862
   /* update xpp and tp */
#line 2862
    xp += ni;
#line 2862
    tp += ni;
#line 2862
    *xpp = (void*)xp;
#line 2862
  }
#line 2862
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2862

#line 2862
#else   /* not SX */
#line 2862

#line 2862
	char *xp = (char *) *xpp;
#line 2862
	int status = ENOERR;
#line 2862

#line 2862
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2862
	{
#line 2862
		int lstatus = ncx_put_ushort_ushort(xp, tp);
#line 2862
		if(lstatus != ENOERR)
#line 2862
			status = lstatus;
#line 2862
	}
#line 2862

#line 2862
	*xpp = (void *)xp;
#line 2862
	return status;
#line 2862
#endif
#line 2862
}
#line 2862

#endif
int
#line 2864
ncx_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp)
#line 2864
{
#line 2864
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2864

#line 2864
 /* basic algorithm is:
#line 2864
  *   - ensure sane alignment of output data
#line 2864
  *   - copy (conversion happens automatically) input data
#line 2864
  *     to output
#line 2864
  *   - update tp to point at next unconverted input, and xpp to point
#line 2864
  *     at next location for converted output
#line 2864
  */
#line 2864
  long i, j, ni;
#line 2864
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2864
  ushort *xp;
#line 2864
  int nrange = 0;         /* number of range errors */
#line 2864
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2864
  long cxp = (long) *((char**)xpp);
#line 2864

#line 2864
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2864
  /* sjl: manually stripmine so we can limit amount of
#line 2864
   * vector work space reserved to LOOPCNT elements. Also
#line 2864
   * makes vectorisation easy */
#line 2864
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2864
    ni=Min(nelems-j,LOOPCNT);
#line 2864
    if (realign) {
#line 2864
      xp = tmp;
#line 2864
    } else {
#line 2864
      xp = (ushort *) *xpp;
#line 2864
    }
#line 2864
   /* copy the next block */
#line 2864
#pragma cdir loopcnt=LOOPCNT
#line 2864
#pragma cdir shortloop
#line 2864
    for (i=0; i<ni; i++) {
#line 2864
      /* the normal case: */
#line 2864
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2864
     /* test for range errors (not always needed but do it anyway) */
#line 2864
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2864
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2864
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2864
    }
#line 2864
   /* copy workspace back if necessary */
#line 2864
    if (realign) {
#line 2864
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2864
      xp = (ushort *) *xpp;
#line 2864
    }
#line 2864
   /* update xpp and tp */
#line 2864
    xp += ni;
#line 2864
    tp += ni;
#line 2864
    *xpp = (void*)xp;
#line 2864
  }
#line 2864
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2864

#line 2864
#else   /* not SX */
#line 2864

#line 2864
	char *xp = (char *) *xpp;
#line 2864
	int status = ENOERR;
#line 2864

#line 2864
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2864
	{
#line 2864
		int lstatus = ncx_put_ushort_schar(xp, tp);
#line 2864
		if(lstatus != ENOERR)
#line 2864
			status = lstatus;
#line 2864
	}
#line 2864

#line 2864
	*xpp = (void *)xp;
#line 2864
	return status;
#line 2864
#endif
#line 2864
}
#line 2864

int
#line 2865
ncx_putn_ushort_short(void **xpp, size_t nelems, const short *tp)
#line 2865
{
#line 2865
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2865

#line 2865
 /* basic algorithm is:
#line 2865
  *   - ensure sane alignment of output data
#line 2865
  *   - copy (conversion happens automatically) input data
#line 2865
  *     to output
#line 2865
  *   - update tp to point at next unconverted input, and xpp to point
#line 2865
  *     at next location for converted output
#line 2865
  */
#line 2865
  long i, j, ni;
#line 2865
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2865
  ushort *xp;
#line 2865
  int nrange = 0;         /* number of range errors */
#line 2865
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2865
  long cxp = (long) *((char**)xpp);
#line 2865

#line 2865
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2865
  /* sjl: manually stripmine so we can limit amount of
#line 2865
   * vector work space reserved to LOOPCNT elements. Also
#line 2865
   * makes vectorisation easy */
#line 2865
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2865
    ni=Min(nelems-j,LOOPCNT);
#line 2865
    if (realign) {
#line 2865
      xp = tmp;
#line 2865
    } else {
#line 2865
      xp = (ushort *) *xpp;
#line 2865
    }
#line 2865
   /* copy the next block */
#line 2865
#pragma cdir loopcnt=LOOPCNT
#line 2865
#pragma cdir shortloop
#line 2865
    for (i=0; i<ni; i++) {
#line 2865
      /* the normal case: */
#line 2865
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2865
     /* test for range errors (not always needed but do it anyway) */
#line 2865
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2865
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2865
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2865
    }
#line 2865
   /* copy workspace back if necessary */
#line 2865
    if (realign) {
#line 2865
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2865
      xp = (ushort *) *xpp;
#line 2865
    }
#line 2865
   /* update xpp and tp */
#line 2865
    xp += ni;
#line 2865
    tp += ni;
#line 2865
    *xpp = (void*)xp;
#line 2865
  }
#line 2865
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2865

#line 2865
#else   /* not SX */
#line 2865

#line 2865
	char *xp = (char *) *xpp;
#line 2865
	int status = ENOERR;
#line 2865

#line 2865
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2865
	{
#line 2865
		int lstatus = ncx_put_ushort_short(xp, tp);
#line 2865
		if(lstatus != ENOERR)
#line 2865
			status = lstatus;
#line 2865
	}
#line 2865

#line 2865
	*xpp = (void *)xp;
#line 2865
	return status;
#line 2865
#endif
#line 2865
}
#line 2865

int
#line 2866
ncx_putn_ushort_int(void **xpp, size_t nelems, const int *tp)
#line 2866
{
#line 2866
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2866

#line 2866
 /* basic algorithm is:
#line 2866
  *   - ensure sane alignment of output data
#line 2866
  *   - copy (conversion happens automatically) input data
#line 2866
  *     to output
#line 2866
  *   - update tp to point at next unconverted input, and xpp to point
#line 2866
  *     at next location for converted output
#line 2866
  */
#line 2866
  long i, j, ni;
#line 2866
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2866
  ushort *xp;
#line 2866
  int nrange = 0;         /* number of range errors */
#line 2866
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2866
  long cxp = (long) *((char**)xpp);
#line 2866

#line 2866
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2866
  /* sjl: manually stripmine so we can limit amount of
#line 2866
   * vector work space reserved to LOOPCNT elements. Also
#line 2866
   * makes vectorisation easy */
#line 2866
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2866
    ni=Min(nelems-j,LOOPCNT);
#line 2866
    if (realign) {
#line 2866
      xp = tmp;
#line 2866
    } else {
#line 2866
      xp = (ushort *) *xpp;
#line 2866
    }
#line 2866
   /* copy the next block */
#line 2866
#pragma cdir loopcnt=LOOPCNT
#line 2866
#pragma cdir shortloop
#line 2866
    for (i=0; i<ni; i++) {
#line 2866
      /* the normal case: */
#line 2866
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2866
     /* test for range errors (not always needed but do it anyway) */
#line 2866
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2866
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2866
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2866
    }
#line 2866
   /* copy workspace back if necessary */
#line 2866
    if (realign) {
#line 2866
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2866
      xp = (ushort *) *xpp;
#line 2866
    }
#line 2866
   /* update xpp and tp */
#line 2866
    xp += ni;
#line 2866
    tp += ni;
#line 2866
    *xpp = (void*)xp;
#line 2866
  }
#line 2866
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2866

#line 2866
#else   /* not SX */
#line 2866

#line 2866
	char *xp = (char *) *xpp;
#line 2866
	int status = ENOERR;
#line 2866

#line 2866
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2866
	{
#line 2866
		int lstatus = ncx_put_ushort_int(xp, tp);
#line 2866
		if(lstatus != ENOERR)
#line 2866
			status = lstatus;
#line 2866
	}
#line 2866

#line 2866
	*xpp = (void *)xp;
#line 2866
	return status;
#line 2866
#endif
#line 2866
}
#line 2866

int
#line 2867
ncx_putn_ushort_float(void **xpp, size_t nelems, const float *tp)
#line 2867
{
#line 2867
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2867

#line 2867
 /* basic algorithm is:
#line 2867
  *   - ensure sane alignment of output data
#line 2867
  *   - copy (conversion happens automatically) input data
#line 2867
  *     to output
#line 2867
  *   - update tp to point at next unconverted input, and xpp to point
#line 2867
  *     at next location for converted output
#line 2867
  */
#line 2867
  long i, j, ni;
#line 2867
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2867
  ushort *xp;
#line 2867
  int nrange = 0;         /* number of range errors */
#line 2867
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2867
  long cxp = (long) *((char**)xpp);
#line 2867

#line 2867
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2867
  /* sjl: manually stripmine so we can limit amount of
#line 2867
   * vector work space reserved to LOOPCNT elements. Also
#line 2867
   * makes vectorisation easy */
#line 2867
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2867
    ni=Min(nelems-j,LOOPCNT);
#line 2867
    if (realign) {
#line 2867
      xp = tmp;
#line 2867
    } else {
#line 2867
      xp = (ushort *) *xpp;
#line 2867
    }
#line 2867
   /* copy the next block */
#line 2867
#pragma cdir loopcnt=LOOPCNT
#line 2867
#pragma cdir shortloop
#line 2867
    for (i=0; i<ni; i++) {
#line 2867
      /* the normal case: */
#line 2867
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2867
     /* test for range errors (not always needed but do it anyway) */
#line 2867
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2867
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2867
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2867
    }
#line 2867
   /* copy workspace back if necessary */
#line 2867
    if (realign) {
#line 2867
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2867
      xp = (ushort *) *xpp;
#line 2867
    }
#line 2867
   /* update xpp and tp */
#line 2867
    xp += ni;
#line 2867
    tp += ni;
#line 2867
    *xpp = (void*)xp;
#line 2867
  }
#line 2867
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2867

#line 2867
#else   /* not SX */
#line 2867

#line 2867
	char *xp = (char *) *xpp;
#line 2867
	int status = ENOERR;
#line 2867

#line 2867
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2867
	{
#line 2867
		int lstatus = ncx_put_ushort_float(xp, tp);
#line 2867
		if(lstatus != ENOERR)
#line 2867
			status = lstatus;
#line 2867
	}
#line 2867

#line 2867
	*xpp = (void *)xp;
#line 2867
	return status;
#line 2867
#endif
#line 2867
}
#line 2867

int
#line 2868
ncx_putn_ushort_double(void **xpp, size_t nelems, const double *tp)
#line 2868
{
#line 2868
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2868

#line 2868
 /* basic algorithm is:
#line 2868
  *   - ensure sane alignment of output data
#line 2868
  *   - copy (conversion happens automatically) input data
#line 2868
  *     to output
#line 2868
  *   - update tp to point at next unconverted input, and xpp to point
#line 2868
  *     at next location for converted output
#line 2868
  */
#line 2868
  long i, j, ni;
#line 2868
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2868
  ushort *xp;
#line 2868
  int nrange = 0;         /* number of range errors */
#line 2868
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2868
  long cxp = (long) *((char**)xpp);
#line 2868

#line 2868
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2868
  /* sjl: manually stripmine so we can limit amount of
#line 2868
   * vector work space reserved to LOOPCNT elements. Also
#line 2868
   * makes vectorisation easy */
#line 2868
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2868
    ni=Min(nelems-j,LOOPCNT);
#line 2868
    if (realign) {
#line 2868
      xp = tmp;
#line 2868
    } else {
#line 2868
      xp = (ushort *) *xpp;
#line 2868
    }
#line 2868
   /* copy the next block */
#line 2868
#pragma cdir loopcnt=LOOPCNT
#line 2868
#pragma cdir shortloop
#line 2868
    for (i=0; i<ni; i++) {
#line 2868
      /* the normal case: */
#line 2868
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2868
     /* test for range errors (not always needed but do it anyway) */
#line 2868
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2868
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2868
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2868
    }
#line 2868
   /* copy workspace back if necessary */
#line 2868
    if (realign) {
#line 2868
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2868
      xp = (ushort *) *xpp;
#line 2868
    }
#line 2868
   /* update xpp and tp */
#line 2868
    xp += ni;
#line 2868
    tp += ni;
#line 2868
    *xpp = (void*)xp;
#line 2868
  }
#line 2868
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2868

#line 2868
#else   /* not SX */
#line 2868

#line 2868
	char *xp = (char *) *xpp;
#line 2868
	int status = ENOERR;
#line 2868

#line 2868
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2868
	{
#line 2868
		int lstatus = ncx_put_ushort_double(xp, tp);
#line 2868
		if(lstatus != ENOERR)
#line 2868
			status = lstatus;
#line 2868
	}
#line 2868

#line 2868
	*xpp = (void *)xp;
#line 2868
	return status;
#line 2868
#endif
#line 2868
}
#line 2868

int
#line 2869
ncx_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2869
{
#line 2869
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2869

#line 2869
 /* basic algorithm is:
#line 2869
  *   - ensure sane alignment of output data
#line 2869
  *   - copy (conversion happens automatically) input data
#line 2869
  *     to output
#line 2869
  *   - update tp to point at next unconverted input, and xpp to point
#line 2869
  *     at next location for converted output
#line 2869
  */
#line 2869
  long i, j, ni;
#line 2869
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2869
  ushort *xp;
#line 2869
  int nrange = 0;         /* number of range errors */
#line 2869
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2869
  long cxp = (long) *((char**)xpp);
#line 2869

#line 2869
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2869
  /* sjl: manually stripmine so we can limit amount of
#line 2869
   * vector work space reserved to LOOPCNT elements. Also
#line 2869
   * makes vectorisation easy */
#line 2869
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2869
    ni=Min(nelems-j,LOOPCNT);
#line 2869
    if (realign) {
#line 2869
      xp = tmp;
#line 2869
    } else {
#line 2869
      xp = (ushort *) *xpp;
#line 2869
    }
#line 2869
   /* copy the next block */
#line 2869
#pragma cdir loopcnt=LOOPCNT
#line 2869
#pragma cdir shortloop
#line 2869
    for (i=0; i<ni; i++) {
#line 2869
      /* the normal case: */
#line 2869
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2869
     /* test for range errors (not always needed but do it anyway) */
#line 2869
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2869
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2869
      nrange += tp[i] > X_USHORT_MAX || tp[i] < 0;
#line 2869
    }
#line 2869
   /* copy workspace back if necessary */
#line 2869
    if (realign) {
#line 2869
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2869
      xp = (ushort *) *xpp;
#line 2869
    }
#line 2869
   /* update xpp and tp */
#line 2869
    xp += ni;
#line 2869
    tp += ni;
#line 2869
    *xpp = (void*)xp;
#line 2869
  }
#line 2869
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2869

#line 2869
#else   /* not SX */
#line 2869

#line 2869
	char *xp = (char *) *xpp;
#line 2869
	int status = ENOERR;
#line 2869

#line 2869
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2869
	{
#line 2869
		int lstatus = ncx_put_ushort_longlong(xp, tp);
#line 2869
		if(lstatus != ENOERR)
#line 2869
			status = lstatus;
#line 2869
	}
#line 2869

#line 2869
	*xpp = (void *)xp;
#line 2869
	return status;
#line 2869
#endif
#line 2869
}
#line 2869

int
#line 2870
ncx_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2870
{
#line 2870
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2870

#line 2870
 /* basic algorithm is:
#line 2870
  *   - ensure sane alignment of output data
#line 2870
  *   - copy (conversion happens automatically) input data
#line 2870
  *     to output
#line 2870
  *   - update tp to point at next unconverted input, and xpp to point
#line 2870
  *     at next location for converted output
#line 2870
  */
#line 2870
  long i, j, ni;
#line 2870
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2870
  ushort *xp;
#line 2870
  int nrange = 0;         /* number of range errors */
#line 2870
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2870
  long cxp = (long) *((char**)xpp);
#line 2870

#line 2870
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2870
  /* sjl: manually stripmine so we can limit amount of
#line 2870
   * vector work space reserved to LOOPCNT elements. Also
#line 2870
   * makes vectorisation easy */
#line 2870
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2870
    ni=Min(nelems-j,LOOPCNT);
#line 2870
    if (realign) {
#line 2870
      xp = tmp;
#line 2870
    } else {
#line 2870
      xp = (ushort *) *xpp;
#line 2870
    }
#line 2870
   /* copy the next block */
#line 2870
#pragma cdir loopcnt=LOOPCNT
#line 2870
#pragma cdir shortloop
#line 2870
    for (i=0; i<ni; i++) {
#line 2870
      /* the normal case: */
#line 2870
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2870
     /* test for range errors (not always needed but do it anyway) */
#line 2870
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2870
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2870
      nrange += tp[i] > X_USHORT_MAX ;
#line 2870
    }
#line 2870
   /* copy workspace back if necessary */
#line 2870
    if (realign) {
#line 2870
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2870
      xp = (ushort *) *xpp;
#line 2870
    }
#line 2870
   /* update xpp and tp */
#line 2870
    xp += ni;
#line 2870
    tp += ni;
#line 2870
    *xpp = (void*)xp;
#line 2870
  }
#line 2870
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2870

#line 2870
#else   /* not SX */
#line 2870

#line 2870
	char *xp = (char *) *xpp;
#line 2870
	int status = ENOERR;
#line 2870

#line 2870
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2870
	{
#line 2870
		int lstatus = ncx_put_ushort_uchar(xp, tp);
#line 2870
		if(lstatus != ENOERR)
#line 2870
			status = lstatus;
#line 2870
	}
#line 2870

#line 2870
	*xpp = (void *)xp;
#line 2870
	return status;
#line 2870
#endif
#line 2870
}
#line 2870

int
#line 2871
ncx_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp)
#line 2871
{
#line 2871
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2871

#line 2871
 /* basic algorithm is:
#line 2871
  *   - ensure sane alignment of output data
#line 2871
  *   - copy (conversion happens automatically) input data
#line 2871
  *     to output
#line 2871
  *   - update tp to point at next unconverted input, and xpp to point
#line 2871
  *     at next location for converted output
#line 2871
  */
#line 2871
  long i, j, ni;
#line 2871
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2871
  ushort *xp;
#line 2871
  int nrange = 0;         /* number of range errors */
#line 2871
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2871
  long cxp = (long) *((char**)xpp);
#line 2871

#line 2871
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2871
  /* sjl: manually stripmine so we can limit amount of
#line 2871
   * vector work space reserved to LOOPCNT elements. Also
#line 2871
   * makes vectorisation easy */
#line 2871
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2871
    ni=Min(nelems-j,LOOPCNT);
#line 2871
    if (realign) {
#line 2871
      xp = tmp;
#line 2871
    } else {
#line 2871
      xp = (ushort *) *xpp;
#line 2871
    }
#line 2871
   /* copy the next block */
#line 2871
#pragma cdir loopcnt=LOOPCNT
#line 2871
#pragma cdir shortloop
#line 2871
    for (i=0; i<ni; i++) {
#line 2871
      /* the normal case: */
#line 2871
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2871
     /* test for range errors (not always needed but do it anyway) */
#line 2871
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2871
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2871
      nrange += tp[i] > X_USHORT_MAX ;
#line 2871
    }
#line 2871
   /* copy workspace back if necessary */
#line 2871
    if (realign) {
#line 2871
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2871
      xp = (ushort *) *xpp;
#line 2871
    }
#line 2871
   /* update xpp and tp */
#line 2871
    xp += ni;
#line 2871
    tp += ni;
#line 2871
    *xpp = (void*)xp;
#line 2871
  }
#line 2871
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2871

#line 2871
#else   /* not SX */
#line 2871

#line 2871
	char *xp = (char *) *xpp;
#line 2871
	int status = ENOERR;
#line 2871

#line 2871
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2871
	{
#line 2871
		int lstatus = ncx_put_ushort_uint(xp, tp);
#line 2871
		if(lstatus != ENOERR)
#line 2871
			status = lstatus;
#line 2871
	}
#line 2871

#line 2871
	*xpp = (void *)xp;
#line 2871
	return status;
#line 2871
#endif
#line 2871
}
#line 2871

int
#line 2872
ncx_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2872
{
#line 2872
#if _SX && X_SIZEOF_USHORT == SIZEOF_USHORT
#line 2872

#line 2872
 /* basic algorithm is:
#line 2872
  *   - ensure sane alignment of output data
#line 2872
  *   - copy (conversion happens automatically) input data
#line 2872
  *     to output
#line 2872
  *   - update tp to point at next unconverted input, and xpp to point
#line 2872
  *     at next location for converted output
#line 2872
  */
#line 2872
  long i, j, ni;
#line 2872
  ushort tmp[LOOPCNT];        /* in case input is misaligned */
#line 2872
  ushort *xp;
#line 2872
  int nrange = 0;         /* number of range errors */
#line 2872
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2872
  long cxp = (long) *((char**)xpp);
#line 2872

#line 2872
  realign = (cxp & 7) % SIZEOF_USHORT;
#line 2872
  /* sjl: manually stripmine so we can limit amount of
#line 2872
   * vector work space reserved to LOOPCNT elements. Also
#line 2872
   * makes vectorisation easy */
#line 2872
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2872
    ni=Min(nelems-j,LOOPCNT);
#line 2872
    if (realign) {
#line 2872
      xp = tmp;
#line 2872
    } else {
#line 2872
      xp = (ushort *) *xpp;
#line 2872
    }
#line 2872
   /* copy the next block */
#line 2872
#pragma cdir loopcnt=LOOPCNT
#line 2872
#pragma cdir shortloop
#line 2872
    for (i=0; i<ni; i++) {
#line 2872
      /* the normal case: */
#line 2872
      xp[i] = (ushort) Max( X_USHORT_MIN, Min(X_USHORT_MAX, (ushort) tp[i]));
#line 2872
     /* test for range errors (not always needed but do it anyway) */
#line 2872
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2872
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2872
      nrange += tp[i] > X_USHORT_MAX ;
#line 2872
    }
#line 2872
   /* copy workspace back if necessary */
#line 2872
    if (realign) {
#line 2872
      memcpy(*xpp, tmp, ni*X_SIZEOF_USHORT);
#line 2872
      xp = (ushort *) *xpp;
#line 2872
    }
#line 2872
   /* update xpp and tp */
#line 2872
    xp += ni;
#line 2872
    tp += ni;
#line 2872
    *xpp = (void*)xp;
#line 2872
  }
#line 2872
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2872

#line 2872
#else   /* not SX */
#line 2872

#line 2872
	char *xp = (char *) *xpp;
#line 2872
	int status = ENOERR;
#line 2872

#line 2872
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2872
	{
#line 2872
		int lstatus = ncx_put_ushort_ulonglong(xp, tp);
#line 2872
		if(lstatus != ENOERR)
#line 2872
			status = lstatus;
#line 2872
	}
#line 2872

#line 2872
	*xpp = (void *)xp;
#line 2872
	return status;
#line 2872
#endif
#line 2872
}
#line 2872


int
#line 2874
ncx_pad_putn_ushort_schar(void **xpp, size_t nelems, const schar *tp)
#line 2874
{
#line 2874
	const size_t rndup = nelems % 2;
#line 2874

#line 2874
	char *xp = (char *) *xpp;
#line 2874
	int status = ENOERR;
#line 2874

#line 2874
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2874
	{
#line 2874
		int lstatus = ncx_put_ushort_schar(xp, tp);
#line 2874
		if(lstatus != ENOERR)
#line 2874
			status = lstatus;
#line 2874
	}
#line 2874

#line 2874
	if(rndup != 0)
#line 2874
	{
#line 2874
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2874
		xp += X_SIZEOF_USHORT;	
#line 2874
	}
#line 2874

#line 2874
	*xpp = (void *)xp;
#line 2874
	return status;
#line 2874
}
#line 2874

int
#line 2875
ncx_pad_putn_ushort_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2875
{
#line 2875
	const size_t rndup = nelems % 2;
#line 2875

#line 2875
	char *xp = (char *) *xpp;
#line 2875
	int status = ENOERR;
#line 2875

#line 2875
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2875
	{
#line 2875
		int lstatus = ncx_put_ushort_uchar(xp, tp);
#line 2875
		if(lstatus != ENOERR)
#line 2875
			status = lstatus;
#line 2875
	}
#line 2875

#line 2875
	if(rndup != 0)
#line 2875
	{
#line 2875
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2875
		xp += X_SIZEOF_USHORT;	
#line 2875
	}
#line 2875

#line 2875
	*xpp = (void *)xp;
#line 2875
	return status;
#line 2875
}
#line 2875

int
#line 2876
ncx_pad_putn_ushort_short(void **xpp, size_t nelems, const short *tp)
#line 2876
{
#line 2876
	const size_t rndup = nelems % 2;
#line 2876

#line 2876
	char *xp = (char *) *xpp;
#line 2876
	int status = ENOERR;
#line 2876

#line 2876
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2876
	{
#line 2876
		int lstatus = ncx_put_ushort_short(xp, tp);
#line 2876
		if(lstatus != ENOERR)
#line 2876
			status = lstatus;
#line 2876
	}
#line 2876

#line 2876
	if(rndup != 0)
#line 2876
	{
#line 2876
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2876
		xp += X_SIZEOF_USHORT;	
#line 2876
	}
#line 2876

#line 2876
	*xpp = (void *)xp;
#line 2876
	return status;
#line 2876
}
#line 2876

int
#line 2877
ncx_pad_putn_ushort_int(void **xpp, size_t nelems, const int *tp)
#line 2877
{
#line 2877
	const size_t rndup = nelems % 2;
#line 2877

#line 2877
	char *xp = (char *) *xpp;
#line 2877
	int status = ENOERR;
#line 2877

#line 2877
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2877
	{
#line 2877
		int lstatus = ncx_put_ushort_int(xp, tp);
#line 2877
		if(lstatus != ENOERR)
#line 2877
			status = lstatus;
#line 2877
	}
#line 2877

#line 2877
	if(rndup != 0)
#line 2877
	{
#line 2877
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2877
		xp += X_SIZEOF_USHORT;	
#line 2877
	}
#line 2877

#line 2877
	*xpp = (void *)xp;
#line 2877
	return status;
#line 2877
}
#line 2877

int
#line 2878
ncx_pad_putn_ushort_float(void **xpp, size_t nelems, const float *tp)
#line 2878
{
#line 2878
	const size_t rndup = nelems % 2;
#line 2878

#line 2878
	char *xp = (char *) *xpp;
#line 2878
	int status = ENOERR;
#line 2878

#line 2878
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2878
	{
#line 2878
		int lstatus = ncx_put_ushort_float(xp, tp);
#line 2878
		if(lstatus != ENOERR)
#line 2878
			status = lstatus;
#line 2878
	}
#line 2878

#line 2878
	if(rndup != 0)
#line 2878
	{
#line 2878
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2878
		xp += X_SIZEOF_USHORT;	
#line 2878
	}
#line 2878

#line 2878
	*xpp = (void *)xp;
#line 2878
	return status;
#line 2878
}
#line 2878

int
#line 2879
ncx_pad_putn_ushort_double(void **xpp, size_t nelems, const double *tp)
#line 2879
{
#line 2879
	const size_t rndup = nelems % 2;
#line 2879

#line 2879
	char *xp = (char *) *xpp;
#line 2879
	int status = ENOERR;
#line 2879

#line 2879
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2879
	{
#line 2879
		int lstatus = ncx_put_ushort_double(xp, tp);
#line 2879
		if(lstatus != ENOERR)
#line 2879
			status = lstatus;
#line 2879
	}
#line 2879

#line 2879
	if(rndup != 0)
#line 2879
	{
#line 2879
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2879
		xp += X_SIZEOF_USHORT;	
#line 2879
	}
#line 2879

#line 2879
	*xpp = (void *)xp;
#line 2879
	return status;
#line 2879
}
#line 2879

int
#line 2880
ncx_pad_putn_ushort_uint(void **xpp, size_t nelems, const uint *tp)
#line 2880
{
#line 2880
	const size_t rndup = nelems % 2;
#line 2880

#line 2880
	char *xp = (char *) *xpp;
#line 2880
	int status = ENOERR;
#line 2880

#line 2880
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2880
	{
#line 2880
		int lstatus = ncx_put_ushort_uint(xp, tp);
#line 2880
		if(lstatus != ENOERR)
#line 2880
			status = lstatus;
#line 2880
	}
#line 2880

#line 2880
	if(rndup != 0)
#line 2880
	{
#line 2880
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2880
		xp += X_SIZEOF_USHORT;	
#line 2880
	}
#line 2880

#line 2880
	*xpp = (void *)xp;
#line 2880
	return status;
#line 2880
}
#line 2880

int
#line 2881
ncx_pad_putn_ushort_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2881
{
#line 2881
	const size_t rndup = nelems % 2;
#line 2881

#line 2881
	char *xp = (char *) *xpp;
#line 2881
	int status = ENOERR;
#line 2881

#line 2881
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2881
	{
#line 2881
		int lstatus = ncx_put_ushort_longlong(xp, tp);
#line 2881
		if(lstatus != ENOERR)
#line 2881
			status = lstatus;
#line 2881
	}
#line 2881

#line 2881
	if(rndup != 0)
#line 2881
	{
#line 2881
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2881
		xp += X_SIZEOF_USHORT;	
#line 2881
	}
#line 2881

#line 2881
	*xpp = (void *)xp;
#line 2881
	return status;
#line 2881
}
#line 2881

int
#line 2882
ncx_pad_putn_ushort_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2882
{
#line 2882
	const size_t rndup = nelems % 2;
#line 2882

#line 2882
	char *xp = (char *) *xpp;
#line 2882
	int status = ENOERR;
#line 2882

#line 2882
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2882
	{
#line 2882
		int lstatus = ncx_put_ushort_ulonglong(xp, tp);
#line 2882
		if(lstatus != ENOERR)
#line 2882
			status = lstatus;
#line 2882
	}
#line 2882

#line 2882
	if(rndup != 0)
#line 2882
	{
#line 2882
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2882
		xp += X_SIZEOF_USHORT;	
#line 2882
	}
#line 2882

#line 2882
	*xpp = (void *)xp;
#line 2882
	return status;
#line 2882
}
#line 2882

int
#line 2883
ncx_pad_putn_ushort_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2883
{
#line 2883
	const size_t rndup = nelems % 2;
#line 2883

#line 2883
	char *xp = (char *) *xpp;
#line 2883
	int status = ENOERR;
#line 2883

#line 2883
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_USHORT, tp++)
#line 2883
	{
#line 2883
		int lstatus = ncx_put_ushort_ushort(xp, tp);
#line 2883
		if(lstatus != ENOERR)
#line 2883
			status = lstatus;
#line 2883
	}
#line 2883

#line 2883
	if(rndup != 0)
#line 2883
	{
#line 2883
		(void) memcpy(xp, nada, X_SIZEOF_USHORT);
#line 2883
		xp += X_SIZEOF_USHORT;	
#line 2883
	}
#line 2883

#line 2883
	*xpp = (void *)xp;
#line 2883
	return status;
#line 2883
}
#line 2883



/* int -----------------------------------------------------------------------*/

#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(int));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
#else
int
#line 2902
ncx_getn_int_int(const void **xpp, size_t nelems, int *tp)
#line 2902
{
#line 2902
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2902

#line 2902
 /* basic algorithm is:
#line 2902
  *   - ensure sane alignment of input data
#line 2902
  *   - copy (conversion happens automatically) input data
#line 2902
  *     to output
#line 2902
  *   - update xpp to point at next unconverted input, and tp to point
#line 2902
  *     at next location for converted output
#line 2902
  */
#line 2902
  long i, j, ni;
#line 2902
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2902
  int *xp;
#line 2902
  int nrange = 0;         /* number of range errors */
#line 2902
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2902
  long cxp = (long) *((char**)xpp);
#line 2902

#line 2902
  realign = (cxp & 7) % SIZEOF_INT;
#line 2902
  /* sjl: manually stripmine so we can limit amount of
#line 2902
   * vector work space reserved to LOOPCNT elements. Also
#line 2902
   * makes vectorisation easy */
#line 2902
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2902
    ni=Min(nelems-j,LOOPCNT);
#line 2902
    if (realign) {
#line 2902
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2902
      xp = tmp;
#line 2902
    } else {
#line 2902
      xp = (int *) *xpp;
#line 2902
    }
#line 2902
   /* copy the next block */
#line 2902
#pragma cdir loopcnt=LOOPCNT
#line 2902
#pragma cdir shortloop
#line 2902
    for (i=0; i<ni; i++) {
#line 2902
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2902
     /* test for range errors (not always needed but do it anyway) */
#line 2902
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2902
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2902
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 2902
    }
#line 2902
   /* update xpp and tp */
#line 2902
    if (realign) xp = (int *) *xpp;
#line 2902
    xp += ni;
#line 2902
    tp += ni;
#line 2902
    *xpp = (void*)xp;
#line 2902
  }
#line 2902
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2902

#line 2902
#else   /* not SX */
#line 2902
	const char *xp = (const char *) *xpp;
#line 2902
	int status = ENOERR;
#line 2902

#line 2902
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2902
	{
#line 2902
		const int lstatus = ncx_get_int_int(xp, tp);
#line 2902
		if(lstatus != ENOERR)
#line 2902
			status = lstatus;
#line 2902
	}
#line 2902

#line 2902
	*xpp = (const void *)xp;
#line 2902
	return status;
#line 2902
#  endif
#line 2902
}
#line 2902

#endif
int
#line 2904
ncx_getn_int_schar(const void **xpp, size_t nelems, schar *tp)
#line 2904
{
#line 2904
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2904

#line 2904
 /* basic algorithm is:
#line 2904
  *   - ensure sane alignment of input data
#line 2904
  *   - copy (conversion happens automatically) input data
#line 2904
  *     to output
#line 2904
  *   - update xpp to point at next unconverted input, and tp to point
#line 2904
  *     at next location for converted output
#line 2904
  */
#line 2904
  long i, j, ni;
#line 2904
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2904
  int *xp;
#line 2904
  int nrange = 0;         /* number of range errors */
#line 2904
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2904
  long cxp = (long) *((char**)xpp);
#line 2904

#line 2904
  realign = (cxp & 7) % SIZEOF_INT;
#line 2904
  /* sjl: manually stripmine so we can limit amount of
#line 2904
   * vector work space reserved to LOOPCNT elements. Also
#line 2904
   * makes vectorisation easy */
#line 2904
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2904
    ni=Min(nelems-j,LOOPCNT);
#line 2904
    if (realign) {
#line 2904
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2904
      xp = tmp;
#line 2904
    } else {
#line 2904
      xp = (int *) *xpp;
#line 2904
    }
#line 2904
   /* copy the next block */
#line 2904
#pragma cdir loopcnt=LOOPCNT
#line 2904
#pragma cdir shortloop
#line 2904
    for (i=0; i<ni; i++) {
#line 2904
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2904
     /* test for range errors (not always needed but do it anyway) */
#line 2904
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2904
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2904
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 2904
    }
#line 2904
   /* update xpp and tp */
#line 2904
    if (realign) xp = (int *) *xpp;
#line 2904
    xp += ni;
#line 2904
    tp += ni;
#line 2904
    *xpp = (void*)xp;
#line 2904
  }
#line 2904
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2904

#line 2904
#else   /* not SX */
#line 2904
	const char *xp = (const char *) *xpp;
#line 2904
	int status = ENOERR;
#line 2904

#line 2904
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2904
	{
#line 2904
		const int lstatus = ncx_get_int_schar(xp, tp);
#line 2904
		if(lstatus != ENOERR)
#line 2904
			status = lstatus;
#line 2904
	}
#line 2904

#line 2904
	*xpp = (const void *)xp;
#line 2904
	return status;
#line 2904
#  endif
#line 2904
}
#line 2904

int
#line 2905
ncx_getn_int_short(const void **xpp, size_t nelems, short *tp)
#line 2905
{
#line 2905
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2905

#line 2905
 /* basic algorithm is:
#line 2905
  *   - ensure sane alignment of input data
#line 2905
  *   - copy (conversion happens automatically) input data
#line 2905
  *     to output
#line 2905
  *   - update xpp to point at next unconverted input, and tp to point
#line 2905
  *     at next location for converted output
#line 2905
  */
#line 2905
  long i, j, ni;
#line 2905
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2905
  int *xp;
#line 2905
  int nrange = 0;         /* number of range errors */
#line 2905
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2905
  long cxp = (long) *((char**)xpp);
#line 2905

#line 2905
  realign = (cxp & 7) % SIZEOF_INT;
#line 2905
  /* sjl: manually stripmine so we can limit amount of
#line 2905
   * vector work space reserved to LOOPCNT elements. Also
#line 2905
   * makes vectorisation easy */
#line 2905
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2905
    ni=Min(nelems-j,LOOPCNT);
#line 2905
    if (realign) {
#line 2905
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2905
      xp = tmp;
#line 2905
    } else {
#line 2905
      xp = (int *) *xpp;
#line 2905
    }
#line 2905
   /* copy the next block */
#line 2905
#pragma cdir loopcnt=LOOPCNT
#line 2905
#pragma cdir shortloop
#line 2905
    for (i=0; i<ni; i++) {
#line 2905
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2905
     /* test for range errors (not always needed but do it anyway) */
#line 2905
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2905
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2905
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 2905
    }
#line 2905
   /* update xpp and tp */
#line 2905
    if (realign) xp = (int *) *xpp;
#line 2905
    xp += ni;
#line 2905
    tp += ni;
#line 2905
    *xpp = (void*)xp;
#line 2905
  }
#line 2905
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2905

#line 2905
#else   /* not SX */
#line 2905
	const char *xp = (const char *) *xpp;
#line 2905
	int status = ENOERR;
#line 2905

#line 2905
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2905
	{
#line 2905
		const int lstatus = ncx_get_int_short(xp, tp);
#line 2905
		if(lstatus != ENOERR)
#line 2905
			status = lstatus;
#line 2905
	}
#line 2905

#line 2905
	*xpp = (const void *)xp;
#line 2905
	return status;
#line 2905
#  endif
#line 2905
}
#line 2905

int
#line 2906
ncx_getn_int_float(const void **xpp, size_t nelems, float *tp)
#line 2906
{
#line 2906
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2906

#line 2906
 /* basic algorithm is:
#line 2906
  *   - ensure sane alignment of input data
#line 2906
  *   - copy (conversion happens automatically) input data
#line 2906
  *     to output
#line 2906
  *   - update xpp to point at next unconverted input, and tp to point
#line 2906
  *     at next location for converted output
#line 2906
  */
#line 2906
  long i, j, ni;
#line 2906
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2906
  int *xp;
#line 2906
  int nrange = 0;         /* number of range errors */
#line 2906
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2906
  long cxp = (long) *((char**)xpp);
#line 2906

#line 2906
  realign = (cxp & 7) % SIZEOF_INT;
#line 2906
  /* sjl: manually stripmine so we can limit amount of
#line 2906
   * vector work space reserved to LOOPCNT elements. Also
#line 2906
   * makes vectorisation easy */
#line 2906
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2906
    ni=Min(nelems-j,LOOPCNT);
#line 2906
    if (realign) {
#line 2906
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2906
      xp = tmp;
#line 2906
    } else {
#line 2906
      xp = (int *) *xpp;
#line 2906
    }
#line 2906
   /* copy the next block */
#line 2906
#pragma cdir loopcnt=LOOPCNT
#line 2906
#pragma cdir shortloop
#line 2906
    for (i=0; i<ni; i++) {
#line 2906
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2906
     /* test for range errors (not always needed but do it anyway) */
#line 2906
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2906
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2906
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 2906
    }
#line 2906
   /* update xpp and tp */
#line 2906
    if (realign) xp = (int *) *xpp;
#line 2906
    xp += ni;
#line 2906
    tp += ni;
#line 2906
    *xpp = (void*)xp;
#line 2906
  }
#line 2906
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2906

#line 2906
#else   /* not SX */
#line 2906
	const char *xp = (const char *) *xpp;
#line 2906
	int status = ENOERR;
#line 2906

#line 2906
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2906
	{
#line 2906
		const int lstatus = ncx_get_int_float(xp, tp);
#line 2906
		if(lstatus != ENOERR)
#line 2906
			status = lstatus;
#line 2906
	}
#line 2906

#line 2906
	*xpp = (const void *)xp;
#line 2906
	return status;
#line 2906
#  endif
#line 2906
}
#line 2906

int
#line 2907
ncx_getn_int_double(const void **xpp, size_t nelems, double *tp)
#line 2907
{
#line 2907
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2907

#line 2907
 /* basic algorithm is:
#line 2907
  *   - ensure sane alignment of input data
#line 2907
  *   - copy (conversion happens automatically) input data
#line 2907
  *     to output
#line 2907
  *   - update xpp to point at next unconverted input, and tp to point
#line 2907
  *     at next location for converted output
#line 2907
  */
#line 2907
  long i, j, ni;
#line 2907
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2907
  int *xp;
#line 2907
  int nrange = 0;         /* number of range errors */
#line 2907
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2907
  long cxp = (long) *((char**)xpp);
#line 2907

#line 2907
  realign = (cxp & 7) % SIZEOF_INT;
#line 2907
  /* sjl: manually stripmine so we can limit amount of
#line 2907
   * vector work space reserved to LOOPCNT elements. Also
#line 2907
   * makes vectorisation easy */
#line 2907
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2907
    ni=Min(nelems-j,LOOPCNT);
#line 2907
    if (realign) {
#line 2907
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2907
      xp = tmp;
#line 2907
    } else {
#line 2907
      xp = (int *) *xpp;
#line 2907
    }
#line 2907
   /* copy the next block */
#line 2907
#pragma cdir loopcnt=LOOPCNT
#line 2907
#pragma cdir shortloop
#line 2907
    for (i=0; i<ni; i++) {
#line 2907
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2907
     /* test for range errors (not always needed but do it anyway) */
#line 2907
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2907
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2907
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 2907
    }
#line 2907
   /* update xpp and tp */
#line 2907
    if (realign) xp = (int *) *xpp;
#line 2907
    xp += ni;
#line 2907
    tp += ni;
#line 2907
    *xpp = (void*)xp;
#line 2907
  }
#line 2907
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2907

#line 2907
#else   /* not SX */
#line 2907
	const char *xp = (const char *) *xpp;
#line 2907
	int status = ENOERR;
#line 2907

#line 2907
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2907
	{
#line 2907
		const int lstatus = ncx_get_int_double(xp, tp);
#line 2907
		if(lstatus != ENOERR)
#line 2907
			status = lstatus;
#line 2907
	}
#line 2907

#line 2907
	*xpp = (const void *)xp;
#line 2907
	return status;
#line 2907
#  endif
#line 2907
}
#line 2907

int
#line 2908
ncx_getn_int_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2908
{
#line 2908
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2908

#line 2908
 /* basic algorithm is:
#line 2908
  *   - ensure sane alignment of input data
#line 2908
  *   - copy (conversion happens automatically) input data
#line 2908
  *     to output
#line 2908
  *   - update xpp to point at next unconverted input, and tp to point
#line 2908
  *     at next location for converted output
#line 2908
  */
#line 2908
  long i, j, ni;
#line 2908
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2908
  int *xp;
#line 2908
  int nrange = 0;         /* number of range errors */
#line 2908
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2908
  long cxp = (long) *((char**)xpp);
#line 2908

#line 2908
  realign = (cxp & 7) % SIZEOF_INT;
#line 2908
  /* sjl: manually stripmine so we can limit amount of
#line 2908
   * vector work space reserved to LOOPCNT elements. Also
#line 2908
   * makes vectorisation easy */
#line 2908
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2908
    ni=Min(nelems-j,LOOPCNT);
#line 2908
    if (realign) {
#line 2908
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2908
      xp = tmp;
#line 2908
    } else {
#line 2908
      xp = (int *) *xpp;
#line 2908
    }
#line 2908
   /* copy the next block */
#line 2908
#pragma cdir loopcnt=LOOPCNT
#line 2908
#pragma cdir shortloop
#line 2908
    for (i=0; i<ni; i++) {
#line 2908
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2908
     /* test for range errors (not always needed but do it anyway) */
#line 2908
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2908
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2908
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 2908
    }
#line 2908
   /* update xpp and tp */
#line 2908
    if (realign) xp = (int *) *xpp;
#line 2908
    xp += ni;
#line 2908
    tp += ni;
#line 2908
    *xpp = (void*)xp;
#line 2908
  }
#line 2908
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2908

#line 2908
#else   /* not SX */
#line 2908
	const char *xp = (const char *) *xpp;
#line 2908
	int status = ENOERR;
#line 2908

#line 2908
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2908
	{
#line 2908
		const int lstatus = ncx_get_int_longlong(xp, tp);
#line 2908
		if(lstatus != ENOERR)
#line 2908
			status = lstatus;
#line 2908
	}
#line 2908

#line 2908
	*xpp = (const void *)xp;
#line 2908
	return status;
#line 2908
#  endif
#line 2908
}
#line 2908

int
#line 2909
ncx_getn_int_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2909
{
#line 2909
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2909

#line 2909
 /* basic algorithm is:
#line 2909
  *   - ensure sane alignment of input data
#line 2909
  *   - copy (conversion happens automatically) input data
#line 2909
  *     to output
#line 2909
  *   - update xpp to point at next unconverted input, and tp to point
#line 2909
  *     at next location for converted output
#line 2909
  */
#line 2909
  long i, j, ni;
#line 2909
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2909
  int *xp;
#line 2909
  int nrange = 0;         /* number of range errors */
#line 2909
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2909
  long cxp = (long) *((char**)xpp);
#line 2909

#line 2909
  realign = (cxp & 7) % SIZEOF_INT;
#line 2909
  /* sjl: manually stripmine so we can limit amount of
#line 2909
   * vector work space reserved to LOOPCNT elements. Also
#line 2909
   * makes vectorisation easy */
#line 2909
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2909
    ni=Min(nelems-j,LOOPCNT);
#line 2909
    if (realign) {
#line 2909
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2909
      xp = tmp;
#line 2909
    } else {
#line 2909
      xp = (int *) *xpp;
#line 2909
    }
#line 2909
   /* copy the next block */
#line 2909
#pragma cdir loopcnt=LOOPCNT
#line 2909
#pragma cdir shortloop
#line 2909
    for (i=0; i<ni; i++) {
#line 2909
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2909
     /* test for range errors (not always needed but do it anyway) */
#line 2909
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2909
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2909
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 2909
    }
#line 2909
   /* update xpp and tp */
#line 2909
    if (realign) xp = (int *) *xpp;
#line 2909
    xp += ni;
#line 2909
    tp += ni;
#line 2909
    *xpp = (void*)xp;
#line 2909
  }
#line 2909
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2909

#line 2909
#else   /* not SX */
#line 2909
	const char *xp = (const char *) *xpp;
#line 2909
	int status = ENOERR;
#line 2909

#line 2909
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2909
	{
#line 2909
		const int lstatus = ncx_get_int_uchar(xp, tp);
#line 2909
		if(lstatus != ENOERR)
#line 2909
			status = lstatus;
#line 2909
	}
#line 2909

#line 2909
	*xpp = (const void *)xp;
#line 2909
	return status;
#line 2909
#  endif
#line 2909
}
#line 2909

int
#line 2910
ncx_getn_int_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2910
{
#line 2910
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2910

#line 2910
 /* basic algorithm is:
#line 2910
  *   - ensure sane alignment of input data
#line 2910
  *   - copy (conversion happens automatically) input data
#line 2910
  *     to output
#line 2910
  *   - update xpp to point at next unconverted input, and tp to point
#line 2910
  *     at next location for converted output
#line 2910
  */
#line 2910
  long i, j, ni;
#line 2910
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2910
  int *xp;
#line 2910
  int nrange = 0;         /* number of range errors */
#line 2910
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2910
  long cxp = (long) *((char**)xpp);
#line 2910

#line 2910
  realign = (cxp & 7) % SIZEOF_INT;
#line 2910
  /* sjl: manually stripmine so we can limit amount of
#line 2910
   * vector work space reserved to LOOPCNT elements. Also
#line 2910
   * makes vectorisation easy */
#line 2910
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2910
    ni=Min(nelems-j,LOOPCNT);
#line 2910
    if (realign) {
#line 2910
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2910
      xp = tmp;
#line 2910
    } else {
#line 2910
      xp = (int *) *xpp;
#line 2910
    }
#line 2910
   /* copy the next block */
#line 2910
#pragma cdir loopcnt=LOOPCNT
#line 2910
#pragma cdir shortloop
#line 2910
    for (i=0; i<ni; i++) {
#line 2910
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2910
     /* test for range errors (not always needed but do it anyway) */
#line 2910
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2910
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2910
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 2910
    }
#line 2910
   /* update xpp and tp */
#line 2910
    if (realign) xp = (int *) *xpp;
#line 2910
    xp += ni;
#line 2910
    tp += ni;
#line 2910
    *xpp = (void*)xp;
#line 2910
  }
#line 2910
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2910

#line 2910
#else   /* not SX */
#line 2910
	const char *xp = (const char *) *xpp;
#line 2910
	int status = ENOERR;
#line 2910

#line 2910
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2910
	{
#line 2910
		const int lstatus = ncx_get_int_ushort(xp, tp);
#line 2910
		if(lstatus != ENOERR)
#line 2910
			status = lstatus;
#line 2910
	}
#line 2910

#line 2910
	*xpp = (const void *)xp;
#line 2910
	return status;
#line 2910
#  endif
#line 2910
}
#line 2910

int
#line 2911
ncx_getn_int_uint(const void **xpp, size_t nelems, uint *tp)
#line 2911
{
#line 2911
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2911

#line 2911
 /* basic algorithm is:
#line 2911
  *   - ensure sane alignment of input data
#line 2911
  *   - copy (conversion happens automatically) input data
#line 2911
  *     to output
#line 2911
  *   - update xpp to point at next unconverted input, and tp to point
#line 2911
  *     at next location for converted output
#line 2911
  */
#line 2911
  long i, j, ni;
#line 2911
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2911
  int *xp;
#line 2911
  int nrange = 0;         /* number of range errors */
#line 2911
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2911
  long cxp = (long) *((char**)xpp);
#line 2911

#line 2911
  realign = (cxp & 7) % SIZEOF_INT;
#line 2911
  /* sjl: manually stripmine so we can limit amount of
#line 2911
   * vector work space reserved to LOOPCNT elements. Also
#line 2911
   * makes vectorisation easy */
#line 2911
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2911
    ni=Min(nelems-j,LOOPCNT);
#line 2911
    if (realign) {
#line 2911
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2911
      xp = tmp;
#line 2911
    } else {
#line 2911
      xp = (int *) *xpp;
#line 2911
    }
#line 2911
   /* copy the next block */
#line 2911
#pragma cdir loopcnt=LOOPCNT
#line 2911
#pragma cdir shortloop
#line 2911
    for (i=0; i<ni; i++) {
#line 2911
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2911
     /* test for range errors (not always needed but do it anyway) */
#line 2911
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2911
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2911
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 2911
    }
#line 2911
   /* update xpp and tp */
#line 2911
    if (realign) xp = (int *) *xpp;
#line 2911
    xp += ni;
#line 2911
    tp += ni;
#line 2911
    *xpp = (void*)xp;
#line 2911
  }
#line 2911
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2911

#line 2911
#else   /* not SX */
#line 2911
	const char *xp = (const char *) *xpp;
#line 2911
	int status = ENOERR;
#line 2911

#line 2911
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2911
	{
#line 2911
		const int lstatus = ncx_get_int_uint(xp, tp);
#line 2911
		if(lstatus != ENOERR)
#line 2911
			status = lstatus;
#line 2911
	}
#line 2911

#line 2911
	*xpp = (const void *)xp;
#line 2911
	return status;
#line 2911
#  endif
#line 2911
}
#line 2911

int
#line 2912
ncx_getn_int_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2912
{
#line 2912
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2912

#line 2912
 /* basic algorithm is:
#line 2912
  *   - ensure sane alignment of input data
#line 2912
  *   - copy (conversion happens automatically) input data
#line 2912
  *     to output
#line 2912
  *   - update xpp to point at next unconverted input, and tp to point
#line 2912
  *     at next location for converted output
#line 2912
  */
#line 2912
  long i, j, ni;
#line 2912
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2912
  int *xp;
#line 2912
  int nrange = 0;         /* number of range errors */
#line 2912
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2912
  long cxp = (long) *((char**)xpp);
#line 2912

#line 2912
  realign = (cxp & 7) % SIZEOF_INT;
#line 2912
  /* sjl: manually stripmine so we can limit amount of
#line 2912
   * vector work space reserved to LOOPCNT elements. Also
#line 2912
   * makes vectorisation easy */
#line 2912
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2912
    ni=Min(nelems-j,LOOPCNT);
#line 2912
    if (realign) {
#line 2912
      memcpy(tmp, *xpp, ni*SIZEOF_INT);
#line 2912
      xp = tmp;
#line 2912
    } else {
#line 2912
      xp = (int *) *xpp;
#line 2912
    }
#line 2912
   /* copy the next block */
#line 2912
#pragma cdir loopcnt=LOOPCNT
#line 2912
#pragma cdir shortloop
#line 2912
    for (i=0; i<ni; i++) {
#line 2912
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2912
     /* test for range errors (not always needed but do it anyway) */
#line 2912
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2912
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2912
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 2912
    }
#line 2912
   /* update xpp and tp */
#line 2912
    if (realign) xp = (int *) *xpp;
#line 2912
    xp += ni;
#line 2912
    tp += ni;
#line 2912
    *xpp = (void*)xp;
#line 2912
  }
#line 2912
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2912

#line 2912
#else   /* not SX */
#line 2912
	const char *xp = (const char *) *xpp;
#line 2912
	int status = ENOERR;
#line 2912

#line 2912
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2912
	{
#line 2912
		const int lstatus = ncx_get_int_ulonglong(xp, tp);
#line 2912
		if(lstatus != ENOERR)
#line 2912
			status = lstatus;
#line 2912
	}
#line 2912

#line 2912
	*xpp = (const void *)xp;
#line 2912
	return status;
#line 2912
#  endif
#line 2912
}
#line 2912


#if X_SIZEOF_INT == SIZEOF_INT
/* optimized version */
int
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_INT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_INT);
	return ENOERR;
}
#else
int
#line 2928
ncx_putn_int_int(void **xpp, size_t nelems, const int *tp)
#line 2928
{
#line 2928
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2928

#line 2928
 /* basic algorithm is:
#line 2928
  *   - ensure sane alignment of output data
#line 2928
  *   - copy (conversion happens automatically) input data
#line 2928
  *     to output
#line 2928
  *   - update tp to point at next unconverted input, and xpp to point
#line 2928
  *     at next location for converted output
#line 2928
  */
#line 2928
  long i, j, ni;
#line 2928
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2928
  int *xp;
#line 2928
  int nrange = 0;         /* number of range errors */
#line 2928
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2928
  long cxp = (long) *((char**)xpp);
#line 2928

#line 2928
  realign = (cxp & 7) % SIZEOF_INT;
#line 2928
  /* sjl: manually stripmine so we can limit amount of
#line 2928
   * vector work space reserved to LOOPCNT elements. Also
#line 2928
   * makes vectorisation easy */
#line 2928
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2928
    ni=Min(nelems-j,LOOPCNT);
#line 2928
    if (realign) {
#line 2928
      xp = tmp;
#line 2928
    } else {
#line 2928
      xp = (int *) *xpp;
#line 2928
    }
#line 2928
   /* copy the next block */
#line 2928
#pragma cdir loopcnt=LOOPCNT
#line 2928
#pragma cdir shortloop
#line 2928
    for (i=0; i<ni; i++) {
#line 2928
      /* the normal case: */
#line 2928
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2928
     /* test for range errors (not always needed but do it anyway) */
#line 2928
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2928
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2928
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2928
    }
#line 2928
   /* copy workspace back if necessary */
#line 2928
    if (realign) {
#line 2928
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2928
      xp = (int *) *xpp;
#line 2928
    }
#line 2928
   /* update xpp and tp */
#line 2928
    xp += ni;
#line 2928
    tp += ni;
#line 2928
    *xpp = (void*)xp;
#line 2928
  }
#line 2928
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2928

#line 2928
#else   /* not SX */
#line 2928

#line 2928
	char *xp = (char *) *xpp;
#line 2928
	int status = ENOERR;
#line 2928

#line 2928
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2928
	{
#line 2928
		int lstatus = ncx_put_int_int(xp, tp);
#line 2928
		if(lstatus != ENOERR)
#line 2928
			status = lstatus;
#line 2928
	}
#line 2928

#line 2928
	*xpp = (void *)xp;
#line 2928
	return status;
#line 2928
#endif
#line 2928
}
#line 2928

#endif
int
#line 2930
ncx_putn_int_schar(void **xpp, size_t nelems, const schar *tp)
#line 2930
{
#line 2930
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2930

#line 2930
 /* basic algorithm is:
#line 2930
  *   - ensure sane alignment of output data
#line 2930
  *   - copy (conversion happens automatically) input data
#line 2930
  *     to output
#line 2930
  *   - update tp to point at next unconverted input, and xpp to point
#line 2930
  *     at next location for converted output
#line 2930
  */
#line 2930
  long i, j, ni;
#line 2930
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2930
  int *xp;
#line 2930
  int nrange = 0;         /* number of range errors */
#line 2930
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2930
  long cxp = (long) *((char**)xpp);
#line 2930

#line 2930
  realign = (cxp & 7) % SIZEOF_INT;
#line 2930
  /* sjl: manually stripmine so we can limit amount of
#line 2930
   * vector work space reserved to LOOPCNT elements. Also
#line 2930
   * makes vectorisation easy */
#line 2930
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2930
    ni=Min(nelems-j,LOOPCNT);
#line 2930
    if (realign) {
#line 2930
      xp = tmp;
#line 2930
    } else {
#line 2930
      xp = (int *) *xpp;
#line 2930
    }
#line 2930
   /* copy the next block */
#line 2930
#pragma cdir loopcnt=LOOPCNT
#line 2930
#pragma cdir shortloop
#line 2930
    for (i=0; i<ni; i++) {
#line 2930
      /* the normal case: */
#line 2930
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2930
     /* test for range errors (not always needed but do it anyway) */
#line 2930
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2930
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2930
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2930
    }
#line 2930
   /* copy workspace back if necessary */
#line 2930
    if (realign) {
#line 2930
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2930
      xp = (int *) *xpp;
#line 2930
    }
#line 2930
   /* update xpp and tp */
#line 2930
    xp += ni;
#line 2930
    tp += ni;
#line 2930
    *xpp = (void*)xp;
#line 2930
  }
#line 2930
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2930

#line 2930
#else   /* not SX */
#line 2930

#line 2930
	char *xp = (char *) *xpp;
#line 2930
	int status = ENOERR;
#line 2930

#line 2930
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2930
	{
#line 2930
		int lstatus = ncx_put_int_schar(xp, tp);
#line 2930
		if(lstatus != ENOERR)
#line 2930
			status = lstatus;
#line 2930
	}
#line 2930

#line 2930
	*xpp = (void *)xp;
#line 2930
	return status;
#line 2930
#endif
#line 2930
}
#line 2930

int
#line 2931
ncx_putn_int_short(void **xpp, size_t nelems, const short *tp)
#line 2931
{
#line 2931
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2931

#line 2931
 /* basic algorithm is:
#line 2931
  *   - ensure sane alignment of output data
#line 2931
  *   - copy (conversion happens automatically) input data
#line 2931
  *     to output
#line 2931
  *   - update tp to point at next unconverted input, and xpp to point
#line 2931
  *     at next location for converted output
#line 2931
  */
#line 2931
  long i, j, ni;
#line 2931
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2931
  int *xp;
#line 2931
  int nrange = 0;         /* number of range errors */
#line 2931
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2931
  long cxp = (long) *((char**)xpp);
#line 2931

#line 2931
  realign = (cxp & 7) % SIZEOF_INT;
#line 2931
  /* sjl: manually stripmine so we can limit amount of
#line 2931
   * vector work space reserved to LOOPCNT elements. Also
#line 2931
   * makes vectorisation easy */
#line 2931
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2931
    ni=Min(nelems-j,LOOPCNT);
#line 2931
    if (realign) {
#line 2931
      xp = tmp;
#line 2931
    } else {
#line 2931
      xp = (int *) *xpp;
#line 2931
    }
#line 2931
   /* copy the next block */
#line 2931
#pragma cdir loopcnt=LOOPCNT
#line 2931
#pragma cdir shortloop
#line 2931
    for (i=0; i<ni; i++) {
#line 2931
      /* the normal case: */
#line 2931
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2931
     /* test for range errors (not always needed but do it anyway) */
#line 2931
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2931
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2931
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2931
    }
#line 2931
   /* copy workspace back if necessary */
#line 2931
    if (realign) {
#line 2931
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2931
      xp = (int *) *xpp;
#line 2931
    }
#line 2931
   /* update xpp and tp */
#line 2931
    xp += ni;
#line 2931
    tp += ni;
#line 2931
    *xpp = (void*)xp;
#line 2931
  }
#line 2931
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2931

#line 2931
#else   /* not SX */
#line 2931

#line 2931
	char *xp = (char *) *xpp;
#line 2931
	int status = ENOERR;
#line 2931

#line 2931
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2931
	{
#line 2931
		int lstatus = ncx_put_int_short(xp, tp);
#line 2931
		if(lstatus != ENOERR)
#line 2931
			status = lstatus;
#line 2931
	}
#line 2931

#line 2931
	*xpp = (void *)xp;
#line 2931
	return status;
#line 2931
#endif
#line 2931
}
#line 2931

int
#line 2932
ncx_putn_int_float(void **xpp, size_t nelems, const float *tp)
#line 2932
{
#line 2932
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2932

#line 2932
 /* basic algorithm is:
#line 2932
  *   - ensure sane alignment of output data
#line 2932
  *   - copy (conversion happens automatically) input data
#line 2932
  *     to output
#line 2932
  *   - update tp to point at next unconverted input, and xpp to point
#line 2932
  *     at next location for converted output
#line 2932
  */
#line 2932
  long i, j, ni;
#line 2932
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2932
  int *xp;
#line 2932
  double d;               /* special case for ncx_putn_int_float */
#line 2932
  int nrange = 0;         /* number of range errors */
#line 2932
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2932
  long cxp = (long) *((char**)xpp);
#line 2932

#line 2932
  realign = (cxp & 7) % SIZEOF_INT;
#line 2932
  /* sjl: manually stripmine so we can limit amount of
#line 2932
   * vector work space reserved to LOOPCNT elements. Also
#line 2932
   * makes vectorisation easy */
#line 2932
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2932
    ni=Min(nelems-j,LOOPCNT);
#line 2932
    if (realign) {
#line 2932
      xp = tmp;
#line 2932
    } else {
#line 2932
      xp = (int *) *xpp;
#line 2932
    }
#line 2932
   /* copy the next block */
#line 2932
#pragma cdir loopcnt=LOOPCNT
#line 2932
#pragma cdir shortloop
#line 2932
    for (i=0; i<ni; i++) {
#line 2932
      /* for some reason int to float, for putn, requires a special case */
#line 2932
      d = tp[i];
#line 2932
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) d));
#line 2932
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2932
    }
#line 2932
   /* copy workspace back if necessary */
#line 2932
    if (realign) {
#line 2932
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2932
      xp = (int *) *xpp;
#line 2932
    }
#line 2932
   /* update xpp and tp */
#line 2932
    xp += ni;
#line 2932
    tp += ni;
#line 2932
    *xpp = (void*)xp;
#line 2932
  }
#line 2932
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2932

#line 2932
#else   /* not SX */
#line 2932

#line 2932
	char *xp = (char *) *xpp;
#line 2932
	int status = ENOERR;
#line 2932

#line 2932
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2932
	{
#line 2932
		int lstatus = ncx_put_int_float(xp, tp);
#line 2932
		if(lstatus != ENOERR)
#line 2932
			status = lstatus;
#line 2932
	}
#line 2932

#line 2932
	*xpp = (void *)xp;
#line 2932
	return status;
#line 2932
#endif
#line 2932
}
#line 2932

int
#line 2933
ncx_putn_int_double(void **xpp, size_t nelems, const double *tp)
#line 2933
{
#line 2933
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2933

#line 2933
 /* basic algorithm is:
#line 2933
  *   - ensure sane alignment of output data
#line 2933
  *   - copy (conversion happens automatically) input data
#line 2933
  *     to output
#line 2933
  *   - update tp to point at next unconverted input, and xpp to point
#line 2933
  *     at next location for converted output
#line 2933
  */
#line 2933
  long i, j, ni;
#line 2933
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2933
  int *xp;
#line 2933
  int nrange = 0;         /* number of range errors */
#line 2933
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2933
  long cxp = (long) *((char**)xpp);
#line 2933

#line 2933
  realign = (cxp & 7) % SIZEOF_INT;
#line 2933
  /* sjl: manually stripmine so we can limit amount of
#line 2933
   * vector work space reserved to LOOPCNT elements. Also
#line 2933
   * makes vectorisation easy */
#line 2933
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2933
    ni=Min(nelems-j,LOOPCNT);
#line 2933
    if (realign) {
#line 2933
      xp = tmp;
#line 2933
    } else {
#line 2933
      xp = (int *) *xpp;
#line 2933
    }
#line 2933
   /* copy the next block */
#line 2933
#pragma cdir loopcnt=LOOPCNT
#line 2933
#pragma cdir shortloop
#line 2933
    for (i=0; i<ni; i++) {
#line 2933
      /* the normal case: */
#line 2933
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2933
     /* test for range errors (not always needed but do it anyway) */
#line 2933
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2933
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2933
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2933
    }
#line 2933
   /* copy workspace back if necessary */
#line 2933
    if (realign) {
#line 2933
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2933
      xp = (int *) *xpp;
#line 2933
    }
#line 2933
   /* update xpp and tp */
#line 2933
    xp += ni;
#line 2933
    tp += ni;
#line 2933
    *xpp = (void*)xp;
#line 2933
  }
#line 2933
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2933

#line 2933
#else   /* not SX */
#line 2933

#line 2933
	char *xp = (char *) *xpp;
#line 2933
	int status = ENOERR;
#line 2933

#line 2933
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2933
	{
#line 2933
		int lstatus = ncx_put_int_double(xp, tp);
#line 2933
		if(lstatus != ENOERR)
#line 2933
			status = lstatus;
#line 2933
	}
#line 2933

#line 2933
	*xpp = (void *)xp;
#line 2933
	return status;
#line 2933
#endif
#line 2933
}
#line 2933

int
#line 2934
ncx_putn_int_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2934
{
#line 2934
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2934

#line 2934
 /* basic algorithm is:
#line 2934
  *   - ensure sane alignment of output data
#line 2934
  *   - copy (conversion happens automatically) input data
#line 2934
  *     to output
#line 2934
  *   - update tp to point at next unconverted input, and xpp to point
#line 2934
  *     at next location for converted output
#line 2934
  */
#line 2934
  long i, j, ni;
#line 2934
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2934
  int *xp;
#line 2934
  int nrange = 0;         /* number of range errors */
#line 2934
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2934
  long cxp = (long) *((char**)xpp);
#line 2934

#line 2934
  realign = (cxp & 7) % SIZEOF_INT;
#line 2934
  /* sjl: manually stripmine so we can limit amount of
#line 2934
   * vector work space reserved to LOOPCNT elements. Also
#line 2934
   * makes vectorisation easy */
#line 2934
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2934
    ni=Min(nelems-j,LOOPCNT);
#line 2934
    if (realign) {
#line 2934
      xp = tmp;
#line 2934
    } else {
#line 2934
      xp = (int *) *xpp;
#line 2934
    }
#line 2934
   /* copy the next block */
#line 2934
#pragma cdir loopcnt=LOOPCNT
#line 2934
#pragma cdir shortloop
#line 2934
    for (i=0; i<ni; i++) {
#line 2934
      /* the normal case: */
#line 2934
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2934
     /* test for range errors (not always needed but do it anyway) */
#line 2934
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2934
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2934
      nrange += tp[i] > X_INT_MAX || tp[i] < X_INT_MIN;
#line 2934
    }
#line 2934
   /* copy workspace back if necessary */
#line 2934
    if (realign) {
#line 2934
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2934
      xp = (int *) *xpp;
#line 2934
    }
#line 2934
   /* update xpp and tp */
#line 2934
    xp += ni;
#line 2934
    tp += ni;
#line 2934
    *xpp = (void*)xp;
#line 2934
  }
#line 2934
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2934

#line 2934
#else   /* not SX */
#line 2934

#line 2934
	char *xp = (char *) *xpp;
#line 2934
	int status = ENOERR;
#line 2934

#line 2934
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2934
	{
#line 2934
		int lstatus = ncx_put_int_longlong(xp, tp);
#line 2934
		if(lstatus != ENOERR)
#line 2934
			status = lstatus;
#line 2934
	}
#line 2934

#line 2934
	*xpp = (void *)xp;
#line 2934
	return status;
#line 2934
#endif
#line 2934
}
#line 2934

int
#line 2935
ncx_putn_int_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2935
{
#line 2935
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2935

#line 2935
 /* basic algorithm is:
#line 2935
  *   - ensure sane alignment of output data
#line 2935
  *   - copy (conversion happens automatically) input data
#line 2935
  *     to output
#line 2935
  *   - update tp to point at next unconverted input, and xpp to point
#line 2935
  *     at next location for converted output
#line 2935
  */
#line 2935
  long i, j, ni;
#line 2935
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2935
  int *xp;
#line 2935
  int nrange = 0;         /* number of range errors */
#line 2935
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2935
  long cxp = (long) *((char**)xpp);
#line 2935

#line 2935
  realign = (cxp & 7) % SIZEOF_INT;
#line 2935
  /* sjl: manually stripmine so we can limit amount of
#line 2935
   * vector work space reserved to LOOPCNT elements. Also
#line 2935
   * makes vectorisation easy */
#line 2935
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2935
    ni=Min(nelems-j,LOOPCNT);
#line 2935
    if (realign) {
#line 2935
      xp = tmp;
#line 2935
    } else {
#line 2935
      xp = (int *) *xpp;
#line 2935
    }
#line 2935
   /* copy the next block */
#line 2935
#pragma cdir loopcnt=LOOPCNT
#line 2935
#pragma cdir shortloop
#line 2935
    for (i=0; i<ni; i++) {
#line 2935
      /* the normal case: */
#line 2935
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2935
     /* test for range errors (not always needed but do it anyway) */
#line 2935
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2935
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2935
      nrange += tp[i] > X_INT_MAX ;
#line 2935
    }
#line 2935
   /* copy workspace back if necessary */
#line 2935
    if (realign) {
#line 2935
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2935
      xp = (int *) *xpp;
#line 2935
    }
#line 2935
   /* update xpp and tp */
#line 2935
    xp += ni;
#line 2935
    tp += ni;
#line 2935
    *xpp = (void*)xp;
#line 2935
  }
#line 2935
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2935

#line 2935
#else   /* not SX */
#line 2935

#line 2935
	char *xp = (char *) *xpp;
#line 2935
	int status = ENOERR;
#line 2935

#line 2935
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2935
	{
#line 2935
		int lstatus = ncx_put_int_uchar(xp, tp);
#line 2935
		if(lstatus != ENOERR)
#line 2935
			status = lstatus;
#line 2935
	}
#line 2935

#line 2935
	*xpp = (void *)xp;
#line 2935
	return status;
#line 2935
#endif
#line 2935
}
#line 2935

int
#line 2936
ncx_putn_int_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2936
{
#line 2936
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2936

#line 2936
 /* basic algorithm is:
#line 2936
  *   - ensure sane alignment of output data
#line 2936
  *   - copy (conversion happens automatically) input data
#line 2936
  *     to output
#line 2936
  *   - update tp to point at next unconverted input, and xpp to point
#line 2936
  *     at next location for converted output
#line 2936
  */
#line 2936
  long i, j, ni;
#line 2936
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2936
  int *xp;
#line 2936
  int nrange = 0;         /* number of range errors */
#line 2936
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2936
  long cxp = (long) *((char**)xpp);
#line 2936

#line 2936
  realign = (cxp & 7) % SIZEOF_INT;
#line 2936
  /* sjl: manually stripmine so we can limit amount of
#line 2936
   * vector work space reserved to LOOPCNT elements. Also
#line 2936
   * makes vectorisation easy */
#line 2936
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2936
    ni=Min(nelems-j,LOOPCNT);
#line 2936
    if (realign) {
#line 2936
      xp = tmp;
#line 2936
    } else {
#line 2936
      xp = (int *) *xpp;
#line 2936
    }
#line 2936
   /* copy the next block */
#line 2936
#pragma cdir loopcnt=LOOPCNT
#line 2936
#pragma cdir shortloop
#line 2936
    for (i=0; i<ni; i++) {
#line 2936
      /* the normal case: */
#line 2936
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2936
     /* test for range errors (not always needed but do it anyway) */
#line 2936
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2936
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2936
      nrange += tp[i] > X_INT_MAX ;
#line 2936
    }
#line 2936
   /* copy workspace back if necessary */
#line 2936
    if (realign) {
#line 2936
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2936
      xp = (int *) *xpp;
#line 2936
    }
#line 2936
   /* update xpp and tp */
#line 2936
    xp += ni;
#line 2936
    tp += ni;
#line 2936
    *xpp = (void*)xp;
#line 2936
  }
#line 2936
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2936

#line 2936
#else   /* not SX */
#line 2936

#line 2936
	char *xp = (char *) *xpp;
#line 2936
	int status = ENOERR;
#line 2936

#line 2936
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2936
	{
#line 2936
		int lstatus = ncx_put_int_ushort(xp, tp);
#line 2936
		if(lstatus != ENOERR)
#line 2936
			status = lstatus;
#line 2936
	}
#line 2936

#line 2936
	*xpp = (void *)xp;
#line 2936
	return status;
#line 2936
#endif
#line 2936
}
#line 2936

int
#line 2937
ncx_putn_int_uint(void **xpp, size_t nelems, const uint *tp)
#line 2937
{
#line 2937
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2937

#line 2937
 /* basic algorithm is:
#line 2937
  *   - ensure sane alignment of output data
#line 2937
  *   - copy (conversion happens automatically) input data
#line 2937
  *     to output
#line 2937
  *   - update tp to point at next unconverted input, and xpp to point
#line 2937
  *     at next location for converted output
#line 2937
  */
#line 2937
  long i, j, ni;
#line 2937
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2937
  int *xp;
#line 2937
  int nrange = 0;         /* number of range errors */
#line 2937
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2937
  long cxp = (long) *((char**)xpp);
#line 2937

#line 2937
  realign = (cxp & 7) % SIZEOF_INT;
#line 2937
  /* sjl: manually stripmine so we can limit amount of
#line 2937
   * vector work space reserved to LOOPCNT elements. Also
#line 2937
   * makes vectorisation easy */
#line 2937
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2937
    ni=Min(nelems-j,LOOPCNT);
#line 2937
    if (realign) {
#line 2937
      xp = tmp;
#line 2937
    } else {
#line 2937
      xp = (int *) *xpp;
#line 2937
    }
#line 2937
   /* copy the next block */
#line 2937
#pragma cdir loopcnt=LOOPCNT
#line 2937
#pragma cdir shortloop
#line 2937
    for (i=0; i<ni; i++) {
#line 2937
      /* the normal case: */
#line 2937
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2937
     /* test for range errors (not always needed but do it anyway) */
#line 2937
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2937
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2937
      nrange += tp[i] > X_INT_MAX ;
#line 2937
    }
#line 2937
   /* copy workspace back if necessary */
#line 2937
    if (realign) {
#line 2937
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2937
      xp = (int *) *xpp;
#line 2937
    }
#line 2937
   /* update xpp and tp */
#line 2937
    xp += ni;
#line 2937
    tp += ni;
#line 2937
    *xpp = (void*)xp;
#line 2937
  }
#line 2937
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2937

#line 2937
#else   /* not SX */
#line 2937

#line 2937
	char *xp = (char *) *xpp;
#line 2937
	int status = ENOERR;
#line 2937

#line 2937
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2937
	{
#line 2937
		int lstatus = ncx_put_int_uint(xp, tp);
#line 2937
		if(lstatus != ENOERR)
#line 2937
			status = lstatus;
#line 2937
	}
#line 2937

#line 2937
	*xpp = (void *)xp;
#line 2937
	return status;
#line 2937
#endif
#line 2937
}
#line 2937

int
#line 2938
ncx_putn_int_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2938
{
#line 2938
#if _SX && X_SIZEOF_INT == SIZEOF_INT
#line 2938

#line 2938
 /* basic algorithm is:
#line 2938
  *   - ensure sane alignment of output data
#line 2938
  *   - copy (conversion happens automatically) input data
#line 2938
  *     to output
#line 2938
  *   - update tp to point at next unconverted input, and xpp to point
#line 2938
  *     at next location for converted output
#line 2938
  */
#line 2938
  long i, j, ni;
#line 2938
  int tmp[LOOPCNT];        /* in case input is misaligned */
#line 2938
  int *xp;
#line 2938
  int nrange = 0;         /* number of range errors */
#line 2938
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2938
  long cxp = (long) *((char**)xpp);
#line 2938

#line 2938
  realign = (cxp & 7) % SIZEOF_INT;
#line 2938
  /* sjl: manually stripmine so we can limit amount of
#line 2938
   * vector work space reserved to LOOPCNT elements. Also
#line 2938
   * makes vectorisation easy */
#line 2938
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2938
    ni=Min(nelems-j,LOOPCNT);
#line 2938
    if (realign) {
#line 2938
      xp = tmp;
#line 2938
    } else {
#line 2938
      xp = (int *) *xpp;
#line 2938
    }
#line 2938
   /* copy the next block */
#line 2938
#pragma cdir loopcnt=LOOPCNT
#line 2938
#pragma cdir shortloop
#line 2938
    for (i=0; i<ni; i++) {
#line 2938
      /* the normal case: */
#line 2938
      xp[i] = (int) Max( X_INT_MIN, Min(X_INT_MAX, (int) tp[i]));
#line 2938
     /* test for range errors (not always needed but do it anyway) */
#line 2938
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2938
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2938
      nrange += tp[i] > X_INT_MAX ;
#line 2938
    }
#line 2938
   /* copy workspace back if necessary */
#line 2938
    if (realign) {
#line 2938
      memcpy(*xpp, tmp, ni*X_SIZEOF_INT);
#line 2938
      xp = (int *) *xpp;
#line 2938
    }
#line 2938
   /* update xpp and tp */
#line 2938
    xp += ni;
#line 2938
    tp += ni;
#line 2938
    *xpp = (void*)xp;
#line 2938
  }
#line 2938
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2938

#line 2938
#else   /* not SX */
#line 2938

#line 2938
	char *xp = (char *) *xpp;
#line 2938
	int status = ENOERR;
#line 2938

#line 2938
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_INT, tp++)
#line 2938
	{
#line 2938
		int lstatus = ncx_put_int_ulonglong(xp, tp);
#line 2938
		if(lstatus != ENOERR)
#line 2938
			status = lstatus;
#line 2938
	}
#line 2938

#line 2938
	*xpp = (void *)xp;
#line 2938
	return status;
#line 2938
#endif
#line 2938
}
#line 2938


/* uint ----------------------------------------------------------------------*/

#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_getn_uint_uint(const void **xpp, size_t nelems, unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(uint));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return ENOERR;
}
#else
int
#line 2956
ncx_getn_uint_uint(const void **xpp, size_t nelems, uint *tp)
#line 2956
{
#line 2956
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2956

#line 2956
 /* basic algorithm is:
#line 2956
  *   - ensure sane alignment of input data
#line 2956
  *   - copy (conversion happens automatically) input data
#line 2956
  *     to output
#line 2956
  *   - update xpp to point at next unconverted input, and tp to point
#line 2956
  *     at next location for converted output
#line 2956
  */
#line 2956
  long i, j, ni;
#line 2956
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2956
  uint *xp;
#line 2956
  int nrange = 0;         /* number of range errors */
#line 2956
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2956
  long cxp = (long) *((char**)xpp);
#line 2956

#line 2956
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2956
  /* sjl: manually stripmine so we can limit amount of
#line 2956
   * vector work space reserved to LOOPCNT elements. Also
#line 2956
   * makes vectorisation easy */
#line 2956
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2956
    ni=Min(nelems-j,LOOPCNT);
#line 2956
    if (realign) {
#line 2956
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2956
      xp = tmp;
#line 2956
    } else {
#line 2956
      xp = (uint *) *xpp;
#line 2956
    }
#line 2956
   /* copy the next block */
#line 2956
#pragma cdir loopcnt=LOOPCNT
#line 2956
#pragma cdir shortloop
#line 2956
    for (i=0; i<ni; i++) {
#line 2956
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 2956
     /* test for range errors (not always needed but do it anyway) */
#line 2956
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2956
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2956
      nrange += xp[i] > UINT_MAX ;
#line 2956
    }
#line 2956
   /* update xpp and tp */
#line 2956
    if (realign) xp = (uint *) *xpp;
#line 2956
    xp += ni;
#line 2956
    tp += ni;
#line 2956
    *xpp = (void*)xp;
#line 2956
  }
#line 2956
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2956

#line 2956
#else   /* not SX */
#line 2956
	const char *xp = (const char *) *xpp;
#line 2956
	int status = ENOERR;
#line 2956

#line 2956
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2956
	{
#line 2956
		const int lstatus = ncx_get_uint_uint(xp, tp);
#line 2956
		if(lstatus != ENOERR)
#line 2956
			status = lstatus;
#line 2956
	}
#line 2956

#line 2956
	*xpp = (const void *)xp;
#line 2956
	return status;
#line 2956
#  endif
#line 2956
}
#line 2956

#endif
int
#line 2958
ncx_getn_uint_schar(const void **xpp, size_t nelems, schar *tp)
#line 2958
{
#line 2958
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2958

#line 2958
 /* basic algorithm is:
#line 2958
  *   - ensure sane alignment of input data
#line 2958
  *   - copy (conversion happens automatically) input data
#line 2958
  *     to output
#line 2958
  *   - update xpp to point at next unconverted input, and tp to point
#line 2958
  *     at next location for converted output
#line 2958
  */
#line 2958
  long i, j, ni;
#line 2958
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2958
  uint *xp;
#line 2958
  int nrange = 0;         /* number of range errors */
#line 2958
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2958
  long cxp = (long) *((char**)xpp);
#line 2958

#line 2958
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2958
  /* sjl: manually stripmine so we can limit amount of
#line 2958
   * vector work space reserved to LOOPCNT elements. Also
#line 2958
   * makes vectorisation easy */
#line 2958
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2958
    ni=Min(nelems-j,LOOPCNT);
#line 2958
    if (realign) {
#line 2958
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2958
      xp = tmp;
#line 2958
    } else {
#line 2958
      xp = (uint *) *xpp;
#line 2958
    }
#line 2958
   /* copy the next block */
#line 2958
#pragma cdir loopcnt=LOOPCNT
#line 2958
#pragma cdir shortloop
#line 2958
    for (i=0; i<ni; i++) {
#line 2958
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 2958
     /* test for range errors (not always needed but do it anyway) */
#line 2958
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2958
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2958
      nrange += xp[i] > SCHAR_MAX ;
#line 2958
    }
#line 2958
   /* update xpp and tp */
#line 2958
    if (realign) xp = (uint *) *xpp;
#line 2958
    xp += ni;
#line 2958
    tp += ni;
#line 2958
    *xpp = (void*)xp;
#line 2958
  }
#line 2958
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2958

#line 2958
#else   /* not SX */
#line 2958
	const char *xp = (const char *) *xpp;
#line 2958
	int status = ENOERR;
#line 2958

#line 2958
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2958
	{
#line 2958
		const int lstatus = ncx_get_uint_schar(xp, tp);
#line 2958
		if(lstatus != ENOERR)
#line 2958
			status = lstatus;
#line 2958
	}
#line 2958

#line 2958
	*xpp = (const void *)xp;
#line 2958
	return status;
#line 2958
#  endif
#line 2958
}
#line 2958

int
#line 2959
ncx_getn_uint_short(const void **xpp, size_t nelems, short *tp)
#line 2959
{
#line 2959
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2959

#line 2959
 /* basic algorithm is:
#line 2959
  *   - ensure sane alignment of input data
#line 2959
  *   - copy (conversion happens automatically) input data
#line 2959
  *     to output
#line 2959
  *   - update xpp to point at next unconverted input, and tp to point
#line 2959
  *     at next location for converted output
#line 2959
  */
#line 2959
  long i, j, ni;
#line 2959
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2959
  uint *xp;
#line 2959
  int nrange = 0;         /* number of range errors */
#line 2959
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2959
  long cxp = (long) *((char**)xpp);
#line 2959

#line 2959
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2959
  /* sjl: manually stripmine so we can limit amount of
#line 2959
   * vector work space reserved to LOOPCNT elements. Also
#line 2959
   * makes vectorisation easy */
#line 2959
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2959
    ni=Min(nelems-j,LOOPCNT);
#line 2959
    if (realign) {
#line 2959
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2959
      xp = tmp;
#line 2959
    } else {
#line 2959
      xp = (uint *) *xpp;
#line 2959
    }
#line 2959
   /* copy the next block */
#line 2959
#pragma cdir loopcnt=LOOPCNT
#line 2959
#pragma cdir shortloop
#line 2959
    for (i=0; i<ni; i++) {
#line 2959
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 2959
     /* test for range errors (not always needed but do it anyway) */
#line 2959
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2959
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2959
      nrange += xp[i] > SHORT_MAX ;
#line 2959
    }
#line 2959
   /* update xpp and tp */
#line 2959
    if (realign) xp = (uint *) *xpp;
#line 2959
    xp += ni;
#line 2959
    tp += ni;
#line 2959
    *xpp = (void*)xp;
#line 2959
  }
#line 2959
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2959

#line 2959
#else   /* not SX */
#line 2959
	const char *xp = (const char *) *xpp;
#line 2959
	int status = ENOERR;
#line 2959

#line 2959
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2959
	{
#line 2959
		const int lstatus = ncx_get_uint_short(xp, tp);
#line 2959
		if(lstatus != ENOERR)
#line 2959
			status = lstatus;
#line 2959
	}
#line 2959

#line 2959
	*xpp = (const void *)xp;
#line 2959
	return status;
#line 2959
#  endif
#line 2959
}
#line 2959

int
#line 2960
ncx_getn_uint_int(const void **xpp, size_t nelems, int *tp)
#line 2960
{
#line 2960
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2960

#line 2960
 /* basic algorithm is:
#line 2960
  *   - ensure sane alignment of input data
#line 2960
  *   - copy (conversion happens automatically) input data
#line 2960
  *     to output
#line 2960
  *   - update xpp to point at next unconverted input, and tp to point
#line 2960
  *     at next location for converted output
#line 2960
  */
#line 2960
  long i, j, ni;
#line 2960
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2960
  uint *xp;
#line 2960
  int nrange = 0;         /* number of range errors */
#line 2960
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2960
  long cxp = (long) *((char**)xpp);
#line 2960

#line 2960
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2960
  /* sjl: manually stripmine so we can limit amount of
#line 2960
   * vector work space reserved to LOOPCNT elements. Also
#line 2960
   * makes vectorisation easy */
#line 2960
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2960
    ni=Min(nelems-j,LOOPCNT);
#line 2960
    if (realign) {
#line 2960
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2960
      xp = tmp;
#line 2960
    } else {
#line 2960
      xp = (uint *) *xpp;
#line 2960
    }
#line 2960
   /* copy the next block */
#line 2960
#pragma cdir loopcnt=LOOPCNT
#line 2960
#pragma cdir shortloop
#line 2960
    for (i=0; i<ni; i++) {
#line 2960
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 2960
     /* test for range errors (not always needed but do it anyway) */
#line 2960
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2960
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2960
      nrange += xp[i] > INT_MAX ;
#line 2960
    }
#line 2960
   /* update xpp and tp */
#line 2960
    if (realign) xp = (uint *) *xpp;
#line 2960
    xp += ni;
#line 2960
    tp += ni;
#line 2960
    *xpp = (void*)xp;
#line 2960
  }
#line 2960
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2960

#line 2960
#else   /* not SX */
#line 2960
	const char *xp = (const char *) *xpp;
#line 2960
	int status = ENOERR;
#line 2960

#line 2960
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2960
	{
#line 2960
		const int lstatus = ncx_get_uint_int(xp, tp);
#line 2960
		if(lstatus != ENOERR)
#line 2960
			status = lstatus;
#line 2960
	}
#line 2960

#line 2960
	*xpp = (const void *)xp;
#line 2960
	return status;
#line 2960
#  endif
#line 2960
}
#line 2960

int
#line 2961
ncx_getn_uint_float(const void **xpp, size_t nelems, float *tp)
#line 2961
{
#line 2961
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2961

#line 2961
 /* basic algorithm is:
#line 2961
  *   - ensure sane alignment of input data
#line 2961
  *   - copy (conversion happens automatically) input data
#line 2961
  *     to output
#line 2961
  *   - update xpp to point at next unconverted input, and tp to point
#line 2961
  *     at next location for converted output
#line 2961
  */
#line 2961
  long i, j, ni;
#line 2961
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2961
  uint *xp;
#line 2961
  int nrange = 0;         /* number of range errors */
#line 2961
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2961
  long cxp = (long) *((char**)xpp);
#line 2961

#line 2961
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2961
  /* sjl: manually stripmine so we can limit amount of
#line 2961
   * vector work space reserved to LOOPCNT elements. Also
#line 2961
   * makes vectorisation easy */
#line 2961
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2961
    ni=Min(nelems-j,LOOPCNT);
#line 2961
    if (realign) {
#line 2961
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2961
      xp = tmp;
#line 2961
    } else {
#line 2961
      xp = (uint *) *xpp;
#line 2961
    }
#line 2961
   /* copy the next block */
#line 2961
#pragma cdir loopcnt=LOOPCNT
#line 2961
#pragma cdir shortloop
#line 2961
    for (i=0; i<ni; i++) {
#line 2961
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 2961
     /* test for range errors (not always needed but do it anyway) */
#line 2961
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2961
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2961
      nrange += xp[i] > FLOAT_MAX ;
#line 2961
    }
#line 2961
   /* update xpp and tp */
#line 2961
    if (realign) xp = (uint *) *xpp;
#line 2961
    xp += ni;
#line 2961
    tp += ni;
#line 2961
    *xpp = (void*)xp;
#line 2961
  }
#line 2961
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2961

#line 2961
#else   /* not SX */
#line 2961
	const char *xp = (const char *) *xpp;
#line 2961
	int status = ENOERR;
#line 2961

#line 2961
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2961
	{
#line 2961
		const int lstatus = ncx_get_uint_float(xp, tp);
#line 2961
		if(lstatus != ENOERR)
#line 2961
			status = lstatus;
#line 2961
	}
#line 2961

#line 2961
	*xpp = (const void *)xp;
#line 2961
	return status;
#line 2961
#  endif
#line 2961
}
#line 2961

int
#line 2962
ncx_getn_uint_double(const void **xpp, size_t nelems, double *tp)
#line 2962
{
#line 2962
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2962

#line 2962
 /* basic algorithm is:
#line 2962
  *   - ensure sane alignment of input data
#line 2962
  *   - copy (conversion happens automatically) input data
#line 2962
  *     to output
#line 2962
  *   - update xpp to point at next unconverted input, and tp to point
#line 2962
  *     at next location for converted output
#line 2962
  */
#line 2962
  long i, j, ni;
#line 2962
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2962
  uint *xp;
#line 2962
  int nrange = 0;         /* number of range errors */
#line 2962
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2962
  long cxp = (long) *((char**)xpp);
#line 2962

#line 2962
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2962
  /* sjl: manually stripmine so we can limit amount of
#line 2962
   * vector work space reserved to LOOPCNT elements. Also
#line 2962
   * makes vectorisation easy */
#line 2962
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2962
    ni=Min(nelems-j,LOOPCNT);
#line 2962
    if (realign) {
#line 2962
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2962
      xp = tmp;
#line 2962
    } else {
#line 2962
      xp = (uint *) *xpp;
#line 2962
    }
#line 2962
   /* copy the next block */
#line 2962
#pragma cdir loopcnt=LOOPCNT
#line 2962
#pragma cdir shortloop
#line 2962
    for (i=0; i<ni; i++) {
#line 2962
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 2962
     /* test for range errors (not always needed but do it anyway) */
#line 2962
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2962
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2962
      nrange += xp[i] > DOUBLE_MAX ;
#line 2962
    }
#line 2962
   /* update xpp and tp */
#line 2962
    if (realign) xp = (uint *) *xpp;
#line 2962
    xp += ni;
#line 2962
    tp += ni;
#line 2962
    *xpp = (void*)xp;
#line 2962
  }
#line 2962
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2962

#line 2962
#else   /* not SX */
#line 2962
	const char *xp = (const char *) *xpp;
#line 2962
	int status = ENOERR;
#line 2962

#line 2962
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2962
	{
#line 2962
		const int lstatus = ncx_get_uint_double(xp, tp);
#line 2962
		if(lstatus != ENOERR)
#line 2962
			status = lstatus;
#line 2962
	}
#line 2962

#line 2962
	*xpp = (const void *)xp;
#line 2962
	return status;
#line 2962
#  endif
#line 2962
}
#line 2962

int
#line 2963
ncx_getn_uint_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 2963
{
#line 2963
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2963

#line 2963
 /* basic algorithm is:
#line 2963
  *   - ensure sane alignment of input data
#line 2963
  *   - copy (conversion happens automatically) input data
#line 2963
  *     to output
#line 2963
  *   - update xpp to point at next unconverted input, and tp to point
#line 2963
  *     at next location for converted output
#line 2963
  */
#line 2963
  long i, j, ni;
#line 2963
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2963
  uint *xp;
#line 2963
  int nrange = 0;         /* number of range errors */
#line 2963
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2963
  long cxp = (long) *((char**)xpp);
#line 2963

#line 2963
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2963
  /* sjl: manually stripmine so we can limit amount of
#line 2963
   * vector work space reserved to LOOPCNT elements. Also
#line 2963
   * makes vectorisation easy */
#line 2963
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2963
    ni=Min(nelems-j,LOOPCNT);
#line 2963
    if (realign) {
#line 2963
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2963
      xp = tmp;
#line 2963
    } else {
#line 2963
      xp = (uint *) *xpp;
#line 2963
    }
#line 2963
   /* copy the next block */
#line 2963
#pragma cdir loopcnt=LOOPCNT
#line 2963
#pragma cdir shortloop
#line 2963
    for (i=0; i<ni; i++) {
#line 2963
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 2963
     /* test for range errors (not always needed but do it anyway) */
#line 2963
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2963
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2963
      nrange += xp[i] > LONGLONG_MAX ;
#line 2963
    }
#line 2963
   /* update xpp and tp */
#line 2963
    if (realign) xp = (uint *) *xpp;
#line 2963
    xp += ni;
#line 2963
    tp += ni;
#line 2963
    *xpp = (void*)xp;
#line 2963
  }
#line 2963
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2963

#line 2963
#else   /* not SX */
#line 2963
	const char *xp = (const char *) *xpp;
#line 2963
	int status = ENOERR;
#line 2963

#line 2963
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2963
	{
#line 2963
		const int lstatus = ncx_get_uint_longlong(xp, tp);
#line 2963
		if(lstatus != ENOERR)
#line 2963
			status = lstatus;
#line 2963
	}
#line 2963

#line 2963
	*xpp = (const void *)xp;
#line 2963
	return status;
#line 2963
#  endif
#line 2963
}
#line 2963

int
#line 2964
ncx_getn_uint_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 2964
{
#line 2964
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2964

#line 2964
 /* basic algorithm is:
#line 2964
  *   - ensure sane alignment of input data
#line 2964
  *   - copy (conversion happens automatically) input data
#line 2964
  *     to output
#line 2964
  *   - update xpp to point at next unconverted input, and tp to point
#line 2964
  *     at next location for converted output
#line 2964
  */
#line 2964
  long i, j, ni;
#line 2964
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2964
  uint *xp;
#line 2964
  int nrange = 0;         /* number of range errors */
#line 2964
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2964
  long cxp = (long) *((char**)xpp);
#line 2964

#line 2964
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2964
  /* sjl: manually stripmine so we can limit amount of
#line 2964
   * vector work space reserved to LOOPCNT elements. Also
#line 2964
   * makes vectorisation easy */
#line 2964
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2964
    ni=Min(nelems-j,LOOPCNT);
#line 2964
    if (realign) {
#line 2964
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2964
      xp = tmp;
#line 2964
    } else {
#line 2964
      xp = (uint *) *xpp;
#line 2964
    }
#line 2964
   /* copy the next block */
#line 2964
#pragma cdir loopcnt=LOOPCNT
#line 2964
#pragma cdir shortloop
#line 2964
    for (i=0; i<ni; i++) {
#line 2964
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 2964
     /* test for range errors (not always needed but do it anyway) */
#line 2964
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2964
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2964
      nrange += xp[i] > UCHAR_MAX ;
#line 2964
    }
#line 2964
   /* update xpp and tp */
#line 2964
    if (realign) xp = (uint *) *xpp;
#line 2964
    xp += ni;
#line 2964
    tp += ni;
#line 2964
    *xpp = (void*)xp;
#line 2964
  }
#line 2964
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2964

#line 2964
#else   /* not SX */
#line 2964
	const char *xp = (const char *) *xpp;
#line 2964
	int status = ENOERR;
#line 2964

#line 2964
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2964
	{
#line 2964
		const int lstatus = ncx_get_uint_uchar(xp, tp);
#line 2964
		if(lstatus != ENOERR)
#line 2964
			status = lstatus;
#line 2964
	}
#line 2964

#line 2964
	*xpp = (const void *)xp;
#line 2964
	return status;
#line 2964
#  endif
#line 2964
}
#line 2964

int
#line 2965
ncx_getn_uint_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 2965
{
#line 2965
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2965

#line 2965
 /* basic algorithm is:
#line 2965
  *   - ensure sane alignment of input data
#line 2965
  *   - copy (conversion happens automatically) input data
#line 2965
  *     to output
#line 2965
  *   - update xpp to point at next unconverted input, and tp to point
#line 2965
  *     at next location for converted output
#line 2965
  */
#line 2965
  long i, j, ni;
#line 2965
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2965
  uint *xp;
#line 2965
  int nrange = 0;         /* number of range errors */
#line 2965
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2965
  long cxp = (long) *((char**)xpp);
#line 2965

#line 2965
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2965
  /* sjl: manually stripmine so we can limit amount of
#line 2965
   * vector work space reserved to LOOPCNT elements. Also
#line 2965
   * makes vectorisation easy */
#line 2965
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2965
    ni=Min(nelems-j,LOOPCNT);
#line 2965
    if (realign) {
#line 2965
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2965
      xp = tmp;
#line 2965
    } else {
#line 2965
      xp = (uint *) *xpp;
#line 2965
    }
#line 2965
   /* copy the next block */
#line 2965
#pragma cdir loopcnt=LOOPCNT
#line 2965
#pragma cdir shortloop
#line 2965
    for (i=0; i<ni; i++) {
#line 2965
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 2965
     /* test for range errors (not always needed but do it anyway) */
#line 2965
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2965
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2965
      nrange += xp[i] > USHORT_MAX ;
#line 2965
    }
#line 2965
   /* update xpp and tp */
#line 2965
    if (realign) xp = (uint *) *xpp;
#line 2965
    xp += ni;
#line 2965
    tp += ni;
#line 2965
    *xpp = (void*)xp;
#line 2965
  }
#line 2965
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2965

#line 2965
#else   /* not SX */
#line 2965
	const char *xp = (const char *) *xpp;
#line 2965
	int status = ENOERR;
#line 2965

#line 2965
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2965
	{
#line 2965
		const int lstatus = ncx_get_uint_ushort(xp, tp);
#line 2965
		if(lstatus != ENOERR)
#line 2965
			status = lstatus;
#line 2965
	}
#line 2965

#line 2965
	*xpp = (const void *)xp;
#line 2965
	return status;
#line 2965
#  endif
#line 2965
}
#line 2965

int
#line 2966
ncx_getn_uint_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 2966
{
#line 2966
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2966

#line 2966
 /* basic algorithm is:
#line 2966
  *   - ensure sane alignment of input data
#line 2966
  *   - copy (conversion happens automatically) input data
#line 2966
  *     to output
#line 2966
  *   - update xpp to point at next unconverted input, and tp to point
#line 2966
  *     at next location for converted output
#line 2966
  */
#line 2966
  long i, j, ni;
#line 2966
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2966
  uint *xp;
#line 2966
  int nrange = 0;         /* number of range errors */
#line 2966
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2966
  long cxp = (long) *((char**)xpp);
#line 2966

#line 2966
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2966
  /* sjl: manually stripmine so we can limit amount of
#line 2966
   * vector work space reserved to LOOPCNT elements. Also
#line 2966
   * makes vectorisation easy */
#line 2966
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2966
    ni=Min(nelems-j,LOOPCNT);
#line 2966
    if (realign) {
#line 2966
      memcpy(tmp, *xpp, ni*SIZEOF_UINT);
#line 2966
      xp = tmp;
#line 2966
    } else {
#line 2966
      xp = (uint *) *xpp;
#line 2966
    }
#line 2966
   /* copy the next block */
#line 2966
#pragma cdir loopcnt=LOOPCNT
#line 2966
#pragma cdir shortloop
#line 2966
    for (i=0; i<ni; i++) {
#line 2966
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 2966
     /* test for range errors (not always needed but do it anyway) */
#line 2966
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 2966
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 2966
      nrange += xp[i] > ULONGLONG_MAX ;
#line 2966
    }
#line 2966
   /* update xpp and tp */
#line 2966
    if (realign) xp = (uint *) *xpp;
#line 2966
    xp += ni;
#line 2966
    tp += ni;
#line 2966
    *xpp = (void*)xp;
#line 2966
  }
#line 2966
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2966

#line 2966
#else   /* not SX */
#line 2966
	const char *xp = (const char *) *xpp;
#line 2966
	int status = ENOERR;
#line 2966

#line 2966
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2966
	{
#line 2966
		const int lstatus = ncx_get_uint_ulonglong(xp, tp);
#line 2966
		if(lstatus != ENOERR)
#line 2966
			status = lstatus;
#line 2966
	}
#line 2966

#line 2966
	*xpp = (const void *)xp;
#line 2966
	return status;
#line 2966
#  endif
#line 2966
}
#line 2966


#if X_SIZEOF_UINT == SIZEOF_UINT
/* optimized version */
int
ncx_putn_uint_uint(void **xpp, size_t nelems, const unsigned int *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_UINT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_UINT);
	return ENOERR;
}
#else
int
#line 2982
ncx_putn_uint_uint(void **xpp, size_t nelems, const uint *tp)
#line 2982
{
#line 2982
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2982

#line 2982
 /* basic algorithm is:
#line 2982
  *   - ensure sane alignment of output data
#line 2982
  *   - copy (conversion happens automatically) input data
#line 2982
  *     to output
#line 2982
  *   - update tp to point at next unconverted input, and xpp to point
#line 2982
  *     at next location for converted output
#line 2982
  */
#line 2982
  long i, j, ni;
#line 2982
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2982
  uint *xp;
#line 2982
  int nrange = 0;         /* number of range errors */
#line 2982
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2982
  long cxp = (long) *((char**)xpp);
#line 2982

#line 2982
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2982
  /* sjl: manually stripmine so we can limit amount of
#line 2982
   * vector work space reserved to LOOPCNT elements. Also
#line 2982
   * makes vectorisation easy */
#line 2982
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2982
    ni=Min(nelems-j,LOOPCNT);
#line 2982
    if (realign) {
#line 2982
      xp = tmp;
#line 2982
    } else {
#line 2982
      xp = (uint *) *xpp;
#line 2982
    }
#line 2982
   /* copy the next block */
#line 2982
#pragma cdir loopcnt=LOOPCNT
#line 2982
#pragma cdir shortloop
#line 2982
    for (i=0; i<ni; i++) {
#line 2982
      /* the normal case: */
#line 2982
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2982
     /* test for range errors (not always needed but do it anyway) */
#line 2982
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2982
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2982
      nrange += tp[i] > X_UINT_MAX ;
#line 2982
    }
#line 2982
   /* copy workspace back if necessary */
#line 2982
    if (realign) {
#line 2982
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2982
      xp = (uint *) *xpp;
#line 2982
    }
#line 2982
   /* update xpp and tp */
#line 2982
    xp += ni;
#line 2982
    tp += ni;
#line 2982
    *xpp = (void*)xp;
#line 2982
  }
#line 2982
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2982

#line 2982
#else   /* not SX */
#line 2982

#line 2982
	char *xp = (char *) *xpp;
#line 2982
	int status = ENOERR;
#line 2982

#line 2982
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2982
	{
#line 2982
		int lstatus = ncx_put_uint_uint(xp, tp);
#line 2982
		if(lstatus != ENOERR)
#line 2982
			status = lstatus;
#line 2982
	}
#line 2982

#line 2982
	*xpp = (void *)xp;
#line 2982
	return status;
#line 2982
#endif
#line 2982
}
#line 2982

#endif
int
#line 2984
ncx_putn_uint_schar(void **xpp, size_t nelems, const schar *tp)
#line 2984
{
#line 2984
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2984

#line 2984
 /* basic algorithm is:
#line 2984
  *   - ensure sane alignment of output data
#line 2984
  *   - copy (conversion happens automatically) input data
#line 2984
  *     to output
#line 2984
  *   - update tp to point at next unconverted input, and xpp to point
#line 2984
  *     at next location for converted output
#line 2984
  */
#line 2984
  long i, j, ni;
#line 2984
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2984
  uint *xp;
#line 2984
  int nrange = 0;         /* number of range errors */
#line 2984
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2984
  long cxp = (long) *((char**)xpp);
#line 2984

#line 2984
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2984
  /* sjl: manually stripmine so we can limit amount of
#line 2984
   * vector work space reserved to LOOPCNT elements. Also
#line 2984
   * makes vectorisation easy */
#line 2984
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2984
    ni=Min(nelems-j,LOOPCNT);
#line 2984
    if (realign) {
#line 2984
      xp = tmp;
#line 2984
    } else {
#line 2984
      xp = (uint *) *xpp;
#line 2984
    }
#line 2984
   /* copy the next block */
#line 2984
#pragma cdir loopcnt=LOOPCNT
#line 2984
#pragma cdir shortloop
#line 2984
    for (i=0; i<ni; i++) {
#line 2984
      /* the normal case: */
#line 2984
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2984
     /* test for range errors (not always needed but do it anyway) */
#line 2984
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2984
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2984
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2984
    }
#line 2984
   /* copy workspace back if necessary */
#line 2984
    if (realign) {
#line 2984
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2984
      xp = (uint *) *xpp;
#line 2984
    }
#line 2984
   /* update xpp and tp */
#line 2984
    xp += ni;
#line 2984
    tp += ni;
#line 2984
    *xpp = (void*)xp;
#line 2984
  }
#line 2984
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2984

#line 2984
#else   /* not SX */
#line 2984

#line 2984
	char *xp = (char *) *xpp;
#line 2984
	int status = ENOERR;
#line 2984

#line 2984
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2984
	{
#line 2984
		int lstatus = ncx_put_uint_schar(xp, tp);
#line 2984
		if(lstatus != ENOERR)
#line 2984
			status = lstatus;
#line 2984
	}
#line 2984

#line 2984
	*xpp = (void *)xp;
#line 2984
	return status;
#line 2984
#endif
#line 2984
}
#line 2984

int
#line 2985
ncx_putn_uint_short(void **xpp, size_t nelems, const short *tp)
#line 2985
{
#line 2985
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2985

#line 2985
 /* basic algorithm is:
#line 2985
  *   - ensure sane alignment of output data
#line 2985
  *   - copy (conversion happens automatically) input data
#line 2985
  *     to output
#line 2985
  *   - update tp to point at next unconverted input, and xpp to point
#line 2985
  *     at next location for converted output
#line 2985
  */
#line 2985
  long i, j, ni;
#line 2985
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2985
  uint *xp;
#line 2985
  int nrange = 0;         /* number of range errors */
#line 2985
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2985
  long cxp = (long) *((char**)xpp);
#line 2985

#line 2985
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2985
  /* sjl: manually stripmine so we can limit amount of
#line 2985
   * vector work space reserved to LOOPCNT elements. Also
#line 2985
   * makes vectorisation easy */
#line 2985
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2985
    ni=Min(nelems-j,LOOPCNT);
#line 2985
    if (realign) {
#line 2985
      xp = tmp;
#line 2985
    } else {
#line 2985
      xp = (uint *) *xpp;
#line 2985
    }
#line 2985
   /* copy the next block */
#line 2985
#pragma cdir loopcnt=LOOPCNT
#line 2985
#pragma cdir shortloop
#line 2985
    for (i=0; i<ni; i++) {
#line 2985
      /* the normal case: */
#line 2985
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2985
     /* test for range errors (not always needed but do it anyway) */
#line 2985
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2985
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2985
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2985
    }
#line 2985
   /* copy workspace back if necessary */
#line 2985
    if (realign) {
#line 2985
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2985
      xp = (uint *) *xpp;
#line 2985
    }
#line 2985
   /* update xpp and tp */
#line 2985
    xp += ni;
#line 2985
    tp += ni;
#line 2985
    *xpp = (void*)xp;
#line 2985
  }
#line 2985
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2985

#line 2985
#else   /* not SX */
#line 2985

#line 2985
	char *xp = (char *) *xpp;
#line 2985
	int status = ENOERR;
#line 2985

#line 2985
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2985
	{
#line 2985
		int lstatus = ncx_put_uint_short(xp, tp);
#line 2985
		if(lstatus != ENOERR)
#line 2985
			status = lstatus;
#line 2985
	}
#line 2985

#line 2985
	*xpp = (void *)xp;
#line 2985
	return status;
#line 2985
#endif
#line 2985
}
#line 2985

int
#line 2986
ncx_putn_uint_int(void **xpp, size_t nelems, const int *tp)
#line 2986
{
#line 2986
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2986

#line 2986
 /* basic algorithm is:
#line 2986
  *   - ensure sane alignment of output data
#line 2986
  *   - copy (conversion happens automatically) input data
#line 2986
  *     to output
#line 2986
  *   - update tp to point at next unconverted input, and xpp to point
#line 2986
  *     at next location for converted output
#line 2986
  */
#line 2986
  long i, j, ni;
#line 2986
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2986
  uint *xp;
#line 2986
  int nrange = 0;         /* number of range errors */
#line 2986
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2986
  long cxp = (long) *((char**)xpp);
#line 2986

#line 2986
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2986
  /* sjl: manually stripmine so we can limit amount of
#line 2986
   * vector work space reserved to LOOPCNT elements. Also
#line 2986
   * makes vectorisation easy */
#line 2986
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2986
    ni=Min(nelems-j,LOOPCNT);
#line 2986
    if (realign) {
#line 2986
      xp = tmp;
#line 2986
    } else {
#line 2986
      xp = (uint *) *xpp;
#line 2986
    }
#line 2986
   /* copy the next block */
#line 2986
#pragma cdir loopcnt=LOOPCNT
#line 2986
#pragma cdir shortloop
#line 2986
    for (i=0; i<ni; i++) {
#line 2986
      /* the normal case: */
#line 2986
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2986
     /* test for range errors (not always needed but do it anyway) */
#line 2986
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2986
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2986
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2986
    }
#line 2986
   /* copy workspace back if necessary */
#line 2986
    if (realign) {
#line 2986
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2986
      xp = (uint *) *xpp;
#line 2986
    }
#line 2986
   /* update xpp and tp */
#line 2986
    xp += ni;
#line 2986
    tp += ni;
#line 2986
    *xpp = (void*)xp;
#line 2986
  }
#line 2986
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2986

#line 2986
#else   /* not SX */
#line 2986

#line 2986
	char *xp = (char *) *xpp;
#line 2986
	int status = ENOERR;
#line 2986

#line 2986
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2986
	{
#line 2986
		int lstatus = ncx_put_uint_int(xp, tp);
#line 2986
		if(lstatus != ENOERR)
#line 2986
			status = lstatus;
#line 2986
	}
#line 2986

#line 2986
	*xpp = (void *)xp;
#line 2986
	return status;
#line 2986
#endif
#line 2986
}
#line 2986

int
#line 2987
ncx_putn_uint_float(void **xpp, size_t nelems, const float *tp)
#line 2987
{
#line 2987
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2987

#line 2987
 /* basic algorithm is:
#line 2987
  *   - ensure sane alignment of output data
#line 2987
  *   - copy (conversion happens automatically) input data
#line 2987
  *     to output
#line 2987
  *   - update tp to point at next unconverted input, and xpp to point
#line 2987
  *     at next location for converted output
#line 2987
  */
#line 2987
  long i, j, ni;
#line 2987
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2987
  uint *xp;
#line 2987
  int nrange = 0;         /* number of range errors */
#line 2987
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2987
  long cxp = (long) *((char**)xpp);
#line 2987

#line 2987
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2987
  /* sjl: manually stripmine so we can limit amount of
#line 2987
   * vector work space reserved to LOOPCNT elements. Also
#line 2987
   * makes vectorisation easy */
#line 2987
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2987
    ni=Min(nelems-j,LOOPCNT);
#line 2987
    if (realign) {
#line 2987
      xp = tmp;
#line 2987
    } else {
#line 2987
      xp = (uint *) *xpp;
#line 2987
    }
#line 2987
   /* copy the next block */
#line 2987
#pragma cdir loopcnt=LOOPCNT
#line 2987
#pragma cdir shortloop
#line 2987
    for (i=0; i<ni; i++) {
#line 2987
      /* the normal case: */
#line 2987
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2987
     /* test for range errors (not always needed but do it anyway) */
#line 2987
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2987
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2987
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2987
    }
#line 2987
   /* copy workspace back if necessary */
#line 2987
    if (realign) {
#line 2987
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2987
      xp = (uint *) *xpp;
#line 2987
    }
#line 2987
   /* update xpp and tp */
#line 2987
    xp += ni;
#line 2987
    tp += ni;
#line 2987
    *xpp = (void*)xp;
#line 2987
  }
#line 2987
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2987

#line 2987
#else   /* not SX */
#line 2987

#line 2987
	char *xp = (char *) *xpp;
#line 2987
	int status = ENOERR;
#line 2987

#line 2987
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2987
	{
#line 2987
		int lstatus = ncx_put_uint_float(xp, tp);
#line 2987
		if(lstatus != ENOERR)
#line 2987
			status = lstatus;
#line 2987
	}
#line 2987

#line 2987
	*xpp = (void *)xp;
#line 2987
	return status;
#line 2987
#endif
#line 2987
}
#line 2987

int
#line 2988
ncx_putn_uint_double(void **xpp, size_t nelems, const double *tp)
#line 2988
{
#line 2988
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2988

#line 2988
 /* basic algorithm is:
#line 2988
  *   - ensure sane alignment of output data
#line 2988
  *   - copy (conversion happens automatically) input data
#line 2988
  *     to output
#line 2988
  *   - update tp to point at next unconverted input, and xpp to point
#line 2988
  *     at next location for converted output
#line 2988
  */
#line 2988
  long i, j, ni;
#line 2988
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2988
  uint *xp;
#line 2988
  int nrange = 0;         /* number of range errors */
#line 2988
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2988
  long cxp = (long) *((char**)xpp);
#line 2988

#line 2988
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2988
  /* sjl: manually stripmine so we can limit amount of
#line 2988
   * vector work space reserved to LOOPCNT elements. Also
#line 2988
   * makes vectorisation easy */
#line 2988
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2988
    ni=Min(nelems-j,LOOPCNT);
#line 2988
    if (realign) {
#line 2988
      xp = tmp;
#line 2988
    } else {
#line 2988
      xp = (uint *) *xpp;
#line 2988
    }
#line 2988
   /* copy the next block */
#line 2988
#pragma cdir loopcnt=LOOPCNT
#line 2988
#pragma cdir shortloop
#line 2988
    for (i=0; i<ni; i++) {
#line 2988
      /* the normal case: */
#line 2988
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2988
     /* test for range errors (not always needed but do it anyway) */
#line 2988
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2988
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2988
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2988
    }
#line 2988
   /* copy workspace back if necessary */
#line 2988
    if (realign) {
#line 2988
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2988
      xp = (uint *) *xpp;
#line 2988
    }
#line 2988
   /* update xpp and tp */
#line 2988
    xp += ni;
#line 2988
    tp += ni;
#line 2988
    *xpp = (void*)xp;
#line 2988
  }
#line 2988
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2988

#line 2988
#else   /* not SX */
#line 2988

#line 2988
	char *xp = (char *) *xpp;
#line 2988
	int status = ENOERR;
#line 2988

#line 2988
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2988
	{
#line 2988
		int lstatus = ncx_put_uint_double(xp, tp);
#line 2988
		if(lstatus != ENOERR)
#line 2988
			status = lstatus;
#line 2988
	}
#line 2988

#line 2988
	*xpp = (void *)xp;
#line 2988
	return status;
#line 2988
#endif
#line 2988
}
#line 2988

int
#line 2989
ncx_putn_uint_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 2989
{
#line 2989
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2989

#line 2989
 /* basic algorithm is:
#line 2989
  *   - ensure sane alignment of output data
#line 2989
  *   - copy (conversion happens automatically) input data
#line 2989
  *     to output
#line 2989
  *   - update tp to point at next unconverted input, and xpp to point
#line 2989
  *     at next location for converted output
#line 2989
  */
#line 2989
  long i, j, ni;
#line 2989
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2989
  uint *xp;
#line 2989
  int nrange = 0;         /* number of range errors */
#line 2989
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2989
  long cxp = (long) *((char**)xpp);
#line 2989

#line 2989
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2989
  /* sjl: manually stripmine so we can limit amount of
#line 2989
   * vector work space reserved to LOOPCNT elements. Also
#line 2989
   * makes vectorisation easy */
#line 2989
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2989
    ni=Min(nelems-j,LOOPCNT);
#line 2989
    if (realign) {
#line 2989
      xp = tmp;
#line 2989
    } else {
#line 2989
      xp = (uint *) *xpp;
#line 2989
    }
#line 2989
   /* copy the next block */
#line 2989
#pragma cdir loopcnt=LOOPCNT
#line 2989
#pragma cdir shortloop
#line 2989
    for (i=0; i<ni; i++) {
#line 2989
      /* the normal case: */
#line 2989
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2989
     /* test for range errors (not always needed but do it anyway) */
#line 2989
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2989
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2989
      nrange += tp[i] > X_UINT_MAX || tp[i] < 0;
#line 2989
    }
#line 2989
   /* copy workspace back if necessary */
#line 2989
    if (realign) {
#line 2989
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2989
      xp = (uint *) *xpp;
#line 2989
    }
#line 2989
   /* update xpp and tp */
#line 2989
    xp += ni;
#line 2989
    tp += ni;
#line 2989
    *xpp = (void*)xp;
#line 2989
  }
#line 2989
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2989

#line 2989
#else   /* not SX */
#line 2989

#line 2989
	char *xp = (char *) *xpp;
#line 2989
	int status = ENOERR;
#line 2989

#line 2989
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2989
	{
#line 2989
		int lstatus = ncx_put_uint_longlong(xp, tp);
#line 2989
		if(lstatus != ENOERR)
#line 2989
			status = lstatus;
#line 2989
	}
#line 2989

#line 2989
	*xpp = (void *)xp;
#line 2989
	return status;
#line 2989
#endif
#line 2989
}
#line 2989

int
#line 2990
ncx_putn_uint_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 2990
{
#line 2990
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2990

#line 2990
 /* basic algorithm is:
#line 2990
  *   - ensure sane alignment of output data
#line 2990
  *   - copy (conversion happens automatically) input data
#line 2990
  *     to output
#line 2990
  *   - update tp to point at next unconverted input, and xpp to point
#line 2990
  *     at next location for converted output
#line 2990
  */
#line 2990
  long i, j, ni;
#line 2990
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2990
  uint *xp;
#line 2990
  int nrange = 0;         /* number of range errors */
#line 2990
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2990
  long cxp = (long) *((char**)xpp);
#line 2990

#line 2990
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2990
  /* sjl: manually stripmine so we can limit amount of
#line 2990
   * vector work space reserved to LOOPCNT elements. Also
#line 2990
   * makes vectorisation easy */
#line 2990
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2990
    ni=Min(nelems-j,LOOPCNT);
#line 2990
    if (realign) {
#line 2990
      xp = tmp;
#line 2990
    } else {
#line 2990
      xp = (uint *) *xpp;
#line 2990
    }
#line 2990
   /* copy the next block */
#line 2990
#pragma cdir loopcnt=LOOPCNT
#line 2990
#pragma cdir shortloop
#line 2990
    for (i=0; i<ni; i++) {
#line 2990
      /* the normal case: */
#line 2990
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2990
     /* test for range errors (not always needed but do it anyway) */
#line 2990
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2990
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2990
      nrange += tp[i] > X_UINT_MAX ;
#line 2990
    }
#line 2990
   /* copy workspace back if necessary */
#line 2990
    if (realign) {
#line 2990
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2990
      xp = (uint *) *xpp;
#line 2990
    }
#line 2990
   /* update xpp and tp */
#line 2990
    xp += ni;
#line 2990
    tp += ni;
#line 2990
    *xpp = (void*)xp;
#line 2990
  }
#line 2990
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2990

#line 2990
#else   /* not SX */
#line 2990

#line 2990
	char *xp = (char *) *xpp;
#line 2990
	int status = ENOERR;
#line 2990

#line 2990
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2990
	{
#line 2990
		int lstatus = ncx_put_uint_uchar(xp, tp);
#line 2990
		if(lstatus != ENOERR)
#line 2990
			status = lstatus;
#line 2990
	}
#line 2990

#line 2990
	*xpp = (void *)xp;
#line 2990
	return status;
#line 2990
#endif
#line 2990
}
#line 2990

int
#line 2991
ncx_putn_uint_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 2991
{
#line 2991
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2991

#line 2991
 /* basic algorithm is:
#line 2991
  *   - ensure sane alignment of output data
#line 2991
  *   - copy (conversion happens automatically) input data
#line 2991
  *     to output
#line 2991
  *   - update tp to point at next unconverted input, and xpp to point
#line 2991
  *     at next location for converted output
#line 2991
  */
#line 2991
  long i, j, ni;
#line 2991
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2991
  uint *xp;
#line 2991
  int nrange = 0;         /* number of range errors */
#line 2991
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2991
  long cxp = (long) *((char**)xpp);
#line 2991

#line 2991
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2991
  /* sjl: manually stripmine so we can limit amount of
#line 2991
   * vector work space reserved to LOOPCNT elements. Also
#line 2991
   * makes vectorisation easy */
#line 2991
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2991
    ni=Min(nelems-j,LOOPCNT);
#line 2991
    if (realign) {
#line 2991
      xp = tmp;
#line 2991
    } else {
#line 2991
      xp = (uint *) *xpp;
#line 2991
    }
#line 2991
   /* copy the next block */
#line 2991
#pragma cdir loopcnt=LOOPCNT
#line 2991
#pragma cdir shortloop
#line 2991
    for (i=0; i<ni; i++) {
#line 2991
      /* the normal case: */
#line 2991
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2991
     /* test for range errors (not always needed but do it anyway) */
#line 2991
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2991
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2991
      nrange += tp[i] > X_UINT_MAX ;
#line 2991
    }
#line 2991
   /* copy workspace back if necessary */
#line 2991
    if (realign) {
#line 2991
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2991
      xp = (uint *) *xpp;
#line 2991
    }
#line 2991
   /* update xpp and tp */
#line 2991
    xp += ni;
#line 2991
    tp += ni;
#line 2991
    *xpp = (void*)xp;
#line 2991
  }
#line 2991
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2991

#line 2991
#else   /* not SX */
#line 2991

#line 2991
	char *xp = (char *) *xpp;
#line 2991
	int status = ENOERR;
#line 2991

#line 2991
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2991
	{
#line 2991
		int lstatus = ncx_put_uint_ushort(xp, tp);
#line 2991
		if(lstatus != ENOERR)
#line 2991
			status = lstatus;
#line 2991
	}
#line 2991

#line 2991
	*xpp = (void *)xp;
#line 2991
	return status;
#line 2991
#endif
#line 2991
}
#line 2991

int
#line 2992
ncx_putn_uint_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 2992
{
#line 2992
#if _SX && X_SIZEOF_UINT == SIZEOF_UINT
#line 2992

#line 2992
 /* basic algorithm is:
#line 2992
  *   - ensure sane alignment of output data
#line 2992
  *   - copy (conversion happens automatically) input data
#line 2992
  *     to output
#line 2992
  *   - update tp to point at next unconverted input, and xpp to point
#line 2992
  *     at next location for converted output
#line 2992
  */
#line 2992
  long i, j, ni;
#line 2992
  uint tmp[LOOPCNT];        /* in case input is misaligned */
#line 2992
  uint *xp;
#line 2992
  int nrange = 0;         /* number of range errors */
#line 2992
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 2992
  long cxp = (long) *((char**)xpp);
#line 2992

#line 2992
  realign = (cxp & 7) % SIZEOF_UINT;
#line 2992
  /* sjl: manually stripmine so we can limit amount of
#line 2992
   * vector work space reserved to LOOPCNT elements. Also
#line 2992
   * makes vectorisation easy */
#line 2992
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 2992
    ni=Min(nelems-j,LOOPCNT);
#line 2992
    if (realign) {
#line 2992
      xp = tmp;
#line 2992
    } else {
#line 2992
      xp = (uint *) *xpp;
#line 2992
    }
#line 2992
   /* copy the next block */
#line 2992
#pragma cdir loopcnt=LOOPCNT
#line 2992
#pragma cdir shortloop
#line 2992
    for (i=0; i<ni; i++) {
#line 2992
      /* the normal case: */
#line 2992
      xp[i] = (uint) Max( X_UINT_MIN, Min(X_UINT_MAX, (uint) tp[i]));
#line 2992
     /* test for range errors (not always needed but do it anyway) */
#line 2992
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 2992
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 2992
      nrange += tp[i] > X_UINT_MAX ;
#line 2992
    }
#line 2992
   /* copy workspace back if necessary */
#line 2992
    if (realign) {
#line 2992
      memcpy(*xpp, tmp, ni*X_SIZEOF_UINT);
#line 2992
      xp = (uint *) *xpp;
#line 2992
    }
#line 2992
   /* update xpp and tp */
#line 2992
    xp += ni;
#line 2992
    tp += ni;
#line 2992
    *xpp = (void*)xp;
#line 2992
  }
#line 2992
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 2992

#line 2992
#else   /* not SX */
#line 2992

#line 2992
	char *xp = (char *) *xpp;
#line 2992
	int status = ENOERR;
#line 2992

#line 2992
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_UINT, tp++)
#line 2992
	{
#line 2992
		int lstatus = ncx_put_uint_ulonglong(xp, tp);
#line 2992
		if(lstatus != ENOERR)
#line 2992
			status = lstatus;
#line 2992
	}
#line 2992

#line 2992
	*xpp = (void *)xp;
#line 2992
	return status;
#line 2992
#endif
#line 2992
}
#line 2992


/* float ---------------------------------------------------------------------*/
#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(float));
# else
	swapn4b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return ENOERR;
}
#elif vax
int
ncx_getn_float_float(const void **xpp, size_t nfloats, float *ip)
{
	float *const end = ip + nfloats;

	while(ip < end)
	{
		struct vax_single *const vsp = (struct vax_single *) ip;
#line 3016
		const struct ieee_single *const isp =
#line 3016
			 (const struct ieee_single *) (*xpp);
#line 3016
		unsigned exp = isp->exp_hi << 1 | isp->exp_lo;
#line 3016

#line 3016
		switch(exp) {
#line 3016
		case 0 :
#line 3016
			/* ieee subnormal */
#line 3016
			if(isp->mant_hi == min.ieee.mant_hi
#line 3016
				&& isp->mant_lo_hi == min.ieee.mant_lo_hi
#line 3016
				&& isp->mant_lo_lo == min.ieee.mant_lo_lo)
#line 3016
			{
#line 3016
				*vsp = min.s;
#line 3016
			}
#line 3016
			else
#line 3016
			{
#line 3016
				unsigned mantissa = (isp->mant_hi << 16)
#line 3016
					 | isp->mant_lo_hi << 8
#line 3016
					 | isp->mant_lo_lo;
#line 3016
				unsigned tmp = mantissa >> 20;
#line 3016
				if(tmp >= 4) {
#line 3016
					vsp->exp = 2;
#line 3016
				} else if (tmp >= 2) {
#line 3016
					vsp->exp = 1;
#line 3016
				} else {
#line 3016
					*vsp = min.s;
#line 3016
					break;
#line 3016
				} /* else */
#line 3016
				tmp = mantissa - (1 << (20 + vsp->exp ));
#line 3016
				tmp <<= 3 - vsp->exp;
#line 3016
				vsp->mantissa2 = tmp;
#line 3016
				vsp->mantissa1 = (tmp >> 16);
#line 3016
			}
#line 3016
			break;
#line 3016
		case 0xfe :
#line 3016
		case 0xff :
#line 3016
			*vsp = max.s;
#line 3016
			break;
#line 3016
		default :
#line 3016
			vsp->exp = exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
#line 3016
			vsp->mantissa2 = isp->mant_lo_hi << 8 | isp->mant_lo_lo;
#line 3016
			vsp->mantissa1 = isp->mant_hi;
#line 3016
		}
#line 3016

#line 3016
		vsp->sign = isp->sign;
#line 3016


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return ENOERR;
}
#else
int
ncx_getn_float_float(const void **xpp, size_t nelems, float *tp)
{
	const char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		const int lstatus = ncx_get_float_float(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}

#endif
int
#line 3042
ncx_getn_float_schar(const void **xpp, size_t nelems, schar *tp)
#line 3042
{
#line 3042
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3042

#line 3042
 /* basic algorithm is:
#line 3042
  *   - ensure sane alignment of input data
#line 3042
  *   - copy (conversion happens automatically) input data
#line 3042
  *     to output
#line 3042
  *   - update xpp to point at next unconverted input, and tp to point
#line 3042
  *     at next location for converted output
#line 3042
  */
#line 3042
  long i, j, ni;
#line 3042
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3042
  float *xp;
#line 3042
  int nrange = 0;         /* number of range errors */
#line 3042
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3042
  long cxp = (long) *((char**)xpp);
#line 3042

#line 3042
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3042
  /* sjl: manually stripmine so we can limit amount of
#line 3042
   * vector work space reserved to LOOPCNT elements. Also
#line 3042
   * makes vectorisation easy */
#line 3042
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3042
    ni=Min(nelems-j,LOOPCNT);
#line 3042
    if (realign) {
#line 3042
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3042
      xp = tmp;
#line 3042
    } else {
#line 3042
      xp = (float *) *xpp;
#line 3042
    }
#line 3042
   /* copy the next block */
#line 3042
#pragma cdir loopcnt=LOOPCNT
#line 3042
#pragma cdir shortloop
#line 3042
    for (i=0; i<ni; i++) {
#line 3042
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3042
     /* test for range errors (not always needed but do it anyway) */
#line 3042
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3042
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3042
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3042
    }
#line 3042
   /* update xpp and tp */
#line 3042
    if (realign) xp = (float *) *xpp;
#line 3042
    xp += ni;
#line 3042
    tp += ni;
#line 3042
    *xpp = (void*)xp;
#line 3042
  }
#line 3042
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3042

#line 3042
#else   /* not SX */
#line 3042
	const char *xp = (const char *) *xpp;
#line 3042
	int status = ENOERR;
#line 3042

#line 3042
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3042
	{
#line 3042
		const int lstatus = ncx_get_float_schar(xp, tp);
#line 3042
		if(lstatus != ENOERR)
#line 3042
			status = lstatus;
#line 3042
	}
#line 3042

#line 3042
	*xpp = (const void *)xp;
#line 3042
	return status;
#line 3042
#  endif
#line 3042
}
#line 3042

int
#line 3043
ncx_getn_float_short(const void **xpp, size_t nelems, short *tp)
#line 3043
{
#line 3043
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3043

#line 3043
 /* basic algorithm is:
#line 3043
  *   - ensure sane alignment of input data
#line 3043
  *   - copy (conversion happens automatically) input data
#line 3043
  *     to output
#line 3043
  *   - update xpp to point at next unconverted input, and tp to point
#line 3043
  *     at next location for converted output
#line 3043
  */
#line 3043
  long i, j, ni;
#line 3043
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3043
  float *xp;
#line 3043
  int nrange = 0;         /* number of range errors */
#line 3043
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3043
  long cxp = (long) *((char**)xpp);
#line 3043

#line 3043
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3043
  /* sjl: manually stripmine so we can limit amount of
#line 3043
   * vector work space reserved to LOOPCNT elements. Also
#line 3043
   * makes vectorisation easy */
#line 3043
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3043
    ni=Min(nelems-j,LOOPCNT);
#line 3043
    if (realign) {
#line 3043
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3043
      xp = tmp;
#line 3043
    } else {
#line 3043
      xp = (float *) *xpp;
#line 3043
    }
#line 3043
   /* copy the next block */
#line 3043
#pragma cdir loopcnt=LOOPCNT
#line 3043
#pragma cdir shortloop
#line 3043
    for (i=0; i<ni; i++) {
#line 3043
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3043
     /* test for range errors (not always needed but do it anyway) */
#line 3043
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3043
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3043
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3043
    }
#line 3043
   /* update xpp and tp */
#line 3043
    if (realign) xp = (float *) *xpp;
#line 3043
    xp += ni;
#line 3043
    tp += ni;
#line 3043
    *xpp = (void*)xp;
#line 3043
  }
#line 3043
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3043

#line 3043
#else   /* not SX */
#line 3043
	const char *xp = (const char *) *xpp;
#line 3043
	int status = ENOERR;
#line 3043

#line 3043
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3043
	{
#line 3043
		const int lstatus = ncx_get_float_short(xp, tp);
#line 3043
		if(lstatus != ENOERR)
#line 3043
			status = lstatus;
#line 3043
	}
#line 3043

#line 3043
	*xpp = (const void *)xp;
#line 3043
	return status;
#line 3043
#  endif
#line 3043
}
#line 3043

int
#line 3044
ncx_getn_float_int(const void **xpp, size_t nelems, int *tp)
#line 3044
{
#line 3044
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3044

#line 3044
 /* basic algorithm is:
#line 3044
  *   - ensure sane alignment of input data
#line 3044
  *   - copy (conversion happens automatically) input data
#line 3044
  *     to output
#line 3044
  *   - update xpp to point at next unconverted input, and tp to point
#line 3044
  *     at next location for converted output
#line 3044
  */
#line 3044
  long i, j, ni;
#line 3044
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3044
  float *xp;
#line 3044
  int nrange = 0;         /* number of range errors */
#line 3044
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3044
  long cxp = (long) *((char**)xpp);
#line 3044

#line 3044
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3044
  /* sjl: manually stripmine so we can limit amount of
#line 3044
   * vector work space reserved to LOOPCNT elements. Also
#line 3044
   * makes vectorisation easy */
#line 3044
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3044
    ni=Min(nelems-j,LOOPCNT);
#line 3044
    if (realign) {
#line 3044
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3044
      xp = tmp;
#line 3044
    } else {
#line 3044
      xp = (float *) *xpp;
#line 3044
    }
#line 3044
   /* copy the next block */
#line 3044
#pragma cdir loopcnt=LOOPCNT
#line 3044
#pragma cdir shortloop
#line 3044
    for (i=0; i<ni; i++) {
#line 3044
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3044
     /* test for range errors (not always needed but do it anyway) */
#line 3044
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3044
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3044
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3044
    }
#line 3044
   /* update xpp and tp */
#line 3044
    if (realign) xp = (float *) *xpp;
#line 3044
    xp += ni;
#line 3044
    tp += ni;
#line 3044
    *xpp = (void*)xp;
#line 3044
  }
#line 3044
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3044

#line 3044
#else   /* not SX */
#line 3044
	const char *xp = (const char *) *xpp;
#line 3044
	int status = ENOERR;
#line 3044

#line 3044
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3044
	{
#line 3044
		const int lstatus = ncx_get_float_int(xp, tp);
#line 3044
		if(lstatus != ENOERR)
#line 3044
			status = lstatus;
#line 3044
	}
#line 3044

#line 3044
	*xpp = (const void *)xp;
#line 3044
	return status;
#line 3044
#  endif
#line 3044
}
#line 3044

int
#line 3045
ncx_getn_float_double(const void **xpp, size_t nelems, double *tp)
#line 3045
{
#line 3045
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3045

#line 3045
 /* basic algorithm is:
#line 3045
  *   - ensure sane alignment of input data
#line 3045
  *   - copy (conversion happens automatically) input data
#line 3045
  *     to output
#line 3045
  *   - update xpp to point at next unconverted input, and tp to point
#line 3045
  *     at next location for converted output
#line 3045
  */
#line 3045
  long i, j, ni;
#line 3045
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3045
  float *xp;
#line 3045
  int nrange = 0;         /* number of range errors */
#line 3045
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3045
  long cxp = (long) *((char**)xpp);
#line 3045

#line 3045
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3045
  /* sjl: manually stripmine so we can limit amount of
#line 3045
   * vector work space reserved to LOOPCNT elements. Also
#line 3045
   * makes vectorisation easy */
#line 3045
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3045
    ni=Min(nelems-j,LOOPCNT);
#line 3045
    if (realign) {
#line 3045
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3045
      xp = tmp;
#line 3045
    } else {
#line 3045
      xp = (float *) *xpp;
#line 3045
    }
#line 3045
   /* copy the next block */
#line 3045
#pragma cdir loopcnt=LOOPCNT
#line 3045
#pragma cdir shortloop
#line 3045
    for (i=0; i<ni; i++) {
#line 3045
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3045
     /* test for range errors (not always needed but do it anyway) */
#line 3045
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3045
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3045
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3045
    }
#line 3045
   /* update xpp and tp */
#line 3045
    if (realign) xp = (float *) *xpp;
#line 3045
    xp += ni;
#line 3045
    tp += ni;
#line 3045
    *xpp = (void*)xp;
#line 3045
  }
#line 3045
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3045

#line 3045
#else   /* not SX */
#line 3045
	const char *xp = (const char *) *xpp;
#line 3045
	int status = ENOERR;
#line 3045

#line 3045
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3045
	{
#line 3045
		const int lstatus = ncx_get_float_double(xp, tp);
#line 3045
		if(lstatus != ENOERR)
#line 3045
			status = lstatus;
#line 3045
	}
#line 3045

#line 3045
	*xpp = (const void *)xp;
#line 3045
	return status;
#line 3045
#  endif
#line 3045
}
#line 3045

int
#line 3046
ncx_getn_float_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3046
{
#line 3046
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3046

#line 3046
 /* basic algorithm is:
#line 3046
  *   - ensure sane alignment of input data
#line 3046
  *   - copy (conversion happens automatically) input data
#line 3046
  *     to output
#line 3046
  *   - update xpp to point at next unconverted input, and tp to point
#line 3046
  *     at next location for converted output
#line 3046
  */
#line 3046
  long i, j, ni;
#line 3046
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3046
  float *xp;
#line 3046
  int nrange = 0;         /* number of range errors */
#line 3046
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3046
  long cxp = (long) *((char**)xpp);
#line 3046

#line 3046
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3046
  /* sjl: manually stripmine so we can limit amount of
#line 3046
   * vector work space reserved to LOOPCNT elements. Also
#line 3046
   * makes vectorisation easy */
#line 3046
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3046
    ni=Min(nelems-j,LOOPCNT);
#line 3046
    if (realign) {
#line 3046
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3046
      xp = tmp;
#line 3046
    } else {
#line 3046
      xp = (float *) *xpp;
#line 3046
    }
#line 3046
   /* copy the next block */
#line 3046
#pragma cdir loopcnt=LOOPCNT
#line 3046
#pragma cdir shortloop
#line 3046
    for (i=0; i<ni; i++) {
#line 3046
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3046
     /* test for range errors (not always needed but do it anyway) */
#line 3046
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3046
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3046
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3046
    }
#line 3046
   /* update xpp and tp */
#line 3046
    if (realign) xp = (float *) *xpp;
#line 3046
    xp += ni;
#line 3046
    tp += ni;
#line 3046
    *xpp = (void*)xp;
#line 3046
  }
#line 3046
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3046

#line 3046
#else   /* not SX */
#line 3046
	const char *xp = (const char *) *xpp;
#line 3046
	int status = ENOERR;
#line 3046

#line 3046
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3046
	{
#line 3046
		const int lstatus = ncx_get_float_longlong(xp, tp);
#line 3046
		if(lstatus != ENOERR)
#line 3046
			status = lstatus;
#line 3046
	}
#line 3046

#line 3046
	*xpp = (const void *)xp;
#line 3046
	return status;
#line 3046
#  endif
#line 3046
}
#line 3046

int
#line 3047
ncx_getn_float_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3047
{
#line 3047
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3047

#line 3047
 /* basic algorithm is:
#line 3047
  *   - ensure sane alignment of input data
#line 3047
  *   - copy (conversion happens automatically) input data
#line 3047
  *     to output
#line 3047
  *   - update xpp to point at next unconverted input, and tp to point
#line 3047
  *     at next location for converted output
#line 3047
  */
#line 3047
  long i, j, ni;
#line 3047
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3047
  float *xp;
#line 3047
  int nrange = 0;         /* number of range errors */
#line 3047
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3047
  long cxp = (long) *((char**)xpp);
#line 3047

#line 3047
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3047
  /* sjl: manually stripmine so we can limit amount of
#line 3047
   * vector work space reserved to LOOPCNT elements. Also
#line 3047
   * makes vectorisation easy */
#line 3047
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3047
    ni=Min(nelems-j,LOOPCNT);
#line 3047
    if (realign) {
#line 3047
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3047
      xp = tmp;
#line 3047
    } else {
#line 3047
      xp = (float *) *xpp;
#line 3047
    }
#line 3047
   /* copy the next block */
#line 3047
#pragma cdir loopcnt=LOOPCNT
#line 3047
#pragma cdir shortloop
#line 3047
    for (i=0; i<ni; i++) {
#line 3047
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3047
     /* test for range errors (not always needed but do it anyway) */
#line 3047
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3047
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3047
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3047
    }
#line 3047
   /* update xpp and tp */
#line 3047
    if (realign) xp = (float *) *xpp;
#line 3047
    xp += ni;
#line 3047
    tp += ni;
#line 3047
    *xpp = (void*)xp;
#line 3047
  }
#line 3047
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3047

#line 3047
#else   /* not SX */
#line 3047
	const char *xp = (const char *) *xpp;
#line 3047
	int status = ENOERR;
#line 3047

#line 3047
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3047
	{
#line 3047
		const int lstatus = ncx_get_float_ushort(xp, tp);
#line 3047
		if(lstatus != ENOERR)
#line 3047
			status = lstatus;
#line 3047
	}
#line 3047

#line 3047
	*xpp = (const void *)xp;
#line 3047
	return status;
#line 3047
#  endif
#line 3047
}
#line 3047

int
#line 3048
ncx_getn_float_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3048
{
#line 3048
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3048

#line 3048
 /* basic algorithm is:
#line 3048
  *   - ensure sane alignment of input data
#line 3048
  *   - copy (conversion happens automatically) input data
#line 3048
  *     to output
#line 3048
  *   - update xpp to point at next unconverted input, and tp to point
#line 3048
  *     at next location for converted output
#line 3048
  */
#line 3048
  long i, j, ni;
#line 3048
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3048
  float *xp;
#line 3048
  int nrange = 0;         /* number of range errors */
#line 3048
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3048
  long cxp = (long) *((char**)xpp);
#line 3048

#line 3048
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3048
  /* sjl: manually stripmine so we can limit amount of
#line 3048
   * vector work space reserved to LOOPCNT elements. Also
#line 3048
   * makes vectorisation easy */
#line 3048
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3048
    ni=Min(nelems-j,LOOPCNT);
#line 3048
    if (realign) {
#line 3048
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3048
      xp = tmp;
#line 3048
    } else {
#line 3048
      xp = (float *) *xpp;
#line 3048
    }
#line 3048
   /* copy the next block */
#line 3048
#pragma cdir loopcnt=LOOPCNT
#line 3048
#pragma cdir shortloop
#line 3048
    for (i=0; i<ni; i++) {
#line 3048
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3048
     /* test for range errors (not always needed but do it anyway) */
#line 3048
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3048
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3048
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3048
    }
#line 3048
   /* update xpp and tp */
#line 3048
    if (realign) xp = (float *) *xpp;
#line 3048
    xp += ni;
#line 3048
    tp += ni;
#line 3048
    *xpp = (void*)xp;
#line 3048
  }
#line 3048
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3048

#line 3048
#else   /* not SX */
#line 3048
	const char *xp = (const char *) *xpp;
#line 3048
	int status = ENOERR;
#line 3048

#line 3048
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3048
	{
#line 3048
		const int lstatus = ncx_get_float_uchar(xp, tp);
#line 3048
		if(lstatus != ENOERR)
#line 3048
			status = lstatus;
#line 3048
	}
#line 3048

#line 3048
	*xpp = (const void *)xp;
#line 3048
	return status;
#line 3048
#  endif
#line 3048
}
#line 3048

int
#line 3049
ncx_getn_float_uint(const void **xpp, size_t nelems, uint *tp)
#line 3049
{
#line 3049
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3049

#line 3049
 /* basic algorithm is:
#line 3049
  *   - ensure sane alignment of input data
#line 3049
  *   - copy (conversion happens automatically) input data
#line 3049
  *     to output
#line 3049
  *   - update xpp to point at next unconverted input, and tp to point
#line 3049
  *     at next location for converted output
#line 3049
  */
#line 3049
  long i, j, ni;
#line 3049
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3049
  float *xp;
#line 3049
  int nrange = 0;         /* number of range errors */
#line 3049
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3049
  long cxp = (long) *((char**)xpp);
#line 3049

#line 3049
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3049
  /* sjl: manually stripmine so we can limit amount of
#line 3049
   * vector work space reserved to LOOPCNT elements. Also
#line 3049
   * makes vectorisation easy */
#line 3049
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3049
    ni=Min(nelems-j,LOOPCNT);
#line 3049
    if (realign) {
#line 3049
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3049
      xp = tmp;
#line 3049
    } else {
#line 3049
      xp = (float *) *xpp;
#line 3049
    }
#line 3049
   /* copy the next block */
#line 3049
#pragma cdir loopcnt=LOOPCNT
#line 3049
#pragma cdir shortloop
#line 3049
    for (i=0; i<ni; i++) {
#line 3049
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3049
     /* test for range errors (not always needed but do it anyway) */
#line 3049
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3049
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3049
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3049
    }
#line 3049
   /* update xpp and tp */
#line 3049
    if (realign) xp = (float *) *xpp;
#line 3049
    xp += ni;
#line 3049
    tp += ni;
#line 3049
    *xpp = (void*)xp;
#line 3049
  }
#line 3049
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3049

#line 3049
#else   /* not SX */
#line 3049
	const char *xp = (const char *) *xpp;
#line 3049
	int status = ENOERR;
#line 3049

#line 3049
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3049
	{
#line 3049
		const int lstatus = ncx_get_float_uint(xp, tp);
#line 3049
		if(lstatus != ENOERR)
#line 3049
			status = lstatus;
#line 3049
	}
#line 3049

#line 3049
	*xpp = (const void *)xp;
#line 3049
	return status;
#line 3049
#  endif
#line 3049
}
#line 3049

int
#line 3050
ncx_getn_float_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3050
{
#line 3050
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3050

#line 3050
 /* basic algorithm is:
#line 3050
  *   - ensure sane alignment of input data
#line 3050
  *   - copy (conversion happens automatically) input data
#line 3050
  *     to output
#line 3050
  *   - update xpp to point at next unconverted input, and tp to point
#line 3050
  *     at next location for converted output
#line 3050
  */
#line 3050
  long i, j, ni;
#line 3050
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3050
  float *xp;
#line 3050
  int nrange = 0;         /* number of range errors */
#line 3050
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3050
  long cxp = (long) *((char**)xpp);
#line 3050

#line 3050
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3050
  /* sjl: manually stripmine so we can limit amount of
#line 3050
   * vector work space reserved to LOOPCNT elements. Also
#line 3050
   * makes vectorisation easy */
#line 3050
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3050
    ni=Min(nelems-j,LOOPCNT);
#line 3050
    if (realign) {
#line 3050
      memcpy(tmp, *xpp, ni*SIZEOF_FLOAT);
#line 3050
      xp = tmp;
#line 3050
    } else {
#line 3050
      xp = (float *) *xpp;
#line 3050
    }
#line 3050
   /* copy the next block */
#line 3050
#pragma cdir loopcnt=LOOPCNT
#line 3050
#pragma cdir shortloop
#line 3050
    for (i=0; i<ni; i++) {
#line 3050
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3050
     /* test for range errors (not always needed but do it anyway) */
#line 3050
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3050
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3050
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3050
    }
#line 3050
   /* update xpp and tp */
#line 3050
    if (realign) xp = (float *) *xpp;
#line 3050
    xp += ni;
#line 3050
    tp += ni;
#line 3050
    *xpp = (void*)xp;
#line 3050
  }
#line 3050
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3050

#line 3050
#else   /* not SX */
#line 3050
	const char *xp = (const char *) *xpp;
#line 3050
	int status = ENOERR;
#line 3050

#line 3050
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3050
	{
#line 3050
		const int lstatus = ncx_get_float_ulonglong(xp, tp);
#line 3050
		if(lstatus != ENOERR)
#line 3050
			status = lstatus;
#line 3050
	}
#line 3050

#line 3050
	*xpp = (const void *)xp;
#line 3050
	return status;
#line 3050
#  endif
#line 3050
}
#line 3050


#if X_SIZEOF_FLOAT == SIZEOF_FLOAT && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_FLOAT);
# else
	swapn4b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_FLOAT);
	return ENOERR;
}
#elif vax
int
ncx_putn_float_float(void **xpp, size_t nfloats, const float *ip)
{
	const float *const end = ip + nfloats;

	while(ip < end)
	{
		const struct vax_single *const vsp =
#line 3073
			 (const struct vax_single *)ip;
#line 3073
		struct ieee_single *const isp = (struct ieee_single *) (*xpp);
#line 3073

#line 3073
		switch(vsp->exp){
#line 3073
		case 0 :
#line 3073
			/* all vax float with zero exponent map to zero */
#line 3073
			*isp = min.ieee;
#line 3073
			break;
#line 3073
		case 2 :
#line 3073
		case 1 :
#line 3073
		{
#line 3073
			/* These will map to subnormals */
#line 3073
			unsigned mantissa = (vsp->mantissa1 << 16)
#line 3073
					 | vsp->mantissa2;
#line 3073
			mantissa >>= 3 - vsp->exp;
#line 3073
			mantissa += (1 << (20 + vsp->exp));
#line 3073
			isp->mant_lo_lo = mantissa;
#line 3073
			isp->mant_lo_hi = mantissa >> 8;
#line 3073
			isp->mant_hi = mantissa >> 16;
#line 3073
			isp->exp_lo = 0;
#line 3073
			isp->exp_hi = 0;
#line 3073
		}
#line 3073
			break;
#line 3073
		case 0xff : /* max.s.exp */
#line 3073
			if( vsp->mantissa2 == max.s.mantissa2
#line 3073
				&& vsp->mantissa1 == max.s.mantissa1)
#line 3073
			{
#line 3073
				/* map largest vax float to ieee infinity */
#line 3073
				*isp = max.ieee;
#line 3073
				break;
#line 3073
			} /* else, fall thru */
#line 3073
		default :
#line 3073
		{
#line 3073
			unsigned exp = vsp->exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
#line 3073
			isp->exp_hi = exp >> 1;
#line 3073
			isp->exp_lo = exp;
#line 3073
			isp->mant_lo_lo = vsp->mantissa2;
#line 3073
			isp->mant_lo_hi = vsp->mantissa2 >> 8;
#line 3073
			isp->mant_hi = vsp->mantissa1;
#line 3073
		}
#line 3073
		}
#line 3073

#line 3073
		isp->sign = vsp->sign;
#line 3073


		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_FLOAT;
	}
	return ENOERR;
}
#else
int
ncx_putn_float_float(void **xpp, size_t nelems, const float *tp)
{
	char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
	{
		int lstatus = ncx_put_float_float(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3098
ncx_putn_float_schar(void **xpp, size_t nelems, const schar *tp)
#line 3098
{
#line 3098
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3098

#line 3098
 /* basic algorithm is:
#line 3098
  *   - ensure sane alignment of output data
#line 3098
  *   - copy (conversion happens automatically) input data
#line 3098
  *     to output
#line 3098
  *   - update tp to point at next unconverted input, and xpp to point
#line 3098
  *     at next location for converted output
#line 3098
  */
#line 3098
  long i, j, ni;
#line 3098
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3098
  float *xp;
#line 3098
  int nrange = 0;         /* number of range errors */
#line 3098
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3098
  long cxp = (long) *((char**)xpp);
#line 3098

#line 3098
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3098
  /* sjl: manually stripmine so we can limit amount of
#line 3098
   * vector work space reserved to LOOPCNT elements. Also
#line 3098
   * makes vectorisation easy */
#line 3098
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3098
    ni=Min(nelems-j,LOOPCNT);
#line 3098
    if (realign) {
#line 3098
      xp = tmp;
#line 3098
    } else {
#line 3098
      xp = (float *) *xpp;
#line 3098
    }
#line 3098
   /* copy the next block */
#line 3098
#pragma cdir loopcnt=LOOPCNT
#line 3098
#pragma cdir shortloop
#line 3098
    for (i=0; i<ni; i++) {
#line 3098
      /* the normal case: */
#line 3098
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3098
     /* test for range errors (not always needed but do it anyway) */
#line 3098
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3098
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3098
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3098
    }
#line 3098
   /* copy workspace back if necessary */
#line 3098
    if (realign) {
#line 3098
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3098
      xp = (float *) *xpp;
#line 3098
    }
#line 3098
   /* update xpp and tp */
#line 3098
    xp += ni;
#line 3098
    tp += ni;
#line 3098
    *xpp = (void*)xp;
#line 3098
  }
#line 3098
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3098

#line 3098
#else   /* not SX */
#line 3098

#line 3098
	char *xp = (char *) *xpp;
#line 3098
	int status = ENOERR;
#line 3098

#line 3098
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3098
	{
#line 3098
		int lstatus = ncx_put_float_schar(xp, tp);
#line 3098
		if(lstatus != ENOERR)
#line 3098
			status = lstatus;
#line 3098
	}
#line 3098

#line 3098
	*xpp = (void *)xp;
#line 3098
	return status;
#line 3098
#endif
#line 3098
}
#line 3098

int
#line 3099
ncx_putn_float_short(void **xpp, size_t nelems, const short *tp)
#line 3099
{
#line 3099
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3099

#line 3099
 /* basic algorithm is:
#line 3099
  *   - ensure sane alignment of output data
#line 3099
  *   - copy (conversion happens automatically) input data
#line 3099
  *     to output
#line 3099
  *   - update tp to point at next unconverted input, and xpp to point
#line 3099
  *     at next location for converted output
#line 3099
  */
#line 3099
  long i, j, ni;
#line 3099
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3099
  float *xp;
#line 3099
  int nrange = 0;         /* number of range errors */
#line 3099
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3099
  long cxp = (long) *((char**)xpp);
#line 3099

#line 3099
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3099
  /* sjl: manually stripmine so we can limit amount of
#line 3099
   * vector work space reserved to LOOPCNT elements. Also
#line 3099
   * makes vectorisation easy */
#line 3099
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3099
    ni=Min(nelems-j,LOOPCNT);
#line 3099
    if (realign) {
#line 3099
      xp = tmp;
#line 3099
    } else {
#line 3099
      xp = (float *) *xpp;
#line 3099
    }
#line 3099
   /* copy the next block */
#line 3099
#pragma cdir loopcnt=LOOPCNT
#line 3099
#pragma cdir shortloop
#line 3099
    for (i=0; i<ni; i++) {
#line 3099
      /* the normal case: */
#line 3099
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3099
     /* test for range errors (not always needed but do it anyway) */
#line 3099
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3099
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3099
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3099
    }
#line 3099
   /* copy workspace back if necessary */
#line 3099
    if (realign) {
#line 3099
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3099
      xp = (float *) *xpp;
#line 3099
    }
#line 3099
   /* update xpp and tp */
#line 3099
    xp += ni;
#line 3099
    tp += ni;
#line 3099
    *xpp = (void*)xp;
#line 3099
  }
#line 3099
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3099

#line 3099
#else   /* not SX */
#line 3099

#line 3099
	char *xp = (char *) *xpp;
#line 3099
	int status = ENOERR;
#line 3099

#line 3099
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3099
	{
#line 3099
		int lstatus = ncx_put_float_short(xp, tp);
#line 3099
		if(lstatus != ENOERR)
#line 3099
			status = lstatus;
#line 3099
	}
#line 3099

#line 3099
	*xpp = (void *)xp;
#line 3099
	return status;
#line 3099
#endif
#line 3099
}
#line 3099

int
#line 3100
ncx_putn_float_int(void **xpp, size_t nelems, const int *tp)
#line 3100
{
#line 3100
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3100

#line 3100
 /* basic algorithm is:
#line 3100
  *   - ensure sane alignment of output data
#line 3100
  *   - copy (conversion happens automatically) input data
#line 3100
  *     to output
#line 3100
  *   - update tp to point at next unconverted input, and xpp to point
#line 3100
  *     at next location for converted output
#line 3100
  */
#line 3100
  long i, j, ni;
#line 3100
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3100
  float *xp;
#line 3100
  int nrange = 0;         /* number of range errors */
#line 3100
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3100
  long cxp = (long) *((char**)xpp);
#line 3100

#line 3100
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3100
  /* sjl: manually stripmine so we can limit amount of
#line 3100
   * vector work space reserved to LOOPCNT elements. Also
#line 3100
   * makes vectorisation easy */
#line 3100
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3100
    ni=Min(nelems-j,LOOPCNT);
#line 3100
    if (realign) {
#line 3100
      xp = tmp;
#line 3100
    } else {
#line 3100
      xp = (float *) *xpp;
#line 3100
    }
#line 3100
   /* copy the next block */
#line 3100
#pragma cdir loopcnt=LOOPCNT
#line 3100
#pragma cdir shortloop
#line 3100
    for (i=0; i<ni; i++) {
#line 3100
      /* the normal case: */
#line 3100
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3100
     /* test for range errors (not always needed but do it anyway) */
#line 3100
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3100
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3100
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3100
    }
#line 3100
   /* copy workspace back if necessary */
#line 3100
    if (realign) {
#line 3100
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3100
      xp = (float *) *xpp;
#line 3100
    }
#line 3100
   /* update xpp and tp */
#line 3100
    xp += ni;
#line 3100
    tp += ni;
#line 3100
    *xpp = (void*)xp;
#line 3100
  }
#line 3100
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3100

#line 3100
#else   /* not SX */
#line 3100

#line 3100
	char *xp = (char *) *xpp;
#line 3100
	int status = ENOERR;
#line 3100

#line 3100
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3100
	{
#line 3100
		int lstatus = ncx_put_float_int(xp, tp);
#line 3100
		if(lstatus != ENOERR)
#line 3100
			status = lstatus;
#line 3100
	}
#line 3100

#line 3100
	*xpp = (void *)xp;
#line 3100
	return status;
#line 3100
#endif
#line 3100
}
#line 3100

int
#line 3101
ncx_putn_float_double(void **xpp, size_t nelems, const double *tp)
#line 3101
{
#line 3101
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3101

#line 3101
 /* basic algorithm is:
#line 3101
  *   - ensure sane alignment of output data
#line 3101
  *   - copy (conversion happens automatically) input data
#line 3101
  *     to output
#line 3101
  *   - update tp to point at next unconverted input, and xpp to point
#line 3101
  *     at next location for converted output
#line 3101
  */
#line 3101
  long i, j, ni;
#line 3101
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3101
  float *xp;
#line 3101
  int nrange = 0;         /* number of range errors */
#line 3101
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3101
  long cxp = (long) *((char**)xpp);
#line 3101

#line 3101
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3101
  /* sjl: manually stripmine so we can limit amount of
#line 3101
   * vector work space reserved to LOOPCNT elements. Also
#line 3101
   * makes vectorisation easy */
#line 3101
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3101
    ni=Min(nelems-j,LOOPCNT);
#line 3101
    if (realign) {
#line 3101
      xp = tmp;
#line 3101
    } else {
#line 3101
      xp = (float *) *xpp;
#line 3101
    }
#line 3101
   /* copy the next block */
#line 3101
#pragma cdir loopcnt=LOOPCNT
#line 3101
#pragma cdir shortloop
#line 3101
    for (i=0; i<ni; i++) {
#line 3101
      /* the normal case: */
#line 3101
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3101
     /* test for range errors (not always needed but do it anyway) */
#line 3101
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3101
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3101
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3101
    }
#line 3101
   /* copy workspace back if necessary */
#line 3101
    if (realign) {
#line 3101
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3101
      xp = (float *) *xpp;
#line 3101
    }
#line 3101
   /* update xpp and tp */
#line 3101
    xp += ni;
#line 3101
    tp += ni;
#line 3101
    *xpp = (void*)xp;
#line 3101
  }
#line 3101
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3101

#line 3101
#else   /* not SX */
#line 3101

#line 3101
	char *xp = (char *) *xpp;
#line 3101
	int status = ENOERR;
#line 3101

#line 3101
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3101
	{
#line 3101
		int lstatus = ncx_put_float_double(xp, tp);
#line 3101
		if(lstatus != ENOERR)
#line 3101
			status = lstatus;
#line 3101
	}
#line 3101

#line 3101
	*xpp = (void *)xp;
#line 3101
	return status;
#line 3101
#endif
#line 3101
}
#line 3101

int
#line 3102
ncx_putn_float_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3102
{
#line 3102
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3102

#line 3102
 /* basic algorithm is:
#line 3102
  *   - ensure sane alignment of output data
#line 3102
  *   - copy (conversion happens automatically) input data
#line 3102
  *     to output
#line 3102
  *   - update tp to point at next unconverted input, and xpp to point
#line 3102
  *     at next location for converted output
#line 3102
  */
#line 3102
  long i, j, ni;
#line 3102
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3102
  float *xp;
#line 3102
  int nrange = 0;         /* number of range errors */
#line 3102
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3102
  long cxp = (long) *((char**)xpp);
#line 3102

#line 3102
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3102
  /* sjl: manually stripmine so we can limit amount of
#line 3102
   * vector work space reserved to LOOPCNT elements. Also
#line 3102
   * makes vectorisation easy */
#line 3102
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3102
    ni=Min(nelems-j,LOOPCNT);
#line 3102
    if (realign) {
#line 3102
      xp = tmp;
#line 3102
    } else {
#line 3102
      xp = (float *) *xpp;
#line 3102
    }
#line 3102
   /* copy the next block */
#line 3102
#pragma cdir loopcnt=LOOPCNT
#line 3102
#pragma cdir shortloop
#line 3102
    for (i=0; i<ni; i++) {
#line 3102
      /* the normal case: */
#line 3102
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3102
     /* test for range errors (not always needed but do it anyway) */
#line 3102
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3102
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3102
      nrange += tp[i] > X_FLOAT_MAX || tp[i] < X_FLOAT_MIN;
#line 3102
    }
#line 3102
   /* copy workspace back if necessary */
#line 3102
    if (realign) {
#line 3102
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3102
      xp = (float *) *xpp;
#line 3102
    }
#line 3102
   /* update xpp and tp */
#line 3102
    xp += ni;
#line 3102
    tp += ni;
#line 3102
    *xpp = (void*)xp;
#line 3102
  }
#line 3102
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3102

#line 3102
#else   /* not SX */
#line 3102

#line 3102
	char *xp = (char *) *xpp;
#line 3102
	int status = ENOERR;
#line 3102

#line 3102
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3102
	{
#line 3102
		int lstatus = ncx_put_float_longlong(xp, tp);
#line 3102
		if(lstatus != ENOERR)
#line 3102
			status = lstatus;
#line 3102
	}
#line 3102

#line 3102
	*xpp = (void *)xp;
#line 3102
	return status;
#line 3102
#endif
#line 3102
}
#line 3102

int
#line 3103
ncx_putn_float_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3103
{
#line 3103
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3103

#line 3103
 /* basic algorithm is:
#line 3103
  *   - ensure sane alignment of output data
#line 3103
  *   - copy (conversion happens automatically) input data
#line 3103
  *     to output
#line 3103
  *   - update tp to point at next unconverted input, and xpp to point
#line 3103
  *     at next location for converted output
#line 3103
  */
#line 3103
  long i, j, ni;
#line 3103
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3103
  float *xp;
#line 3103
  int nrange = 0;         /* number of range errors */
#line 3103
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3103
  long cxp = (long) *((char**)xpp);
#line 3103

#line 3103
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3103
  /* sjl: manually stripmine so we can limit amount of
#line 3103
   * vector work space reserved to LOOPCNT elements. Also
#line 3103
   * makes vectorisation easy */
#line 3103
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3103
    ni=Min(nelems-j,LOOPCNT);
#line 3103
    if (realign) {
#line 3103
      xp = tmp;
#line 3103
    } else {
#line 3103
      xp = (float *) *xpp;
#line 3103
    }
#line 3103
   /* copy the next block */
#line 3103
#pragma cdir loopcnt=LOOPCNT
#line 3103
#pragma cdir shortloop
#line 3103
    for (i=0; i<ni; i++) {
#line 3103
      /* the normal case: */
#line 3103
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3103
     /* test for range errors (not always needed but do it anyway) */
#line 3103
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3103
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3103
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3103
    }
#line 3103
   /* copy workspace back if necessary */
#line 3103
    if (realign) {
#line 3103
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3103
      xp = (float *) *xpp;
#line 3103
    }
#line 3103
   /* update xpp and tp */
#line 3103
    xp += ni;
#line 3103
    tp += ni;
#line 3103
    *xpp = (void*)xp;
#line 3103
  }
#line 3103
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3103

#line 3103
#else   /* not SX */
#line 3103

#line 3103
	char *xp = (char *) *xpp;
#line 3103
	int status = ENOERR;
#line 3103

#line 3103
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3103
	{
#line 3103
		int lstatus = ncx_put_float_uchar(xp, tp);
#line 3103
		if(lstatus != ENOERR)
#line 3103
			status = lstatus;
#line 3103
	}
#line 3103

#line 3103
	*xpp = (void *)xp;
#line 3103
	return status;
#line 3103
#endif
#line 3103
}
#line 3103

int
#line 3104
ncx_putn_float_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3104
{
#line 3104
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3104

#line 3104
 /* basic algorithm is:
#line 3104
  *   - ensure sane alignment of output data
#line 3104
  *   - copy (conversion happens automatically) input data
#line 3104
  *     to output
#line 3104
  *   - update tp to point at next unconverted input, and xpp to point
#line 3104
  *     at next location for converted output
#line 3104
  */
#line 3104
  long i, j, ni;
#line 3104
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3104
  float *xp;
#line 3104
  int nrange = 0;         /* number of range errors */
#line 3104
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3104
  long cxp = (long) *((char**)xpp);
#line 3104

#line 3104
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3104
  /* sjl: manually stripmine so we can limit amount of
#line 3104
   * vector work space reserved to LOOPCNT elements. Also
#line 3104
   * makes vectorisation easy */
#line 3104
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3104
    ni=Min(nelems-j,LOOPCNT);
#line 3104
    if (realign) {
#line 3104
      xp = tmp;
#line 3104
    } else {
#line 3104
      xp = (float *) *xpp;
#line 3104
    }
#line 3104
   /* copy the next block */
#line 3104
#pragma cdir loopcnt=LOOPCNT
#line 3104
#pragma cdir shortloop
#line 3104
    for (i=0; i<ni; i++) {
#line 3104
      /* the normal case: */
#line 3104
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3104
     /* test for range errors (not always needed but do it anyway) */
#line 3104
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3104
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3104
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3104
    }
#line 3104
   /* copy workspace back if necessary */
#line 3104
    if (realign) {
#line 3104
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3104
      xp = (float *) *xpp;
#line 3104
    }
#line 3104
   /* update xpp and tp */
#line 3104
    xp += ni;
#line 3104
    tp += ni;
#line 3104
    *xpp = (void*)xp;
#line 3104
  }
#line 3104
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3104

#line 3104
#else   /* not SX */
#line 3104

#line 3104
	char *xp = (char *) *xpp;
#line 3104
	int status = ENOERR;
#line 3104

#line 3104
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3104
	{
#line 3104
		int lstatus = ncx_put_float_ushort(xp, tp);
#line 3104
		if(lstatus != ENOERR)
#line 3104
			status = lstatus;
#line 3104
	}
#line 3104

#line 3104
	*xpp = (void *)xp;
#line 3104
	return status;
#line 3104
#endif
#line 3104
}
#line 3104

int
#line 3105
ncx_putn_float_uint(void **xpp, size_t nelems, const uint *tp)
#line 3105
{
#line 3105
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3105

#line 3105
 /* basic algorithm is:
#line 3105
  *   - ensure sane alignment of output data
#line 3105
  *   - copy (conversion happens automatically) input data
#line 3105
  *     to output
#line 3105
  *   - update tp to point at next unconverted input, and xpp to point
#line 3105
  *     at next location for converted output
#line 3105
  */
#line 3105
  long i, j, ni;
#line 3105
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3105
  float *xp;
#line 3105
  int nrange = 0;         /* number of range errors */
#line 3105
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3105
  long cxp = (long) *((char**)xpp);
#line 3105

#line 3105
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3105
  /* sjl: manually stripmine so we can limit amount of
#line 3105
   * vector work space reserved to LOOPCNT elements. Also
#line 3105
   * makes vectorisation easy */
#line 3105
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3105
    ni=Min(nelems-j,LOOPCNT);
#line 3105
    if (realign) {
#line 3105
      xp = tmp;
#line 3105
    } else {
#line 3105
      xp = (float *) *xpp;
#line 3105
    }
#line 3105
   /* copy the next block */
#line 3105
#pragma cdir loopcnt=LOOPCNT
#line 3105
#pragma cdir shortloop
#line 3105
    for (i=0; i<ni; i++) {
#line 3105
      /* the normal case: */
#line 3105
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3105
     /* test for range errors (not always needed but do it anyway) */
#line 3105
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3105
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3105
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3105
    }
#line 3105
   /* copy workspace back if necessary */
#line 3105
    if (realign) {
#line 3105
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3105
      xp = (float *) *xpp;
#line 3105
    }
#line 3105
   /* update xpp and tp */
#line 3105
    xp += ni;
#line 3105
    tp += ni;
#line 3105
    *xpp = (void*)xp;
#line 3105
  }
#line 3105
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3105

#line 3105
#else   /* not SX */
#line 3105

#line 3105
	char *xp = (char *) *xpp;
#line 3105
	int status = ENOERR;
#line 3105

#line 3105
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3105
	{
#line 3105
		int lstatus = ncx_put_float_uint(xp, tp);
#line 3105
		if(lstatus != ENOERR)
#line 3105
			status = lstatus;
#line 3105
	}
#line 3105

#line 3105
	*xpp = (void *)xp;
#line 3105
	return status;
#line 3105
#endif
#line 3105
}
#line 3105

int
#line 3106
ncx_putn_float_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3106
{
#line 3106
#if _SX && X_SIZEOF_FLOAT == SIZEOF_FLOAT
#line 3106

#line 3106
 /* basic algorithm is:
#line 3106
  *   - ensure sane alignment of output data
#line 3106
  *   - copy (conversion happens automatically) input data
#line 3106
  *     to output
#line 3106
  *   - update tp to point at next unconverted input, and xpp to point
#line 3106
  *     at next location for converted output
#line 3106
  */
#line 3106
  long i, j, ni;
#line 3106
  float tmp[LOOPCNT];        /* in case input is misaligned */
#line 3106
  float *xp;
#line 3106
  int nrange = 0;         /* number of range errors */
#line 3106
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3106
  long cxp = (long) *((char**)xpp);
#line 3106

#line 3106
  realign = (cxp & 7) % SIZEOF_FLOAT;
#line 3106
  /* sjl: manually stripmine so we can limit amount of
#line 3106
   * vector work space reserved to LOOPCNT elements. Also
#line 3106
   * makes vectorisation easy */
#line 3106
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3106
    ni=Min(nelems-j,LOOPCNT);
#line 3106
    if (realign) {
#line 3106
      xp = tmp;
#line 3106
    } else {
#line 3106
      xp = (float *) *xpp;
#line 3106
    }
#line 3106
   /* copy the next block */
#line 3106
#pragma cdir loopcnt=LOOPCNT
#line 3106
#pragma cdir shortloop
#line 3106
    for (i=0; i<ni; i++) {
#line 3106
      /* the normal case: */
#line 3106
      xp[i] = (float) Max( X_FLOAT_MIN, Min(X_FLOAT_MAX, (float) tp[i]));
#line 3106
     /* test for range errors (not always needed but do it anyway) */
#line 3106
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3106
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3106
      nrange += tp[i] > X_FLOAT_MAX ;
#line 3106
    }
#line 3106
   /* copy workspace back if necessary */
#line 3106
    if (realign) {
#line 3106
      memcpy(*xpp, tmp, ni*X_SIZEOF_FLOAT);
#line 3106
      xp = (float *) *xpp;
#line 3106
    }
#line 3106
   /* update xpp and tp */
#line 3106
    xp += ni;
#line 3106
    tp += ni;
#line 3106
    *xpp = (void*)xp;
#line 3106
  }
#line 3106
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3106

#line 3106
#else   /* not SX */
#line 3106

#line 3106
	char *xp = (char *) *xpp;
#line 3106
	int status = ENOERR;
#line 3106

#line 3106
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_FLOAT, tp++)
#line 3106
	{
#line 3106
		int lstatus = ncx_put_float_ulonglong(xp, tp);
#line 3106
		if(lstatus != ENOERR)
#line 3106
			status = lstatus;
#line 3106
	}
#line 3106

#line 3106
	*xpp = (void *)xp;
#line 3106
	return status;
#line 3106
#endif
#line 3106
}
#line 3106


/* double --------------------------------------------------------------------*/

#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(double));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return ENOERR;
}
#elif vax
int
ncx_getn_double_double(const void **xpp, size_t ndoubles, double *ip)
{
	double *const end = ip + ndoubles;

	while(ip < end)
	{
	struct vax_double *const vdp =
#line 3131
			 (struct vax_double *)ip;
#line 3131
	const struct ieee_double *const idp =
#line 3131
			 (const struct ieee_double *) (*xpp);
#line 3131
	{
#line 3131
		const struct dbl_limits *lim;
#line 3131
		int ii;
#line 3131
		for (ii = 0, lim = dbl_limits;
#line 3131
			ii < sizeof(dbl_limits)/sizeof(struct dbl_limits);
#line 3131
			ii++, lim++)
#line 3131
		{
#line 3131
			if ((idp->mant_lo == lim->ieee.mant_lo)
#line 3131
				&& (idp->mant_4 == lim->ieee.mant_4)
#line 3131
				&& (idp->mant_5 == lim->ieee.mant_5)
#line 3131
				&& (idp->mant_6 == lim->ieee.mant_6)
#line 3131
				&& (idp->exp_lo == lim->ieee.exp_lo)
#line 3131
				&& (idp->exp_hi == lim->ieee.exp_hi)
#line 3131
				)
#line 3131
			{
#line 3131
				*vdp = lim->d;
#line 3131
				goto doneit;
#line 3131
			}
#line 3131
		}
#line 3131
	}
#line 3131
	{
#line 3131
		unsigned exp = idp->exp_hi << 4 | idp->exp_lo;
#line 3131
		vdp->exp = exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
#line 3131
	}
#line 3131
	{
#line 3131
		unsigned mant_hi = ((idp->mant_6 << 16)
#line 3131
				 | (idp->mant_5 << 8)
#line 3131
				 | idp->mant_4);
#line 3131
		unsigned mant_lo = SWAP4(idp->mant_lo);
#line 3131
		vdp->mantissa1 = (mant_hi >> 13);
#line 3131
		vdp->mantissa2 = ((mant_hi & MASK(13)) << 3)
#line 3131
				| (mant_lo >> 29);
#line 3131
		vdp->mantissa3 = (mant_lo >> 13);
#line 3131
		vdp->mantissa4 = (mant_lo << 3);
#line 3131
	}
#line 3131
	doneit:
#line 3131
		vdp->sign = idp->sign;
#line 3131

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return ENOERR;
}
	/* vax */
#else
int
ncx_getn_double_double(const void **xpp, size_t nelems, double *tp)
{
	const char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		const int lstatus = ncx_get_double_double(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (const void *)xp;
	return status;
}
#endif
int
#line 3156
ncx_getn_double_schar(const void **xpp, size_t nelems, schar *tp)
#line 3156
{
#line 3156
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3156

#line 3156
 /* basic algorithm is:
#line 3156
  *   - ensure sane alignment of input data
#line 3156
  *   - copy (conversion happens automatically) input data
#line 3156
  *     to output
#line 3156
  *   - update xpp to point at next unconverted input, and tp to point
#line 3156
  *     at next location for converted output
#line 3156
  */
#line 3156
  long i, j, ni;
#line 3156
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3156
  double *xp;
#line 3156
  int nrange = 0;         /* number of range errors */
#line 3156
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3156
  long cxp = (long) *((char**)xpp);
#line 3156

#line 3156
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3156
  /* sjl: manually stripmine so we can limit amount of
#line 3156
   * vector work space reserved to LOOPCNT elements. Also
#line 3156
   * makes vectorisation easy */
#line 3156
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3156
    ni=Min(nelems-j,LOOPCNT);
#line 3156
    if (realign) {
#line 3156
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3156
      xp = tmp;
#line 3156
    } else {
#line 3156
      xp = (double *) *xpp;
#line 3156
    }
#line 3156
   /* copy the next block */
#line 3156
#pragma cdir loopcnt=LOOPCNT
#line 3156
#pragma cdir shortloop
#line 3156
    for (i=0; i<ni; i++) {
#line 3156
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3156
     /* test for range errors (not always needed but do it anyway) */
#line 3156
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3156
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3156
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3156
    }
#line 3156
   /* update xpp and tp */
#line 3156
    if (realign) xp = (double *) *xpp;
#line 3156
    xp += ni;
#line 3156
    tp += ni;
#line 3156
    *xpp = (void*)xp;
#line 3156
  }
#line 3156
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3156

#line 3156
#else   /* not SX */
#line 3156
	const char *xp = (const char *) *xpp;
#line 3156
	int status = ENOERR;
#line 3156

#line 3156
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3156
	{
#line 3156
		const int lstatus = ncx_get_double_schar(xp, tp);
#line 3156
		if(lstatus != ENOERR)
#line 3156
			status = lstatus;
#line 3156
	}
#line 3156

#line 3156
	*xpp = (const void *)xp;
#line 3156
	return status;
#line 3156
#  endif
#line 3156
}
#line 3156

int
#line 3157
ncx_getn_double_short(const void **xpp, size_t nelems, short *tp)
#line 3157
{
#line 3157
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3157

#line 3157
 /* basic algorithm is:
#line 3157
  *   - ensure sane alignment of input data
#line 3157
  *   - copy (conversion happens automatically) input data
#line 3157
  *     to output
#line 3157
  *   - update xpp to point at next unconverted input, and tp to point
#line 3157
  *     at next location for converted output
#line 3157
  */
#line 3157
  long i, j, ni;
#line 3157
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3157
  double *xp;
#line 3157
  int nrange = 0;         /* number of range errors */
#line 3157
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3157
  long cxp = (long) *((char**)xpp);
#line 3157

#line 3157
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3157
  /* sjl: manually stripmine so we can limit amount of
#line 3157
   * vector work space reserved to LOOPCNT elements. Also
#line 3157
   * makes vectorisation easy */
#line 3157
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3157
    ni=Min(nelems-j,LOOPCNT);
#line 3157
    if (realign) {
#line 3157
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3157
      xp = tmp;
#line 3157
    } else {
#line 3157
      xp = (double *) *xpp;
#line 3157
    }
#line 3157
   /* copy the next block */
#line 3157
#pragma cdir loopcnt=LOOPCNT
#line 3157
#pragma cdir shortloop
#line 3157
    for (i=0; i<ni; i++) {
#line 3157
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3157
     /* test for range errors (not always needed but do it anyway) */
#line 3157
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3157
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3157
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3157
    }
#line 3157
   /* update xpp and tp */
#line 3157
    if (realign) xp = (double *) *xpp;
#line 3157
    xp += ni;
#line 3157
    tp += ni;
#line 3157
    *xpp = (void*)xp;
#line 3157
  }
#line 3157
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3157

#line 3157
#else   /* not SX */
#line 3157
	const char *xp = (const char *) *xpp;
#line 3157
	int status = ENOERR;
#line 3157

#line 3157
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3157
	{
#line 3157
		const int lstatus = ncx_get_double_short(xp, tp);
#line 3157
		if(lstatus != ENOERR)
#line 3157
			status = lstatus;
#line 3157
	}
#line 3157

#line 3157
	*xpp = (const void *)xp;
#line 3157
	return status;
#line 3157
#  endif
#line 3157
}
#line 3157

int
#line 3158
ncx_getn_double_int(const void **xpp, size_t nelems, int *tp)
#line 3158
{
#line 3158
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3158

#line 3158
 /* basic algorithm is:
#line 3158
  *   - ensure sane alignment of input data
#line 3158
  *   - copy (conversion happens automatically) input data
#line 3158
  *     to output
#line 3158
  *   - update xpp to point at next unconverted input, and tp to point
#line 3158
  *     at next location for converted output
#line 3158
  */
#line 3158
  long i, j, ni;
#line 3158
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3158
  double *xp;
#line 3158
  int nrange = 0;         /* number of range errors */
#line 3158
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3158
  long cxp = (long) *((char**)xpp);
#line 3158

#line 3158
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3158
  /* sjl: manually stripmine so we can limit amount of
#line 3158
   * vector work space reserved to LOOPCNT elements. Also
#line 3158
   * makes vectorisation easy */
#line 3158
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3158
    ni=Min(nelems-j,LOOPCNT);
#line 3158
    if (realign) {
#line 3158
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3158
      xp = tmp;
#line 3158
    } else {
#line 3158
      xp = (double *) *xpp;
#line 3158
    }
#line 3158
   /* copy the next block */
#line 3158
#pragma cdir loopcnt=LOOPCNT
#line 3158
#pragma cdir shortloop
#line 3158
    for (i=0; i<ni; i++) {
#line 3158
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3158
     /* test for range errors (not always needed but do it anyway) */
#line 3158
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3158
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3158
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3158
    }
#line 3158
   /* update xpp and tp */
#line 3158
    if (realign) xp = (double *) *xpp;
#line 3158
    xp += ni;
#line 3158
    tp += ni;
#line 3158
    *xpp = (void*)xp;
#line 3158
  }
#line 3158
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3158

#line 3158
#else   /* not SX */
#line 3158
	const char *xp = (const char *) *xpp;
#line 3158
	int status = ENOERR;
#line 3158

#line 3158
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3158
	{
#line 3158
		const int lstatus = ncx_get_double_int(xp, tp);
#line 3158
		if(lstatus != ENOERR)
#line 3158
			status = lstatus;
#line 3158
	}
#line 3158

#line 3158
	*xpp = (const void *)xp;
#line 3158
	return status;
#line 3158
#  endif
#line 3158
}
#line 3158

int
#line 3159
ncx_getn_double_float(const void **xpp, size_t nelems, float *tp)
#line 3159
{
#line 3159
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3159

#line 3159
 /* basic algorithm is:
#line 3159
  *   - ensure sane alignment of input data
#line 3159
  *   - copy (conversion happens automatically) input data
#line 3159
  *     to output
#line 3159
  *   - update xpp to point at next unconverted input, and tp to point
#line 3159
  *     at next location for converted output
#line 3159
  */
#line 3159
  long i, j, ni;
#line 3159
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3159
  double *xp;
#line 3159
  int nrange = 0;         /* number of range errors */
#line 3159
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3159
  long cxp = (long) *((char**)xpp);
#line 3159

#line 3159
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3159
  /* sjl: manually stripmine so we can limit amount of
#line 3159
   * vector work space reserved to LOOPCNT elements. Also
#line 3159
   * makes vectorisation easy */
#line 3159
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3159
    ni=Min(nelems-j,LOOPCNT);
#line 3159
    if (realign) {
#line 3159
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3159
      xp = tmp;
#line 3159
    } else {
#line 3159
      xp = (double *) *xpp;
#line 3159
    }
#line 3159
   /* copy the next block */
#line 3159
#pragma cdir loopcnt=LOOPCNT
#line 3159
#pragma cdir shortloop
#line 3159
    for (i=0; i<ni; i++) {
#line 3159
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3159
     /* test for range errors (not always needed but do it anyway) */
#line 3159
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3159
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3159
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3159
    }
#line 3159
   /* update xpp and tp */
#line 3159
    if (realign) xp = (double *) *xpp;
#line 3159
    xp += ni;
#line 3159
    tp += ni;
#line 3159
    *xpp = (void*)xp;
#line 3159
  }
#line 3159
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3159

#line 3159
#else   /* not SX */
#line 3159
	const char *xp = (const char *) *xpp;
#line 3159
	int status = ENOERR;
#line 3159

#line 3159
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3159
	{
#line 3159
		const int lstatus = ncx_get_double_float(xp, tp);
#line 3159
		if(lstatus != ENOERR)
#line 3159
			status = lstatus;
#line 3159
	}
#line 3159

#line 3159
	*xpp = (const void *)xp;
#line 3159
	return status;
#line 3159
#  endif
#line 3159
}
#line 3159

int
#line 3160
ncx_getn_double_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3160
{
#line 3160
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3160

#line 3160
 /* basic algorithm is:
#line 3160
  *   - ensure sane alignment of input data
#line 3160
  *   - copy (conversion happens automatically) input data
#line 3160
  *     to output
#line 3160
  *   - update xpp to point at next unconverted input, and tp to point
#line 3160
  *     at next location for converted output
#line 3160
  */
#line 3160
  long i, j, ni;
#line 3160
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3160
  double *xp;
#line 3160
  int nrange = 0;         /* number of range errors */
#line 3160
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3160
  long cxp = (long) *((char**)xpp);
#line 3160

#line 3160
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3160
  /* sjl: manually stripmine so we can limit amount of
#line 3160
   * vector work space reserved to LOOPCNT elements. Also
#line 3160
   * makes vectorisation easy */
#line 3160
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3160
    ni=Min(nelems-j,LOOPCNT);
#line 3160
    if (realign) {
#line 3160
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3160
      xp = tmp;
#line 3160
    } else {
#line 3160
      xp = (double *) *xpp;
#line 3160
    }
#line 3160
   /* copy the next block */
#line 3160
#pragma cdir loopcnt=LOOPCNT
#line 3160
#pragma cdir shortloop
#line 3160
    for (i=0; i<ni; i++) {
#line 3160
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3160
     /* test for range errors (not always needed but do it anyway) */
#line 3160
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3160
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3160
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3160
    }
#line 3160
   /* update xpp and tp */
#line 3160
    if (realign) xp = (double *) *xpp;
#line 3160
    xp += ni;
#line 3160
    tp += ni;
#line 3160
    *xpp = (void*)xp;
#line 3160
  }
#line 3160
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3160

#line 3160
#else   /* not SX */
#line 3160
	const char *xp = (const char *) *xpp;
#line 3160
	int status = ENOERR;
#line 3160

#line 3160
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3160
	{
#line 3160
		const int lstatus = ncx_get_double_longlong(xp, tp);
#line 3160
		if(lstatus != ENOERR)
#line 3160
			status = lstatus;
#line 3160
	}
#line 3160

#line 3160
	*xpp = (const void *)xp;
#line 3160
	return status;
#line 3160
#  endif
#line 3160
}
#line 3160

int
#line 3161
ncx_getn_double_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3161
{
#line 3161
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3161

#line 3161
 /* basic algorithm is:
#line 3161
  *   - ensure sane alignment of input data
#line 3161
  *   - copy (conversion happens automatically) input data
#line 3161
  *     to output
#line 3161
  *   - update xpp to point at next unconverted input, and tp to point
#line 3161
  *     at next location for converted output
#line 3161
  */
#line 3161
  long i, j, ni;
#line 3161
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3161
  double *xp;
#line 3161
  int nrange = 0;         /* number of range errors */
#line 3161
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3161
  long cxp = (long) *((char**)xpp);
#line 3161

#line 3161
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3161
  /* sjl: manually stripmine so we can limit amount of
#line 3161
   * vector work space reserved to LOOPCNT elements. Also
#line 3161
   * makes vectorisation easy */
#line 3161
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3161
    ni=Min(nelems-j,LOOPCNT);
#line 3161
    if (realign) {
#line 3161
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3161
      xp = tmp;
#line 3161
    } else {
#line 3161
      xp = (double *) *xpp;
#line 3161
    }
#line 3161
   /* copy the next block */
#line 3161
#pragma cdir loopcnt=LOOPCNT
#line 3161
#pragma cdir shortloop
#line 3161
    for (i=0; i<ni; i++) {
#line 3161
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3161
     /* test for range errors (not always needed but do it anyway) */
#line 3161
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3161
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3161
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3161
    }
#line 3161
   /* update xpp and tp */
#line 3161
    if (realign) xp = (double *) *xpp;
#line 3161
    xp += ni;
#line 3161
    tp += ni;
#line 3161
    *xpp = (void*)xp;
#line 3161
  }
#line 3161
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3161

#line 3161
#else   /* not SX */
#line 3161
	const char *xp = (const char *) *xpp;
#line 3161
	int status = ENOERR;
#line 3161

#line 3161
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3161
	{
#line 3161
		const int lstatus = ncx_get_double_uchar(xp, tp);
#line 3161
		if(lstatus != ENOERR)
#line 3161
			status = lstatus;
#line 3161
	}
#line 3161

#line 3161
	*xpp = (const void *)xp;
#line 3161
	return status;
#line 3161
#  endif
#line 3161
}
#line 3161

int
#line 3162
ncx_getn_double_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3162
{
#line 3162
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3162

#line 3162
 /* basic algorithm is:
#line 3162
  *   - ensure sane alignment of input data
#line 3162
  *   - copy (conversion happens automatically) input data
#line 3162
  *     to output
#line 3162
  *   - update xpp to point at next unconverted input, and tp to point
#line 3162
  *     at next location for converted output
#line 3162
  */
#line 3162
  long i, j, ni;
#line 3162
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3162
  double *xp;
#line 3162
  int nrange = 0;         /* number of range errors */
#line 3162
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3162
  long cxp = (long) *((char**)xpp);
#line 3162

#line 3162
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3162
  /* sjl: manually stripmine so we can limit amount of
#line 3162
   * vector work space reserved to LOOPCNT elements. Also
#line 3162
   * makes vectorisation easy */
#line 3162
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3162
    ni=Min(nelems-j,LOOPCNT);
#line 3162
    if (realign) {
#line 3162
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3162
      xp = tmp;
#line 3162
    } else {
#line 3162
      xp = (double *) *xpp;
#line 3162
    }
#line 3162
   /* copy the next block */
#line 3162
#pragma cdir loopcnt=LOOPCNT
#line 3162
#pragma cdir shortloop
#line 3162
    for (i=0; i<ni; i++) {
#line 3162
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3162
     /* test for range errors (not always needed but do it anyway) */
#line 3162
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3162
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3162
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3162
    }
#line 3162
   /* update xpp and tp */
#line 3162
    if (realign) xp = (double *) *xpp;
#line 3162
    xp += ni;
#line 3162
    tp += ni;
#line 3162
    *xpp = (void*)xp;
#line 3162
  }
#line 3162
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3162

#line 3162
#else   /* not SX */
#line 3162
	const char *xp = (const char *) *xpp;
#line 3162
	int status = ENOERR;
#line 3162

#line 3162
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3162
	{
#line 3162
		const int lstatus = ncx_get_double_ushort(xp, tp);
#line 3162
		if(lstatus != ENOERR)
#line 3162
			status = lstatus;
#line 3162
	}
#line 3162

#line 3162
	*xpp = (const void *)xp;
#line 3162
	return status;
#line 3162
#  endif
#line 3162
}
#line 3162

int
#line 3163
ncx_getn_double_uint(const void **xpp, size_t nelems, uint *tp)
#line 3163
{
#line 3163
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3163

#line 3163
 /* basic algorithm is:
#line 3163
  *   - ensure sane alignment of input data
#line 3163
  *   - copy (conversion happens automatically) input data
#line 3163
  *     to output
#line 3163
  *   - update xpp to point at next unconverted input, and tp to point
#line 3163
  *     at next location for converted output
#line 3163
  */
#line 3163
  long i, j, ni;
#line 3163
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3163
  double *xp;
#line 3163
  int nrange = 0;         /* number of range errors */
#line 3163
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3163
  long cxp = (long) *((char**)xpp);
#line 3163

#line 3163
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3163
  /* sjl: manually stripmine so we can limit amount of
#line 3163
   * vector work space reserved to LOOPCNT elements. Also
#line 3163
   * makes vectorisation easy */
#line 3163
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3163
    ni=Min(nelems-j,LOOPCNT);
#line 3163
    if (realign) {
#line 3163
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3163
      xp = tmp;
#line 3163
    } else {
#line 3163
      xp = (double *) *xpp;
#line 3163
    }
#line 3163
   /* copy the next block */
#line 3163
#pragma cdir loopcnt=LOOPCNT
#line 3163
#pragma cdir shortloop
#line 3163
    for (i=0; i<ni; i++) {
#line 3163
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3163
     /* test for range errors (not always needed but do it anyway) */
#line 3163
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3163
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3163
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3163
    }
#line 3163
   /* update xpp and tp */
#line 3163
    if (realign) xp = (double *) *xpp;
#line 3163
    xp += ni;
#line 3163
    tp += ni;
#line 3163
    *xpp = (void*)xp;
#line 3163
  }
#line 3163
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3163

#line 3163
#else   /* not SX */
#line 3163
	const char *xp = (const char *) *xpp;
#line 3163
	int status = ENOERR;
#line 3163

#line 3163
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3163
	{
#line 3163
		const int lstatus = ncx_get_double_uint(xp, tp);
#line 3163
		if(lstatus != ENOERR)
#line 3163
			status = lstatus;
#line 3163
	}
#line 3163

#line 3163
	*xpp = (const void *)xp;
#line 3163
	return status;
#line 3163
#  endif
#line 3163
}
#line 3163

int
#line 3164
ncx_getn_double_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3164
{
#line 3164
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3164

#line 3164
 /* basic algorithm is:
#line 3164
  *   - ensure sane alignment of input data
#line 3164
  *   - copy (conversion happens automatically) input data
#line 3164
  *     to output
#line 3164
  *   - update xpp to point at next unconverted input, and tp to point
#line 3164
  *     at next location for converted output
#line 3164
  */
#line 3164
  long i, j, ni;
#line 3164
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3164
  double *xp;
#line 3164
  int nrange = 0;         /* number of range errors */
#line 3164
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3164
  long cxp = (long) *((char**)xpp);
#line 3164

#line 3164
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3164
  /* sjl: manually stripmine so we can limit amount of
#line 3164
   * vector work space reserved to LOOPCNT elements. Also
#line 3164
   * makes vectorisation easy */
#line 3164
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3164
    ni=Min(nelems-j,LOOPCNT);
#line 3164
    if (realign) {
#line 3164
      memcpy(tmp, *xpp, ni*SIZEOF_DOUBLE);
#line 3164
      xp = tmp;
#line 3164
    } else {
#line 3164
      xp = (double *) *xpp;
#line 3164
    }
#line 3164
   /* copy the next block */
#line 3164
#pragma cdir loopcnt=LOOPCNT
#line 3164
#pragma cdir shortloop
#line 3164
    for (i=0; i<ni; i++) {
#line 3164
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3164
     /* test for range errors (not always needed but do it anyway) */
#line 3164
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3164
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3164
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3164
    }
#line 3164
   /* update xpp and tp */
#line 3164
    if (realign) xp = (double *) *xpp;
#line 3164
    xp += ni;
#line 3164
    tp += ni;
#line 3164
    *xpp = (void*)xp;
#line 3164
  }
#line 3164
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3164

#line 3164
#else   /* not SX */
#line 3164
	const char *xp = (const char *) *xpp;
#line 3164
	int status = ENOERR;
#line 3164

#line 3164
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3164
	{
#line 3164
		const int lstatus = ncx_get_double_ulonglong(xp, tp);
#line 3164
		if(lstatus != ENOERR)
#line 3164
			status = lstatus;
#line 3164
	}
#line 3164

#line 3164
	*xpp = (const void *)xp;
#line 3164
	return status;
#line 3164
#  endif
#line 3164
}
#line 3164


#if X_SIZEOF_DOUBLE == SIZEOF_DOUBLE && !defined(NO_IEEE_FLOAT)
/* optimized version */
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_DOUBLE);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_DOUBLE);
	return ENOERR;
}
#elif vax
int
ncx_putn_double_double(void **xpp, size_t ndoubles, const double *ip)
{
	const double *const end = ip + ndoubles;

	while(ip < end)
	{
	const struct vax_double *const vdp =
#line 3187
			(const struct vax_double *)ip;
#line 3187
	struct ieee_double *const idp =
#line 3187
			 (struct ieee_double *) (*xpp);
#line 3187

#line 3187
	if ((vdp->mantissa4 > (dbl_limits[0].d.mantissa4 - 3)) &&
#line 3187
		(vdp->mantissa3 == dbl_limits[0].d.mantissa3) &&
#line 3187
		(vdp->mantissa2 == dbl_limits[0].d.mantissa2) &&
#line 3187
		(vdp->mantissa1 == dbl_limits[0].d.mantissa1) &&
#line 3187
		(vdp->exp == dbl_limits[0].d.exp))
#line 3187
	{
#line 3187
		*idp = dbl_limits[0].ieee;
#line 3187
		goto shipit;
#line 3187
	}
#line 3187
	if ((vdp->mantissa4 == dbl_limits[1].d.mantissa4) &&
#line 3187
		(vdp->mantissa3 == dbl_limits[1].d.mantissa3) &&
#line 3187
		(vdp->mantissa2 == dbl_limits[1].d.mantissa2) &&
#line 3187
		(vdp->mantissa1 == dbl_limits[1].d.mantissa1) &&
#line 3187
		(vdp->exp == dbl_limits[1].d.exp))
#line 3187
	{
#line 3187
		*idp = dbl_limits[1].ieee;
#line 3187
		goto shipit;
#line 3187
	}
#line 3187

#line 3187
	{
#line 3187
		unsigned exp = vdp->exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
#line 3187

#line 3187
		unsigned mant_lo = ((vdp->mantissa2 & MASK(3)) << 29) |
#line 3187
			(vdp->mantissa3 << 13) |
#line 3187
			((vdp->mantissa4 >> 3) & MASK(13));
#line 3187

#line 3187
		unsigned mant_hi = (vdp->mantissa1 << 13)
#line 3187
				 | (vdp->mantissa2 >> 3);
#line 3187

#line 3187
		if((vdp->mantissa4 & 7) > 4)
#line 3187
		{
#line 3187
			/* round up */
#line 3187
			mant_lo++;
#line 3187
			if(mant_lo == 0)
#line 3187
			{
#line 3187
				mant_hi++;
#line 3187
				if(mant_hi > 0xffffff)
#line 3187
				{
#line 3187
					mant_hi = 0;
#line 3187
					exp++;
#line 3187
				}
#line 3187
			}
#line 3187
		}
#line 3187

#line 3187
		idp->mant_lo = SWAP4(mant_lo);
#line 3187
		idp->mant_6 = mant_hi >> 16;
#line 3187
		idp->mant_5 = (mant_hi & 0xff00) >> 8;
#line 3187
		idp->mant_4 = mant_hi;
#line 3187
		idp->exp_hi = exp >> 4;
#line 3187
		idp->exp_lo = exp;
#line 3187
	}
#line 3187

#line 3187
	shipit:
#line 3187
		idp->sign = vdp->sign;
#line 3187

		ip++;
		*xpp = (char *)(*xpp) + X_SIZEOF_DOUBLE;
	}
	return ENOERR;
}
	/* vax */
#else
int
ncx_putn_double_double(void **xpp, size_t nelems, const double *tp)
{
	char *xp = *xpp;
	int status = ENOERR;

	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
	{
		int lstatus = ncx_put_double_double(xp, tp);
		if(lstatus != ENOERR)
			status = lstatus;
	}

	*xpp = (void *)xp;
	return status;
}
#endif
int
#line 3212
ncx_putn_double_schar(void **xpp, size_t nelems, const schar *tp)
#line 3212
{
#line 3212
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3212

#line 3212
 /* basic algorithm is:
#line 3212
  *   - ensure sane alignment of output data
#line 3212
  *   - copy (conversion happens automatically) input data
#line 3212
  *     to output
#line 3212
  *   - update tp to point at next unconverted input, and xpp to point
#line 3212
  *     at next location for converted output
#line 3212
  */
#line 3212
  long i, j, ni;
#line 3212
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3212
  double *xp;
#line 3212
  int nrange = 0;         /* number of range errors */
#line 3212
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3212
  long cxp = (long) *((char**)xpp);
#line 3212

#line 3212
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3212
  /* sjl: manually stripmine so we can limit amount of
#line 3212
   * vector work space reserved to LOOPCNT elements. Also
#line 3212
   * makes vectorisation easy */
#line 3212
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3212
    ni=Min(nelems-j,LOOPCNT);
#line 3212
    if (realign) {
#line 3212
      xp = tmp;
#line 3212
    } else {
#line 3212
      xp = (double *) *xpp;
#line 3212
    }
#line 3212
   /* copy the next block */
#line 3212
#pragma cdir loopcnt=LOOPCNT
#line 3212
#pragma cdir shortloop
#line 3212
    for (i=0; i<ni; i++) {
#line 3212
      /* the normal case: */
#line 3212
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3212
     /* test for range errors (not always needed but do it anyway) */
#line 3212
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3212
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3212
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3212
    }
#line 3212
   /* copy workspace back if necessary */
#line 3212
    if (realign) {
#line 3212
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3212
      xp = (double *) *xpp;
#line 3212
    }
#line 3212
   /* update xpp and tp */
#line 3212
    xp += ni;
#line 3212
    tp += ni;
#line 3212
    *xpp = (void*)xp;
#line 3212
  }
#line 3212
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3212

#line 3212
#else   /* not SX */
#line 3212

#line 3212
	char *xp = (char *) *xpp;
#line 3212
	int status = ENOERR;
#line 3212

#line 3212
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3212
	{
#line 3212
		int lstatus = ncx_put_double_schar(xp, tp);
#line 3212
		if(lstatus != ENOERR)
#line 3212
			status = lstatus;
#line 3212
	}
#line 3212

#line 3212
	*xpp = (void *)xp;
#line 3212
	return status;
#line 3212
#endif
#line 3212
}
#line 3212

int
#line 3213
ncx_putn_double_short(void **xpp, size_t nelems, const short *tp)
#line 3213
{
#line 3213
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3213

#line 3213
 /* basic algorithm is:
#line 3213
  *   - ensure sane alignment of output data
#line 3213
  *   - copy (conversion happens automatically) input data
#line 3213
  *     to output
#line 3213
  *   - update tp to point at next unconverted input, and xpp to point
#line 3213
  *     at next location for converted output
#line 3213
  */
#line 3213
  long i, j, ni;
#line 3213
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3213
  double *xp;
#line 3213
  int nrange = 0;         /* number of range errors */
#line 3213
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3213
  long cxp = (long) *((char**)xpp);
#line 3213

#line 3213
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3213
  /* sjl: manually stripmine so we can limit amount of
#line 3213
   * vector work space reserved to LOOPCNT elements. Also
#line 3213
   * makes vectorisation easy */
#line 3213
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3213
    ni=Min(nelems-j,LOOPCNT);
#line 3213
    if (realign) {
#line 3213
      xp = tmp;
#line 3213
    } else {
#line 3213
      xp = (double *) *xpp;
#line 3213
    }
#line 3213
   /* copy the next block */
#line 3213
#pragma cdir loopcnt=LOOPCNT
#line 3213
#pragma cdir shortloop
#line 3213
    for (i=0; i<ni; i++) {
#line 3213
      /* the normal case: */
#line 3213
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3213
     /* test for range errors (not always needed but do it anyway) */
#line 3213
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3213
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3213
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3213
    }
#line 3213
   /* copy workspace back if necessary */
#line 3213
    if (realign) {
#line 3213
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3213
      xp = (double *) *xpp;
#line 3213
    }
#line 3213
   /* update xpp and tp */
#line 3213
    xp += ni;
#line 3213
    tp += ni;
#line 3213
    *xpp = (void*)xp;
#line 3213
  }
#line 3213
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3213

#line 3213
#else   /* not SX */
#line 3213

#line 3213
	char *xp = (char *) *xpp;
#line 3213
	int status = ENOERR;
#line 3213

#line 3213
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3213
	{
#line 3213
		int lstatus = ncx_put_double_short(xp, tp);
#line 3213
		if(lstatus != ENOERR)
#line 3213
			status = lstatus;
#line 3213
	}
#line 3213

#line 3213
	*xpp = (void *)xp;
#line 3213
	return status;
#line 3213
#endif
#line 3213
}
#line 3213

int
#line 3214
ncx_putn_double_int(void **xpp, size_t nelems, const int *tp)
#line 3214
{
#line 3214
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3214

#line 3214
 /* basic algorithm is:
#line 3214
  *   - ensure sane alignment of output data
#line 3214
  *   - copy (conversion happens automatically) input data
#line 3214
  *     to output
#line 3214
  *   - update tp to point at next unconverted input, and xpp to point
#line 3214
  *     at next location for converted output
#line 3214
  */
#line 3214
  long i, j, ni;
#line 3214
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3214
  double *xp;
#line 3214
  int nrange = 0;         /* number of range errors */
#line 3214
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3214
  long cxp = (long) *((char**)xpp);
#line 3214

#line 3214
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3214
  /* sjl: manually stripmine so we can limit amount of
#line 3214
   * vector work space reserved to LOOPCNT elements. Also
#line 3214
   * makes vectorisation easy */
#line 3214
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3214
    ni=Min(nelems-j,LOOPCNT);
#line 3214
    if (realign) {
#line 3214
      xp = tmp;
#line 3214
    } else {
#line 3214
      xp = (double *) *xpp;
#line 3214
    }
#line 3214
   /* copy the next block */
#line 3214
#pragma cdir loopcnt=LOOPCNT
#line 3214
#pragma cdir shortloop
#line 3214
    for (i=0; i<ni; i++) {
#line 3214
      /* the normal case: */
#line 3214
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3214
     /* test for range errors (not always needed but do it anyway) */
#line 3214
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3214
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3214
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3214
    }
#line 3214
   /* copy workspace back if necessary */
#line 3214
    if (realign) {
#line 3214
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3214
      xp = (double *) *xpp;
#line 3214
    }
#line 3214
   /* update xpp and tp */
#line 3214
    xp += ni;
#line 3214
    tp += ni;
#line 3214
    *xpp = (void*)xp;
#line 3214
  }
#line 3214
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3214

#line 3214
#else   /* not SX */
#line 3214

#line 3214
	char *xp = (char *) *xpp;
#line 3214
	int status = ENOERR;
#line 3214

#line 3214
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3214
	{
#line 3214
		int lstatus = ncx_put_double_int(xp, tp);
#line 3214
		if(lstatus != ENOERR)
#line 3214
			status = lstatus;
#line 3214
	}
#line 3214

#line 3214
	*xpp = (void *)xp;
#line 3214
	return status;
#line 3214
#endif
#line 3214
}
#line 3214

int
#line 3215
ncx_putn_double_float(void **xpp, size_t nelems, const float *tp)
#line 3215
{
#line 3215
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3215

#line 3215
 /* basic algorithm is:
#line 3215
  *   - ensure sane alignment of output data
#line 3215
  *   - copy (conversion happens automatically) input data
#line 3215
  *     to output
#line 3215
  *   - update tp to point at next unconverted input, and xpp to point
#line 3215
  *     at next location for converted output
#line 3215
  */
#line 3215
  long i, j, ni;
#line 3215
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3215
  double *xp;
#line 3215
  int nrange = 0;         /* number of range errors */
#line 3215
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3215
  long cxp = (long) *((char**)xpp);
#line 3215

#line 3215
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3215
  /* sjl: manually stripmine so we can limit amount of
#line 3215
   * vector work space reserved to LOOPCNT elements. Also
#line 3215
   * makes vectorisation easy */
#line 3215
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3215
    ni=Min(nelems-j,LOOPCNT);
#line 3215
    if (realign) {
#line 3215
      xp = tmp;
#line 3215
    } else {
#line 3215
      xp = (double *) *xpp;
#line 3215
    }
#line 3215
   /* copy the next block */
#line 3215
#pragma cdir loopcnt=LOOPCNT
#line 3215
#pragma cdir shortloop
#line 3215
    for (i=0; i<ni; i++) {
#line 3215
      /* the normal case: */
#line 3215
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3215
     /* test for range errors (not always needed but do it anyway) */
#line 3215
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3215
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3215
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3215
    }
#line 3215
   /* copy workspace back if necessary */
#line 3215
    if (realign) {
#line 3215
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3215
      xp = (double *) *xpp;
#line 3215
    }
#line 3215
   /* update xpp and tp */
#line 3215
    xp += ni;
#line 3215
    tp += ni;
#line 3215
    *xpp = (void*)xp;
#line 3215
  }
#line 3215
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3215

#line 3215
#else   /* not SX */
#line 3215

#line 3215
	char *xp = (char *) *xpp;
#line 3215
	int status = ENOERR;
#line 3215

#line 3215
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3215
	{
#line 3215
		int lstatus = ncx_put_double_float(xp, tp);
#line 3215
		if(lstatus != ENOERR)
#line 3215
			status = lstatus;
#line 3215
	}
#line 3215

#line 3215
	*xpp = (void *)xp;
#line 3215
	return status;
#line 3215
#endif
#line 3215
}
#line 3215

int
#line 3216
ncx_putn_double_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3216
{
#line 3216
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3216

#line 3216
 /* basic algorithm is:
#line 3216
  *   - ensure sane alignment of output data
#line 3216
  *   - copy (conversion happens automatically) input data
#line 3216
  *     to output
#line 3216
  *   - update tp to point at next unconverted input, and xpp to point
#line 3216
  *     at next location for converted output
#line 3216
  */
#line 3216
  long i, j, ni;
#line 3216
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3216
  double *xp;
#line 3216
  int nrange = 0;         /* number of range errors */
#line 3216
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3216
  long cxp = (long) *((char**)xpp);
#line 3216

#line 3216
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3216
  /* sjl: manually stripmine so we can limit amount of
#line 3216
   * vector work space reserved to LOOPCNT elements. Also
#line 3216
   * makes vectorisation easy */
#line 3216
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3216
    ni=Min(nelems-j,LOOPCNT);
#line 3216
    if (realign) {
#line 3216
      xp = tmp;
#line 3216
    } else {
#line 3216
      xp = (double *) *xpp;
#line 3216
    }
#line 3216
   /* copy the next block */
#line 3216
#pragma cdir loopcnt=LOOPCNT
#line 3216
#pragma cdir shortloop
#line 3216
    for (i=0; i<ni; i++) {
#line 3216
      /* the normal case: */
#line 3216
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3216
     /* test for range errors (not always needed but do it anyway) */
#line 3216
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3216
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3216
      nrange += tp[i] > X_DOUBLE_MAX || tp[i] < X_DOUBLE_MIN;
#line 3216
    }
#line 3216
   /* copy workspace back if necessary */
#line 3216
    if (realign) {
#line 3216
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3216
      xp = (double *) *xpp;
#line 3216
    }
#line 3216
   /* update xpp and tp */
#line 3216
    xp += ni;
#line 3216
    tp += ni;
#line 3216
    *xpp = (void*)xp;
#line 3216
  }
#line 3216
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3216

#line 3216
#else   /* not SX */
#line 3216

#line 3216
	char *xp = (char *) *xpp;
#line 3216
	int status = ENOERR;
#line 3216

#line 3216
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3216
	{
#line 3216
		int lstatus = ncx_put_double_longlong(xp, tp);
#line 3216
		if(lstatus != ENOERR)
#line 3216
			status = lstatus;
#line 3216
	}
#line 3216

#line 3216
	*xpp = (void *)xp;
#line 3216
	return status;
#line 3216
#endif
#line 3216
}
#line 3216

int
#line 3217
ncx_putn_double_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3217
{
#line 3217
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3217

#line 3217
 /* basic algorithm is:
#line 3217
  *   - ensure sane alignment of output data
#line 3217
  *   - copy (conversion happens automatically) input data
#line 3217
  *     to output
#line 3217
  *   - update tp to point at next unconverted input, and xpp to point
#line 3217
  *     at next location for converted output
#line 3217
  */
#line 3217
  long i, j, ni;
#line 3217
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3217
  double *xp;
#line 3217
  int nrange = 0;         /* number of range errors */
#line 3217
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3217
  long cxp = (long) *((char**)xpp);
#line 3217

#line 3217
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3217
  /* sjl: manually stripmine so we can limit amount of
#line 3217
   * vector work space reserved to LOOPCNT elements. Also
#line 3217
   * makes vectorisation easy */
#line 3217
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3217
    ni=Min(nelems-j,LOOPCNT);
#line 3217
    if (realign) {
#line 3217
      xp = tmp;
#line 3217
    } else {
#line 3217
      xp = (double *) *xpp;
#line 3217
    }
#line 3217
   /* copy the next block */
#line 3217
#pragma cdir loopcnt=LOOPCNT
#line 3217
#pragma cdir shortloop
#line 3217
    for (i=0; i<ni; i++) {
#line 3217
      /* the normal case: */
#line 3217
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3217
     /* test for range errors (not always needed but do it anyway) */
#line 3217
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3217
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3217
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3217
    }
#line 3217
   /* copy workspace back if necessary */
#line 3217
    if (realign) {
#line 3217
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3217
      xp = (double *) *xpp;
#line 3217
    }
#line 3217
   /* update xpp and tp */
#line 3217
    xp += ni;
#line 3217
    tp += ni;
#line 3217
    *xpp = (void*)xp;
#line 3217
  }
#line 3217
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3217

#line 3217
#else   /* not SX */
#line 3217

#line 3217
	char *xp = (char *) *xpp;
#line 3217
	int status = ENOERR;
#line 3217

#line 3217
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3217
	{
#line 3217
		int lstatus = ncx_put_double_uchar(xp, tp);
#line 3217
		if(lstatus != ENOERR)
#line 3217
			status = lstatus;
#line 3217
	}
#line 3217

#line 3217
	*xpp = (void *)xp;
#line 3217
	return status;
#line 3217
#endif
#line 3217
}
#line 3217

int
#line 3218
ncx_putn_double_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3218
{
#line 3218
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3218

#line 3218
 /* basic algorithm is:
#line 3218
  *   - ensure sane alignment of output data
#line 3218
  *   - copy (conversion happens automatically) input data
#line 3218
  *     to output
#line 3218
  *   - update tp to point at next unconverted input, and xpp to point
#line 3218
  *     at next location for converted output
#line 3218
  */
#line 3218
  long i, j, ni;
#line 3218
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3218
  double *xp;
#line 3218
  int nrange = 0;         /* number of range errors */
#line 3218
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3218
  long cxp = (long) *((char**)xpp);
#line 3218

#line 3218
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3218
  /* sjl: manually stripmine so we can limit amount of
#line 3218
   * vector work space reserved to LOOPCNT elements. Also
#line 3218
   * makes vectorisation easy */
#line 3218
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3218
    ni=Min(nelems-j,LOOPCNT);
#line 3218
    if (realign) {
#line 3218
      xp = tmp;
#line 3218
    } else {
#line 3218
      xp = (double *) *xpp;
#line 3218
    }
#line 3218
   /* copy the next block */
#line 3218
#pragma cdir loopcnt=LOOPCNT
#line 3218
#pragma cdir shortloop
#line 3218
    for (i=0; i<ni; i++) {
#line 3218
      /* the normal case: */
#line 3218
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3218
     /* test for range errors (not always needed but do it anyway) */
#line 3218
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3218
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3218
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3218
    }
#line 3218
   /* copy workspace back if necessary */
#line 3218
    if (realign) {
#line 3218
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3218
      xp = (double *) *xpp;
#line 3218
    }
#line 3218
   /* update xpp and tp */
#line 3218
    xp += ni;
#line 3218
    tp += ni;
#line 3218
    *xpp = (void*)xp;
#line 3218
  }
#line 3218
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3218

#line 3218
#else   /* not SX */
#line 3218

#line 3218
	char *xp = (char *) *xpp;
#line 3218
	int status = ENOERR;
#line 3218

#line 3218
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3218
	{
#line 3218
		int lstatus = ncx_put_double_ushort(xp, tp);
#line 3218
		if(lstatus != ENOERR)
#line 3218
			status = lstatus;
#line 3218
	}
#line 3218

#line 3218
	*xpp = (void *)xp;
#line 3218
	return status;
#line 3218
#endif
#line 3218
}
#line 3218

int
#line 3219
ncx_putn_double_uint(void **xpp, size_t nelems, const uint *tp)
#line 3219
{
#line 3219
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3219

#line 3219
 /* basic algorithm is:
#line 3219
  *   - ensure sane alignment of output data
#line 3219
  *   - copy (conversion happens automatically) input data
#line 3219
  *     to output
#line 3219
  *   - update tp to point at next unconverted input, and xpp to point
#line 3219
  *     at next location for converted output
#line 3219
  */
#line 3219
  long i, j, ni;
#line 3219
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3219
  double *xp;
#line 3219
  int nrange = 0;         /* number of range errors */
#line 3219
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3219
  long cxp = (long) *((char**)xpp);
#line 3219

#line 3219
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3219
  /* sjl: manually stripmine so we can limit amount of
#line 3219
   * vector work space reserved to LOOPCNT elements. Also
#line 3219
   * makes vectorisation easy */
#line 3219
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3219
    ni=Min(nelems-j,LOOPCNT);
#line 3219
    if (realign) {
#line 3219
      xp = tmp;
#line 3219
    } else {
#line 3219
      xp = (double *) *xpp;
#line 3219
    }
#line 3219
   /* copy the next block */
#line 3219
#pragma cdir loopcnt=LOOPCNT
#line 3219
#pragma cdir shortloop
#line 3219
    for (i=0; i<ni; i++) {
#line 3219
      /* the normal case: */
#line 3219
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3219
     /* test for range errors (not always needed but do it anyway) */
#line 3219
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3219
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3219
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3219
    }
#line 3219
   /* copy workspace back if necessary */
#line 3219
    if (realign) {
#line 3219
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3219
      xp = (double *) *xpp;
#line 3219
    }
#line 3219
   /* update xpp and tp */
#line 3219
    xp += ni;
#line 3219
    tp += ni;
#line 3219
    *xpp = (void*)xp;
#line 3219
  }
#line 3219
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3219

#line 3219
#else   /* not SX */
#line 3219

#line 3219
	char *xp = (char *) *xpp;
#line 3219
	int status = ENOERR;
#line 3219

#line 3219
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3219
	{
#line 3219
		int lstatus = ncx_put_double_uint(xp, tp);
#line 3219
		if(lstatus != ENOERR)
#line 3219
			status = lstatus;
#line 3219
	}
#line 3219

#line 3219
	*xpp = (void *)xp;
#line 3219
	return status;
#line 3219
#endif
#line 3219
}
#line 3219

int
#line 3220
ncx_putn_double_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3220
{
#line 3220
#if _SX && X_SIZEOF_DOUBLE == SIZEOF_DOUBLE
#line 3220

#line 3220
 /* basic algorithm is:
#line 3220
  *   - ensure sane alignment of output data
#line 3220
  *   - copy (conversion happens automatically) input data
#line 3220
  *     to output
#line 3220
  *   - update tp to point at next unconverted input, and xpp to point
#line 3220
  *     at next location for converted output
#line 3220
  */
#line 3220
  long i, j, ni;
#line 3220
  double tmp[LOOPCNT];        /* in case input is misaligned */
#line 3220
  double *xp;
#line 3220
  int nrange = 0;         /* number of range errors */
#line 3220
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3220
  long cxp = (long) *((char**)xpp);
#line 3220

#line 3220
  realign = (cxp & 7) % SIZEOF_DOUBLE;
#line 3220
  /* sjl: manually stripmine so we can limit amount of
#line 3220
   * vector work space reserved to LOOPCNT elements. Also
#line 3220
   * makes vectorisation easy */
#line 3220
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3220
    ni=Min(nelems-j,LOOPCNT);
#line 3220
    if (realign) {
#line 3220
      xp = tmp;
#line 3220
    } else {
#line 3220
      xp = (double *) *xpp;
#line 3220
    }
#line 3220
   /* copy the next block */
#line 3220
#pragma cdir loopcnt=LOOPCNT
#line 3220
#pragma cdir shortloop
#line 3220
    for (i=0; i<ni; i++) {
#line 3220
      /* the normal case: */
#line 3220
      xp[i] = (double) Max( X_DOUBLE_MIN, Min(X_DOUBLE_MAX, (double) tp[i]));
#line 3220
     /* test for range errors (not always needed but do it anyway) */
#line 3220
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3220
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3220
      nrange += tp[i] > X_DOUBLE_MAX ;
#line 3220
    }
#line 3220
   /* copy workspace back if necessary */
#line 3220
    if (realign) {
#line 3220
      memcpy(*xpp, tmp, ni*X_SIZEOF_DOUBLE);
#line 3220
      xp = (double *) *xpp;
#line 3220
    }
#line 3220
   /* update xpp and tp */
#line 3220
    xp += ni;
#line 3220
    tp += ni;
#line 3220
    *xpp = (void*)xp;
#line 3220
  }
#line 3220
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3220

#line 3220
#else   /* not SX */
#line 3220

#line 3220
	char *xp = (char *) *xpp;
#line 3220
	int status = ENOERR;
#line 3220

#line 3220
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_DOUBLE, tp++)
#line 3220
	{
#line 3220
		int lstatus = ncx_put_double_ulonglong(xp, tp);
#line 3220
		if(lstatus != ENOERR)
#line 3220
			status = lstatus;
#line 3220
	}
#line 3220

#line 3220
	*xpp = (void *)xp;
#line 3220
	return status;
#line 3220
#endif
#line 3220
}
#line 3220



/* longlong -----------------------------------------------------------------------*/

#if X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
/* optimized version */
int
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(long long));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_LONGLONG);
	return ENOERR;
}
#else
int
#line 3239
ncx_getn_longlong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3239
{
#line 3239
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3239

#line 3239
 /* basic algorithm is:
#line 3239
  *   - ensure sane alignment of input data
#line 3239
  *   - copy (conversion happens automatically) input data
#line 3239
  *     to output
#line 3239
  *   - update xpp to point at next unconverted input, and tp to point
#line 3239
  *     at next location for converted output
#line 3239
  */
#line 3239
  long i, j, ni;
#line 3239
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3239
  longlong *xp;
#line 3239
  int nrange = 0;         /* number of range errors */
#line 3239
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3239
  long cxp = (long) *((char**)xpp);
#line 3239

#line 3239
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3239
  /* sjl: manually stripmine so we can limit amount of
#line 3239
   * vector work space reserved to LOOPCNT elements. Also
#line 3239
   * makes vectorisation easy */
#line 3239
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3239
    ni=Min(nelems-j,LOOPCNT);
#line 3239
    if (realign) {
#line 3239
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3239
      xp = tmp;
#line 3239
    } else {
#line 3239
      xp = (longlong *) *xpp;
#line 3239
    }
#line 3239
   /* copy the next block */
#line 3239
#pragma cdir loopcnt=LOOPCNT
#line 3239
#pragma cdir shortloop
#line 3239
    for (i=0; i<ni; i++) {
#line 3239
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3239
     /* test for range errors (not always needed but do it anyway) */
#line 3239
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3239
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3239
      nrange += xp[i] > LONGLONG_MAX || xp[i] < LONGLONG_MIN;
#line 3239
    }
#line 3239
   /* update xpp and tp */
#line 3239
    if (realign) xp = (longlong *) *xpp;
#line 3239
    xp += ni;
#line 3239
    tp += ni;
#line 3239
    *xpp = (void*)xp;
#line 3239
  }
#line 3239
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3239

#line 3239
#else   /* not SX */
#line 3239
	const char *xp = (const char *) *xpp;
#line 3239
	int status = ENOERR;
#line 3239

#line 3239
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3239
	{
#line 3239
		const int lstatus = ncx_get_longlong_longlong(xp, tp);
#line 3239
		if(lstatus != ENOERR)
#line 3239
			status = lstatus;
#line 3239
	}
#line 3239

#line 3239
	*xpp = (const void *)xp;
#line 3239
	return status;
#line 3239
#  endif
#line 3239
}
#line 3239

#endif
int
#line 3241
ncx_getn_longlong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3241
{
#line 3241
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3241

#line 3241
 /* basic algorithm is:
#line 3241
  *   - ensure sane alignment of input data
#line 3241
  *   - copy (conversion happens automatically) input data
#line 3241
  *     to output
#line 3241
  *   - update xpp to point at next unconverted input, and tp to point
#line 3241
  *     at next location for converted output
#line 3241
  */
#line 3241
  long i, j, ni;
#line 3241
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3241
  longlong *xp;
#line 3241
  int nrange = 0;         /* number of range errors */
#line 3241
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3241
  long cxp = (long) *((char**)xpp);
#line 3241

#line 3241
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3241
  /* sjl: manually stripmine so we can limit amount of
#line 3241
   * vector work space reserved to LOOPCNT elements. Also
#line 3241
   * makes vectorisation easy */
#line 3241
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3241
    ni=Min(nelems-j,LOOPCNT);
#line 3241
    if (realign) {
#line 3241
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3241
      xp = tmp;
#line 3241
    } else {
#line 3241
      xp = (longlong *) *xpp;
#line 3241
    }
#line 3241
   /* copy the next block */
#line 3241
#pragma cdir loopcnt=LOOPCNT
#line 3241
#pragma cdir shortloop
#line 3241
    for (i=0; i<ni; i++) {
#line 3241
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3241
     /* test for range errors (not always needed but do it anyway) */
#line 3241
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3241
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3241
      nrange += xp[i] > SCHAR_MAX || xp[i] < SCHAR_MIN;
#line 3241
    }
#line 3241
   /* update xpp and tp */
#line 3241
    if (realign) xp = (longlong *) *xpp;
#line 3241
    xp += ni;
#line 3241
    tp += ni;
#line 3241
    *xpp = (void*)xp;
#line 3241
  }
#line 3241
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3241

#line 3241
#else   /* not SX */
#line 3241
	const char *xp = (const char *) *xpp;
#line 3241
	int status = ENOERR;
#line 3241

#line 3241
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3241
	{
#line 3241
		const int lstatus = ncx_get_longlong_schar(xp, tp);
#line 3241
		if(lstatus != ENOERR)
#line 3241
			status = lstatus;
#line 3241
	}
#line 3241

#line 3241
	*xpp = (const void *)xp;
#line 3241
	return status;
#line 3241
#  endif
#line 3241
}
#line 3241

int
#line 3242
ncx_getn_longlong_short(const void **xpp, size_t nelems, short *tp)
#line 3242
{
#line 3242
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3242

#line 3242
 /* basic algorithm is:
#line 3242
  *   - ensure sane alignment of input data
#line 3242
  *   - copy (conversion happens automatically) input data
#line 3242
  *     to output
#line 3242
  *   - update xpp to point at next unconverted input, and tp to point
#line 3242
  *     at next location for converted output
#line 3242
  */
#line 3242
  long i, j, ni;
#line 3242
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3242
  longlong *xp;
#line 3242
  int nrange = 0;         /* number of range errors */
#line 3242
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3242
  long cxp = (long) *((char**)xpp);
#line 3242

#line 3242
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3242
  /* sjl: manually stripmine so we can limit amount of
#line 3242
   * vector work space reserved to LOOPCNT elements. Also
#line 3242
   * makes vectorisation easy */
#line 3242
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3242
    ni=Min(nelems-j,LOOPCNT);
#line 3242
    if (realign) {
#line 3242
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3242
      xp = tmp;
#line 3242
    } else {
#line 3242
      xp = (longlong *) *xpp;
#line 3242
    }
#line 3242
   /* copy the next block */
#line 3242
#pragma cdir loopcnt=LOOPCNT
#line 3242
#pragma cdir shortloop
#line 3242
    for (i=0; i<ni; i++) {
#line 3242
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3242
     /* test for range errors (not always needed but do it anyway) */
#line 3242
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3242
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3242
      nrange += xp[i] > SHORT_MAX || xp[i] < SHORT_MIN;
#line 3242
    }
#line 3242
   /* update xpp and tp */
#line 3242
    if (realign) xp = (longlong *) *xpp;
#line 3242
    xp += ni;
#line 3242
    tp += ni;
#line 3242
    *xpp = (void*)xp;
#line 3242
  }
#line 3242
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3242

#line 3242
#else   /* not SX */
#line 3242
	const char *xp = (const char *) *xpp;
#line 3242
	int status = ENOERR;
#line 3242

#line 3242
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3242
	{
#line 3242
		const int lstatus = ncx_get_longlong_short(xp, tp);
#line 3242
		if(lstatus != ENOERR)
#line 3242
			status = lstatus;
#line 3242
	}
#line 3242

#line 3242
	*xpp = (const void *)xp;
#line 3242
	return status;
#line 3242
#  endif
#line 3242
}
#line 3242

int
#line 3243
ncx_getn_longlong_int(const void **xpp, size_t nelems, int *tp)
#line 3243
{
#line 3243
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3243

#line 3243
 /* basic algorithm is:
#line 3243
  *   - ensure sane alignment of input data
#line 3243
  *   - copy (conversion happens automatically) input data
#line 3243
  *     to output
#line 3243
  *   - update xpp to point at next unconverted input, and tp to point
#line 3243
  *     at next location for converted output
#line 3243
  */
#line 3243
  long i, j, ni;
#line 3243
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3243
  longlong *xp;
#line 3243
  int nrange = 0;         /* number of range errors */
#line 3243
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3243
  long cxp = (long) *((char**)xpp);
#line 3243

#line 3243
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3243
  /* sjl: manually stripmine so we can limit amount of
#line 3243
   * vector work space reserved to LOOPCNT elements. Also
#line 3243
   * makes vectorisation easy */
#line 3243
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3243
    ni=Min(nelems-j,LOOPCNT);
#line 3243
    if (realign) {
#line 3243
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3243
      xp = tmp;
#line 3243
    } else {
#line 3243
      xp = (longlong *) *xpp;
#line 3243
    }
#line 3243
   /* copy the next block */
#line 3243
#pragma cdir loopcnt=LOOPCNT
#line 3243
#pragma cdir shortloop
#line 3243
    for (i=0; i<ni; i++) {
#line 3243
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3243
     /* test for range errors (not always needed but do it anyway) */
#line 3243
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3243
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3243
      nrange += xp[i] > INT_MAX || xp[i] < INT_MIN;
#line 3243
    }
#line 3243
   /* update xpp and tp */
#line 3243
    if (realign) xp = (longlong *) *xpp;
#line 3243
    xp += ni;
#line 3243
    tp += ni;
#line 3243
    *xpp = (void*)xp;
#line 3243
  }
#line 3243
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3243

#line 3243
#else   /* not SX */
#line 3243
	const char *xp = (const char *) *xpp;
#line 3243
	int status = ENOERR;
#line 3243

#line 3243
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3243
	{
#line 3243
		const int lstatus = ncx_get_longlong_int(xp, tp);
#line 3243
		if(lstatus != ENOERR)
#line 3243
			status = lstatus;
#line 3243
	}
#line 3243

#line 3243
	*xpp = (const void *)xp;
#line 3243
	return status;
#line 3243
#  endif
#line 3243
}
#line 3243

int
#line 3244
ncx_getn_longlong_float(const void **xpp, size_t nelems, float *tp)
#line 3244
{
#line 3244
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3244

#line 3244
 /* basic algorithm is:
#line 3244
  *   - ensure sane alignment of input data
#line 3244
  *   - copy (conversion happens automatically) input data
#line 3244
  *     to output
#line 3244
  *   - update xpp to point at next unconverted input, and tp to point
#line 3244
  *     at next location for converted output
#line 3244
  */
#line 3244
  long i, j, ni;
#line 3244
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3244
  longlong *xp;
#line 3244
  int nrange = 0;         /* number of range errors */
#line 3244
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3244
  long cxp = (long) *((char**)xpp);
#line 3244

#line 3244
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3244
  /* sjl: manually stripmine so we can limit amount of
#line 3244
   * vector work space reserved to LOOPCNT elements. Also
#line 3244
   * makes vectorisation easy */
#line 3244
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3244
    ni=Min(nelems-j,LOOPCNT);
#line 3244
    if (realign) {
#line 3244
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3244
      xp = tmp;
#line 3244
    } else {
#line 3244
      xp = (longlong *) *xpp;
#line 3244
    }
#line 3244
   /* copy the next block */
#line 3244
#pragma cdir loopcnt=LOOPCNT
#line 3244
#pragma cdir shortloop
#line 3244
    for (i=0; i<ni; i++) {
#line 3244
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3244
     /* test for range errors (not always needed but do it anyway) */
#line 3244
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3244
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3244
      nrange += xp[i] > FLOAT_MAX || xp[i] < FLOAT_MIN;
#line 3244
    }
#line 3244
   /* update xpp and tp */
#line 3244
    if (realign) xp = (longlong *) *xpp;
#line 3244
    xp += ni;
#line 3244
    tp += ni;
#line 3244
    *xpp = (void*)xp;
#line 3244
  }
#line 3244
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3244

#line 3244
#else   /* not SX */
#line 3244
	const char *xp = (const char *) *xpp;
#line 3244
	int status = ENOERR;
#line 3244

#line 3244
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3244
	{
#line 3244
		const int lstatus = ncx_get_longlong_float(xp, tp);
#line 3244
		if(lstatus != ENOERR)
#line 3244
			status = lstatus;
#line 3244
	}
#line 3244

#line 3244
	*xpp = (const void *)xp;
#line 3244
	return status;
#line 3244
#  endif
#line 3244
}
#line 3244

int
#line 3245
ncx_getn_longlong_double(const void **xpp, size_t nelems, double *tp)
#line 3245
{
#line 3245
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3245

#line 3245
 /* basic algorithm is:
#line 3245
  *   - ensure sane alignment of input data
#line 3245
  *   - copy (conversion happens automatically) input data
#line 3245
  *     to output
#line 3245
  *   - update xpp to point at next unconverted input, and tp to point
#line 3245
  *     at next location for converted output
#line 3245
  */
#line 3245
  long i, j, ni;
#line 3245
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3245
  longlong *xp;
#line 3245
  int nrange = 0;         /* number of range errors */
#line 3245
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3245
  long cxp = (long) *((char**)xpp);
#line 3245

#line 3245
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3245
  /* sjl: manually stripmine so we can limit amount of
#line 3245
   * vector work space reserved to LOOPCNT elements. Also
#line 3245
   * makes vectorisation easy */
#line 3245
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3245
    ni=Min(nelems-j,LOOPCNT);
#line 3245
    if (realign) {
#line 3245
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3245
      xp = tmp;
#line 3245
    } else {
#line 3245
      xp = (longlong *) *xpp;
#line 3245
    }
#line 3245
   /* copy the next block */
#line 3245
#pragma cdir loopcnt=LOOPCNT
#line 3245
#pragma cdir shortloop
#line 3245
    for (i=0; i<ni; i++) {
#line 3245
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3245
     /* test for range errors (not always needed but do it anyway) */
#line 3245
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3245
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3245
      nrange += xp[i] > DOUBLE_MAX || xp[i] < DOUBLE_MIN;
#line 3245
    }
#line 3245
   /* update xpp and tp */
#line 3245
    if (realign) xp = (longlong *) *xpp;
#line 3245
    xp += ni;
#line 3245
    tp += ni;
#line 3245
    *xpp = (void*)xp;
#line 3245
  }
#line 3245
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3245

#line 3245
#else   /* not SX */
#line 3245
	const char *xp = (const char *) *xpp;
#line 3245
	int status = ENOERR;
#line 3245

#line 3245
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3245
	{
#line 3245
		const int lstatus = ncx_get_longlong_double(xp, tp);
#line 3245
		if(lstatus != ENOERR)
#line 3245
			status = lstatus;
#line 3245
	}
#line 3245

#line 3245
	*xpp = (const void *)xp;
#line 3245
	return status;
#line 3245
#  endif
#line 3245
}
#line 3245

int
#line 3246
ncx_getn_longlong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3246
{
#line 3246
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3246

#line 3246
 /* basic algorithm is:
#line 3246
  *   - ensure sane alignment of input data
#line 3246
  *   - copy (conversion happens automatically) input data
#line 3246
  *     to output
#line 3246
  *   - update xpp to point at next unconverted input, and tp to point
#line 3246
  *     at next location for converted output
#line 3246
  */
#line 3246
  long i, j, ni;
#line 3246
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3246
  longlong *xp;
#line 3246
  int nrange = 0;         /* number of range errors */
#line 3246
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3246
  long cxp = (long) *((char**)xpp);
#line 3246

#line 3246
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3246
  /* sjl: manually stripmine so we can limit amount of
#line 3246
   * vector work space reserved to LOOPCNT elements. Also
#line 3246
   * makes vectorisation easy */
#line 3246
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3246
    ni=Min(nelems-j,LOOPCNT);
#line 3246
    if (realign) {
#line 3246
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3246
      xp = tmp;
#line 3246
    } else {
#line 3246
      xp = (longlong *) *xpp;
#line 3246
    }
#line 3246
   /* copy the next block */
#line 3246
#pragma cdir loopcnt=LOOPCNT
#line 3246
#pragma cdir shortloop
#line 3246
    for (i=0; i<ni; i++) {
#line 3246
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3246
     /* test for range errors (not always needed but do it anyway) */
#line 3246
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3246
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3246
      nrange += xp[i] > UCHAR_MAX || xp[i] < 0;
#line 3246
    }
#line 3246
   /* update xpp and tp */
#line 3246
    if (realign) xp = (longlong *) *xpp;
#line 3246
    xp += ni;
#line 3246
    tp += ni;
#line 3246
    *xpp = (void*)xp;
#line 3246
  }
#line 3246
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3246

#line 3246
#else   /* not SX */
#line 3246
	const char *xp = (const char *) *xpp;
#line 3246
	int status = ENOERR;
#line 3246

#line 3246
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3246
	{
#line 3246
		const int lstatus = ncx_get_longlong_uchar(xp, tp);
#line 3246
		if(lstatus != ENOERR)
#line 3246
			status = lstatus;
#line 3246
	}
#line 3246

#line 3246
	*xpp = (const void *)xp;
#line 3246
	return status;
#line 3246
#  endif
#line 3246
}
#line 3246

int
#line 3247
ncx_getn_longlong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3247
{
#line 3247
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3247

#line 3247
 /* basic algorithm is:
#line 3247
  *   - ensure sane alignment of input data
#line 3247
  *   - copy (conversion happens automatically) input data
#line 3247
  *     to output
#line 3247
  *   - update xpp to point at next unconverted input, and tp to point
#line 3247
  *     at next location for converted output
#line 3247
  */
#line 3247
  long i, j, ni;
#line 3247
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3247
  longlong *xp;
#line 3247
  int nrange = 0;         /* number of range errors */
#line 3247
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3247
  long cxp = (long) *((char**)xpp);
#line 3247

#line 3247
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3247
  /* sjl: manually stripmine so we can limit amount of
#line 3247
   * vector work space reserved to LOOPCNT elements. Also
#line 3247
   * makes vectorisation easy */
#line 3247
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3247
    ni=Min(nelems-j,LOOPCNT);
#line 3247
    if (realign) {
#line 3247
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3247
      xp = tmp;
#line 3247
    } else {
#line 3247
      xp = (longlong *) *xpp;
#line 3247
    }
#line 3247
   /* copy the next block */
#line 3247
#pragma cdir loopcnt=LOOPCNT
#line 3247
#pragma cdir shortloop
#line 3247
    for (i=0; i<ni; i++) {
#line 3247
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3247
     /* test for range errors (not always needed but do it anyway) */
#line 3247
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3247
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3247
      nrange += xp[i] > USHORT_MAX || xp[i] < 0;
#line 3247
    }
#line 3247
   /* update xpp and tp */
#line 3247
    if (realign) xp = (longlong *) *xpp;
#line 3247
    xp += ni;
#line 3247
    tp += ni;
#line 3247
    *xpp = (void*)xp;
#line 3247
  }
#line 3247
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3247

#line 3247
#else   /* not SX */
#line 3247
	const char *xp = (const char *) *xpp;
#line 3247
	int status = ENOERR;
#line 3247

#line 3247
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3247
	{
#line 3247
		const int lstatus = ncx_get_longlong_ushort(xp, tp);
#line 3247
		if(lstatus != ENOERR)
#line 3247
			status = lstatus;
#line 3247
	}
#line 3247

#line 3247
	*xpp = (const void *)xp;
#line 3247
	return status;
#line 3247
#  endif
#line 3247
}
#line 3247

int
#line 3248
ncx_getn_longlong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3248
{
#line 3248
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3248

#line 3248
 /* basic algorithm is:
#line 3248
  *   - ensure sane alignment of input data
#line 3248
  *   - copy (conversion happens automatically) input data
#line 3248
  *     to output
#line 3248
  *   - update xpp to point at next unconverted input, and tp to point
#line 3248
  *     at next location for converted output
#line 3248
  */
#line 3248
  long i, j, ni;
#line 3248
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3248
  longlong *xp;
#line 3248
  int nrange = 0;         /* number of range errors */
#line 3248
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3248
  long cxp = (long) *((char**)xpp);
#line 3248

#line 3248
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3248
  /* sjl: manually stripmine so we can limit amount of
#line 3248
   * vector work space reserved to LOOPCNT elements. Also
#line 3248
   * makes vectorisation easy */
#line 3248
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3248
    ni=Min(nelems-j,LOOPCNT);
#line 3248
    if (realign) {
#line 3248
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3248
      xp = tmp;
#line 3248
    } else {
#line 3248
      xp = (longlong *) *xpp;
#line 3248
    }
#line 3248
   /* copy the next block */
#line 3248
#pragma cdir loopcnt=LOOPCNT
#line 3248
#pragma cdir shortloop
#line 3248
    for (i=0; i<ni; i++) {
#line 3248
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3248
     /* test for range errors (not always needed but do it anyway) */
#line 3248
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3248
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3248
      nrange += xp[i] > UINT_MAX || xp[i] < 0;
#line 3248
    }
#line 3248
   /* update xpp and tp */
#line 3248
    if (realign) xp = (longlong *) *xpp;
#line 3248
    xp += ni;
#line 3248
    tp += ni;
#line 3248
    *xpp = (void*)xp;
#line 3248
  }
#line 3248
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3248

#line 3248
#else   /* not SX */
#line 3248
	const char *xp = (const char *) *xpp;
#line 3248
	int status = ENOERR;
#line 3248

#line 3248
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3248
	{
#line 3248
		const int lstatus = ncx_get_longlong_uint(xp, tp);
#line 3248
		if(lstatus != ENOERR)
#line 3248
			status = lstatus;
#line 3248
	}
#line 3248

#line 3248
	*xpp = (const void *)xp;
#line 3248
	return status;
#line 3248
#  endif
#line 3248
}
#line 3248

int
#line 3249
ncx_getn_longlong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3249
{
#line 3249
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3249

#line 3249
 /* basic algorithm is:
#line 3249
  *   - ensure sane alignment of input data
#line 3249
  *   - copy (conversion happens automatically) input data
#line 3249
  *     to output
#line 3249
  *   - update xpp to point at next unconverted input, and tp to point
#line 3249
  *     at next location for converted output
#line 3249
  */
#line 3249
  long i, j, ni;
#line 3249
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3249
  longlong *xp;
#line 3249
  int nrange = 0;         /* number of range errors */
#line 3249
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3249
  long cxp = (long) *((char**)xpp);
#line 3249

#line 3249
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3249
  /* sjl: manually stripmine so we can limit amount of
#line 3249
   * vector work space reserved to LOOPCNT elements. Also
#line 3249
   * makes vectorisation easy */
#line 3249
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3249
    ni=Min(nelems-j,LOOPCNT);
#line 3249
    if (realign) {
#line 3249
      memcpy(tmp, *xpp, ni*SIZEOF_LONGLONG);
#line 3249
      xp = tmp;
#line 3249
    } else {
#line 3249
      xp = (longlong *) *xpp;
#line 3249
    }
#line 3249
   /* copy the next block */
#line 3249
#pragma cdir loopcnt=LOOPCNT
#line 3249
#pragma cdir shortloop
#line 3249
    for (i=0; i<ni; i++) {
#line 3249
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3249
     /* test for range errors (not always needed but do it anyway) */
#line 3249
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3249
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3249
      nrange += xp[i] > ULONGLONG_MAX || xp[i] < 0;
#line 3249
    }
#line 3249
   /* update xpp and tp */
#line 3249
    if (realign) xp = (longlong *) *xpp;
#line 3249
    xp += ni;
#line 3249
    tp += ni;
#line 3249
    *xpp = (void*)xp;
#line 3249
  }
#line 3249
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3249

#line 3249
#else   /* not SX */
#line 3249
	const char *xp = (const char *) *xpp;
#line 3249
	int status = ENOERR;
#line 3249

#line 3249
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3249
	{
#line 3249
		const int lstatus = ncx_get_longlong_ulonglong(xp, tp);
#line 3249
		if(lstatus != ENOERR)
#line 3249
			status = lstatus;
#line 3249
	}
#line 3249

#line 3249
	*xpp = (const void *)xp;
#line 3249
	return status;
#line 3249
#  endif
#line 3249
}
#line 3249


#if X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
/* optimized version */
int
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_LONGLONG);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_LONGLONG);
	return ENOERR;
}
#else
int
#line 3265
ncx_putn_longlong_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3265
{
#line 3265
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3265

#line 3265
 /* basic algorithm is:
#line 3265
  *   - ensure sane alignment of output data
#line 3265
  *   - copy (conversion happens automatically) input data
#line 3265
  *     to output
#line 3265
  *   - update tp to point at next unconverted input, and xpp to point
#line 3265
  *     at next location for converted output
#line 3265
  */
#line 3265
  long i, j, ni;
#line 3265
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3265
  longlong *xp;
#line 3265
  int nrange = 0;         /* number of range errors */
#line 3265
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3265
  long cxp = (long) *((char**)xpp);
#line 3265

#line 3265
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3265
  /* sjl: manually stripmine so we can limit amount of
#line 3265
   * vector work space reserved to LOOPCNT elements. Also
#line 3265
   * makes vectorisation easy */
#line 3265
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3265
    ni=Min(nelems-j,LOOPCNT);
#line 3265
    if (realign) {
#line 3265
      xp = tmp;
#line 3265
    } else {
#line 3265
      xp = (longlong *) *xpp;
#line 3265
    }
#line 3265
   /* copy the next block */
#line 3265
#pragma cdir loopcnt=LOOPCNT
#line 3265
#pragma cdir shortloop
#line 3265
    for (i=0; i<ni; i++) {
#line 3265
      /* the normal case: */
#line 3265
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3265
     /* test for range errors (not always needed but do it anyway) */
#line 3265
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3265
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3265
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3265
    }
#line 3265
   /* copy workspace back if necessary */
#line 3265
    if (realign) {
#line 3265
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3265
      xp = (longlong *) *xpp;
#line 3265
    }
#line 3265
   /* update xpp and tp */
#line 3265
    xp += ni;
#line 3265
    tp += ni;
#line 3265
    *xpp = (void*)xp;
#line 3265
  }
#line 3265
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3265

#line 3265
#else   /* not SX */
#line 3265

#line 3265
	char *xp = (char *) *xpp;
#line 3265
	int status = ENOERR;
#line 3265

#line 3265
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3265
	{
#line 3265
		int lstatus = ncx_put_longlong_longlong(xp, tp);
#line 3265
		if(lstatus != ENOERR)
#line 3265
			status = lstatus;
#line 3265
	}
#line 3265

#line 3265
	*xpp = (void *)xp;
#line 3265
	return status;
#line 3265
#endif
#line 3265
}
#line 3265

#endif
int
#line 3267
ncx_putn_longlong_schar(void **xpp, size_t nelems, const schar *tp)
#line 3267
{
#line 3267
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3267

#line 3267
 /* basic algorithm is:
#line 3267
  *   - ensure sane alignment of output data
#line 3267
  *   - copy (conversion happens automatically) input data
#line 3267
  *     to output
#line 3267
  *   - update tp to point at next unconverted input, and xpp to point
#line 3267
  *     at next location for converted output
#line 3267
  */
#line 3267
  long i, j, ni;
#line 3267
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3267
  longlong *xp;
#line 3267
  int nrange = 0;         /* number of range errors */
#line 3267
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3267
  long cxp = (long) *((char**)xpp);
#line 3267

#line 3267
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3267
  /* sjl: manually stripmine so we can limit amount of
#line 3267
   * vector work space reserved to LOOPCNT elements. Also
#line 3267
   * makes vectorisation easy */
#line 3267
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3267
    ni=Min(nelems-j,LOOPCNT);
#line 3267
    if (realign) {
#line 3267
      xp = tmp;
#line 3267
    } else {
#line 3267
      xp = (longlong *) *xpp;
#line 3267
    }
#line 3267
   /* copy the next block */
#line 3267
#pragma cdir loopcnt=LOOPCNT
#line 3267
#pragma cdir shortloop
#line 3267
    for (i=0; i<ni; i++) {
#line 3267
      /* the normal case: */
#line 3267
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3267
     /* test for range errors (not always needed but do it anyway) */
#line 3267
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3267
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3267
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3267
    }
#line 3267
   /* copy workspace back if necessary */
#line 3267
    if (realign) {
#line 3267
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3267
      xp = (longlong *) *xpp;
#line 3267
    }
#line 3267
   /* update xpp and tp */
#line 3267
    xp += ni;
#line 3267
    tp += ni;
#line 3267
    *xpp = (void*)xp;
#line 3267
  }
#line 3267
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3267

#line 3267
#else   /* not SX */
#line 3267

#line 3267
	char *xp = (char *) *xpp;
#line 3267
	int status = ENOERR;
#line 3267

#line 3267
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3267
	{
#line 3267
		int lstatus = ncx_put_longlong_schar(xp, tp);
#line 3267
		if(lstatus != ENOERR)
#line 3267
			status = lstatus;
#line 3267
	}
#line 3267

#line 3267
	*xpp = (void *)xp;
#line 3267
	return status;
#line 3267
#endif
#line 3267
}
#line 3267

int
#line 3268
ncx_putn_longlong_short(void **xpp, size_t nelems, const short *tp)
#line 3268
{
#line 3268
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3268

#line 3268
 /* basic algorithm is:
#line 3268
  *   - ensure sane alignment of output data
#line 3268
  *   - copy (conversion happens automatically) input data
#line 3268
  *     to output
#line 3268
  *   - update tp to point at next unconverted input, and xpp to point
#line 3268
  *     at next location for converted output
#line 3268
  */
#line 3268
  long i, j, ni;
#line 3268
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3268
  longlong *xp;
#line 3268
  int nrange = 0;         /* number of range errors */
#line 3268
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3268
  long cxp = (long) *((char**)xpp);
#line 3268

#line 3268
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3268
  /* sjl: manually stripmine so we can limit amount of
#line 3268
   * vector work space reserved to LOOPCNT elements. Also
#line 3268
   * makes vectorisation easy */
#line 3268
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3268
    ni=Min(nelems-j,LOOPCNT);
#line 3268
    if (realign) {
#line 3268
      xp = tmp;
#line 3268
    } else {
#line 3268
      xp = (longlong *) *xpp;
#line 3268
    }
#line 3268
   /* copy the next block */
#line 3268
#pragma cdir loopcnt=LOOPCNT
#line 3268
#pragma cdir shortloop
#line 3268
    for (i=0; i<ni; i++) {
#line 3268
      /* the normal case: */
#line 3268
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3268
     /* test for range errors (not always needed but do it anyway) */
#line 3268
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3268
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3268
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3268
    }
#line 3268
   /* copy workspace back if necessary */
#line 3268
    if (realign) {
#line 3268
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3268
      xp = (longlong *) *xpp;
#line 3268
    }
#line 3268
   /* update xpp and tp */
#line 3268
    xp += ni;
#line 3268
    tp += ni;
#line 3268
    *xpp = (void*)xp;
#line 3268
  }
#line 3268
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3268

#line 3268
#else   /* not SX */
#line 3268

#line 3268
	char *xp = (char *) *xpp;
#line 3268
	int status = ENOERR;
#line 3268

#line 3268
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3268
	{
#line 3268
		int lstatus = ncx_put_longlong_short(xp, tp);
#line 3268
		if(lstatus != ENOERR)
#line 3268
			status = lstatus;
#line 3268
	}
#line 3268

#line 3268
	*xpp = (void *)xp;
#line 3268
	return status;
#line 3268
#endif
#line 3268
}
#line 3268

int
#line 3269
ncx_putn_longlong_int(void **xpp, size_t nelems, const int *tp)
#line 3269
{
#line 3269
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3269

#line 3269
 /* basic algorithm is:
#line 3269
  *   - ensure sane alignment of output data
#line 3269
  *   - copy (conversion happens automatically) input data
#line 3269
  *     to output
#line 3269
  *   - update tp to point at next unconverted input, and xpp to point
#line 3269
  *     at next location for converted output
#line 3269
  */
#line 3269
  long i, j, ni;
#line 3269
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3269
  longlong *xp;
#line 3269
  int nrange = 0;         /* number of range errors */
#line 3269
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3269
  long cxp = (long) *((char**)xpp);
#line 3269

#line 3269
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3269
  /* sjl: manually stripmine so we can limit amount of
#line 3269
   * vector work space reserved to LOOPCNT elements. Also
#line 3269
   * makes vectorisation easy */
#line 3269
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3269
    ni=Min(nelems-j,LOOPCNT);
#line 3269
    if (realign) {
#line 3269
      xp = tmp;
#line 3269
    } else {
#line 3269
      xp = (longlong *) *xpp;
#line 3269
    }
#line 3269
   /* copy the next block */
#line 3269
#pragma cdir loopcnt=LOOPCNT
#line 3269
#pragma cdir shortloop
#line 3269
    for (i=0; i<ni; i++) {
#line 3269
      /* the normal case: */
#line 3269
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3269
     /* test for range errors (not always needed but do it anyway) */
#line 3269
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3269
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3269
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3269
    }
#line 3269
   /* copy workspace back if necessary */
#line 3269
    if (realign) {
#line 3269
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3269
      xp = (longlong *) *xpp;
#line 3269
    }
#line 3269
   /* update xpp and tp */
#line 3269
    xp += ni;
#line 3269
    tp += ni;
#line 3269
    *xpp = (void*)xp;
#line 3269
  }
#line 3269
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3269

#line 3269
#else   /* not SX */
#line 3269

#line 3269
	char *xp = (char *) *xpp;
#line 3269
	int status = ENOERR;
#line 3269

#line 3269
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3269
	{
#line 3269
		int lstatus = ncx_put_longlong_int(xp, tp);
#line 3269
		if(lstatus != ENOERR)
#line 3269
			status = lstatus;
#line 3269
	}
#line 3269

#line 3269
	*xpp = (void *)xp;
#line 3269
	return status;
#line 3269
#endif
#line 3269
}
#line 3269

int
#line 3270
ncx_putn_longlong_float(void **xpp, size_t nelems, const float *tp)
#line 3270
{
#line 3270
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3270

#line 3270
 /* basic algorithm is:
#line 3270
  *   - ensure sane alignment of output data
#line 3270
  *   - copy (conversion happens automatically) input data
#line 3270
  *     to output
#line 3270
  *   - update tp to point at next unconverted input, and xpp to point
#line 3270
  *     at next location for converted output
#line 3270
  */
#line 3270
  long i, j, ni;
#line 3270
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3270
  longlong *xp;
#line 3270
  int nrange = 0;         /* number of range errors */
#line 3270
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3270
  long cxp = (long) *((char**)xpp);
#line 3270

#line 3270
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3270
  /* sjl: manually stripmine so we can limit amount of
#line 3270
   * vector work space reserved to LOOPCNT elements. Also
#line 3270
   * makes vectorisation easy */
#line 3270
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3270
    ni=Min(nelems-j,LOOPCNT);
#line 3270
    if (realign) {
#line 3270
      xp = tmp;
#line 3270
    } else {
#line 3270
      xp = (longlong *) *xpp;
#line 3270
    }
#line 3270
   /* copy the next block */
#line 3270
#pragma cdir loopcnt=LOOPCNT
#line 3270
#pragma cdir shortloop
#line 3270
    for (i=0; i<ni; i++) {
#line 3270
      /* the normal case: */
#line 3270
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3270
     /* test for range errors (not always needed but do it anyway) */
#line 3270
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3270
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3270
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3270
    }
#line 3270
   /* copy workspace back if necessary */
#line 3270
    if (realign) {
#line 3270
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3270
      xp = (longlong *) *xpp;
#line 3270
    }
#line 3270
   /* update xpp and tp */
#line 3270
    xp += ni;
#line 3270
    tp += ni;
#line 3270
    *xpp = (void*)xp;
#line 3270
  }
#line 3270
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3270

#line 3270
#else   /* not SX */
#line 3270

#line 3270
	char *xp = (char *) *xpp;
#line 3270
	int status = ENOERR;
#line 3270

#line 3270
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3270
	{
#line 3270
		int lstatus = ncx_put_longlong_float(xp, tp);
#line 3270
		if(lstatus != ENOERR)
#line 3270
			status = lstatus;
#line 3270
	}
#line 3270

#line 3270
	*xpp = (void *)xp;
#line 3270
	return status;
#line 3270
#endif
#line 3270
}
#line 3270

int
#line 3271
ncx_putn_longlong_double(void **xpp, size_t nelems, const double *tp)
#line 3271
{
#line 3271
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3271

#line 3271
 /* basic algorithm is:
#line 3271
  *   - ensure sane alignment of output data
#line 3271
  *   - copy (conversion happens automatically) input data
#line 3271
  *     to output
#line 3271
  *   - update tp to point at next unconverted input, and xpp to point
#line 3271
  *     at next location for converted output
#line 3271
  */
#line 3271
  long i, j, ni;
#line 3271
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3271
  longlong *xp;
#line 3271
  int nrange = 0;         /* number of range errors */
#line 3271
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3271
  long cxp = (long) *((char**)xpp);
#line 3271

#line 3271
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3271
  /* sjl: manually stripmine so we can limit amount of
#line 3271
   * vector work space reserved to LOOPCNT elements. Also
#line 3271
   * makes vectorisation easy */
#line 3271
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3271
    ni=Min(nelems-j,LOOPCNT);
#line 3271
    if (realign) {
#line 3271
      xp = tmp;
#line 3271
    } else {
#line 3271
      xp = (longlong *) *xpp;
#line 3271
    }
#line 3271
   /* copy the next block */
#line 3271
#pragma cdir loopcnt=LOOPCNT
#line 3271
#pragma cdir shortloop
#line 3271
    for (i=0; i<ni; i++) {
#line 3271
      /* the normal case: */
#line 3271
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3271
     /* test for range errors (not always needed but do it anyway) */
#line 3271
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3271
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3271
      nrange += tp[i] > X_LONGLONG_MAX || tp[i] < X_LONGLONG_MIN;
#line 3271
    }
#line 3271
   /* copy workspace back if necessary */
#line 3271
    if (realign) {
#line 3271
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3271
      xp = (longlong *) *xpp;
#line 3271
    }
#line 3271
   /* update xpp and tp */
#line 3271
    xp += ni;
#line 3271
    tp += ni;
#line 3271
    *xpp = (void*)xp;
#line 3271
  }
#line 3271
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3271

#line 3271
#else   /* not SX */
#line 3271

#line 3271
	char *xp = (char *) *xpp;
#line 3271
	int status = ENOERR;
#line 3271

#line 3271
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3271
	{
#line 3271
		int lstatus = ncx_put_longlong_double(xp, tp);
#line 3271
		if(lstatus != ENOERR)
#line 3271
			status = lstatus;
#line 3271
	}
#line 3271

#line 3271
	*xpp = (void *)xp;
#line 3271
	return status;
#line 3271
#endif
#line 3271
}
#line 3271

int
#line 3272
ncx_putn_longlong_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3272
{
#line 3272
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3272

#line 3272
 /* basic algorithm is:
#line 3272
  *   - ensure sane alignment of output data
#line 3272
  *   - copy (conversion happens automatically) input data
#line 3272
  *     to output
#line 3272
  *   - update tp to point at next unconverted input, and xpp to point
#line 3272
  *     at next location for converted output
#line 3272
  */
#line 3272
  long i, j, ni;
#line 3272
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3272
  longlong *xp;
#line 3272
  int nrange = 0;         /* number of range errors */
#line 3272
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3272
  long cxp = (long) *((char**)xpp);
#line 3272

#line 3272
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3272
  /* sjl: manually stripmine so we can limit amount of
#line 3272
   * vector work space reserved to LOOPCNT elements. Also
#line 3272
   * makes vectorisation easy */
#line 3272
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3272
    ni=Min(nelems-j,LOOPCNT);
#line 3272
    if (realign) {
#line 3272
      xp = tmp;
#line 3272
    } else {
#line 3272
      xp = (longlong *) *xpp;
#line 3272
    }
#line 3272
   /* copy the next block */
#line 3272
#pragma cdir loopcnt=LOOPCNT
#line 3272
#pragma cdir shortloop
#line 3272
    for (i=0; i<ni; i++) {
#line 3272
      /* the normal case: */
#line 3272
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3272
     /* test for range errors (not always needed but do it anyway) */
#line 3272
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3272
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3272
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3272
    }
#line 3272
   /* copy workspace back if necessary */
#line 3272
    if (realign) {
#line 3272
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3272
      xp = (longlong *) *xpp;
#line 3272
    }
#line 3272
   /* update xpp and tp */
#line 3272
    xp += ni;
#line 3272
    tp += ni;
#line 3272
    *xpp = (void*)xp;
#line 3272
  }
#line 3272
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3272

#line 3272
#else   /* not SX */
#line 3272

#line 3272
	char *xp = (char *) *xpp;
#line 3272
	int status = ENOERR;
#line 3272

#line 3272
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3272
	{
#line 3272
		int lstatus = ncx_put_longlong_uchar(xp, tp);
#line 3272
		if(lstatus != ENOERR)
#line 3272
			status = lstatus;
#line 3272
	}
#line 3272

#line 3272
	*xpp = (void *)xp;
#line 3272
	return status;
#line 3272
#endif
#line 3272
}
#line 3272

int
#line 3273
ncx_putn_longlong_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3273
{
#line 3273
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3273

#line 3273
 /* basic algorithm is:
#line 3273
  *   - ensure sane alignment of output data
#line 3273
  *   - copy (conversion happens automatically) input data
#line 3273
  *     to output
#line 3273
  *   - update tp to point at next unconverted input, and xpp to point
#line 3273
  *     at next location for converted output
#line 3273
  */
#line 3273
  long i, j, ni;
#line 3273
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3273
  longlong *xp;
#line 3273
  int nrange = 0;         /* number of range errors */
#line 3273
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3273
  long cxp = (long) *((char**)xpp);
#line 3273

#line 3273
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3273
  /* sjl: manually stripmine so we can limit amount of
#line 3273
   * vector work space reserved to LOOPCNT elements. Also
#line 3273
   * makes vectorisation easy */
#line 3273
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3273
    ni=Min(nelems-j,LOOPCNT);
#line 3273
    if (realign) {
#line 3273
      xp = tmp;
#line 3273
    } else {
#line 3273
      xp = (longlong *) *xpp;
#line 3273
    }
#line 3273
   /* copy the next block */
#line 3273
#pragma cdir loopcnt=LOOPCNT
#line 3273
#pragma cdir shortloop
#line 3273
    for (i=0; i<ni; i++) {
#line 3273
      /* the normal case: */
#line 3273
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3273
     /* test for range errors (not always needed but do it anyway) */
#line 3273
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3273
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3273
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3273
    }
#line 3273
   /* copy workspace back if necessary */
#line 3273
    if (realign) {
#line 3273
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3273
      xp = (longlong *) *xpp;
#line 3273
    }
#line 3273
   /* update xpp and tp */
#line 3273
    xp += ni;
#line 3273
    tp += ni;
#line 3273
    *xpp = (void*)xp;
#line 3273
  }
#line 3273
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3273

#line 3273
#else   /* not SX */
#line 3273

#line 3273
	char *xp = (char *) *xpp;
#line 3273
	int status = ENOERR;
#line 3273

#line 3273
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3273
	{
#line 3273
		int lstatus = ncx_put_longlong_ushort(xp, tp);
#line 3273
		if(lstatus != ENOERR)
#line 3273
			status = lstatus;
#line 3273
	}
#line 3273

#line 3273
	*xpp = (void *)xp;
#line 3273
	return status;
#line 3273
#endif
#line 3273
}
#line 3273

int
#line 3274
ncx_putn_longlong_uint(void **xpp, size_t nelems, const uint *tp)
#line 3274
{
#line 3274
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3274

#line 3274
 /* basic algorithm is:
#line 3274
  *   - ensure sane alignment of output data
#line 3274
  *   - copy (conversion happens automatically) input data
#line 3274
  *     to output
#line 3274
  *   - update tp to point at next unconverted input, and xpp to point
#line 3274
  *     at next location for converted output
#line 3274
  */
#line 3274
  long i, j, ni;
#line 3274
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3274
  longlong *xp;
#line 3274
  int nrange = 0;         /* number of range errors */
#line 3274
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3274
  long cxp = (long) *((char**)xpp);
#line 3274

#line 3274
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3274
  /* sjl: manually stripmine so we can limit amount of
#line 3274
   * vector work space reserved to LOOPCNT elements. Also
#line 3274
   * makes vectorisation easy */
#line 3274
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3274
    ni=Min(nelems-j,LOOPCNT);
#line 3274
    if (realign) {
#line 3274
      xp = tmp;
#line 3274
    } else {
#line 3274
      xp = (longlong *) *xpp;
#line 3274
    }
#line 3274
   /* copy the next block */
#line 3274
#pragma cdir loopcnt=LOOPCNT
#line 3274
#pragma cdir shortloop
#line 3274
    for (i=0; i<ni; i++) {
#line 3274
      /* the normal case: */
#line 3274
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3274
     /* test for range errors (not always needed but do it anyway) */
#line 3274
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3274
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3274
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3274
    }
#line 3274
   /* copy workspace back if necessary */
#line 3274
    if (realign) {
#line 3274
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3274
      xp = (longlong *) *xpp;
#line 3274
    }
#line 3274
   /* update xpp and tp */
#line 3274
    xp += ni;
#line 3274
    tp += ni;
#line 3274
    *xpp = (void*)xp;
#line 3274
  }
#line 3274
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3274

#line 3274
#else   /* not SX */
#line 3274

#line 3274
	char *xp = (char *) *xpp;
#line 3274
	int status = ENOERR;
#line 3274

#line 3274
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3274
	{
#line 3274
		int lstatus = ncx_put_longlong_uint(xp, tp);
#line 3274
		if(lstatus != ENOERR)
#line 3274
			status = lstatus;
#line 3274
	}
#line 3274

#line 3274
	*xpp = (void *)xp;
#line 3274
	return status;
#line 3274
#endif
#line 3274
}
#line 3274

int
#line 3275
ncx_putn_longlong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3275
{
#line 3275
#if _SX && X_SIZEOF_LONGLONG == SIZEOF_LONGLONG
#line 3275

#line 3275
 /* basic algorithm is:
#line 3275
  *   - ensure sane alignment of output data
#line 3275
  *   - copy (conversion happens automatically) input data
#line 3275
  *     to output
#line 3275
  *   - update tp to point at next unconverted input, and xpp to point
#line 3275
  *     at next location for converted output
#line 3275
  */
#line 3275
  long i, j, ni;
#line 3275
  longlong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3275
  longlong *xp;
#line 3275
  int nrange = 0;         /* number of range errors */
#line 3275
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3275
  long cxp = (long) *((char**)xpp);
#line 3275

#line 3275
  realign = (cxp & 7) % SIZEOF_LONGLONG;
#line 3275
  /* sjl: manually stripmine so we can limit amount of
#line 3275
   * vector work space reserved to LOOPCNT elements. Also
#line 3275
   * makes vectorisation easy */
#line 3275
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3275
    ni=Min(nelems-j,LOOPCNT);
#line 3275
    if (realign) {
#line 3275
      xp = tmp;
#line 3275
    } else {
#line 3275
      xp = (longlong *) *xpp;
#line 3275
    }
#line 3275
   /* copy the next block */
#line 3275
#pragma cdir loopcnt=LOOPCNT
#line 3275
#pragma cdir shortloop
#line 3275
    for (i=0; i<ni; i++) {
#line 3275
      /* the normal case: */
#line 3275
      xp[i] = (longlong) Max( X_LONGLONG_MIN, Min(X_LONGLONG_MAX, (longlong) tp[i]));
#line 3275
     /* test for range errors (not always needed but do it anyway) */
#line 3275
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3275
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3275
      nrange += tp[i] > X_LONGLONG_MAX ;
#line 3275
    }
#line 3275
   /* copy workspace back if necessary */
#line 3275
    if (realign) {
#line 3275
      memcpy(*xpp, tmp, ni*X_SIZEOF_LONGLONG);
#line 3275
      xp = (longlong *) *xpp;
#line 3275
    }
#line 3275
   /* update xpp and tp */
#line 3275
    xp += ni;
#line 3275
    tp += ni;
#line 3275
    *xpp = (void*)xp;
#line 3275
  }
#line 3275
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3275

#line 3275
#else   /* not SX */
#line 3275

#line 3275
	char *xp = (char *) *xpp;
#line 3275
	int status = ENOERR;
#line 3275

#line 3275
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_LONGLONG, tp++)
#line 3275
	{
#line 3275
		int lstatus = ncx_put_longlong_ulonglong(xp, tp);
#line 3275
		if(lstatus != ENOERR)
#line 3275
			status = lstatus;
#line 3275
	}
#line 3275

#line 3275
	*xpp = (void *)xp;
#line 3275
	return status;
#line 3275
#endif
#line 3275
}
#line 3275


/* ulonglong ----------------------------------------------------------------------*/

#if X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, unsigned long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(tp, *xpp, nelems * sizeof(unsigned long long));
# else
	swapn8b(tp, *xpp, nelems);
# endif
	*xpp = (const void *)((const char *)(*xpp) + nelems * X_SIZEOF_ULONGLONG);
	return ENOERR;
}
#else
int
#line 3293
ncx_getn_ulonglong_ulonglong(const void **xpp, size_t nelems, ulonglong *tp)
#line 3293
{
#line 3293
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3293

#line 3293
 /* basic algorithm is:
#line 3293
  *   - ensure sane alignment of input data
#line 3293
  *   - copy (conversion happens automatically) input data
#line 3293
  *     to output
#line 3293
  *   - update xpp to point at next unconverted input, and tp to point
#line 3293
  *     at next location for converted output
#line 3293
  */
#line 3293
  long i, j, ni;
#line 3293
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3293
  ulonglong *xp;
#line 3293
  int nrange = 0;         /* number of range errors */
#line 3293
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3293
  long cxp = (long) *((char**)xpp);
#line 3293

#line 3293
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3293
  /* sjl: manually stripmine so we can limit amount of
#line 3293
   * vector work space reserved to LOOPCNT elements. Also
#line 3293
   * makes vectorisation easy */
#line 3293
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3293
    ni=Min(nelems-j,LOOPCNT);
#line 3293
    if (realign) {
#line 3293
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3293
      xp = tmp;
#line 3293
    } else {
#line 3293
      xp = (ulonglong *) *xpp;
#line 3293
    }
#line 3293
   /* copy the next block */
#line 3293
#pragma cdir loopcnt=LOOPCNT
#line 3293
#pragma cdir shortloop
#line 3293
    for (i=0; i<ni; i++) {
#line 3293
      tp[i] = (ulonglong) Max( ULONGLONG_MIN, Min(ULONGLONG_MAX, (ulonglong) xp[i]));
#line 3293
     /* test for range errors (not always needed but do it anyway) */
#line 3293
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3293
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3293
      nrange += xp[i] > ULONGLONG_MAX ;
#line 3293
    }
#line 3293
   /* update xpp and tp */
#line 3293
    if (realign) xp = (ulonglong *) *xpp;
#line 3293
    xp += ni;
#line 3293
    tp += ni;
#line 3293
    *xpp = (void*)xp;
#line 3293
  }
#line 3293
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3293

#line 3293
#else   /* not SX */
#line 3293
	const char *xp = (const char *) *xpp;
#line 3293
	int status = ENOERR;
#line 3293

#line 3293
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3293
	{
#line 3293
		const int lstatus = ncx_get_ulonglong_ulonglong(xp, tp);
#line 3293
		if(lstatus != ENOERR)
#line 3293
			status = lstatus;
#line 3293
	}
#line 3293

#line 3293
	*xpp = (const void *)xp;
#line 3293
	return status;
#line 3293
#  endif
#line 3293
}
#line 3293

#endif
int
#line 3295
ncx_getn_ulonglong_schar(const void **xpp, size_t nelems, schar *tp)
#line 3295
{
#line 3295
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3295

#line 3295
 /* basic algorithm is:
#line 3295
  *   - ensure sane alignment of input data
#line 3295
  *   - copy (conversion happens automatically) input data
#line 3295
  *     to output
#line 3295
  *   - update xpp to point at next unconverted input, and tp to point
#line 3295
  *     at next location for converted output
#line 3295
  */
#line 3295
  long i, j, ni;
#line 3295
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3295
  ulonglong *xp;
#line 3295
  int nrange = 0;         /* number of range errors */
#line 3295
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3295
  long cxp = (long) *((char**)xpp);
#line 3295

#line 3295
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3295
  /* sjl: manually stripmine so we can limit amount of
#line 3295
   * vector work space reserved to LOOPCNT elements. Also
#line 3295
   * makes vectorisation easy */
#line 3295
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3295
    ni=Min(nelems-j,LOOPCNT);
#line 3295
    if (realign) {
#line 3295
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3295
      xp = tmp;
#line 3295
    } else {
#line 3295
      xp = (ulonglong *) *xpp;
#line 3295
    }
#line 3295
   /* copy the next block */
#line 3295
#pragma cdir loopcnt=LOOPCNT
#line 3295
#pragma cdir shortloop
#line 3295
    for (i=0; i<ni; i++) {
#line 3295
      tp[i] = (schar) Max( SCHAR_MIN, Min(SCHAR_MAX, (schar) xp[i]));
#line 3295
     /* test for range errors (not always needed but do it anyway) */
#line 3295
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3295
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3295
      nrange += xp[i] > SCHAR_MAX ;
#line 3295
    }
#line 3295
   /* update xpp and tp */
#line 3295
    if (realign) xp = (ulonglong *) *xpp;
#line 3295
    xp += ni;
#line 3295
    tp += ni;
#line 3295
    *xpp = (void*)xp;
#line 3295
  }
#line 3295
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3295

#line 3295
#else   /* not SX */
#line 3295
	const char *xp = (const char *) *xpp;
#line 3295
	int status = ENOERR;
#line 3295

#line 3295
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3295
	{
#line 3295
		const int lstatus = ncx_get_ulonglong_schar(xp, tp);
#line 3295
		if(lstatus != ENOERR)
#line 3295
			status = lstatus;
#line 3295
	}
#line 3295

#line 3295
	*xpp = (const void *)xp;
#line 3295
	return status;
#line 3295
#  endif
#line 3295
}
#line 3295

int
#line 3296
ncx_getn_ulonglong_short(const void **xpp, size_t nelems, short *tp)
#line 3296
{
#line 3296
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3296

#line 3296
 /* basic algorithm is:
#line 3296
  *   - ensure sane alignment of input data
#line 3296
  *   - copy (conversion happens automatically) input data
#line 3296
  *     to output
#line 3296
  *   - update xpp to point at next unconverted input, and tp to point
#line 3296
  *     at next location for converted output
#line 3296
  */
#line 3296
  long i, j, ni;
#line 3296
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3296
  ulonglong *xp;
#line 3296
  int nrange = 0;         /* number of range errors */
#line 3296
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3296
  long cxp = (long) *((char**)xpp);
#line 3296

#line 3296
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3296
  /* sjl: manually stripmine so we can limit amount of
#line 3296
   * vector work space reserved to LOOPCNT elements. Also
#line 3296
   * makes vectorisation easy */
#line 3296
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3296
    ni=Min(nelems-j,LOOPCNT);
#line 3296
    if (realign) {
#line 3296
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3296
      xp = tmp;
#line 3296
    } else {
#line 3296
      xp = (ulonglong *) *xpp;
#line 3296
    }
#line 3296
   /* copy the next block */
#line 3296
#pragma cdir loopcnt=LOOPCNT
#line 3296
#pragma cdir shortloop
#line 3296
    for (i=0; i<ni; i++) {
#line 3296
      tp[i] = (short) Max( SHORT_MIN, Min(SHORT_MAX, (short) xp[i]));
#line 3296
     /* test for range errors (not always needed but do it anyway) */
#line 3296
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3296
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3296
      nrange += xp[i] > SHORT_MAX ;
#line 3296
    }
#line 3296
   /* update xpp and tp */
#line 3296
    if (realign) xp = (ulonglong *) *xpp;
#line 3296
    xp += ni;
#line 3296
    tp += ni;
#line 3296
    *xpp = (void*)xp;
#line 3296
  }
#line 3296
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3296

#line 3296
#else   /* not SX */
#line 3296
	const char *xp = (const char *) *xpp;
#line 3296
	int status = ENOERR;
#line 3296

#line 3296
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3296
	{
#line 3296
		const int lstatus = ncx_get_ulonglong_short(xp, tp);
#line 3296
		if(lstatus != ENOERR)
#line 3296
			status = lstatus;
#line 3296
	}
#line 3296

#line 3296
	*xpp = (const void *)xp;
#line 3296
	return status;
#line 3296
#  endif
#line 3296
}
#line 3296

int
#line 3297
ncx_getn_ulonglong_int(const void **xpp, size_t nelems, int *tp)
#line 3297
{
#line 3297
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3297

#line 3297
 /* basic algorithm is:
#line 3297
  *   - ensure sane alignment of input data
#line 3297
  *   - copy (conversion happens automatically) input data
#line 3297
  *     to output
#line 3297
  *   - update xpp to point at next unconverted input, and tp to point
#line 3297
  *     at next location for converted output
#line 3297
  */
#line 3297
  long i, j, ni;
#line 3297
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3297
  ulonglong *xp;
#line 3297
  int nrange = 0;         /* number of range errors */
#line 3297
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3297
  long cxp = (long) *((char**)xpp);
#line 3297

#line 3297
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3297
  /* sjl: manually stripmine so we can limit amount of
#line 3297
   * vector work space reserved to LOOPCNT elements. Also
#line 3297
   * makes vectorisation easy */
#line 3297
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3297
    ni=Min(nelems-j,LOOPCNT);
#line 3297
    if (realign) {
#line 3297
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3297
      xp = tmp;
#line 3297
    } else {
#line 3297
      xp = (ulonglong *) *xpp;
#line 3297
    }
#line 3297
   /* copy the next block */
#line 3297
#pragma cdir loopcnt=LOOPCNT
#line 3297
#pragma cdir shortloop
#line 3297
    for (i=0; i<ni; i++) {
#line 3297
      tp[i] = (int) Max( INT_MIN, Min(INT_MAX, (int) xp[i]));
#line 3297
     /* test for range errors (not always needed but do it anyway) */
#line 3297
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3297
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3297
      nrange += xp[i] > INT_MAX ;
#line 3297
    }
#line 3297
   /* update xpp and tp */
#line 3297
    if (realign) xp = (ulonglong *) *xpp;
#line 3297
    xp += ni;
#line 3297
    tp += ni;
#line 3297
    *xpp = (void*)xp;
#line 3297
  }
#line 3297
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3297

#line 3297
#else   /* not SX */
#line 3297
	const char *xp = (const char *) *xpp;
#line 3297
	int status = ENOERR;
#line 3297

#line 3297
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3297
	{
#line 3297
		const int lstatus = ncx_get_ulonglong_int(xp, tp);
#line 3297
		if(lstatus != ENOERR)
#line 3297
			status = lstatus;
#line 3297
	}
#line 3297

#line 3297
	*xpp = (const void *)xp;
#line 3297
	return status;
#line 3297
#  endif
#line 3297
}
#line 3297

int
#line 3298
ncx_getn_ulonglong_float(const void **xpp, size_t nelems, float *tp)
#line 3298
{
#line 3298
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3298

#line 3298
 /* basic algorithm is:
#line 3298
  *   - ensure sane alignment of input data
#line 3298
  *   - copy (conversion happens automatically) input data
#line 3298
  *     to output
#line 3298
  *   - update xpp to point at next unconverted input, and tp to point
#line 3298
  *     at next location for converted output
#line 3298
  */
#line 3298
  long i, j, ni;
#line 3298
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3298
  ulonglong *xp;
#line 3298
  int nrange = 0;         /* number of range errors */
#line 3298
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3298
  long cxp = (long) *((char**)xpp);
#line 3298

#line 3298
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3298
  /* sjl: manually stripmine so we can limit amount of
#line 3298
   * vector work space reserved to LOOPCNT elements. Also
#line 3298
   * makes vectorisation easy */
#line 3298
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3298
    ni=Min(nelems-j,LOOPCNT);
#line 3298
    if (realign) {
#line 3298
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3298
      xp = tmp;
#line 3298
    } else {
#line 3298
      xp = (ulonglong *) *xpp;
#line 3298
    }
#line 3298
   /* copy the next block */
#line 3298
#pragma cdir loopcnt=LOOPCNT
#line 3298
#pragma cdir shortloop
#line 3298
    for (i=0; i<ni; i++) {
#line 3298
      tp[i] = (float) Max( FLOAT_MIN, Min(FLOAT_MAX, (float) xp[i]));
#line 3298
     /* test for range errors (not always needed but do it anyway) */
#line 3298
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3298
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3298
      nrange += xp[i] > FLOAT_MAX ;
#line 3298
    }
#line 3298
   /* update xpp and tp */
#line 3298
    if (realign) xp = (ulonglong *) *xpp;
#line 3298
    xp += ni;
#line 3298
    tp += ni;
#line 3298
    *xpp = (void*)xp;
#line 3298
  }
#line 3298
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3298

#line 3298
#else   /* not SX */
#line 3298
	const char *xp = (const char *) *xpp;
#line 3298
	int status = ENOERR;
#line 3298

#line 3298
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3298
	{
#line 3298
		const int lstatus = ncx_get_ulonglong_float(xp, tp);
#line 3298
		if(lstatus != ENOERR)
#line 3298
			status = lstatus;
#line 3298
	}
#line 3298

#line 3298
	*xpp = (const void *)xp;
#line 3298
	return status;
#line 3298
#  endif
#line 3298
}
#line 3298

int
#line 3299
ncx_getn_ulonglong_double(const void **xpp, size_t nelems, double *tp)
#line 3299
{
#line 3299
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3299

#line 3299
 /* basic algorithm is:
#line 3299
  *   - ensure sane alignment of input data
#line 3299
  *   - copy (conversion happens automatically) input data
#line 3299
  *     to output
#line 3299
  *   - update xpp to point at next unconverted input, and tp to point
#line 3299
  *     at next location for converted output
#line 3299
  */
#line 3299
  long i, j, ni;
#line 3299
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3299
  ulonglong *xp;
#line 3299
  int nrange = 0;         /* number of range errors */
#line 3299
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3299
  long cxp = (long) *((char**)xpp);
#line 3299

#line 3299
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3299
  /* sjl: manually stripmine so we can limit amount of
#line 3299
   * vector work space reserved to LOOPCNT elements. Also
#line 3299
   * makes vectorisation easy */
#line 3299
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3299
    ni=Min(nelems-j,LOOPCNT);
#line 3299
    if (realign) {
#line 3299
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3299
      xp = tmp;
#line 3299
    } else {
#line 3299
      xp = (ulonglong *) *xpp;
#line 3299
    }
#line 3299
   /* copy the next block */
#line 3299
#pragma cdir loopcnt=LOOPCNT
#line 3299
#pragma cdir shortloop
#line 3299
    for (i=0; i<ni; i++) {
#line 3299
      tp[i] = (double) Max( DOUBLE_MIN, Min(DOUBLE_MAX, (double) xp[i]));
#line 3299
     /* test for range errors (not always needed but do it anyway) */
#line 3299
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3299
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3299
      nrange += xp[i] > DOUBLE_MAX ;
#line 3299
    }
#line 3299
   /* update xpp and tp */
#line 3299
    if (realign) xp = (ulonglong *) *xpp;
#line 3299
    xp += ni;
#line 3299
    tp += ni;
#line 3299
    *xpp = (void*)xp;
#line 3299
  }
#line 3299
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3299

#line 3299
#else   /* not SX */
#line 3299
	const char *xp = (const char *) *xpp;
#line 3299
	int status = ENOERR;
#line 3299

#line 3299
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3299
	{
#line 3299
		const int lstatus = ncx_get_ulonglong_double(xp, tp);
#line 3299
		if(lstatus != ENOERR)
#line 3299
			status = lstatus;
#line 3299
	}
#line 3299

#line 3299
	*xpp = (const void *)xp;
#line 3299
	return status;
#line 3299
#  endif
#line 3299
}
#line 3299

int
#line 3300
ncx_getn_ulonglong_longlong(const void **xpp, size_t nelems, longlong *tp)
#line 3300
{
#line 3300
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3300

#line 3300
 /* basic algorithm is:
#line 3300
  *   - ensure sane alignment of input data
#line 3300
  *   - copy (conversion happens automatically) input data
#line 3300
  *     to output
#line 3300
  *   - update xpp to point at next unconverted input, and tp to point
#line 3300
  *     at next location for converted output
#line 3300
  */
#line 3300
  long i, j, ni;
#line 3300
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3300
  ulonglong *xp;
#line 3300
  int nrange = 0;         /* number of range errors */
#line 3300
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3300
  long cxp = (long) *((char**)xpp);
#line 3300

#line 3300
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3300
  /* sjl: manually stripmine so we can limit amount of
#line 3300
   * vector work space reserved to LOOPCNT elements. Also
#line 3300
   * makes vectorisation easy */
#line 3300
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3300
    ni=Min(nelems-j,LOOPCNT);
#line 3300
    if (realign) {
#line 3300
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3300
      xp = tmp;
#line 3300
    } else {
#line 3300
      xp = (ulonglong *) *xpp;
#line 3300
    }
#line 3300
   /* copy the next block */
#line 3300
#pragma cdir loopcnt=LOOPCNT
#line 3300
#pragma cdir shortloop
#line 3300
    for (i=0; i<ni; i++) {
#line 3300
      tp[i] = (longlong) Max( LONGLONG_MIN, Min(LONGLONG_MAX, (longlong) xp[i]));
#line 3300
     /* test for range errors (not always needed but do it anyway) */
#line 3300
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3300
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3300
      nrange += xp[i] > LONGLONG_MAX ;
#line 3300
    }
#line 3300
   /* update xpp and tp */
#line 3300
    if (realign) xp = (ulonglong *) *xpp;
#line 3300
    xp += ni;
#line 3300
    tp += ni;
#line 3300
    *xpp = (void*)xp;
#line 3300
  }
#line 3300
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3300

#line 3300
#else   /* not SX */
#line 3300
	const char *xp = (const char *) *xpp;
#line 3300
	int status = ENOERR;
#line 3300

#line 3300
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3300
	{
#line 3300
		const int lstatus = ncx_get_ulonglong_longlong(xp, tp);
#line 3300
		if(lstatus != ENOERR)
#line 3300
			status = lstatus;
#line 3300
	}
#line 3300

#line 3300
	*xpp = (const void *)xp;
#line 3300
	return status;
#line 3300
#  endif
#line 3300
}
#line 3300

int
#line 3301
ncx_getn_ulonglong_uchar(const void **xpp, size_t nelems, uchar *tp)
#line 3301
{
#line 3301
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3301

#line 3301
 /* basic algorithm is:
#line 3301
  *   - ensure sane alignment of input data
#line 3301
  *   - copy (conversion happens automatically) input data
#line 3301
  *     to output
#line 3301
  *   - update xpp to point at next unconverted input, and tp to point
#line 3301
  *     at next location for converted output
#line 3301
  */
#line 3301
  long i, j, ni;
#line 3301
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3301
  ulonglong *xp;
#line 3301
  int nrange = 0;         /* number of range errors */
#line 3301
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3301
  long cxp = (long) *((char**)xpp);
#line 3301

#line 3301
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3301
  /* sjl: manually stripmine so we can limit amount of
#line 3301
   * vector work space reserved to LOOPCNT elements. Also
#line 3301
   * makes vectorisation easy */
#line 3301
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3301
    ni=Min(nelems-j,LOOPCNT);
#line 3301
    if (realign) {
#line 3301
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3301
      xp = tmp;
#line 3301
    } else {
#line 3301
      xp = (ulonglong *) *xpp;
#line 3301
    }
#line 3301
   /* copy the next block */
#line 3301
#pragma cdir loopcnt=LOOPCNT
#line 3301
#pragma cdir shortloop
#line 3301
    for (i=0; i<ni; i++) {
#line 3301
      tp[i] = (uchar) Max( UCHAR_MIN, Min(UCHAR_MAX, (uchar) xp[i]));
#line 3301
     /* test for range errors (not always needed but do it anyway) */
#line 3301
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3301
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3301
      nrange += xp[i] > UCHAR_MAX ;
#line 3301
    }
#line 3301
   /* update xpp and tp */
#line 3301
    if (realign) xp = (ulonglong *) *xpp;
#line 3301
    xp += ni;
#line 3301
    tp += ni;
#line 3301
    *xpp = (void*)xp;
#line 3301
  }
#line 3301
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3301

#line 3301
#else   /* not SX */
#line 3301
	const char *xp = (const char *) *xpp;
#line 3301
	int status = ENOERR;
#line 3301

#line 3301
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3301
	{
#line 3301
		const int lstatus = ncx_get_ulonglong_uchar(xp, tp);
#line 3301
		if(lstatus != ENOERR)
#line 3301
			status = lstatus;
#line 3301
	}
#line 3301

#line 3301
	*xpp = (const void *)xp;
#line 3301
	return status;
#line 3301
#  endif
#line 3301
}
#line 3301

int
#line 3302
ncx_getn_ulonglong_ushort(const void **xpp, size_t nelems, ushort *tp)
#line 3302
{
#line 3302
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3302

#line 3302
 /* basic algorithm is:
#line 3302
  *   - ensure sane alignment of input data
#line 3302
  *   - copy (conversion happens automatically) input data
#line 3302
  *     to output
#line 3302
  *   - update xpp to point at next unconverted input, and tp to point
#line 3302
  *     at next location for converted output
#line 3302
  */
#line 3302
  long i, j, ni;
#line 3302
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3302
  ulonglong *xp;
#line 3302
  int nrange = 0;         /* number of range errors */
#line 3302
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3302
  long cxp = (long) *((char**)xpp);
#line 3302

#line 3302
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3302
  /* sjl: manually stripmine so we can limit amount of
#line 3302
   * vector work space reserved to LOOPCNT elements. Also
#line 3302
   * makes vectorisation easy */
#line 3302
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3302
    ni=Min(nelems-j,LOOPCNT);
#line 3302
    if (realign) {
#line 3302
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3302
      xp = tmp;
#line 3302
    } else {
#line 3302
      xp = (ulonglong *) *xpp;
#line 3302
    }
#line 3302
   /* copy the next block */
#line 3302
#pragma cdir loopcnt=LOOPCNT
#line 3302
#pragma cdir shortloop
#line 3302
    for (i=0; i<ni; i++) {
#line 3302
      tp[i] = (ushort) Max( USHORT_MIN, Min(USHORT_MAX, (ushort) xp[i]));
#line 3302
     /* test for range errors (not always needed but do it anyway) */
#line 3302
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3302
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3302
      nrange += xp[i] > USHORT_MAX ;
#line 3302
    }
#line 3302
   /* update xpp and tp */
#line 3302
    if (realign) xp = (ulonglong *) *xpp;
#line 3302
    xp += ni;
#line 3302
    tp += ni;
#line 3302
    *xpp = (void*)xp;
#line 3302
  }
#line 3302
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3302

#line 3302
#else   /* not SX */
#line 3302
	const char *xp = (const char *) *xpp;
#line 3302
	int status = ENOERR;
#line 3302

#line 3302
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3302
	{
#line 3302
		const int lstatus = ncx_get_ulonglong_ushort(xp, tp);
#line 3302
		if(lstatus != ENOERR)
#line 3302
			status = lstatus;
#line 3302
	}
#line 3302

#line 3302
	*xpp = (const void *)xp;
#line 3302
	return status;
#line 3302
#  endif
#line 3302
}
#line 3302

int
#line 3303
ncx_getn_ulonglong_uint(const void **xpp, size_t nelems, uint *tp)
#line 3303
{
#line 3303
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3303

#line 3303
 /* basic algorithm is:
#line 3303
  *   - ensure sane alignment of input data
#line 3303
  *   - copy (conversion happens automatically) input data
#line 3303
  *     to output
#line 3303
  *   - update xpp to point at next unconverted input, and tp to point
#line 3303
  *     at next location for converted output
#line 3303
  */
#line 3303
  long i, j, ni;
#line 3303
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3303
  ulonglong *xp;
#line 3303
  int nrange = 0;         /* number of range errors */
#line 3303
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3303
  long cxp = (long) *((char**)xpp);
#line 3303

#line 3303
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3303
  /* sjl: manually stripmine so we can limit amount of
#line 3303
   * vector work space reserved to LOOPCNT elements. Also
#line 3303
   * makes vectorisation easy */
#line 3303
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3303
    ni=Min(nelems-j,LOOPCNT);
#line 3303
    if (realign) {
#line 3303
      memcpy(tmp, *xpp, ni*SIZEOF_ULONGLONG);
#line 3303
      xp = tmp;
#line 3303
    } else {
#line 3303
      xp = (ulonglong *) *xpp;
#line 3303
    }
#line 3303
   /* copy the next block */
#line 3303
#pragma cdir loopcnt=LOOPCNT
#line 3303
#pragma cdir shortloop
#line 3303
    for (i=0; i<ni; i++) {
#line 3303
      tp[i] = (uint) Max( UINT_MIN, Min(UINT_MAX, (uint) xp[i]));
#line 3303
     /* test for range errors (not always needed but do it anyway) */
#line 3303
     /* if xpp is unsigned, we need not check if xp[i] < _MIN */
#line 3303
     /* if xpp is signed && tp is unsigned, we need check if xp[i] >= 0 */
#line 3303
      nrange += xp[i] > UINT_MAX ;
#line 3303
    }
#line 3303
   /* update xpp and tp */
#line 3303
    if (realign) xp = (ulonglong *) *xpp;
#line 3303
    xp += ni;
#line 3303
    tp += ni;
#line 3303
    *xpp = (void*)xp;
#line 3303
  }
#line 3303
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3303

#line 3303
#else   /* not SX */
#line 3303
	const char *xp = (const char *) *xpp;
#line 3303
	int status = ENOERR;
#line 3303

#line 3303
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3303
	{
#line 3303
		const int lstatus = ncx_get_ulonglong_uint(xp, tp);
#line 3303
		if(lstatus != ENOERR)
#line 3303
			status = lstatus;
#line 3303
	}
#line 3303

#line 3303
	*xpp = (const void *)xp;
#line 3303
	return status;
#line 3303
#  endif
#line 3303
}
#line 3303


#if X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
/* optimized version */
int
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const unsigned long long *tp)
{
#ifdef WORDS_BIGENDIAN
	(void) memcpy(*xpp, tp, nelems * X_SIZEOF_ULONGLONG);
# else
	swapn8b(*xpp, tp, nelems);
# endif
	*xpp = (void *)((char *)(*xpp) + nelems * X_SIZEOF_ULONGLONG);
	return ENOERR;
}
#else
int
#line 3319
ncx_putn_ulonglong_ulonglong(void **xpp, size_t nelems, const ulonglong *tp)
#line 3319
{
#line 3319
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3319

#line 3319
 /* basic algorithm is:
#line 3319
  *   - ensure sane alignment of output data
#line 3319
  *   - copy (conversion happens automatically) input data
#line 3319
  *     to output
#line 3319
  *   - update tp to point at next unconverted input, and xpp to point
#line 3319
  *     at next location for converted output
#line 3319
  */
#line 3319
  long i, j, ni;
#line 3319
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3319
  ulonglong *xp;
#line 3319
  int nrange = 0;         /* number of range errors */
#line 3319
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3319
  long cxp = (long) *((char**)xpp);
#line 3319

#line 3319
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3319
  /* sjl: manually stripmine so we can limit amount of
#line 3319
   * vector work space reserved to LOOPCNT elements. Also
#line 3319
   * makes vectorisation easy */
#line 3319
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3319
    ni=Min(nelems-j,LOOPCNT);
#line 3319
    if (realign) {
#line 3319
      xp = tmp;
#line 3319
    } else {
#line 3319
      xp = (ulonglong *) *xpp;
#line 3319
    }
#line 3319
   /* copy the next block */
#line 3319
#pragma cdir loopcnt=LOOPCNT
#line 3319
#pragma cdir shortloop
#line 3319
    for (i=0; i<ni; i++) {
#line 3319
      /* the normal case: */
#line 3319
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3319
     /* test for range errors (not always needed but do it anyway) */
#line 3319
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3319
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3319
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3319
    }
#line 3319
   /* copy workspace back if necessary */
#line 3319
    if (realign) {
#line 3319
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3319
      xp = (ulonglong *) *xpp;
#line 3319
    }
#line 3319
   /* update xpp and tp */
#line 3319
    xp += ni;
#line 3319
    tp += ni;
#line 3319
    *xpp = (void*)xp;
#line 3319
  }
#line 3319
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3319

#line 3319
#else   /* not SX */
#line 3319

#line 3319
	char *xp = (char *) *xpp;
#line 3319
	int status = ENOERR;
#line 3319

#line 3319
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3319
	{
#line 3319
		int lstatus = ncx_put_ulonglong_ulonglong(xp, tp);
#line 3319
		if(lstatus != ENOERR)
#line 3319
			status = lstatus;
#line 3319
	}
#line 3319

#line 3319
	*xpp = (void *)xp;
#line 3319
	return status;
#line 3319
#endif
#line 3319
}
#line 3319

#endif
int
#line 3321
ncx_putn_ulonglong_schar(void **xpp, size_t nelems, const schar *tp)
#line 3321
{
#line 3321
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3321

#line 3321
 /* basic algorithm is:
#line 3321
  *   - ensure sane alignment of output data
#line 3321
  *   - copy (conversion happens automatically) input data
#line 3321
  *     to output
#line 3321
  *   - update tp to point at next unconverted input, and xpp to point
#line 3321
  *     at next location for converted output
#line 3321
  */
#line 3321
  long i, j, ni;
#line 3321
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3321
  ulonglong *xp;
#line 3321
  int nrange = 0;         /* number of range errors */
#line 3321
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3321
  long cxp = (long) *((char**)xpp);
#line 3321

#line 3321
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3321
  /* sjl: manually stripmine so we can limit amount of
#line 3321
   * vector work space reserved to LOOPCNT elements. Also
#line 3321
   * makes vectorisation easy */
#line 3321
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3321
    ni=Min(nelems-j,LOOPCNT);
#line 3321
    if (realign) {
#line 3321
      xp = tmp;
#line 3321
    } else {
#line 3321
      xp = (ulonglong *) *xpp;
#line 3321
    }
#line 3321
   /* copy the next block */
#line 3321
#pragma cdir loopcnt=LOOPCNT
#line 3321
#pragma cdir shortloop
#line 3321
    for (i=0; i<ni; i++) {
#line 3321
      /* the normal case: */
#line 3321
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3321
     /* test for range errors (not always needed but do it anyway) */
#line 3321
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3321
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3321
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3321
    }
#line 3321
   /* copy workspace back if necessary */
#line 3321
    if (realign) {
#line 3321
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3321
      xp = (ulonglong *) *xpp;
#line 3321
    }
#line 3321
   /* update xpp and tp */
#line 3321
    xp += ni;
#line 3321
    tp += ni;
#line 3321
    *xpp = (void*)xp;
#line 3321
  }
#line 3321
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3321

#line 3321
#else   /* not SX */
#line 3321

#line 3321
	char *xp = (char *) *xpp;
#line 3321
	int status = ENOERR;
#line 3321

#line 3321
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3321
	{
#line 3321
		int lstatus = ncx_put_ulonglong_schar(xp, tp);
#line 3321
		if(lstatus != ENOERR)
#line 3321
			status = lstatus;
#line 3321
	}
#line 3321

#line 3321
	*xpp = (void *)xp;
#line 3321
	return status;
#line 3321
#endif
#line 3321
}
#line 3321

int
#line 3322
ncx_putn_ulonglong_short(void **xpp, size_t nelems, const short *tp)
#line 3322
{
#line 3322
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3322

#line 3322
 /* basic algorithm is:
#line 3322
  *   - ensure sane alignment of output data
#line 3322
  *   - copy (conversion happens automatically) input data
#line 3322
  *     to output
#line 3322
  *   - update tp to point at next unconverted input, and xpp to point
#line 3322
  *     at next location for converted output
#line 3322
  */
#line 3322
  long i, j, ni;
#line 3322
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3322
  ulonglong *xp;
#line 3322
  int nrange = 0;         /* number of range errors */
#line 3322
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3322
  long cxp = (long) *((char**)xpp);
#line 3322

#line 3322
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3322
  /* sjl: manually stripmine so we can limit amount of
#line 3322
   * vector work space reserved to LOOPCNT elements. Also
#line 3322
   * makes vectorisation easy */
#line 3322
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3322
    ni=Min(nelems-j,LOOPCNT);
#line 3322
    if (realign) {
#line 3322
      xp = tmp;
#line 3322
    } else {
#line 3322
      xp = (ulonglong *) *xpp;
#line 3322
    }
#line 3322
   /* copy the next block */
#line 3322
#pragma cdir loopcnt=LOOPCNT
#line 3322
#pragma cdir shortloop
#line 3322
    for (i=0; i<ni; i++) {
#line 3322
      /* the normal case: */
#line 3322
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3322
     /* test for range errors (not always needed but do it anyway) */
#line 3322
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3322
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3322
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3322
    }
#line 3322
   /* copy workspace back if necessary */
#line 3322
    if (realign) {
#line 3322
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3322
      xp = (ulonglong *) *xpp;
#line 3322
    }
#line 3322
   /* update xpp and tp */
#line 3322
    xp += ni;
#line 3322
    tp += ni;
#line 3322
    *xpp = (void*)xp;
#line 3322
  }
#line 3322
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3322

#line 3322
#else   /* not SX */
#line 3322

#line 3322
	char *xp = (char *) *xpp;
#line 3322
	int status = ENOERR;
#line 3322

#line 3322
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3322
	{
#line 3322
		int lstatus = ncx_put_ulonglong_short(xp, tp);
#line 3322
		if(lstatus != ENOERR)
#line 3322
			status = lstatus;
#line 3322
	}
#line 3322

#line 3322
	*xpp = (void *)xp;
#line 3322
	return status;
#line 3322
#endif
#line 3322
}
#line 3322

int
#line 3323
ncx_putn_ulonglong_int(void **xpp, size_t nelems, const int *tp)
#line 3323
{
#line 3323
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3323

#line 3323
 /* basic algorithm is:
#line 3323
  *   - ensure sane alignment of output data
#line 3323
  *   - copy (conversion happens automatically) input data
#line 3323
  *     to output
#line 3323
  *   - update tp to point at next unconverted input, and xpp to point
#line 3323
  *     at next location for converted output
#line 3323
  */
#line 3323
  long i, j, ni;
#line 3323
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3323
  ulonglong *xp;
#line 3323
  int nrange = 0;         /* number of range errors */
#line 3323
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3323
  long cxp = (long) *((char**)xpp);
#line 3323

#line 3323
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3323
  /* sjl: manually stripmine so we can limit amount of
#line 3323
   * vector work space reserved to LOOPCNT elements. Also
#line 3323
   * makes vectorisation easy */
#line 3323
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3323
    ni=Min(nelems-j,LOOPCNT);
#line 3323
    if (realign) {
#line 3323
      xp = tmp;
#line 3323
    } else {
#line 3323
      xp = (ulonglong *) *xpp;
#line 3323
    }
#line 3323
   /* copy the next block */
#line 3323
#pragma cdir loopcnt=LOOPCNT
#line 3323
#pragma cdir shortloop
#line 3323
    for (i=0; i<ni; i++) {
#line 3323
      /* the normal case: */
#line 3323
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3323
     /* test for range errors (not always needed but do it anyway) */
#line 3323
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3323
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3323
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3323
    }
#line 3323
   /* copy workspace back if necessary */
#line 3323
    if (realign) {
#line 3323
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3323
      xp = (ulonglong *) *xpp;
#line 3323
    }
#line 3323
   /* update xpp and tp */
#line 3323
    xp += ni;
#line 3323
    tp += ni;
#line 3323
    *xpp = (void*)xp;
#line 3323
  }
#line 3323
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3323

#line 3323
#else   /* not SX */
#line 3323

#line 3323
	char *xp = (char *) *xpp;
#line 3323
	int status = ENOERR;
#line 3323

#line 3323
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3323
	{
#line 3323
		int lstatus = ncx_put_ulonglong_int(xp, tp);
#line 3323
		if(lstatus != ENOERR)
#line 3323
			status = lstatus;
#line 3323
	}
#line 3323

#line 3323
	*xpp = (void *)xp;
#line 3323
	return status;
#line 3323
#endif
#line 3323
}
#line 3323

int
#line 3324
ncx_putn_ulonglong_float(void **xpp, size_t nelems, const float *tp)
#line 3324
{
#line 3324
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3324

#line 3324
 /* basic algorithm is:
#line 3324
  *   - ensure sane alignment of output data
#line 3324
  *   - copy (conversion happens automatically) input data
#line 3324
  *     to output
#line 3324
  *   - update tp to point at next unconverted input, and xpp to point
#line 3324
  *     at next location for converted output
#line 3324
  */
#line 3324
  long i, j, ni;
#line 3324
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3324
  ulonglong *xp;
#line 3324
  int nrange = 0;         /* number of range errors */
#line 3324
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3324
  long cxp = (long) *((char**)xpp);
#line 3324

#line 3324
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3324
  /* sjl: manually stripmine so we can limit amount of
#line 3324
   * vector work space reserved to LOOPCNT elements. Also
#line 3324
   * makes vectorisation easy */
#line 3324
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3324
    ni=Min(nelems-j,LOOPCNT);
#line 3324
    if (realign) {
#line 3324
      xp = tmp;
#line 3324
    } else {
#line 3324
      xp = (ulonglong *) *xpp;
#line 3324
    }
#line 3324
   /* copy the next block */
#line 3324
#pragma cdir loopcnt=LOOPCNT
#line 3324
#pragma cdir shortloop
#line 3324
    for (i=0; i<ni; i++) {
#line 3324
      /* the normal case: */
#line 3324
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3324
     /* test for range errors (not always needed but do it anyway) */
#line 3324
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3324
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3324
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3324
    }
#line 3324
   /* copy workspace back if necessary */
#line 3324
    if (realign) {
#line 3324
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3324
      xp = (ulonglong *) *xpp;
#line 3324
    }
#line 3324
   /* update xpp and tp */
#line 3324
    xp += ni;
#line 3324
    tp += ni;
#line 3324
    *xpp = (void*)xp;
#line 3324
  }
#line 3324
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3324

#line 3324
#else   /* not SX */
#line 3324

#line 3324
	char *xp = (char *) *xpp;
#line 3324
	int status = ENOERR;
#line 3324

#line 3324
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3324
	{
#line 3324
		int lstatus = ncx_put_ulonglong_float(xp, tp);
#line 3324
		if(lstatus != ENOERR)
#line 3324
			status = lstatus;
#line 3324
	}
#line 3324

#line 3324
	*xpp = (void *)xp;
#line 3324
	return status;
#line 3324
#endif
#line 3324
}
#line 3324

int
#line 3325
ncx_putn_ulonglong_double(void **xpp, size_t nelems, const double *tp)
#line 3325
{
#line 3325
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3325

#line 3325
 /* basic algorithm is:
#line 3325
  *   - ensure sane alignment of output data
#line 3325
  *   - copy (conversion happens automatically) input data
#line 3325
  *     to output
#line 3325
  *   - update tp to point at next unconverted input, and xpp to point
#line 3325
  *     at next location for converted output
#line 3325
  */
#line 3325
  long i, j, ni;
#line 3325
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3325
  ulonglong *xp;
#line 3325
  int nrange = 0;         /* number of range errors */
#line 3325
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3325
  long cxp = (long) *((char**)xpp);
#line 3325

#line 3325
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3325
  /* sjl: manually stripmine so we can limit amount of
#line 3325
   * vector work space reserved to LOOPCNT elements. Also
#line 3325
   * makes vectorisation easy */
#line 3325
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3325
    ni=Min(nelems-j,LOOPCNT);
#line 3325
    if (realign) {
#line 3325
      xp = tmp;
#line 3325
    } else {
#line 3325
      xp = (ulonglong *) *xpp;
#line 3325
    }
#line 3325
   /* copy the next block */
#line 3325
#pragma cdir loopcnt=LOOPCNT
#line 3325
#pragma cdir shortloop
#line 3325
    for (i=0; i<ni; i++) {
#line 3325
      /* the normal case: */
#line 3325
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3325
     /* test for range errors (not always needed but do it anyway) */
#line 3325
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3325
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3325
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3325
    }
#line 3325
   /* copy workspace back if necessary */
#line 3325
    if (realign) {
#line 3325
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3325
      xp = (ulonglong *) *xpp;
#line 3325
    }
#line 3325
   /* update xpp and tp */
#line 3325
    xp += ni;
#line 3325
    tp += ni;
#line 3325
    *xpp = (void*)xp;
#line 3325
  }
#line 3325
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3325

#line 3325
#else   /* not SX */
#line 3325

#line 3325
	char *xp = (char *) *xpp;
#line 3325
	int status = ENOERR;
#line 3325

#line 3325
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3325
	{
#line 3325
		int lstatus = ncx_put_ulonglong_double(xp, tp);
#line 3325
		if(lstatus != ENOERR)
#line 3325
			status = lstatus;
#line 3325
	}
#line 3325

#line 3325
	*xpp = (void *)xp;
#line 3325
	return status;
#line 3325
#endif
#line 3325
}
#line 3325

int
#line 3326
ncx_putn_ulonglong_longlong(void **xpp, size_t nelems, const longlong *tp)
#line 3326
{
#line 3326
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3326

#line 3326
 /* basic algorithm is:
#line 3326
  *   - ensure sane alignment of output data
#line 3326
  *   - copy (conversion happens automatically) input data
#line 3326
  *     to output
#line 3326
  *   - update tp to point at next unconverted input, and xpp to point
#line 3326
  *     at next location for converted output
#line 3326
  */
#line 3326
  long i, j, ni;
#line 3326
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3326
  ulonglong *xp;
#line 3326
  int nrange = 0;         /* number of range errors */
#line 3326
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3326
  long cxp = (long) *((char**)xpp);
#line 3326

#line 3326
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3326
  /* sjl: manually stripmine so we can limit amount of
#line 3326
   * vector work space reserved to LOOPCNT elements. Also
#line 3326
   * makes vectorisation easy */
#line 3326
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3326
    ni=Min(nelems-j,LOOPCNT);
#line 3326
    if (realign) {
#line 3326
      xp = tmp;
#line 3326
    } else {
#line 3326
      xp = (ulonglong *) *xpp;
#line 3326
    }
#line 3326
   /* copy the next block */
#line 3326
#pragma cdir loopcnt=LOOPCNT
#line 3326
#pragma cdir shortloop
#line 3326
    for (i=0; i<ni; i++) {
#line 3326
      /* the normal case: */
#line 3326
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3326
     /* test for range errors (not always needed but do it anyway) */
#line 3326
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3326
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3326
      nrange += tp[i] > X_ULONGLONG_MAX || tp[i] < 0;
#line 3326
    }
#line 3326
   /* copy workspace back if necessary */
#line 3326
    if (realign) {
#line 3326
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3326
      xp = (ulonglong *) *xpp;
#line 3326
    }
#line 3326
   /* update xpp and tp */
#line 3326
    xp += ni;
#line 3326
    tp += ni;
#line 3326
    *xpp = (void*)xp;
#line 3326
  }
#line 3326
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3326

#line 3326
#else   /* not SX */
#line 3326

#line 3326
	char *xp = (char *) *xpp;
#line 3326
	int status = ENOERR;
#line 3326

#line 3326
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3326
	{
#line 3326
		int lstatus = ncx_put_ulonglong_longlong(xp, tp);
#line 3326
		if(lstatus != ENOERR)
#line 3326
			status = lstatus;
#line 3326
	}
#line 3326

#line 3326
	*xpp = (void *)xp;
#line 3326
	return status;
#line 3326
#endif
#line 3326
}
#line 3326

int
#line 3327
ncx_putn_ulonglong_uchar(void **xpp, size_t nelems, const uchar *tp)
#line 3327
{
#line 3327
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3327

#line 3327
 /* basic algorithm is:
#line 3327
  *   - ensure sane alignment of output data
#line 3327
  *   - copy (conversion happens automatically) input data
#line 3327
  *     to output
#line 3327
  *   - update tp to point at next unconverted input, and xpp to point
#line 3327
  *     at next location for converted output
#line 3327
  */
#line 3327
  long i, j, ni;
#line 3327
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3327
  ulonglong *xp;
#line 3327
  int nrange = 0;         /* number of range errors */
#line 3327
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3327
  long cxp = (long) *((char**)xpp);
#line 3327

#line 3327
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3327
  /* sjl: manually stripmine so we can limit amount of
#line 3327
   * vector work space reserved to LOOPCNT elements. Also
#line 3327
   * makes vectorisation easy */
#line 3327
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3327
    ni=Min(nelems-j,LOOPCNT);
#line 3327
    if (realign) {
#line 3327
      xp = tmp;
#line 3327
    } else {
#line 3327
      xp = (ulonglong *) *xpp;
#line 3327
    }
#line 3327
   /* copy the next block */
#line 3327
#pragma cdir loopcnt=LOOPCNT
#line 3327
#pragma cdir shortloop
#line 3327
    for (i=0; i<ni; i++) {
#line 3327
      /* the normal case: */
#line 3327
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3327
     /* test for range errors (not always needed but do it anyway) */
#line 3327
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3327
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3327
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3327
    }
#line 3327
   /* copy workspace back if necessary */
#line 3327
    if (realign) {
#line 3327
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3327
      xp = (ulonglong *) *xpp;
#line 3327
    }
#line 3327
   /* update xpp and tp */
#line 3327
    xp += ni;
#line 3327
    tp += ni;
#line 3327
    *xpp = (void*)xp;
#line 3327
  }
#line 3327
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3327

#line 3327
#else   /* not SX */
#line 3327

#line 3327
	char *xp = (char *) *xpp;
#line 3327
	int status = ENOERR;
#line 3327

#line 3327
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3327
	{
#line 3327
		int lstatus = ncx_put_ulonglong_uchar(xp, tp);
#line 3327
		if(lstatus != ENOERR)
#line 3327
			status = lstatus;
#line 3327
	}
#line 3327

#line 3327
	*xpp = (void *)xp;
#line 3327
	return status;
#line 3327
#endif
#line 3327
}
#line 3327

int
#line 3328
ncx_putn_ulonglong_ushort(void **xpp, size_t nelems, const ushort *tp)
#line 3328
{
#line 3328
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3328

#line 3328
 /* basic algorithm is:
#line 3328
  *   - ensure sane alignment of output data
#line 3328
  *   - copy (conversion happens automatically) input data
#line 3328
  *     to output
#line 3328
  *   - update tp to point at next unconverted input, and xpp to point
#line 3328
  *     at next location for converted output
#line 3328
  */
#line 3328
  long i, j, ni;
#line 3328
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3328
  ulonglong *xp;
#line 3328
  int nrange = 0;         /* number of range errors */
#line 3328
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3328
  long cxp = (long) *((char**)xpp);
#line 3328

#line 3328
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3328
  /* sjl: manually stripmine so we can limit amount of
#line 3328
   * vector work space reserved to LOOPCNT elements. Also
#line 3328
   * makes vectorisation easy */
#line 3328
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3328
    ni=Min(nelems-j,LOOPCNT);
#line 3328
    if (realign) {
#line 3328
      xp = tmp;
#line 3328
    } else {
#line 3328
      xp = (ulonglong *) *xpp;
#line 3328
    }
#line 3328
   /* copy the next block */
#line 3328
#pragma cdir loopcnt=LOOPCNT
#line 3328
#pragma cdir shortloop
#line 3328
    for (i=0; i<ni; i++) {
#line 3328
      /* the normal case: */
#line 3328
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3328
     /* test for range errors (not always needed but do it anyway) */
#line 3328
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3328
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3328
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3328
    }
#line 3328
   /* copy workspace back if necessary */
#line 3328
    if (realign) {
#line 3328
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3328
      xp = (ulonglong *) *xpp;
#line 3328
    }
#line 3328
   /* update xpp and tp */
#line 3328
    xp += ni;
#line 3328
    tp += ni;
#line 3328
    *xpp = (void*)xp;
#line 3328
  }
#line 3328
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3328

#line 3328
#else   /* not SX */
#line 3328

#line 3328
	char *xp = (char *) *xpp;
#line 3328
	int status = ENOERR;
#line 3328

#line 3328
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3328
	{
#line 3328
		int lstatus = ncx_put_ulonglong_ushort(xp, tp);
#line 3328
		if(lstatus != ENOERR)
#line 3328
			status = lstatus;
#line 3328
	}
#line 3328

#line 3328
	*xpp = (void *)xp;
#line 3328
	return status;
#line 3328
#endif
#line 3328
}
#line 3328

int
#line 3329
ncx_putn_ulonglong_uint(void **xpp, size_t nelems, const uint *tp)
#line 3329
{
#line 3329
#if _SX && X_SIZEOF_ULONGLONG == SIZEOF_ULONGLONG
#line 3329

#line 3329
 /* basic algorithm is:
#line 3329
  *   - ensure sane alignment of output data
#line 3329
  *   - copy (conversion happens automatically) input data
#line 3329
  *     to output
#line 3329
  *   - update tp to point at next unconverted input, and xpp to point
#line 3329
  *     at next location for converted output
#line 3329
  */
#line 3329
  long i, j, ni;
#line 3329
  ulonglong tmp[LOOPCNT];        /* in case input is misaligned */
#line 3329
  ulonglong *xp;
#line 3329
  int nrange = 0;         /* number of range errors */
#line 3329
  int realign = 0;        /* "do we need to fix input data alignment?" */
#line 3329
  long cxp = (long) *((char**)xpp);
#line 3329

#line 3329
  realign = (cxp & 7) % SIZEOF_ULONGLONG;
#line 3329
  /* sjl: manually stripmine so we can limit amount of
#line 3329
   * vector work space reserved to LOOPCNT elements. Also
#line 3329
   * makes vectorisation easy */
#line 3329
  for (j=0; j<nelems && nrange==0; j+=LOOPCNT) {
#line 3329
    ni=Min(nelems-j,LOOPCNT);
#line 3329
    if (realign) {
#line 3329
      xp = tmp;
#line 3329
    } else {
#line 3329
      xp = (ulonglong *) *xpp;
#line 3329
    }
#line 3329
   /* copy the next block */
#line 3329
#pragma cdir loopcnt=LOOPCNT
#line 3329
#pragma cdir shortloop
#line 3329
    for (i=0; i<ni; i++) {
#line 3329
      /* the normal case: */
#line 3329
      xp[i] = (ulonglong) Max( X_ULONGLONG_MIN, Min(X_ULONGLONG_MAX, (ulonglong) tp[i]));
#line 3329
     /* test for range errors (not always needed but do it anyway) */
#line 3329
     /* if xpp is unsigned && tp is signed, we need check if tp[i] >= 0 */
#line 3329
     /* if tp is unsigned, we need not check if tp[i] < X__MIN */
#line 3329
      nrange += tp[i] > X_ULONGLONG_MAX ;
#line 3329
    }
#line 3329
   /* copy workspace back if necessary */
#line 3329
    if (realign) {
#line 3329
      memcpy(*xpp, tmp, ni*X_SIZEOF_ULONGLONG);
#line 3329
      xp = (ulonglong *) *xpp;
#line 3329
    }
#line 3329
   /* update xpp and tp */
#line 3329
    xp += ni;
#line 3329
    tp += ni;
#line 3329
    *xpp = (void*)xp;
#line 3329
  }
#line 3329
  return nrange == 0 ? ENOERR : NC_ERANGE;
#line 3329

#line 3329
#else   /* not SX */
#line 3329

#line 3329
	char *xp = (char *) *xpp;
#line 3329
	int status = ENOERR;
#line 3329

#line 3329
	for( ; nelems != 0; nelems--, xp += X_SIZEOF_ULONGLONG, tp++)
#line 3329
	{
#line 3329
		int lstatus = ncx_put_ulonglong_uint(xp, tp);
#line 3329
		if(lstatus != ENOERR)
#line 3329
			status = lstatus;
#line 3329
	}
#line 3329

#line 3329
	*xpp = (void *)xp;
#line 3329
	return status;
#line 3329
#endif
#line 3329
}
#line 3329



/*
 * Other aggregate conversion functions.
 */

/* text */

int
ncx_getn_text(const void **xpp, size_t nelems, char *tp)
{
	(void) memcpy(tp, *xpp, nelems);
#line 3341
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3341
	return ENOERR;
#line 3341

}

int
ncx_pad_getn_text(const void **xpp, size_t nelems, char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3347

#line 3347
	if(rndup)
#line 3347
		rndup = X_ALIGN - rndup;
#line 3347

#line 3347
	(void) memcpy(tp, *xpp, nelems);
#line 3347
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3347

#line 3347
	return ENOERR;
#line 3347

}

int
ncx_putn_text(void **xpp, size_t nelems, const char *tp)
{
	(void) memcpy(*xpp, tp, nelems);
#line 3353
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3353

#line 3353
	return ENOERR;
#line 3353

}

int
ncx_pad_putn_text(void **xpp, size_t nelems, const char *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3359

#line 3359
	if(rndup)
#line 3359
		rndup = X_ALIGN - rndup;
#line 3359

#line 3359
	(void) memcpy(*xpp, tp, nelems);
#line 3359
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3359

#line 3359
	if(rndup)
#line 3359
	{
#line 3359
		(void) memcpy(*xpp, nada, rndup);
#line 3359
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3359
	}
#line 3359

#line 3359
	return ENOERR;
#line 3359

}


/* opaque */

int
ncx_getn_void(const void **xpp, size_t nelems, void *tp)
{
	(void) memcpy(tp, *xpp, nelems);
#line 3368
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3368
	return ENOERR;
#line 3368

}

int
ncx_pad_getn_void(const void **xpp, size_t nelems, void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3374

#line 3374
	if(rndup)
#line 3374
		rndup = X_ALIGN - rndup;
#line 3374

#line 3374
	(void) memcpy(tp, *xpp, nelems);
#line 3374
	*xpp = (void *)((char *)(*xpp) + nelems + rndup);
#line 3374

#line 3374
	return ENOERR;
#line 3374

}

int
ncx_putn_void(void **xpp, size_t nelems, const void *tp)
{
	(void) memcpy(*xpp, tp, nelems);
#line 3380
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3380

#line 3380
	return ENOERR;
#line 3380

}

int
ncx_pad_putn_void(void **xpp, size_t nelems, const void *tp)
{
	size_t rndup = nelems % X_ALIGN;
#line 3386

#line 3386
	if(rndup)
#line 3386
		rndup = X_ALIGN - rndup;
#line 3386

#line 3386
	(void) memcpy(*xpp, tp, nelems);
#line 3386
	*xpp = (void *)((char *)(*xpp) + nelems);
#line 3386

#line 3386
	if(rndup)
#line 3386
	{
#line 3386
		(void) memcpy(*xpp, nada, rndup);
#line 3386
		*xpp = (void *)((char *)(*xpp) + rndup);
#line 3386
	}
#line 3386

#line 3386
	return ENOERR;
#line 3386

}
